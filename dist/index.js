var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __moduleCache = /* @__PURE__ */ new WeakMap;
var __toCommonJS = (from) => {
  var entry = __moduleCache.get(from), desc;
  if (entry)
    return entry;
  entry = __defProp({}, "__esModule", { value: true });
  if (from && typeof from === "object" || typeof from === "function")
    __getOwnPropNames(from).map((key) => !__hasOwnProp.call(entry, key) && __defProp(entry, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    }));
  __moduleCache.set(from, entry);
  return entry;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS((exports, module) => {
  var has = Object.prototype.hasOwnProperty;
  var prefix = "~";
  function Events() {}
  if (Object.create) {
    Events.prototype = Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events;
    else
      delete emitter._events[evt];
  }
  function EventEmitter() {
    this._events = new Events;
    this._eventsCount = 0;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0)
      return names;
    for (name in events = this._events) {
      if (has.call(events, name))
        names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l);i < l; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, undefined, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1);i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i = 0;i < length; i++) {
        if (listeners[i].once)
          this.removeListener(event, listeners[i].fn, undefined, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1);j < len; j++) {
                args[j - 1] = arguments[j];
              }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length;i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
          events.push(listeners[i]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events;
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  EventEmitter.prefixed = prefix;
  EventEmitter.EventEmitter = EventEmitter;
  if (typeof module !== "undefined") {
    module.exports = EventEmitter;
  }
});

// node_modules/fast-decode-uri-component/index.js
var require_fast_decode_uri_component = __commonJS((exports, module) => {
  var UTF8_ACCEPT = 12;
  var UTF8_REJECT = 0;
  var UTF8_DATA = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    8,
    7,
    7,
    10,
    9,
    9,
    9,
    11,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    12,
    0,
    0,
    0,
    0,
    24,
    36,
    48,
    60,
    72,
    84,
    96,
    0,
    12,
    12,
    12,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    127,
    63,
    63,
    63,
    0,
    31,
    15,
    15,
    15,
    7,
    7,
    7
  ];
  function decodeURIComponent2(uri) {
    var percentPosition = uri.indexOf("%");
    if (percentPosition === -1)
      return uri;
    var length = uri.length;
    var decoded = "";
    var last = 0;
    var codepoint = 0;
    var startOfOctets = percentPosition;
    var state = UTF8_ACCEPT;
    while (percentPosition > -1 && percentPosition < length) {
      var high = hexCodeToInt(uri[percentPosition + 1], 4);
      var low = hexCodeToInt(uri[percentPosition + 2], 0);
      var byte = high | low;
      var type3 = UTF8_DATA[byte];
      state = UTF8_DATA[256 + state + type3];
      codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type3];
      if (state === UTF8_ACCEPT) {
        decoded += uri.slice(last, startOfOctets);
        decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023));
        codepoint = 0;
        last = percentPosition + 3;
        percentPosition = startOfOctets = uri.indexOf("%", last);
      } else if (state === UTF8_REJECT) {
        return null;
      } else {
        percentPosition += 3;
        if (percentPosition < length && uri.charCodeAt(percentPosition) === 37)
          continue;
        return null;
      }
    }
    return decoded + uri.slice(last);
  }
  var HEX = {
    "0": 0,
    "1": 1,
    "2": 2,
    "3": 3,
    "4": 4,
    "5": 5,
    "6": 6,
    "7": 7,
    "8": 8,
    "9": 9,
    a: 10,
    A: 10,
    b: 11,
    B: 11,
    c: 12,
    C: 12,
    d: 13,
    D: 13,
    e: 14,
    E: 14,
    f: 15,
    F: 15
  };
  function hexCodeToInt(c, shift) {
    var i = HEX[c];
    return i === undefined ? 255 : i << shift;
  }
  module.exports = decodeURIComponent2;
});

// node_modules/fast-querystring/lib/parse.js
var require_parse = __commonJS((exports, module) => {
  var fastDecode = require_fast_decode_uri_component();
  var plusRegex = /\+/g;
  var Empty = function() {};
  Empty.prototype = Object.create(null);
  function parse3(input) {
    const result = new Empty;
    if (typeof input !== "string") {
      return result;
    }
    let inputLength = input.length;
    let key = "";
    let value2 = "";
    let startingIndex = -1;
    let equalityIndex = -1;
    let shouldDecodeKey = false;
    let shouldDecodeValue = false;
    let keyHasPlus = false;
    let valueHasPlus = false;
    let hasBothKeyValuePair = false;
    let c = 0;
    for (let i = 0;i < inputLength + 1; i++) {
      c = i !== inputLength ? input.charCodeAt(i) : 38;
      if (c === 38) {
        hasBothKeyValuePair = equalityIndex > startingIndex;
        if (!hasBothKeyValuePair) {
          equalityIndex = i;
        }
        key = input.slice(startingIndex + 1, equalityIndex);
        if (hasBothKeyValuePair || key.length > 0) {
          if (keyHasPlus) {
            key = key.replace(plusRegex, " ");
          }
          if (shouldDecodeKey) {
            key = fastDecode(key) || key;
          }
          if (hasBothKeyValuePair) {
            value2 = input.slice(equalityIndex + 1, i);
            if (valueHasPlus) {
              value2 = value2.replace(plusRegex, " ");
            }
            if (shouldDecodeValue) {
              value2 = fastDecode(value2) || value2;
            }
          }
          const currentValue = result[key];
          if (currentValue === undefined) {
            result[key] = value2;
          } else {
            if (currentValue.pop) {
              currentValue.push(value2);
            } else {
              result[key] = [currentValue, value2];
            }
          }
        }
        value2 = "";
        startingIndex = i;
        equalityIndex = i;
        shouldDecodeKey = false;
        shouldDecodeValue = false;
        keyHasPlus = false;
        valueHasPlus = false;
      } else if (c === 61) {
        if (equalityIndex <= startingIndex) {
          equalityIndex = i;
        } else {
          shouldDecodeValue = true;
        }
      } else if (c === 43) {
        if (equalityIndex > startingIndex) {
          valueHasPlus = true;
        } else {
          keyHasPlus = true;
        }
      } else if (c === 37) {
        if (equalityIndex > startingIndex) {
          shouldDecodeValue = true;
        } else {
          shouldDecodeKey = true;
        }
      }
    }
    return result;
  }
  module.exports = parse3;
});

// node_modules/fast-querystring/lib/internals/querystring.js
var require_querystring = __commonJS((exports, module) => {
  var hexTable = Array.from({ length: 256 }, (_, i) => "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  var noEscape = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
  ]);
  function encodeString(str) {
    const len = str.length;
    if (len === 0)
      return "";
    let out = "";
    let lastPos = 0;
    let i = 0;
    outer:
      for (;i < len; i++) {
        let c = str.charCodeAt(i);
        while (c < 128) {
          if (noEscape[c] !== 1) {
            if (lastPos < i)
              out += str.slice(lastPos, i);
            lastPos = i + 1;
            out += hexTable[c];
          }
          if (++i === len)
            break outer;
          c = str.charCodeAt(i);
        }
        if (lastPos < i)
          out += str.slice(lastPos, i);
        if (c < 2048) {
          lastPos = i + 1;
          out += hexTable[192 | c >> 6] + hexTable[128 | c & 63];
          continue;
        }
        if (c < 55296 || c >= 57344) {
          lastPos = i + 1;
          out += hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
          continue;
        }
        ++i;
        if (i >= len) {
          throw new Error("URI malformed");
        }
        const c2 = str.charCodeAt(i) & 1023;
        lastPos = i + 1;
        c = 65536 + ((c & 1023) << 10 | c2);
        out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
    if (lastPos === 0)
      return str;
    if (lastPos < len)
      return out + str.slice(lastPos);
    return out;
  }
  module.exports = { encodeString };
});

// node_modules/fast-querystring/lib/stringify.js
var require_stringify = __commonJS((exports, module) => {
  var { encodeString } = require_querystring();
  function getAsPrimitive(value2) {
    const type3 = typeof value2;
    if (type3 === "string") {
      return encodeString(value2);
    } else if (type3 === "bigint") {
      return value2.toString();
    } else if (type3 === "boolean") {
      return value2 ? "true" : "false";
    } else if (type3 === "number" && Number.isFinite(value2)) {
      return value2 < 1000000000000000000000 ? "" + value2 : encodeString("" + value2);
    }
    return "";
  }
  function stringify(input) {
    let result = "";
    if (input === null || typeof input !== "object") {
      return result;
    }
    const separator = "&";
    const keys = Object.keys(input);
    const keyLength = keys.length;
    let valueLength = 0;
    for (let i = 0;i < keyLength; i++) {
      const key = keys[i];
      const value2 = input[key];
      const encodedKey = encodeString(key) + "=";
      if (i) {
        result += separator;
      }
      if (Array.isArray(value2)) {
        valueLength = value2.length;
        for (let j = 0;j < valueLength; j++) {
          if (j) {
            result += separator;
          }
          result += encodedKey;
          result += getAsPrimitive(value2[j]);
        }
      } else {
        result += encodedKey;
        result += getAsPrimitive(value2);
      }
    }
    return result;
  }
  module.exports = stringify;
});

// node_modules/fast-querystring/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var parse3 = require_parse();
  var stringify = require_stringify();
  var fastQuerystring = {
    parse: parse3,
    stringify
  };
  module.exports = fastQuerystring;
  module.exports.default = fastQuerystring;
  module.exports.parse = parse3;
  module.exports.stringify = stringify;
});

// node_modules/lodash.clonedeep/index.js
var require_lodash = __commonJS((exports, module) => {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]";
  var arrayTag = "[object Array]";
  var boolTag = "[object Boolean]";
  var dateTag = "[object Date]";
  var errorTag = "[object Error]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var mapTag = "[object Map]";
  var numberTag = "[object Number]";
  var objectTag = "[object Object]";
  var promiseTag = "[object Promise]";
  var regexpTag = "[object RegExp]";
  var setTag = "[object Set]";
  var stringTag = "[object String]";
  var symbolTag = "[object Symbol]";
  var weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]";
  var dataViewTag = "[object DataView]";
  var float32Tag = "[object Float32Array]";
  var float64Tag = "[object Float64Array]";
  var int8Tag = "[object Int8Array]";
  var int16Tag = "[object Int16Array]";
  var int32Tag = "[object Int32Array]";
  var uint8Tag = "[object Uint8Array]";
  var uint8ClampedTag = "[object Uint8ClampedArray]";
  var uint16Tag = "[object Uint16Array]";
  var uint32Tag = "[object Uint32Array]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reFlags = /\w*$/;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  function addMapEntry(map3, pair) {
    map3.set(pair[0], pair[1]);
    return map3;
  }
  function addSetEntry(set2, value2) {
    set2.add(value2);
    return set2;
  }
  function arrayEach(array3, iteratee) {
    var index = -1, length = array3 ? array3.length : 0;
    while (++index < length) {
      if (iteratee(array3[index], index, array3) === false) {
        break;
      }
    }
    return array3;
  }
  function arrayPush(array3, values) {
    var index = -1, length = values.length, offset = array3.length;
    while (++index < length) {
      array3[offset + index] = values[index];
    }
    return array3;
  }
  function arrayReduce(array3, iteratee, accumulator, initAccum) {
    var index = -1, length = array3 ? array3.length : 0;
    if (initAccum && length) {
      accumulator = array3[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array3[index], index, array3);
    }
    return accumulator;
  }
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  function getValue(object3, key) {
    return object3 == null ? undefined : object3[key];
  }
  function isHostObject(value2) {
    var result = false;
    if (value2 != null && typeof value2.toString != "function") {
      try {
        result = !!(value2 + "");
      } catch (e) {}
    }
    return result;
  }
  function mapToArray(map3) {
    var index = -1, result = Array(map3.size);
    map3.forEach(function(value2, key) {
      result[++index] = [key, value2];
    });
    return result;
  }
  function overArg(func, transform4) {
    return function(arg) {
      return func(transform4(arg));
    };
  }
  function setToArray(set2) {
    var index = -1, result = Array(set2.size);
    set2.forEach(function(value2) {
      result[++index] = value2;
    });
    return result;
  }
  var arrayProto = Array.prototype;
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  var Buffer2 = moduleExports ? root.Buffer : undefined;
  var Symbol3 = root.Symbol;
  var Uint8Array3 = root.Uint8Array;
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  var objectCreate = Object.create;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var splice = arrayProto.splice;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined;
  var nativeKeys = overArg(Object.keys, Object);
  var DataView2 = getNative(root, "DataView");
  var Map2 = getNative(root, "Map");
  var Promise3 = getNative(root, "Promise");
  var Set5 = getNative(root, "Set");
  var WeakMap2 = getNative(root, "WeakMap");
  var nativeCreate = getNative(Object, "create");
  var dataViewCtorString = toSource(DataView2);
  var mapCtorString = toSource(Map2);
  var promiseCtorString = toSource(Promise3);
  var setCtorString = toSource(Set5);
  var weakMapCtorString = toSource(WeakMap2);
  var symbolProto = Symbol3 ? Symbol3.prototype : undefined;
  var symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
  function Hash3(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }
  function hashSet(key, value2) {
    var data = this.__data__;
    data[key] = nativeCreate && value2 === undefined ? HASH_UNDEFINED : value2;
    return this;
  }
  Hash3.prototype.clear = hashClear;
  Hash3.prototype["delete"] = hashDelete;
  Hash3.prototype.get = hashGet;
  Hash3.prototype.has = hashHas;
  Hash3.prototype.set = hashSet;
  function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
  }
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    return true;
  }
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value2) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      data.push([key, value2]);
    } else {
      data[index][1] = value2;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.__data__ = {
      hash: new Hash3,
      map: new (Map2 || ListCache),
      string: new Hash3
    };
  }
  function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value2) {
    getMapData(this, key).set(key, value2);
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function Stack(entries) {
    this.__data__ = new ListCache(entries);
  }
  function stackClear() {
    this.__data__ = new ListCache;
  }
  function stackDelete(key) {
    return this.__data__["delete"](key);
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value2) {
    var cache = this.__data__;
    if (cache instanceof ListCache) {
      var pairs = cache.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value2]);
        return this;
      }
      cache = this.__data__ = new MapCache(pairs);
    }
    cache.set(key, value2);
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value2, inherited) {
    var result = isArray(value2) || isArguments(value2) ? baseTimes(value2.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value2) {
      if ((inherited || hasOwnProperty.call(value2, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assignValue(object3, key, value2) {
    var objValue = object3[key];
    if (!(hasOwnProperty.call(object3, key) && eq(objValue, value2)) || value2 === undefined && !(key in object3)) {
      object3[key] = value2;
    }
  }
  function assocIndexOf(array3, key) {
    var length = array3.length;
    while (length--) {
      if (eq(array3[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseAssign(object3, source) {
    return object3 && copyObject(source, keys(source), object3);
  }
  function baseClone(value2, isDeep, isFull, customizer, key, object3, stack) {
    var result;
    if (customizer) {
      result = object3 ? customizer(value2, key, object3, stack) : customizer(value2);
    }
    if (result !== undefined) {
      return result;
    }
    if (!isObject2(value2)) {
      return value2;
    }
    var isArr = isArray(value2);
    if (isArr) {
      result = initCloneArray(value2);
      if (!isDeep) {
        return copyArray(value2, result);
      }
    } else {
      var tag = getTag(value2), isFunc = tag == funcTag || tag == genTag;
      if (isBuffer(value2)) {
        return cloneBuffer(value2, isDeep);
      }
      if (tag == objectTag || tag == argsTag || isFunc && !object3) {
        if (isHostObject(value2)) {
          return object3 ? value2 : {};
        }
        result = initCloneObject(isFunc ? {} : value2);
        if (!isDeep) {
          return copySymbols(value2, baseAssign(result, value2));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object3 ? value2 : {};
        }
        result = initCloneByTag(value2, tag, baseClone, isDeep);
      }
    }
    stack || (stack = new Stack);
    var stacked = stack.get(value2);
    if (stacked) {
      return stacked;
    }
    stack.set(value2, result);
    if (!isArr) {
      var props = isFull ? getAllKeys(value2) : keys(value2);
    }
    arrayEach(props || value2, function(subValue, key2) {
      if (props) {
        key2 = subValue;
        subValue = value2[key2];
      }
      assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value2, stack));
    });
    return result;
  }
  function baseCreate(proto) {
    return isObject2(proto) ? objectCreate(proto) : {};
  }
  function baseGetAllKeys(object3, keysFunc, symbolsFunc) {
    var result = keysFunc(object3);
    return isArray(object3) ? result : arrayPush(result, symbolsFunc(object3));
  }
  function baseGetTag(value2) {
    return objectToString.call(value2);
  }
  function baseIsNative(value2) {
    if (!isObject2(value2) || isMasked(value2)) {
      return false;
    }
    var pattern2 = isFunction(value2) || isHostObject(value2) ? reIsNative : reIsHostCtor;
    return pattern2.test(toSource(value2));
  }
  function baseKeys(object3) {
    if (!isPrototype(object3)) {
      return nativeKeys(object3);
    }
    var result = [];
    for (var key in Object(object3)) {
      if (hasOwnProperty.call(object3, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var result = new buffer.constructor(buffer.length);
    buffer.copy(result);
    return result;
  }
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array3(result).set(new Uint8Array3(arrayBuffer));
    return result;
  }
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }
  function cloneMap(map3, isDeep, cloneFunc) {
    var array3 = isDeep ? cloneFunc(mapToArray(map3), true) : mapToArray(map3);
    return arrayReduce(array3, addMapEntry, new map3.constructor);
  }
  function cloneRegExp(regexp3) {
    var result = new regexp3.constructor(regexp3.source, reFlags.exec(regexp3));
    result.lastIndex = regexp3.lastIndex;
    return result;
  }
  function cloneSet(set2, isDeep, cloneFunc) {
    var array3 = isDeep ? cloneFunc(setToArray(set2), true) : setToArray(set2);
    return arrayReduce(array3, addSetEntry, new set2.constructor);
  }
  function cloneSymbol(symbol3) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol3)) : {};
  }
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  function copyArray(source, array3) {
    var index = -1, length = source.length;
    array3 || (array3 = Array(length));
    while (++index < length) {
      array3[index] = source[index];
    }
    return array3;
  }
  function copyObject(source, props, object3, customizer) {
    object3 || (object3 = {});
    var index = -1, length = props.length;
    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object3[key], source[key], key, object3, source) : undefined;
      assignValue(object3, key, newValue === undefined ? source[key] : newValue);
    }
    return object3;
  }
  function copySymbols(source, object3) {
    return copyObject(source, getSymbols(source), object3);
  }
  function getAllKeys(object3) {
    return baseGetAllKeys(object3, keys, getSymbols);
  }
  function getMapData(map3, key) {
    var data = map3.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative(object3, key) {
    var value2 = getValue(object3, key);
    return baseIsNative(value2) ? value2 : undefined;
  }
  var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
  var getTag = baseGetTag;
  if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2) != mapTag || Promise3 && getTag(Promise3.resolve()) != promiseTag || Set5 && getTag(new Set5) != setTag || WeakMap2 && getTag(new WeakMap2) != weakMapTag) {
    getTag = function(value2) {
      var result = objectToString.call(value2), Ctor = result == objectTag ? value2.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : undefined;
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  function initCloneArray(array3) {
    var length = array3.length, result = array3.constructor(length);
    if (length && typeof array3[0] == "string" && hasOwnProperty.call(array3, "index")) {
      result.index = array3.index;
      result.input = array3.input;
    }
    return result;
  }
  function initCloneObject(object3) {
    return typeof object3.constructor == "function" && !isPrototype(object3) ? baseCreate(getPrototype(object3)) : {};
  }
  function initCloneByTag(object3, tag, cloneFunc, isDeep) {
    var Ctor = object3.constructor;
    switch (tag) {
      case arrayBufferTag:
        return cloneArrayBuffer(object3);
      case boolTag:
      case dateTag:
        return new Ctor(+object3);
      case dataViewTag:
        return cloneDataView(object3, isDeep);
      case float32Tag:
      case float64Tag:
      case int8Tag:
      case int16Tag:
      case int32Tag:
      case uint8Tag:
      case uint8ClampedTag:
      case uint16Tag:
      case uint32Tag:
        return cloneTypedArray(object3, isDeep);
      case mapTag:
        return cloneMap(object3, isDeep, cloneFunc);
      case numberTag:
      case stringTag:
        return new Ctor(object3);
      case regexpTag:
        return cloneRegExp(object3);
      case setTag:
        return cloneSet(object3, isDeep, cloneFunc);
      case symbolTag:
        return cloneSymbol(object3);
    }
  }
  function isIndex(value2, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value2 == "number" || reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length);
  }
  function isKeyable(value2) {
    var type3 = typeof value2;
    return type3 == "string" || type3 == "number" || type3 == "symbol" || type3 == "boolean" ? value2 !== "__proto__" : value2 === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function isPrototype(value2) {
    var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value2 === proto;
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}
      try {
        return func + "";
      } catch (e) {}
    }
    return "";
  }
  function cloneDeep(value2) {
    return baseClone(value2, true, true);
  }
  function eq(value2, other) {
    return value2 === other || value2 !== value2 && other !== other;
  }
  function isArguments(value2) {
    return isArrayLikeObject(value2) && hasOwnProperty.call(value2, "callee") && (!propertyIsEnumerable.call(value2, "callee") || objectToString.call(value2) == argsTag);
  }
  var isArray = Array.isArray;
  function isArrayLike(value2) {
    return value2 != null && isLength(value2.length) && !isFunction(value2);
  }
  function isArrayLikeObject(value2) {
    return isObjectLike(value2) && isArrayLike(value2);
  }
  var isBuffer = nativeIsBuffer || stubFalse;
  function isFunction(value2) {
    var tag = isObject2(value2) ? objectToString.call(value2) : "";
    return tag == funcTag || tag == genTag;
  }
  function isLength(value2) {
    return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER;
  }
  function isObject2(value2) {
    var type3 = typeof value2;
    return !!value2 && (type3 == "object" || type3 == "function");
  }
  function isObjectLike(value2) {
    return !!value2 && typeof value2 == "object";
  }
  function keys(object3) {
    return isArrayLike(object3) ? arrayLikeKeys(object3) : baseKeys(object3);
  }
  function stubArray() {
    return [];
  }
  function stubFalse() {
    return false;
  }
  module.exports = cloneDeep;
});

// node_modules/mongoose/dist/browser.umd.js
var require_browser_umd = __commonJS((exports, module) => {
  /*! For license information please see browser.umd.js.LICENSE.txt */
  (function(t2, e) {
    typeof exports == "object" && typeof module == "object" ? module.exports = e() : typeof define == "function" && define.amd ? define([], e) : typeof exports == "object" ? exports.mongoose = e() : t2.mongoose = e();
  })(typeof self != "undefined" ? self : exports, () => (() => {
    var t2 = { 118: (t3) => {
      t3.exports = function(t4) {
        return t4 != t4;
      };
    }, 170: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var o = r2(3609), i = r2(8995), s = r2(7768), a = r2(7236), u = new Set(["$and", "$or"]), c = new Set(["$cmp", "$eq", "$lt", "$lte", "$gt", "$gte"]), l = new Set(["$multiply", "$divide", "$log", "$mod", "$trunc", "$avg", "$max", "$min", "$stdDevPop", "$stdDevSamp", "$sum"]), f = new Set(["$abs", "$exp", "$ceil", "$floor", "$ln", "$log10", "$sqrt", "$sin", "$cos", "$tan", "$asin", "$acos", "$atan", "$atan2", "$asinh", "$acosh", "$atanh", "$sinh", "$cosh", "$tanh", "$degreesToRadians", "$radiansToDegrees"]), p = new Set(["$arrayElemAt", "$first", "$last"]), h = new Set(["$year", "$month", "$week", "$dayOfMonth", "$dayOfYear", "$hour", "$minute", "$second", "$isoDayOfWeek", "$isoWeekYear", "$isoWeek", "$millisecond"]), y = new Set(["$not"]);
      function d(t4, e3, r3) {
        if (g(t4) || t4 === null)
          return t4;
        t4.$cond != null ? Array.isArray(t4.$cond) ? t4.$cond = t4.$cond.map(function(t5) {
          return d(t5, e3, r3);
        }) : (t4.$cond.if = d(t4.$cond.if, e3, r3), t4.$cond.then = d(t4.$cond.then, e3, r3), t4.$cond.else = d(t4.$cond.else, e3, r3)) : t4.$ifNull != null ? t4.$ifNull.map(function(t5) {
          return d(t5, e3, r3);
        }) : t4.$switch != null && (Array.isArray(t4.$switch.branches) && (t4.$switch.branches = t4.$switch.branches.map(function(t5) {
          return d(t5, e3, r3);
        })), ("default" in t4.$switch) && (t4.$switch.default = d(t4.$switch.default, e3, r3)));
        for (var n2 = 0, s2 = Object.keys(t4);n2 < s2.length; n2++) {
          var p2 = s2[n2];
          u.has(p2) ? t4[p2] = t4[p2].map(function(t5) {
            return d(t5, e3, r3);
          }) : c.has(p2) ? t4[p2] = v(t4[p2], e3, r3) : l.has(p2) ? t4[p2] = m(t4[p2]) : f.has(p2) ? t4[p2] = b(t4[p2]) : y.has(p2) && (t4[p2] = d(t4[p2], e3, r3));
        }
        if (t4.$in && (t4.$in = function(t5, e4, r4) {
          var n3 = t5[1];
          if (!g(n3))
            return t5;
          var o2 = t5[0], s3 = e4.path(n3.slice(1));
          if (s3 !== null) {
            if (!s3.$isMongooseArray)
              throw new Error("Path must be an array for $in");
            return [s3.$isMongooseDocumentArray ? s3.$embeddedSchemaType.cast(o2) : s3.caster.cast(o2), n3];
          }
          if (r4 === false)
            return t5;
          if (r4 === "throw")
            throw new i("$in");
        }(t4.$in, e3, r3)), t4.$size && (t4.$size = b(t4.$size)), t4.$round) {
          var h2 = t4.$round;
          if (!Array.isArray(h2) || h2.length < 1 || h2.length > 2)
            throw new o("Array", h2, "$round");
          t4.$round = h2.map(function(t5) {
            return b(t5);
          });
        }
        return a(t4), t4;
      }
      function b(t4) {
        if (!_(t4))
          return t4;
        try {
          return s(t4);
        } catch (e3) {
          throw new o("Number", t4);
        }
      }
      function m(t4) {
        if (!Array.isArray(t4)) {
          if (!_(t4))
            return t4;
          try {
            return s(t4);
          } catch (e3) {
            throw new o("Number", t4);
          }
        }
        return t4.map(function(t5) {
          if (!_(t5))
            return t5;
          try {
            return s(t5);
          } catch (e3) {
            throw new o("Number", t5);
          }
        });
      }
      function v(t4, e3, r3) {
        if (!Array.isArray(t4) || t4.length !== 2)
          throw new Error("Comparison operator must be an array of length 2");
        t4[0] = d(t4[0], e3, r3);
        var a2 = t4[0];
        if (_(t4[1])) {
          var u2 = null, c2 = null, l2 = null;
          if (g(a2))
            u2 = a2.slice(1), c2 = e3.path(u2);
          else if (n(a2) === "object" && a2 != null)
            for (var f2 = 0, y2 = Object.keys(a2);f2 < y2.length; f2++) {
              var b2 = y2[f2];
              h.has(b2) && g(a2[b2]) ? (u2 = a2[b2].slice(1) + "." + b2, l2 = s) : p.has(b2) && g(a2[b2]) && (u2 = a2[b2].slice(1) + "." + b2, (c2 = e3.path(a2[b2].slice(1))) != null && (c2.$isMongooseDocumentArray ? c2 = c2.$embeddedSchemaType : c2.$isMongooseArray && (c2 = c2.caster)));
            }
          var m2 = n(t4[1]) === "object" && t4[1] != null && t4[1].$literal != null;
          if (c2 != null)
            t4[1] = m2 ? { $literal: c2.cast(t4[1].$literal) } : c2.cast(t4[1]);
          else if (l2 != null)
            if (m2)
              try {
                t4[1] = { $literal: l2(t4[1].$literal) };
              } catch (e4) {
                throw new o(l2.name.replace(/^cast/, ""), t4[1], u2 + ".$literal");
              }
            else
              try {
                t4[1] = l2(t4[1]);
              } catch (e4) {
                throw new o(l2.name.replace(/^cast/, ""), t4[1], u2);
              }
          else {
            if (u2 != null && r3 === true)
              return;
            if (u2 != null && r3 === "throw")
              throw new i(u2);
          }
        } else
          t4[1] = d(t4[1]);
        return t4;
      }
      function g(t4) {
        return typeof t4 == "string" && t4[0] === "$";
      }
      function _(t4) {
        return !(typeof t4 == "string" && t4[0] === "$" || n(t4) === "object" && t4 !== null && Object.keys(t4).find(function(t5) {
          return t5[0] === "$";
        }) && t4.$literal == null);
      }
      t3.exports = function(t4, e3, r3) {
        if (typeof t4 == "boolean")
          return t4;
        if (n(t4) !== "object" || t4 === null)
          throw new Error("`$expr` must be an object or boolean literal");
        return d(t4, e3, r3);
      };
    }, 209: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var o = r2(2403), i = r2(5825), s = r2(6583);
      t3.exports = o ? function(t4) {
        return o(t4);
      } : i ? function(t4) {
        if (!t4 || n(t4) !== "object" && typeof t4 != "function")
          throw new TypeError("getProto: not an object");
        return i(t4);
      } : s ? function(t4) {
        return s(t4);
      } : null;
    }, 241: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (o = function() {
          return !!t4;
        })();
      }
      function i(t4) {
        return i = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, i(t4);
      }
      function s(t4, e3) {
        return s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s(t4, e3);
      }
      var a = function(t4) {
        function e3() {
          return function(t5, e4) {
            if (!(t5 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), function(t5, e4, r4) {
            return e4 = i(e4), function(t6, e5) {
              if (e5 && (n(e5) == "object" || typeof e5 == "function"))
                return e5;
              if (e5 !== undefined)
                throw new TypeError("Derived constructors may only return object or undefined");
              return function(t7) {
                if (t7 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t7;
              }(t6);
            }(t5, o() ? Reflect.construct(e4, r4 || [], i(t5).constructor) : e4.apply(t5, r4));
          }(this, e3, arguments);
        }
        return function(t5, e4) {
          if (typeof e4 != "function" && e4 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(8879)), u = r2(5761);
      Object.defineProperty(a.prototype, "of", u), t3.exports = a;
    }, 354: (t3) => {
      function e2(t4) {
        return e2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      var r2 = 1000, n = 60 * r2, o = 60 * n, i = 24 * o, s = 7 * i;
      function a(t4, e3, r3, n2) {
        var o2 = e3 >= 1.5 * r3;
        return Math.round(t4 / r3) + " " + n2 + (o2 ? "s" : "");
      }
      t3.exports = function(t4, u) {
        u = u || {};
        var c, l, f = e2(t4);
        if (f === "string" && t4.length > 0)
          return function(t5) {
            if (!((t5 = String(t5)).length > 100)) {
              var e3 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(t5);
              if (e3) {
                var a2 = parseFloat(e3[1]);
                switch ((e3[2] || "ms").toLowerCase()) {
                  case "years":
                  case "year":
                  case "yrs":
                  case "yr":
                  case "y":
                    return 31557600000 * a2;
                  case "weeks":
                  case "week":
                  case "w":
                    return a2 * s;
                  case "days":
                  case "day":
                  case "d":
                    return a2 * i;
                  case "hours":
                  case "hour":
                  case "hrs":
                  case "hr":
                  case "h":
                    return a2 * o;
                  case "minutes":
                  case "minute":
                  case "mins":
                  case "min":
                  case "m":
                    return a2 * n;
                  case "seconds":
                  case "second":
                  case "secs":
                  case "sec":
                  case "s":
                    return a2 * r2;
                  case "milliseconds":
                  case "millisecond":
                  case "msecs":
                  case "msec":
                  case "ms":
                    return a2;
                  default:
                    return;
                }
              }
            }
          }(t4);
        if (f === "number" && isFinite(t4))
          return u.long ? (c = t4, (l = Math.abs(c)) >= i ? a(c, l, i, "day") : l >= o ? a(c, l, o, "hour") : l >= n ? a(c, l, n, "minute") : l >= r2 ? a(c, l, r2, "second") : c + " ms") : function(t5) {
            var e3 = Math.abs(t5);
            return e3 >= i ? Math.round(t5 / i) + "d" : e3 >= o ? Math.round(t5 / o) + "h" : e3 >= n ? Math.round(t5 / n) + "m" : e3 >= r2 ? Math.round(t5 / r2) + "s" : t5 + "ms";
          }(t4);
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(t4));
      };
    }, 433: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function i(t4) {
        for (var e3 = 1;e3 < arguments.length; e3++) {
          var r3 = arguments[e3] != null ? arguments[e3] : {};
          e3 % 2 ? o(Object(r3), true).forEach(function(e4) {
            s(t4, e4, r3[e4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : o(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      function s(t4, e3, r3) {
        return (e3 = function(t5) {
          var e4 = function(t6) {
            if (n(t6) != "object" || !t6)
              return t6;
            var e5 = t6[Symbol.toPrimitive];
            if (e5 !== undefined) {
              var r4 = e5.call(t6, "string");
              if (n(r4) != "object")
                return r4;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t6);
          }(t5);
          return n(e4) == "symbol" ? e4 : e4 + "";
        }(e3)) in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      var a = r2(3609), u = r2(6426), c = r2(5413), l = r2(4327), f = r2(9460);
      function p(t4, e3) {
        u.call(this, t4, e3, "Int32");
      }
      p.schemaName = "Int32", p.defaultOptions = {}, p.prototype = Object.create(u.prototype), p.prototype.constructor = p, p._cast = c, p.set = u.set, p.setters = [], p.get = u.get, p._defaultCaster = function(t4) {
        if (t4 != null && (typeof t4 != "number" || t4 !== (0 | t4) || t4 < -2147483648 || t4 > 2147483647))
          throw new Error;
        return t4;
      }, p.cast = function(t4) {
        return arguments.length === 0 || (t4 === false && (t4 = this._defaultCaster), this._cast = t4), this._cast;
      }, p._checkRequired = function(t4) {
        return t4 != null;
      }, p.checkRequired = u.checkRequired, p.prototype.checkRequired = function(t4) {
        return this.constructor._checkRequired(t4);
      }, p.prototype.cast = function(t4) {
        var e3;
        e3 = typeof this._castFunction == "function" ? this._castFunction : typeof this.constructor.cast == "function" ? this.constructor.cast() : p.cast();
        try {
          return e3(t4);
        } catch (e4) {
          throw new a("Int32", t4, this.path, e4, this);
        }
      };
      var h = i(i({}, u.prototype.$conditionalHandlers), {}, { $gt: y, $gte: y, $lt: y, $lte: y, $bitsAllClear: f, $bitsAnyClear: f, $bitsAllSet: f, $bitsAnySet: f });
      function y(t4, e3) {
        return this.castForQuery(null, t4, e3);
      }
      Object.defineProperty(p.prototype, "$conditionalHandlers", { enumerable: false, value: h }), p.prototype.castForQuery = function(t4, e3, r3) {
        var n2;
        if (t4 != null)
          return (n2 = this.$conditionalHandlers[t4]) ? n2.call(this, e3) : this.applySetters(e3, r3);
        try {
          return this.applySetters(e3, r3);
        } catch (t5) {
          throw t5 instanceof a && t5.path === this.path && this.$fullPath != null && (t5.path = this.$fullPath), t5;
        }
      }, p.prototype.toJSONSchema = function(t4) {
        var e3 = this.options.required && typeof this.options.required != "function";
        return l("number", "int", t4 == null ? undefined : t4.useBsonType, e3);
      }, p.prototype.autoEncryptionType = function() {
        return "int";
      }, t3.exports = p;
    }, 486: (t3) => {
      t3.exports = function(t4) {
        var e2 = { _id: { auto: true } };
        e2._id[t4.options.typeKey] = "ObjectId", t4.add(e2);
      };
    }, 533: (t3, e2, r2) => {
      var n = r2(8213), o = r2(7352);
      t3.exports = function(t4, e3) {
        if (typeof t4 != "string" && typeof t4 != "function")
          throw new n('Invalid ref at path "' + e3 + '". Got ' + o.inspect(t4, { depth: 0 }));
      };
    }, 542: (t3) => {
      function e2(t4) {
        return e2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      t3.exports = function(t4) {
        return !!t4 && (e2(t4) === "object" || typeof t4 == "function") && typeof t4.then == "function";
      };
    }, 608: (t3, e2, r2) => {
      var n = r2(5832).hp;
      t3.exports = function(t4) {
        return n.isBuffer(t4) || Object.prototype.toString.call(t4) === "[object Object]";
      };
    }, 622: (t3, e2, r2) => {
      function n(t4, e3) {
        var r3 = typeof Symbol != "undefined" && t4[Symbol.iterator] || t4["@@iterator"];
        if (!r3) {
          if (Array.isArray(t4) || (r3 = function(t5, e4) {
            if (t5) {
              if (typeof t5 == "string")
                return o(t5, e4);
              var r4 = {}.toString.call(t5).slice(8, -1);
              return r4 === "Object" && t5.constructor && (r4 = t5.constructor.name), r4 === "Map" || r4 === "Set" ? Array.from(t5) : r4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r4) ? o(t5, e4) : undefined;
            }
          }(t4)) || e3 && t4 && typeof t4.length == "number") {
            r3 && (t4 = r3);
            var n2 = 0, i2 = function() {};
            return { s: i2, n: function() {
              return n2 >= t4.length ? { done: true } : { done: false, value: t4[n2++] };
            }, e: function(t5) {
              throw t5;
            }, f: i2 };
          }
          throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        var s2, a2 = true, u2 = false;
        return { s: function() {
          r3 = r3.call(t4);
        }, n: function() {
          var t5 = r3.next();
          return a2 = t5.done, t5;
        }, e: function(t5) {
          u2 = true, s2 = t5;
        }, f: function() {
          try {
            a2 || r3.return == null || r3.return();
          } finally {
            if (u2)
              throw s2;
          }
        } };
      }
      function o(t4, e3) {
        (e3 == null || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = Array(e3);r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      var i = r2(4009), s = r2(8768), a = r2(7930).modelSymbol;
      function u(t4, e3) {
        this.path = e3, this.getters = [], this.setters = [], this.options = Object.assign({}, t4);
      }
      u.prototype._applyDefaultGetters = function() {
        if (!(this.getters.length > 0 || this.setters.length > 0)) {
          var t4 = "$" + this.path;
          this.getters.push(function() {
            return this.$locals[t4];
          }), this.setters.push(function(e3) {
            this.$locals[t4] = e3;
          });
        }
      }, u.prototype.clone = function() {
        var t4 = new u(this.options, this.path);
        return t4.getters = [].concat(this.getters), t4.setters = [].concat(this.setters), t4;
      }, u.prototype.get = function(t4) {
        return this.getters.push(t4), this;
      }, u.prototype.set = function(t4) {
        return this.setters.push(t4), this;
      }, u.prototype.applyGetters = function(t4, e3) {
        s.hasUserDefinedProperty(this.options, ["ref", "refPath"]) && e3.$$populatedVirtuals && e3.$$populatedVirtuals.hasOwnProperty(this.path) && (t4 = e3.$$populatedVirtuals[this.path]);
        var r3, o2 = t4, i2 = n(this.getters);
        try {
          for (i2.s();!(r3 = i2.n()).done; )
            o2 = r3.value.call(e3, o2, this, e3);
        } catch (t5) {
          i2.e(t5);
        } finally {
          i2.f();
        }
        return o2;
      }, u.prototype.applySetters = function(t4, e3) {
        var r3, o2 = t4, i2 = n(this.setters);
        try {
          for (i2.s();!(r3 = i2.n()).done; )
            o2 = r3.value.call(e3, o2, this, e3);
        } catch (t5) {
          i2.e(t5);
        } finally {
          i2.f();
        }
        return o2;
      }, u.prototype._getModelNamesForPopulate = function(t4) {
        if (this.options.refPath)
          return i(this.options.refPath, t4, this.path);
        var e3;
        return (e3 = typeof this.options.ref != "function" || this.options.ref[a] ? this.options.ref : this.options.ref.call(t4, t4)) == null || Array.isArray(e3) ? e3 : [e3];
      }, t3.exports = u;
    }, 668: (t3, e2, r2) => {
      var n = Array.prototype.slice, o = r2(6312), i = Object.keys, s = i ? function(t4) {
        return i(t4);
      } : r2(6544), a = Object.keys;
      s.shim = function() {
        if (Object.keys) {
          var t4 = function() {
            var t5 = Object.keys(arguments);
            return t5 && t5.length === arguments.length;
          }(1, 2);
          t4 || (Object.keys = function(t5) {
            return o(t5) ? a(n.call(t5)) : a(t5);
          });
        } else
          Object.keys = s;
        return Object.keys || s;
      }, t3.exports = s;
    }, 674: (t3, e2, r2) => {
      var n = r2(3414);
      t3.exports = function(t4) {
        return n(t4) || t4 === 0 ? t4 : t4 < 0 ? -1 : 1;
      };
    }, 766: (t3, e2) => {
      var r2 = t3.exports = {};
      r2.DocumentNotFoundError = null, r2.general = {}, r2.general.default = "Validator failed for path `{PATH}` with value `{VALUE}`", r2.general.required = "Path `{PATH}` is required.", r2.Number = {}, r2.Number.min = "Path `{PATH}` ({VALUE}) is less than minimum allowed value ({MIN}).", r2.Number.max = "Path `{PATH}` ({VALUE}) is more than maximum allowed value ({MAX}).", r2.Number.enum = "`{VALUE}` is not a valid enum value for path `{PATH}`.", r2.Date = {}, r2.Date.min = "Path `{PATH}` ({VALUE}) is before minimum allowed value ({MIN}).", r2.Date.max = "Path `{PATH}` ({VALUE}) is after maximum allowed value ({MAX}).", r2.String = {}, r2.String.enum = "`{VALUE}` is not a valid enum value for path `{PATH}`.", r2.String.match = "Path `{PATH}` is invalid ({VALUE}).", r2.String.minlength = "Path `{PATH}` (`{VALUE}`, length {LENGTH}) is shorter than the minimum allowed length ({MINLENGTH}).", r2.String.maxlength = "Path `{PATH}` (`{VALUE}`, length {LENGTH}) is longer than the maximum allowed length ({MAXLENGTH}).";
    }, 783: (t3) => {
      t3.exports = ReferenceError;
    }, 791: (t3, e2, r2) => {
      function n(t4, e3) {
        var r3 = typeof Symbol != "undefined" && t4[Symbol.iterator] || t4["@@iterator"];
        if (!r3) {
          if (Array.isArray(t4) || (r3 = function(t5, e4) {
            if (t5) {
              if (typeof t5 == "string")
                return o(t5, e4);
              var r4 = {}.toString.call(t5).slice(8, -1);
              return r4 === "Object" && t5.constructor && (r4 = t5.constructor.name), r4 === "Map" || r4 === "Set" ? Array.from(t5) : r4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r4) ? o(t5, e4) : undefined;
            }
          }(t4)) || e3 && t4 && typeof t4.length == "number") {
            r3 && (t4 = r3);
            var n2 = 0, i2 = function() {};
            return { s: i2, n: function() {
              return n2 >= t4.length ? { done: true } : { done: false, value: t4[n2++] };
            }, e: function(t5) {
              throw t5;
            }, f: i2 };
          }
          throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        var s, a = true, u = false;
        return { s: function() {
          r3 = r3.call(t4);
        }, n: function() {
          var t5 = r3.next();
          return a = t5.done, t5;
        }, e: function(t5) {
          u = true, s = t5;
        }, f: function() {
          try {
            a || r3.return == null || r3.return();
          } finally {
            if (u)
              throw s;
          }
        } };
      }
      function o(t4, e3) {
        (e3 == null || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = Array(e3);r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      var i = r2(3703);
      t3.exports = function(t4, e3, r3) {
        var o2, s = r3 != null ? Object.keys(i(t4.tree, r3, {})) : Object.keys(t4.tree), a = new Set(Object.keys(e3));
        if (a.size > 1) {
          o2 = new Set;
          var u, c = n(s);
          try {
            for (c.s();!(u = c.n()).done; ) {
              var l = u.value;
              a.has(l) && o2.add(l);
            }
          } catch (t5) {
            c.e(t5);
          } finally {
            c.f();
          }
          var f, p = n(a);
          try {
            for (p.s();!(f = p.n()).done; ) {
              var h = f.value;
              o2.has(h) || o2.add(h);
            }
          } catch (t5) {
            p.e(t5);
          } finally {
            p.f();
          }
          o2 = Array.from(o2);
        } else
          o2 = Array.from(a);
        return o2;
      };
    }, 863: (t3, e2, r2) => {
      var n = r2(3305), o = r2(5549);
      t3.exports = function(t4) {
        if (t4 == null)
          return t4;
        if (n(t4, "ObjectId"))
          return t4;
        if (t4._id) {
          if (n(t4._id, "ObjectId"))
            return t4._id;
          if (t4._id.toString instanceof Function)
            return new o(t4._id.toString());
        }
        return t4.toString instanceof Function ? new o(t4.toString()) : new o(t4);
      };
    }, 953: (t3, e2, r2) => {
      var n = r2(5484);
      t3.exports = function() {
        return n() && !!Symbol.toStringTag;
      };
    }, 988: (t3) => {
      var e2 = Object.defineProperty || false;
      if (e2)
        try {
          e2({}, "a", { value: 1 });
        } catch (t4) {
          e2 = false;
        }
      t3.exports = e2;
    }, 1007: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (o = function() {
          return !!t4;
        })();
      }
      function i(t4) {
        return i = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, i(t4);
      }
      function s(t4, e3) {
        return s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s(t4, e3);
      }
      var a = function(t4) {
        function e3() {
          return function(t5, e4) {
            if (!(t5 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), function(t5, e4, r4) {
            return e4 = i(e4), function(t6, e5) {
              if (e5 && (n(e5) == "object" || typeof e5 == "function"))
                return e5;
              if (e5 !== undefined)
                throw new TypeError("Derived constructors may only return object or undefined");
              return function(t7) {
                if (t7 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t7;
              }(t6);
            }(t5, o() ? Reflect.construct(e4, r4 || [], i(t5).constructor) : e4.apply(t5, r4));
          }(this, e3, arguments);
        }
        return function(t5, e4) {
          if (typeof e4 != "function" && e4 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(8879)), u = r2(5761);
      Object.defineProperty(a.prototype, "min", u), Object.defineProperty(a.prototype, "max", u), Object.defineProperty(a.prototype, "enum", u), Object.defineProperty(a.prototype, "populate", u), t3.exports = a;
    }, 1058: (t3, e2, r2) => {
      var n = r2(2696);
      t3.exports = function(t4, e3) {
        if (t4 == null)
          return null;
        for (var r3 = 0, o = Object.keys(t4);r3 < o.length; r3++) {
          var i = t4[o[r3]];
          if (i.schema && i.schema.discriminatorMapping && n(i.schema.discriminatorMapping.value, e3))
            return i;
        }
        return null;
      };
    }, 1091: (t3) => {
      function e2(t4) {
        return e2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      t3.exports = function(t4) {
        return t4 != null && e2(t4) === "object" && t4.$slice == null && t4.$elemMatch == null && t4.$meta == null && t4.$ == null;
      };
    }, 1129: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (o = function() {
          return !!t4;
        })();
      }
      function i(t4) {
        return i = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, i(t4);
      }
      function s(t4, e3) {
        return s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s(t4, e3);
      }
      var a = r2(8213), u = r2(7352), c = function(t4) {
        function e3(t5, r4, s2, c2) {
          var l;
          (function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          })(this, e3);
          var f = a.messages;
          return (l = function(t6, e4, r5) {
            return e4 = i(e4), function(t7, e5) {
              if (e5 && (n(e5) == "object" || typeof e5 == "function"))
                return e5;
              if (e5 !== undefined)
                throw new TypeError("Derived constructors may only return object or undefined");
              return function(t8) {
                if (t8 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t8;
              }(t7);
            }(t6, o() ? Reflect.construct(e4, r5 || [], i(t6).constructor) : e4.apply(t6, r5));
          }(this, e3, [f.DocumentNotFoundError != null ? typeof f.DocumentNotFoundError == "function" ? f.DocumentNotFoundError(t5, r4) : f.DocumentNotFoundError : 'No document found for query "' + u.inspect(t5) + '" on model "' + r4 + '"'])).result = c2, l.numAffected = s2, l.filter = t5, l.query = t5, l;
        }
        return function(t5, e4) {
          if (typeof e4 != "function" && e4 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(a);
      Object.defineProperty(c.prototype, "name", { value: "DocumentNotFoundError" }), t3.exports = c;
    }, 1199: (t3) => {
      t3.exports = function(t4, e2) {
        var r2 = Object.keys(t4), n = Object.keys(e2);
        if (r2.length !== n.length)
          return false;
        for (var o = 0;o < r2.length; o++) {
          var i = r2[o];
          if (i !== n[o] || t4[i] !== e2[i])
            return false;
        }
        return true;
      };
    }, 1226: (t3) => {
      t3.exports = function(t4) {
        return t4 == null ? null : Object.keys(t4)[0];
      };
    }, 1243: (t3, e2) => {
      e2.isMongooseArray = function(t4) {
        return Array.isArray(t4) && t4.isMongooseArray;
      };
    }, 1244: (t3, e2, r2) => {
      var n = r2(3609);
      t3.exports = function(t4, e3) {
        if (t4 == null)
          return t4;
        if (t4._id && typeof t4._id == "string")
          return t4._id;
        if (t4.toString && t4.toString !== Object.prototype.toString && !Array.isArray(t4))
          return t4.toString();
        throw new n("string", t4, e3);
      };
    }, 1260: (t3, e2) => {
      var r2 = Object.freeze(["countDocuments", "distinct", "estimatedDocumentCount", "find", "findOne", "findOneAndReplace", "findOneAndUpdate", "replaceOne", "updateMany", "updateOne", "deleteMany", "deleteOne", "findOneAndDelete"]).concat(["validate"]);
      e2.Ut = r2;
    }, 1313: (t3, e2, r2) => {
      var n = r2(486);
      t3.exports = function(t4, e3) {
        return e3 == null || e3._id == null || (t4 = t4.clone(), e3._id ? t4.paths._id || (n(t4), t4.options._id = true) : (t4.remove("_id"), t4.options._id = false)), t4;
      };
    }, 1344: (t3, e2, r2) => {
      t3.exports = r2(6353).UUID;
    }, 1347: (t3, e2) => {
      e2.isMongooseDocumentArray = function(t4) {
        return Array.isArray(t4) && t4.isMongooseDocumentArray;
      };
    }, 1350: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (o = function() {
          return !!t4;
        })();
      }
      function i(t4) {
        return i = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, i(t4);
      }
      function s(t4, e3) {
        return s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s(t4, e3);
      }
      var a = function(t4) {
        function e3(t5, r4, s2) {
          return function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), function(t6, e4, r5) {
            return e4 = i(e4), function(t7, e5) {
              if (e5 && (n(e5) == "object" || typeof e5 == "function"))
                return e5;
              if (e5 !== undefined)
                throw new TypeError("Derived constructors may only return object or undefined");
              return function(t8) {
                if (t8 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t8;
              }(t7);
            }(t6, o() ? Reflect.construct(e4, r5 || [], i(t6).constructor) : e4.apply(t6, r5));
          }(this, e3, ['Parameter "' + r4 + '" to ' + s2 + '() must be an object, got "' + t5.toString() + '" (type ' + n(t5) + ")"]);
        }
        return function(t5, e4) {
          if (typeof e4 != "function" && e4 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(8213));
      Object.defineProperty(a.prototype, "name", { value: "ObjectParameterError" }), t3.exports = a;
    }, 1417: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (o = function() {
          return !!t4;
        })();
      }
      function i(t4) {
        return i = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, i(t4);
      }
      function s(t4, e3) {
        return s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s(t4, e3);
      }
      var a = function(t4) {
        function e3(t5) {
          return function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), function(t6, e4, r4) {
            return e4 = i(e4), function(t7, e5) {
              if (e5 && (n(e5) == "object" || typeof e5 == "function"))
                return e5;
              if (e5 !== undefined)
                throw new TypeError("Derived constructors may only return object or undefined");
              return function(t8) {
                if (t8 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t8;
              }(t7);
            }(t6, o() ? Reflect.construct(e4, r4 || [], i(t6).constructor) : e4.apply(t6, r4));
          }(this, e3, ["For your own good, using `document.save()` to update an array which was selected using an $elemMatch projection OR populated using skip, limit, query conditions, or exclusion of the _id field when the operation results in a $pop or $set of the entire array is not supported. The following path(s) would have been modified unsafely:\n  " + t5.join(`
  `) + `
Use Model.updateOne() to update these arrays instead.`]);
        }
        return function(t5, e4) {
          if (typeof e4 != "function" && e4 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(8213));
      Object.defineProperty(a.prototype, "name", { value: "DivergentArrayError" }), t3.exports = a;
    }, 1464: (t3, e2, r2) => {
      var n = r2(5807);
      if (n)
        try {
          n([], "length");
        } catch (t4) {
          n = null;
        }
      t3.exports = n;
    }, 1469: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function i(t4, e3, r3) {
        return (e3 = function(t5) {
          var e4 = function(t6) {
            if (n(t6) != "object" || !t6)
              return t6;
            var e5 = t6[Symbol.toPrimitive];
            if (e5 !== undefined) {
              var r4 = e5.call(t6, "string");
              if (n(r4) != "object")
                return r4;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t6);
          }(t5);
          return n(e4) == "symbol" ? e4 : e4 + "";
        }(e3)) in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      function s() {
        var t4, e3, r3 = typeof Symbol == "function" ? Symbol : {}, n2 = r3.iterator || "@@iterator", o2 = r3.toStringTag || "@@toStringTag";
        function i2(r4, n3, o3, i3) {
          var s2 = n3 && n3.prototype instanceof c2 ? n3 : c2, l3 = Object.create(s2.prototype);
          return a(l3, "_invoke", function(r5, n4, o4) {
            var i4, s3, a2, c3 = 0, l4 = o4 || [], f3 = false, p3 = { p: 0, n: 0, v: t4, a: h3, f: h3.bind(t4, 4), d: function(e4, r6) {
              return i4 = e4, s3 = 0, a2 = t4, p3.n = r6, u2;
            } };
            function h3(r6, n5) {
              for (s3 = r6, a2 = n5, e3 = 0;!f3 && c3 && !o5 && e3 < l4.length; e3++) {
                var o5, i5 = l4[e3], h4 = p3.p, y3 = i5[2];
                r6 > 3 ? (o5 = y3 === n5) && (a2 = i5[(s3 = i5[4]) ? 5 : (s3 = 3, 3)], i5[4] = i5[5] = t4) : i5[0] <= h4 && ((o5 = r6 < 2 && h4 < i5[1]) ? (s3 = 0, p3.v = n5, p3.n = i5[1]) : h4 < y3 && (o5 = r6 < 3 || i5[0] > n5 || n5 > y3) && (i5[4] = r6, i5[5] = n5, p3.n = y3, s3 = 0));
              }
              if (o5 || r6 > 1)
                return u2;
              throw f3 = true, n5;
            }
            return function(o5, l5, y3) {
              if (c3 > 1)
                throw TypeError("Generator is already running");
              for (f3 && l5 === 1 && h3(l5, y3), s3 = l5, a2 = y3;(e3 = s3 < 2 ? t4 : a2) || !f3; ) {
                i4 || (s3 ? s3 < 3 ? (s3 > 1 && (p3.n = -1), h3(s3, a2)) : p3.n = a2 : p3.v = a2);
                try {
                  if (c3 = 2, i4) {
                    if (s3 || (o5 = "next"), e3 = i4[o5]) {
                      if (!(e3 = e3.call(i4, a2)))
                        throw TypeError("iterator result is not an object");
                      if (!e3.done)
                        return e3;
                      a2 = e3.value, s3 < 2 && (s3 = 0);
                    } else
                      s3 === 1 && (e3 = i4.return) && e3.call(i4), s3 < 2 && (a2 = TypeError("The iterator does not provide a '" + o5 + "' method"), s3 = 1);
                    i4 = t4;
                  } else if ((e3 = (f3 = p3.n < 0) ? a2 : r5.call(n4, p3)) !== u2)
                    break;
                } catch (e4) {
                  i4 = t4, s3 = 1, a2 = e4;
                } finally {
                  c3 = 1;
                }
              }
              return { value: e3, done: f3 };
            };
          }(r4, o3, i3), true), l3;
        }
        var u2 = {};
        function c2() {}
        function l2() {}
        function f2() {}
        e3 = Object.getPrototypeOf;
        var p2 = [][n2] ? e3(e3([][n2]())) : (a(e3 = {}, n2, function() {
          return this;
        }), e3), h2 = f2.prototype = c2.prototype = Object.create(p2);
        function y2(t5) {
          return Object.setPrototypeOf ? Object.setPrototypeOf(t5, f2) : (t5.__proto__ = f2, a(t5, o2, "GeneratorFunction")), t5.prototype = Object.create(h2), t5;
        }
        return l2.prototype = f2, a(h2, "constructor", f2), a(f2, "constructor", l2), l2.displayName = "GeneratorFunction", a(f2, o2, "GeneratorFunction"), a(h2), a(h2, o2, "Generator"), a(h2, n2, function() {
          return this;
        }), a(h2, "toString", function() {
          return "[object Generator]";
        }), (s = function() {
          return { w: i2, m: y2 };
        })();
      }
      function a(t4, e3, r3, n2) {
        var o2 = Object.defineProperty;
        try {
          o2({}, "", {});
        } catch (t5) {
          o2 = 0;
        }
        a = function(t5, e4, r4, n3) {
          function i2(e5, r5) {
            a(t5, e5, function(t6) {
              return this._invoke(e5, r5, t6);
            });
          }
          e4 ? o2 ? o2(t5, e4, { value: r4, enumerable: !n3, configurable: !n3, writable: !n3 }) : t5[e4] = r4 : (i2("next", 0), i2("throw", 1), i2("return", 2));
        }, a(t4, e3, r3, n2);
      }
      function u(t4) {
        return function(t5) {
          if (Array.isArray(t5))
            return f(t5);
        }(t4) || function(t5) {
          if (typeof Symbol != "undefined" && t5[Symbol.iterator] != null || t5["@@iterator"] != null)
            return Array.from(t5);
        }(t4) || l(t4) || function() {
          throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }();
      }
      function c(t4, e3) {
        var r3 = typeof Symbol != "undefined" && t4[Symbol.iterator] || t4["@@iterator"];
        if (!r3) {
          if (Array.isArray(t4) || (r3 = l(t4)) || e3 && t4 && typeof t4.length == "number") {
            r3 && (t4 = r3);
            var n2 = 0, o2 = function() {};
            return { s: o2, n: function() {
              return n2 >= t4.length ? { done: true } : { done: false, value: t4[n2++] };
            }, e: function(t5) {
              throw t5;
            }, f: o2 };
          }
          throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        var i2, s2 = true, a2 = false;
        return { s: function() {
          r3 = r3.call(t4);
        }, n: function() {
          var t5 = r3.next();
          return s2 = t5.done, t5;
        }, e: function(t5) {
          a2 = true, i2 = t5;
        }, f: function() {
          try {
            s2 || r3.return == null || r3.return();
          } finally {
            if (a2)
              throw i2;
          }
        } };
      }
      function l(t4, e3) {
        if (t4) {
          if (typeof t4 == "string")
            return f(t4, e3);
          var r3 = {}.toString.call(t4).slice(8, -1);
          return r3 === "Object" && t4.constructor && (r3 = t4.constructor.name), r3 === "Map" || r3 === "Set" ? Array.from(t4) : r3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? f(t4, e3) : undefined;
        }
      }
      function f(t4, e3) {
        (e3 == null || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = Array(e3);r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      var p = r2(5022), h = r2(8442), y = r2(4450), d = r2(2068).X, b = r2(3703), m = r2(8768), v = r2(4301), g = { toJSON: true, toObject: true, _id: true, id: true, virtuals: true, methods: true, statics: true };
      t3.exports = function(t4, e3, r3, n2, a2, l2, f2) {
        if (!r3 || !r3.instanceOfSchema)
          throw new Error("You must pass a valid discriminator Schema");
        if (l2 = l2 == null || l2, t4.schema.discriminatorMapping && !t4.schema.discriminatorMapping.isRoot)
          throw new Error('Discriminator "' + e3 + '" can only be a discriminator of the root model');
        if (a2) {
          var _ = b(t4.base, "options.applyPluginsToDiscriminators", false) || !l2;
          t4.base._applyPlugins(r3, { skipTopLevel: !_ });
        } else
          l2 || h(r3);
        var w = t4.schema.options.discriminatorKey, O = t4.schema.path(w);
        if (O != null)
          m.hasUserDefinedProperty(O.options, "select") || (O.options.select = true), O.options.$skipDiscriminatorCheck = true;
        else {
          var S = {};
          S[w] = { default: undefined, select: true, $skipDiscriminatorCheck: true }, S[w][t4.schema.options.typeKey] = String, t4.schema.add(S), d({ prop: w, prototype: t4.prototype, options: t4.schema.options });
        }
        if (r3.path(w) && r3.path(w).options.$skipDiscriminatorCheck !== true)
          throw new Error('Discriminator "' + e3 + '" cannot have field with name "' + w + '"');
        var $ = e3;
        if ((typeof n2 == "string" && n2.length || n2 != null) && ($ = n2), function(t5, e4) {
          var r4 = s().m(l3);
          if (t5.encryptionType() != null || e4.encryptionType() != null) {
            var n3, o2 = c(l3(a3(t5), a3(e4)));
            try {
              for (o2.s();!(n3 = o2.n()).done; ) {
                var i2 = n3.value;
                if (t5._hasEncryptedField(i2) && e4._hasEncryptedField(i2))
                  throw new Error("encrypted fields cannot be declared on both the base schema and the child schema in a discriminator. path=".concat(i2));
                if (t5._hasEncryptedField(i2) || e4._hasEncryptedField(i2))
                  throw new Error("encrypted fields cannot have the same path as a non-encrypted field for discriminators. path=".concat(i2));
              }
            } catch (t6) {
              o2.e(t6);
            } finally {
              o2.f();
            }
          }
          function a3(t6) {
            return [].concat(u(Object.keys(t6.paths)), u(Object.keys(t6.singleNestedPaths)));
          }
          function l3(t6, e5) {
            var n4, o3, i3, a4, u2;
            return s().w(function(r5) {
              for (;; )
                switch (r5.p = r5.n) {
                  case 0:
                    n4 = new Set(t6), o3 = c(e5), r5.p = 1, o3.s();
                  case 2:
                    if ((i3 = o3.n()).done) {
                      r5.n = 4;
                      break;
                    }
                    if (a4 = i3.value, !n4.has(a4)) {
                      r5.n = 3;
                      break;
                    }
                    return r5.n = 3, a4;
                  case 3:
                    r5.n = 2;
                    break;
                  case 4:
                    r5.n = 6;
                    break;
                  case 5:
                    r5.p = 5, u2 = r5.v, o3.e(u2);
                  case 6:
                    return r5.p = 6, o3.f(), r5.f(6);
                  case 7:
                    return r5.a(2);
                }
            }, r4, null, [[1, 5, 6, 7]]);
          }
        }(t4.schema, r3), function(e4, r4) {
          e4._baseSchema = r4, r4.paths._id && r4.paths._id.options && !r4.paths._id.options.auto && e4.remove("_id");
          for (var n3 = [], s2 = 0, u2 = Object.keys(r4.paths);s2 < u2.length; s2++) {
            var f3 = u2[s2];
            if (e4.nested[f3])
              n3.push(f3);
            else if (f3.indexOf(".") !== -1) {
              var h2, d2 = "", b2 = c(f3.split(".").slice(0, -1));
              try {
                for (b2.s();!(h2 = b2.n()).done; ) {
                  var _2 = h2.value;
                  d2 += (d2.length ? "." : "") + _2, (e4.paths[d2] instanceof p || e4.singleNestedPaths[d2] instanceof p) && n3.push(f3);
                }
              } catch (t5) {
                b2.e(t5);
              } finally {
                b2.f();
              }
            }
          }
          e4.obj = function(t5) {
            for (var e5 = 1;e5 < arguments.length; e5++) {
              var r5 = arguments[e5] != null ? arguments[e5] : {};
              e5 % 2 ? o(Object(r5), true).forEach(function(e6) {
                i(t5, e6, r5[e6]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t5, Object.getOwnPropertyDescriptors(r5)) : o(Object(r5)).forEach(function(e6) {
                Object.defineProperty(t5, e6, Object.getOwnPropertyDescriptor(r5, e6));
              });
            }
            return t5;
          }({}, e4.obj), v(e4, r4), e4._gatherChildSchemas();
          for (var S2 = 0, j = n3;S2 < j.length; S2++) {
            var P = j[S2];
            delete e4.paths[P];
          }
          e4.childSchemas.forEach(function(t5) {
            t5.model.prototype.$__setSchema(t5.schema);
          });
          var A = {};
          A[w] = { default: $, select: true, set: function(t5) {
            if (t5 === $ || Array.isArray($) && m.deepEqual(t5, $))
              return $;
            throw new Error(`Can't set discriminator key "` + w + '"');
          }, $skipDiscriminatorCheck: true }, A[w][e4.options.typeKey] = O ? O.options[e4.options.typeKey] : String, e4.add(A), e4.discriminatorMapping = { key: w, value: $, isRoot: false }, r4.options.collection && (e4.options.collection = r4.options.collection);
          var E = e4.options.toJSON, x = e4.options.toObject, T = e4.options._id, k = e4.options.id, N = Object.keys(e4.options);
          e4.options.discriminatorKey = r4.options.discriminatorKey;
          for (var I = e4._userProvidedOptions, B = 0, M = N;B < M.length; B++) {
            var D = M[B];
            if (!g[D] && D in I && !m.deepEqual(e4.options[D], r4.options[D]))
              throw new Error("Can't customize discriminator option " + D + " (can only modify " + Object.keys(g).join(", ") + ")");
          }
          e4.options = y(r4.options);
          for (var R = 0, U = Object.keys(I);R < U.length; R++) {
            var C = U[R];
            e4.options[C] = I[C];
          }
          E && (e4.options.toJSON = E), x && (e4.options.toObject = x), T !== undefined && (e4.options._id = T), e4.options.id = k, l2 && (e4.s.hooks = t4.schema.s.hooks.merge(e4.s.hooks)), a2 && (e4.plugins = Array.prototype.slice.call(r4.plugins)), e4.callQueue = r4.callQueue.concat(e4.callQueue), delete e4._requiredpaths;
        }(r3, t4.schema), t4.discriminators || (t4.discriminators = {}), t4.schema.discriminatorMapping || (t4.schema.discriminatorMapping = { key: w, value: null, isRoot: true }), t4.schema.discriminators || (t4.schema.discriminators = {}), t4.schema.discriminators[e3] = r3, t4.discriminators[e3] && !r3.options.overwriteModels && !f2)
          throw new Error('Discriminator with name "' + e3 + '" already exists');
        return r3;
      };
    }, 1505: (t3) => {
      t3.exports = function(t4, e2, r2, n, o) {
        var i = e2 != null && e2.updatedAt === false, s = e2 != null && e2.createdAt === false, a = r2 != null ? r2() : t4.ownerDocument().constructor.base.now();
        if (!s && (t4.isNew || t4.$isSubdocument) && n && !t4.$__getValue(n) && t4.$__isSelected(n) && t4.$set(n, a, undefined, { overwriteImmutable: true }), !i && o && (t4.isNew || t4.$isModified())) {
          var u = a;
          t4.isNew && n != null && (u = t4.$__getValue(n)), t4.$set(o, u);
        }
      };
    }, 1635: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (o = function() {
          return !!t4;
        })();
      }
      function i(t4) {
        return i = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, i(t4);
      }
      function s(t4, e3) {
        return s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s(t4, e3);
      }
      var a = function(t4) {
        function e3(t5) {
          return function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), function(t6, e4, r4) {
            return e4 = i(e4), function(t7, e5) {
              if (e5 && (n(e5) == "object" || typeof e5 == "function"))
                return e5;
              if (e5 !== undefined)
                throw new TypeError("Derived constructors may only return object or undefined");
              return function(t8) {
                if (t8 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t8;
              }(t7);
            }(t6, o() ? Reflect.construct(e4, r4 || [], i(t6).constructor) : e4.apply(t6, r4));
          }(this, e3, ["Can't validate() the same doc multiple times in parallel. Document: " + t5._doc._id]);
        }
        return function(t5, e4) {
          if (typeof e4 != "function" && e4 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(8213));
      Object.defineProperty(a.prototype, "name", { value: "ParallelValidateError" }), t3.exports = a;
    }, 1679: (t3) => {
      typeof Object.create == "function" ? t3.exports = function(t4, e2) {
        e2 && (t4.super_ = e2, t4.prototype = Object.create(e2.prototype, { constructor: { value: t4, enumerable: false, writable: true, configurable: true } }));
      } : t3.exports = function(t4, e2) {
        if (e2) {
          t4.super_ = e2;
          var r2 = function() {};
          r2.prototype = e2.prototype, t4.prototype = new r2, t4.prototype.constructor = t4;
        }
      };
    }, 1697: (t3) => {
      t3.exports = Math.max;
    }, 1732: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function i(t4) {
        for (var e3 = 1;e3 < arguments.length; e3++) {
          var r3 = arguments[e3] != null ? arguments[e3] : {};
          e3 % 2 ? o(Object(r3), true).forEach(function(e4) {
            s(t4, e4, r3[e4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : o(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      function s(t4, e3, r3) {
        return (e3 = function(t5) {
          var e4 = function(t6) {
            if (n(t6) != "object" || !t6)
              return t6;
            var e5 = t6[Symbol.toPrimitive];
            if (e5 !== undefined) {
              var r4 = e5.call(t6, "string");
              if (n(r4) != "object")
                return r4;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t6);
          }(t5);
          return n(e4) == "symbol" ? e4 : e4 + "";
        }(e3)) in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      var a = r2(3609), u = r2(6426), c = r2(3704), l = r2(4327);
      function f(t4, e3) {
        u.call(this, t4, e3, "Double");
      }
      function p(t4) {
        return this.cast(t4);
      }
      f.schemaName = "Double", f.defaultOptions = {}, f.prototype = Object.create(u.prototype), f.prototype.constructor = f, f._cast = c, f.set = u.set, f.setters = [], f.get = u.get, f._defaultCaster = function(t4) {
        if (t4 != null && t4._bsontype !== "Double")
          throw new Error;
        return t4;
      }, f.cast = function(t4) {
        return arguments.length === 0 || (t4 === false && (t4 = this._defaultCaster), this._cast = t4), this._cast;
      }, f._checkRequired = function(t4) {
        return t4 != null;
      }, f.checkRequired = u.checkRequired, f.prototype.checkRequired = function(t4) {
        return this.constructor._checkRequired(t4);
      }, f.prototype.cast = function(t4) {
        var e3;
        e3 = typeof this._castFunction == "function" ? this._castFunction : typeof this.constructor.cast == "function" ? this.constructor.cast() : f.cast();
        try {
          return e3(t4);
        } catch (e4) {
          throw new a("Double", t4, this.path, e4, this);
        }
      };
      var h = i(i({}, u.prototype.$conditionalHandlers), {}, { $gt: p, $gte: p, $lt: p, $lte: p });
      Object.defineProperty(f.prototype, "$conditionalHandlers", { enumerable: false, value: h }), f.prototype.toJSONSchema = function(t4) {
        var e3 = this.options.required && typeof this.options.required != "function";
        return l("number", "double", t4 == null ? undefined : t4.useBsonType, e3);
      }, f.prototype.autoEncryptionType = function() {
        return "double";
      }, t3.exports = f;
    }, 1793: (t3, e2, r2) => {
      var n = r2(7300), o = r2(2789);
      t3.exports = function t(e3) {
        if (e3 == null)
          return null;
        var r3 = Object.keys(e3), i = null;
        if (r3.length === 1 && r3[0] === "_id")
          i = !e3._id;
        else
          for (var s = 0;s < r3.length; ++s) {
            var a, u = r3[s];
            if (u !== "_id" && n(e3[u]) && (i = o(e3[u]) ? (a = t(e3[u])) !== null && a !== undefined ? a : i : !e3[u]) != null)
              break;
          }
        return i;
      };
    }, 1824: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var o = r2(3703);
      t3.exports = function(t4, e3, r3, i, s, a) {
        var u = i, c = u, l = o(s, "timestamps", true);
        if (!l || u == null)
          return i;
        var f, p, h, y = l != null && l.createdAt === false, d = l != null && l.updatedAt === false;
        if (a)
          return i && i.$set && (i = i.$set, u.$set = {}, c = u.$set), d || !r3 || i[r3] || (c[r3] = t4), y || !e3 || i[e3] || (c[e3] = t4), u;
        if (i = i || {}, Array.isArray(u))
          return r3 == null || u.push({ $set: (f = {}, p = r3, h = t4, ((p = function(t5) {
            var e4 = function(t6) {
              if (n(t6) != "object" || !t6)
                return t6;
              var e5 = t6[Symbol.toPrimitive];
              if (e5 !== undefined) {
                var r4 = e5.call(t6, "string");
                if (n(r4) != "object")
                  return r4;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(t6);
            }(t5);
            return n(e4) == "symbol" ? e4 : e4 + "";
          }(p)) in f) ? Object.defineProperty(f, p, { value: h, enumerable: true, configurable: true, writable: true }) : f[p] = h, f) }), u;
        if (u.$set = u.$set || {}, !d && r3 && (!i.$currentDate || !i.$currentDate[r3])) {
          var b = false;
          if (r3.indexOf(".") !== -1)
            for (var m = r3.split("."), v = 1;v < m.length; ++v) {
              var g = m.slice(-v).join("."), _ = m.slice(0, -v).join(".");
              if (i[_] != null) {
                i[_][g] = t4, b = true;
                break;
              }
              if (i.$set && i.$set[_]) {
                i.$set[_][g] = t4, b = true;
                break;
              }
            }
          b || (u.$set[r3] = t4), u.hasOwnProperty(r3) && delete u[r3];
        }
        if (!y && e3) {
          i[e3] && delete i[e3], i.$set && i.$set[e3] && delete i.$set[e3];
          var w = false;
          if (e3.indexOf(".") !== -1)
            for (var O = e3.split("."), S = 1;S < O.length; ++S) {
              var $ = O.slice(-S).join("."), j = O.slice(0, -S).join(".");
              if (i[j] != null) {
                i[j][$] = t4, w = true;
                break;
              }
              if (i.$set && i.$set[j]) {
                i.$set[j][$] = t4, w = true;
                break;
              }
            }
          w || (u.$setOnInsert = u.$setOnInsert || {}, u.$setOnInsert[e3] = t4);
        }
        return Object.keys(u.$set).length === 0 && delete u.$set, u;
      };
    }, 1849: (t3, e2, r2) => {
      function n(t4, e3) {
        (e3 == null || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = Array(e3);r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      var o = r2(8768);
      t3.exports = function(t4, e3) {
        if (t4._doc._id != null && e3 != null && e3.length !== 0) {
          var r3, i = String(t4._doc._id), s = function(t5, e4) {
            var r4 = typeof Symbol != "undefined" && t5[Symbol.iterator] || t5["@@iterator"];
            if (!r4) {
              if (Array.isArray(t5) || (r4 = function(t6, e5) {
                if (t6) {
                  if (typeof t6 == "string")
                    return n(t6, e5);
                  var r5 = {}.toString.call(t6).slice(8, -1);
                  return r5 === "Object" && t6.constructor && (r5 = t6.constructor.name), r5 === "Map" || r5 === "Set" ? Array.from(t6) : r5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? n(t6, e5) : undefined;
                }
              }(t5)) || e4 && t5 && typeof t5.length == "number") {
                r4 && (t5 = r4);
                var o2 = 0, i2 = function() {};
                return { s: i2, n: function() {
                  return o2 >= t5.length ? { done: true } : { done: false, value: t5[o2++] };
                }, e: function(t6) {
                  throw t6;
                }, f: i2 };
              }
              throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            var s2, a2 = true, u2 = false;
            return { s: function() {
              r4 = r4.call(t5);
            }, n: function() {
              var t6 = r4.next();
              return a2 = t6.done, t6;
            }, e: function(t6) {
              u2 = true, s2 = t6;
            }, f: function() {
              try {
                a2 || r4.return == null || r4.return();
              } finally {
                if (u2)
                  throw s2;
              }
            } };
          }(e3);
          try {
            for (s.s();!(r3 = s.n()).done; ) {
              var a = r3.value;
              if (!a.isVirtual)
                for (var u = a.path.split("."), c = 0;c < u.length - 1; ++c) {
                  var l = u.slice(0, c + 1).join("."), f = u.slice(c + 1).join("."), p = t4.get(l);
                  if (p != null && o.isMongooseDocumentArray(p)) {
                    for (var h = 0;h < p.length; ++h)
                      p[h] && p[h].populated(f, a._docs[i] == null ? undefined : a._docs[i][h], a);
                    break;
                  }
                }
            }
          } catch (t5) {
            s.e(t5);
          } finally {
            s.f();
          }
        }
      };
    }, 1875: (t3) => {
      t3.exports = function(t4) {
        for (var e2, r2 = Object.keys(t4.errors || {}), n = r2.length, o = [], i = 0;i < n; ++i)
          e2 = r2[i], t4 !== t4.errors[e2] && o.push(e2 + ": " + t4.errors[e2].message);
        return o.join(", ");
      };
    }, 1898: (t3, e2, r2) => {
      e2.saveSubdocs = r2(4432), e2.sharding = r2(2824), e2.trackTransaction = r2(5889), e2.validateBeforeSave = r2(9848);
    }, 1905: (t3, e2, r2) => {
      var n, o = r2(3071), i = r2(2724)(/^\s*(?:function)?\*/), s = r2(953)(), a = r2(209), u = o("Object.prototype.toString"), c = o("Function.prototype.toString");
      t3.exports = function(t4) {
        if (typeof t4 != "function")
          return false;
        if (i(c(t4)))
          return true;
        if (!s)
          return u(t4) === "[object GeneratorFunction]";
        if (!a)
          return false;
        if (n === undefined) {
          var e3 = function() {
            if (!s)
              return false;
            try {
              return Function("return function*() {}")();
            } catch (t5) {}
          }();
          n = !!e3 && a(e3);
        }
        return a(t4) === n;
      };
    }, 2003: (t3, e2, r2) => {
      var n = r2(3703), o = r2(608), i = r2(2423);
      t3.exports = function(t4) {
        var e3 = [], r3 = new WeakMap, s = t4.constructor.indexTypes, a = new Map;
        return function t(u, c, l) {
          if (!r3.has(u)) {
            r3.set(u, true), c = c || "";
            for (var f = 0, p = Object.keys(u.paths);f < p.length; f++) {
              var h = p[f], y = u.paths[h];
              if (l == null || !l.paths[h]) {
                if (y._duplicateKeyErrorMessage != null && (u._duplicateKeyErrorMessagesByPath = u._duplicateKeyErrorMessagesByPath || {}, u._duplicateKeyErrorMessagesByPath[h] = y._duplicateKeyErrorMessage), y.$isMongooseDocumentArray || y.$isSingleNested) {
                  if (n(y, "options.excludeIndexes") !== true && n(y, "schemaOptions.excludeIndexes") !== true && n(y, "schema.options.excludeIndexes") !== true && t(y.schema, c + h + "."), y.schema.discriminators != null)
                    for (var d = y.schema.discriminators, b = 0, m = Object.keys(d);b < m.length; b++) {
                      t(d[m[b]], c + h + ".", y.schema);
                    }
                  if (y.$isMongooseDocumentArray)
                    continue;
                }
                var v = y._index || y.caster && y.caster._index;
                if (v !== false && v != null) {
                  var g = {}, _ = o(v), w = _ ? v : {}, O = typeof v == "string" ? v : !!_ && v.type;
                  if (O && s.indexOf(O) !== -1)
                    g[c + h] = O;
                  else if (w.text)
                    g[c + h] = "text", delete w.text;
                  else {
                    var S;
                    S = v === "descending" || v === "desc" || v !== "ascending" && v !== "asc" && Number(v) === -1, g[c + h] = S ? -1 : 1;
                  }
                  delete w.type, "background" in w || (w.background = true), u.options.autoIndex != null && (w._autoIndex = u.options.autoIndex);
                  var $ = w && w.name;
                  typeof $ == "string" && a.has($) ? Object.assign(a.get($), g) : (e3.push([g, w]), a.set($, g));
                }
              }
            }
            r3.delete(u), c ? function(t5, r4) {
              for (var n2 = t5._indexes, o2 = n2.length, i2 = 0;i2 < o2; ++i2) {
                for (var s2 = n2[i2][0], a2 = n2[i2][1], u2 = Object.keys(s2), c2 = u2.length, l2 = {}, f2 = 0;f2 < c2; ++f2) {
                  var p2 = u2[f2];
                  l2[r4 + p2] = s2[p2];
                }
                var h2 = Object.assign({}, a2);
                if (a2 != null && a2.partialFilterExpression != null) {
                  h2.partialFilterExpression = {};
                  for (var y2 = a2.partialFilterExpression, d2 = 0, b2 = Object.keys(y2);d2 < b2.length; d2++) {
                    var m2 = b2[d2];
                    h2.partialFilterExpression[r4 + m2] = y2[m2];
                  }
                }
                e3.push([l2, h2]);
              }
            }(u, c) : (u._indexes.forEach(function(t5) {
              var e4 = t5[1];
              "background" in e4 || (e4.background = true), i(u, e4);
            }), e3 = e3.concat(u._indexes));
          }
        }(t4), e3;
      };
    }, 2064: (t3, e2, r2) => {
      var n = r2(2273), o = r2(9122), i = r2(4756), s = r2(2481), a = r2(9247), u = o(s(), Object);
      n(u, { getPolyfill: s, implementation: i, shim: a }), t3.exports = u;
    }, 2068: (t3, e2, r2) => {
      var n, o = r2(4450), i = r2(7930).documentSchemaSymbol, s = r2(3303)._, a = r2(8768), u = r2(7930).getSymbol, c = r2(7930).scopeSymbol, l = a.isPOJO;
      e2.w = h, e2.X = y;
      var f = Object.freeze({ minimize: true, virtuals: false, getters: false, transform: false }), p = Object.freeze({ noDottedPath: true });
      function h(t4, e3, o2, i2) {
        n = n || r2(2400);
        for (var s2 = i2.typeKey, a2 = 0, u2 = Object.keys(t4);a2 < u2.length; a2++) {
          var c2 = u2[a2], f2 = t4[c2];
          y({ prop: c2, subprops: l(f2) && Object.keys(f2).length > 0 && (!f2[s2] || s2 === "type" && l(f2.type) && f2.type.type) ? f2 : null, prototype: e3, prefix: o2, options: i2 });
        }
      }
      function y(t4) {
        var { prop: e3, subprops: a2, prototype: l2, prefix: y2, options: d } = t4;
        n = n || r2(2400);
        var b = (y2 ? y2 + "." : "") + e3, m = (y2 = y2 || "") ? Object.freeze({}) : p;
        a2 ? Object.defineProperty(l2, e3, { enumerable: true, configurable: true, get: function() {
          var t5, e4, r3 = this;
          if (this.$__.getters || (this.$__.getters = {}), !this.$__.getters[b]) {
            var s2 = Object.create(n.prototype, (t5 = this, e4 = {}, Object.getOwnPropertyNames(t5).forEach(function(r4) {
              ["isNew", "$__", "$errors", "errors", "_doc", "$locals", "$op", "__parentArray", "__index", "$isDocumentArrayElement"].indexOf(r4) === -1 || (e4[r4] = Object.getOwnPropertyDescriptor(t5, r4), e4[r4].enumerable = false);
            }), e4));
            y2 || (s2.$__[c] = this), s2.$__.nestedPath = b, Object.defineProperty(s2, "schema", { enumerable: false, configurable: true, writable: false, value: l2.schema }), Object.defineProperty(s2, "$__schema", { enumerable: false, configurable: true, writable: false, value: l2.schema }), Object.defineProperty(s2, i, { enumerable: false, configurable: true, writable: false, value: l2.schema }), Object.defineProperty(s2, "toObject", { enumerable: false, configurable: true, writable: false, value: function() {
              return o(r3.get(b, null, { virtuals: this && this.schema && this.schema.options && this.schema.options.toObject && this.schema.options.toObject.virtuals || null }));
            } }), Object.defineProperty(s2, "$__get", { enumerable: false, configurable: true, writable: false, value: function() {
              return r3.get(b, null, { virtuals: this && this.schema && this.schema.options && this.schema.options.toObject && this.schema.options.toObject.virtuals || null });
            } }), Object.defineProperty(s2, "toJSON", { enumerable: false, configurable: true, writable: false, value: function() {
              return r3.get(b, null, { virtuals: this && this.schema && this.schema.options && this.schema.options.toJSON && this.schema.options.toJSON.virtuals || null });
            } }), Object.defineProperty(s2, "$__isNested", { enumerable: false, configurable: true, writable: false, value: true }), Object.defineProperty(s2, "$isEmpty", { enumerable: false, configurable: true, writable: false, value: function() {
              return Object.keys(this.get(b, null, f) || {}).length === 0;
            } }), Object.defineProperty(s2, "$__parent", { enumerable: false, configurable: true, writable: false, value: this }), h(a2, s2, b, d), this.$__.getters[b] = s2;
          }
          return this.$__.getters[b];
        }, set: function(t5) {
          t5 != null && t5.$__isNested ? t5 = t5.$__get() : t5 instanceof n && !t5.$__isNested && (t5 = t5.$toObject(s)), (this.$__[c] || this).$set(b, t5);
        } }) : Object.defineProperty(l2, e3, { enumerable: true, configurable: true, get: function() {
          return this[u].call(this.$__[c] || this, b, null, m);
        }, set: function(t5) {
          this.$set.call(this.$__[c] || this, b, t5);
        } });
      }
    }, 2069: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o(t4, e3) {
        for (var r3 = 0;r3 < e3.length; r3++) {
          var n2 = e3[r3];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t4, s(n2.key), n2);
        }
      }
      function i(t4, e3, r3) {
        return e3 && o(t4.prototype, e3), r3 && o(t4, r3), Object.defineProperty(t4, "prototype", { writable: false }), t4;
      }
      function s(t4) {
        var e3 = function(t5) {
          if (n(t5) != "object" || !t5)
            return t5;
          var e4 = t5[Symbol.toPrimitive];
          if (e4 !== undefined) {
            var r3 = e4.call(t5, "string");
            if (n(r3) != "object")
              return r3;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t5);
        }(t4);
        return n(e3) == "symbol" ? e3 : e3 + "";
      }
      var a = r2(5761), u = i(function t(e3) {
        (function(t4, e4) {
          if (!(t4 instanceof e4))
            throw new TypeError("Cannot call a class as a function");
        })(this, t), Object.assign(this, e3), e3 != null && e3.options != null && (this.options = Object.assign({}, e3.options));
      });
      Object.defineProperty(u.prototype, "ref", a), Object.defineProperty(u.prototype, "refPath", a), Object.defineProperty(u.prototype, "localField", a), Object.defineProperty(u.prototype, "foreignField", a), Object.defineProperty(u.prototype, "justOne", a), Object.defineProperty(u.prototype, "count", a), Object.defineProperty(u.prototype, "match", a), Object.defineProperty(u.prototype, "options", a), Object.defineProperty(u.prototype, "skip", a), Object.defineProperty(u.prototype, "limit", a), Object.defineProperty(u.prototype, "perDocumentLimit", a), t3.exports = u;
    }, 2073: (t3) => {
      t3.exports = function t(e2) {
        if (!Array.isArray(e2))
          return { min: 0, max: 0, containsNonArrayItem: true };
        if (e2.length === 0)
          return { min: 1, max: 1, containsNonArrayItem: false };
        if (e2.length === 1 && !Array.isArray(e2[0]))
          return { min: 1, max: 1, containsNonArrayItem: false };
        for (var r2 = t(e2[0]), n = 1;n < e2.length; ++n) {
          var o = t(e2[n]);
          o.min < r2.min && (r2.min = o.min), o.max > r2.max && (r2.max = o.max), r2.containsNonArrayItem = r2.containsNonArrayItem || o.containsNonArrayItem;
        }
        return r2.min = r2.min + 1, r2.max = r2.max + 1, r2;
      };
    }, 2081: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o(t4, e3) {
        var r3 = typeof Symbol != "undefined" && t4[Symbol.iterator] || t4["@@iterator"];
        if (!r3) {
          if (Array.isArray(t4) || (r3 = function(t5, e4) {
            if (t5) {
              if (typeof t5 == "string")
                return i(t5, e4);
              var r4 = {}.toString.call(t5).slice(8, -1);
              return r4 === "Object" && t5.constructor && (r4 = t5.constructor.name), r4 === "Map" || r4 === "Set" ? Array.from(t5) : r4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r4) ? i(t5, e4) : undefined;
            }
          }(t4)) || e3 && t4 && typeof t4.length == "number") {
            r3 && (t4 = r3);
            var n2 = 0, o2 = function() {};
            return { s: o2, n: function() {
              return n2 >= t4.length ? { done: true } : { done: false, value: t4[n2++] };
            }, e: function(t5) {
              throw t5;
            }, f: o2 };
          }
          throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        var s2, a2 = true, u2 = false;
        return { s: function() {
          r3 = r3.call(t4);
        }, n: function() {
          var t5 = r3.next();
          return a2 = t5.done, t5;
        }, e: function(t5) {
          u2 = true, s2 = t5;
        }, f: function() {
          try {
            a2 || r3.return == null || r3.return();
          } finally {
            if (u2)
              throw s2;
          }
        } };
      }
      function i(t4, e3) {
        (e3 == null || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = Array(e3);r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      function s(t4, e3) {
        for (var r3 = 0;r3 < e3.length; r3++) {
          var n2 = e3[r3];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t4, a(n2.key), n2);
        }
      }
      function a(t4) {
        var e3 = function(t5) {
          if (n(t5) != "object" || !t5)
            return t5;
          var e4 = t5[Symbol.toPrimitive];
          if (e4 !== undefined) {
            var r3 = e4.call(t5, "string");
            if (n(r3) != "object")
              return r3;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t5);
        }(t4);
        return n(e3) == "symbol" ? e3 : e3 + "";
      }
      function u(t4, e3, r3, n2) {
        var o2 = c(h(1 & n2 ? t4.prototype : t4), e3, r3);
        return 2 & n2 && typeof o2 == "function" ? function(t5) {
          return o2.apply(r3, t5);
        } : o2;
      }
      function c() {
        return c = typeof Reflect != "undefined" && Reflect.get ? Reflect.get.bind() : function(t4, e3, r3) {
          var n2 = function(t5, e4) {
            for (;!{}.hasOwnProperty.call(t5, e4) && (t5 = h(t5)) !== null; )
              ;
            return t5;
          }(t4, e3);
          if (n2) {
            var o2 = Object.getOwnPropertyDescriptor(n2, e3);
            return o2.get ? o2.get.call(arguments.length < 3 ? t4 : r3) : o2.value;
          }
        }, c.apply(null, arguments);
      }
      function l(t4) {
        var e3 = typeof Map == "function" ? new Map : undefined;
        return l = function(t5) {
          if (t5 === null || !function(t6) {
            try {
              return Function.toString.call(t6).indexOf("[native code]") !== -1;
            } catch (e4) {
              return typeof t6 == "function";
            }
          }(t5))
            return t5;
          if (typeof t5 != "function")
            throw new TypeError("Super expression must either be null or a function");
          if (e3 !== undefined) {
            if (e3.has(t5))
              return e3.get(t5);
            e3.set(t5, r3);
          }
          function r3() {
            return function(t6, e4, r4) {
              if (f())
                return Reflect.construct.apply(null, arguments);
              var n2 = [null];
              n2.push.apply(n2, e4);
              var o2 = new (t6.bind.apply(t6, n2));
              return r4 && p(o2, r4.prototype), o2;
            }(t5, arguments, h(this).constructor);
          }
          return r3.prototype = Object.create(t5.prototype, { constructor: { value: r3, enumerable: false, writable: true, configurable: true } }), p(r3, t5);
        }, l(t4);
      }
      function f() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (f = function() {
          return !!t4;
        })();
      }
      function p(t4, e3) {
        return p = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, p(t4, e3);
      }
      function h(t4) {
        return h = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, h(t4);
      }
      var y = r2(5022), d = r2(8213), b = r2(4450), m = r2(8768).deepEqual, v = r2(8260), g = r2(3216), _ = r2(7352), w = r2(2793), O = r2(3305), S = r2(4473), $ = r2(7930).populateModelSymbol, j = function(t4) {
        function e3(t5, r4, o2, i3) {
          var s2;
          return function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), v(t5) === "Object" && (t5 = Object.keys(t5).reduce(function(e4, r5) {
            return e4.concat([[r5, t5[r5]]]);
          }, [])), (s2 = function(t6, e4, r5) {
            return e4 = h(e4), function(t7, e5) {
              if (e5 && (n(e5) == "object" || typeof e5 == "function"))
                return e5;
              if (e5 !== undefined)
                throw new TypeError("Derived constructors may only return object or undefined");
              return function(t8) {
                if (t8 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t8;
              }(t7);
            }(t6, f() ? Reflect.construct(e4, r5 || [], h(t6).constructor) : e4.apply(t6, r5));
          }(this, e3, [t5])).$__parent = o2 != null && o2.$__ != null ? o2 : null, s2.$__path = r4, s2.$__schemaType = i3 == null ? new y(r4) : i3, s2.$__runDeferred(), s2;
        }
        return function(t5, e4) {
          if (typeof e4 != "function" && e4 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && p(t5, e4);
        }(e3, t4), r3 = e3, i2 = [{ key: "$init", value: function(t5, r4) {
          P(t5), u(e3, "set", this, 3)([t5, r4]), r4 != null && r4.$isSingleNested && (r4.$basePath = this.$__path + "." + t5);
        } }, { key: "$__set", value: function(t5, r4) {
          u(e3, "set", this, 3)([t5, r4]);
        } }, { key: "get", value: function(t5, r4) {
          return O(t5, "ObjectId") && (t5 = t5.toString()), (r4 = r4 || {}).getters === false ? u(e3, "get", this, 3)([t5]) : this.$__schemaType.applyGetters(u(e3, "get", this, 3)([t5]), this.$__parent);
        } }, { key: "set", value: function(t5, r4) {
          if (O(t5, "ObjectId") && (t5 = t5.toString()), P(t5), r4 = g(r4), this.$__schemaType == null)
            return this.$__deferred = this.$__deferred || [], void this.$__deferred.push({ key: t5, value: r4 });
          var n2, o2 = this.$__parent, i3 = o2 != null && o2.$__ && o2.$__.populated ? o2.$populated(l2.call(this), true) || o2.$populated(this.$__path, true) : null, s2 = this.get(t5);
          if (i3 != null) {
            if (this.$__schemaType.$isSingleNested)
              throw new d("Cannot manually populate single nested subdoc underneath Map " + 'at path "'.concat(this.$__path, '". Try using an array instead of a Map.'));
            Array.isArray(r4) && this.$__schemaType.$isMongooseArray ? r4 = r4.map(function(t6) {
              return t6.$__ == null && (t6 = new i3.options[$](t6)), t6.$__.wasPopulated = { value: t6._doc._id }, t6;
            }) : r4 != null && (r4.$__ == null && (r4 = new i3.options[$](r4)), r4.$__.wasPopulated = { value: r4._doc._id });
          } else
            try {
              var a2 = this.$__schemaType.$isMongooseDocumentArray || this.$__schemaType.$isSingleNested || this.$__schemaType.$isMongooseArray || this.$__schemaType.$isSchemaMap ? { path: l2.call(this) } : null;
              r4 = this.$__schemaType.applySetters(r4, this.$__parent, false, this.get(t5), a2);
            } catch (t6) {
              if (this.$__parent != null && this.$__parent.$__ != null)
                return void this.$__parent.invalidate(l2.call(this), t6);
              throw t6;
            }
          if (u(e3, "set", this, 3)([t5, r4]), o2 != null && o2.$__ != null && !m(r4, s2)) {
            var c2 = l2.call(this);
            o2.markModified(c2), (this.$__schemaType.$isMongooseDocumentArray || this.$__schemaType.$isSingleNested) && S(o2, c2);
          }
          function l2() {
            return n2 || (n2 = this.$__path + "." + t5);
          }
        } }, { key: "clear", value: function() {
          u(e3, "clear", this, 3)([]);
          var t5 = this.$__parent;
          t5 != null && t5.markModified(this.$__path);
        } }, { key: "delete", value: function(t5) {
          return O(t5, "ObjectId") && (t5 = t5.toString()), this.set(t5, undefined), u(e3, "delete", this, 3)([t5]);
        } }, { key: "toBSON", value: function() {
          return new Map(this);
        } }, { key: "toObject", value: function(t5) {
          if (t5 && t5.flattenMaps) {
            var e4, r4 = {}, n2 = o(this.keys());
            try {
              for (n2.s();!(e4 = n2.n()).done; ) {
                var i3 = e4.value;
                r4[i3] = b(this.get(i3), t5);
              }
            } catch (t6) {
              n2.e(t6);
            } finally {
              n2.f();
            }
            return r4;
          }
          return new Map(this);
        } }, { key: "$toObject", value: function() {
          return this.constructor.prototype.toObject.apply(this, arguments);
        } }, { key: "toJSON", value: function(t5) {
          if (typeof (t5 && t5.flattenMaps) != "boolean" || t5.flattenMaps) {
            var e4, r4 = {}, n2 = o(this.keys());
            try {
              for (n2.s();!(e4 = n2.n()).done; ) {
                var i3 = e4.value;
                r4[i3] = b(this.get(i3), t5);
              }
            } catch (t6) {
              n2.e(t6);
            } finally {
              n2.f();
            }
            return r4;
          }
          return new Map(this);
        } }, { key: "inspect", value: function() {
          return new Map(this);
        } }, { key: "$__runDeferred", value: function() {
          if (this.$__deferred) {
            var t5, e4 = o(this.$__deferred);
            try {
              for (e4.s();!(t5 = e4.n()).done; ) {
                var r4 = t5.value;
                this.set(r4.key, r4.value);
              }
            } catch (t6) {
              e4.e(t6);
            } finally {
              e4.f();
            }
            this.$__deferred = null;
          }
        } }], i2 && s(r3.prototype, i2), Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3, i2;
      }(l(Map));
      function P(t4) {
        var e3 = n(t4);
        if (e3 !== "string")
          throw new TypeError("Mongoose maps only support string keys, got ".concat(e3));
        if (t4.startsWith("$"))
          throw new Error('Mongoose maps do not support keys that start with "$", got "'.concat(t4, '"'));
        if (t4.includes("."))
          throw new Error('Mongoose maps do not support keys that contain ".", got "'.concat(t4, '"'));
        if (w.has(t4))
          throw new Error('Mongoose maps do not support reserved key name "'.concat(t4, '"'));
      }
      _.inspect.custom && Object.defineProperty(j.prototype, _.inspect.custom, { enumerable: false, writable: false, configurable: false, value: j.prototype.inspect }), Object.defineProperty(j.prototype, "$__set", { enumerable: false, writable: true, configurable: false }), Object.defineProperty(j.prototype, "$__parent", { enumerable: false, writable: true, configurable: false }), Object.defineProperty(j.prototype, "$__path", { enumerable: false, writable: true, configurable: false }), Object.defineProperty(j.prototype, "$__schemaType", { enumerable: false, writable: true, configurable: false }), Object.defineProperty(j.prototype, "$isMongooseMap", { enumerable: false, writable: false, configurable: false, value: true }), Object.defineProperty(j.prototype, "$__deferredCalls", { enumerable: false, writable: false, configurable: false, value: true }), t3.exports = j;
    }, 2097: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o(t4, e3) {
        (e3 == null || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = Array(e3);r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      function i(t4, e3, r3) {
        return (e3 = function(t5) {
          var e4 = function(t6) {
            if (n(t6) != "object" || !t6)
              return t6;
            var e5 = t6[Symbol.toPrimitive];
            if (e5 !== undefined) {
              var r4 = e5.call(t6, "string");
              if (n(r4) != "object")
                return r4;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t6);
          }(t5);
          return n(e4) == "symbol" ? e4 : e4 + "";
        }(e3)) in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      var s = r2(9166), a = r2(1824), u = r2(3703), c = r2(3696), l = r2(1505), f = r2(7160), p = new Set(["replaceOne", "findOneAndReplace"]);
      t3.exports = function(t4, e3) {
        var r3 = t4.childSchemas.find(function(t5) {
          return !!t5.schema.options.timestamps;
        });
        if (e3 || r3) {
          var n2 = c(e3, "createdAt"), h = c(e3, "updatedAt"), y = e3 != null && e3.hasOwnProperty("currentTime") ? e3.currentTime : null, d = {};
          if (t4.$timestamps = { createdAt: n2, updatedAt: h }, n2 && !t4.paths[n2]) {
            var b = t4.base != null ? t4.base.get("timestamps.createdAt.immutable") : null, m = b == null || b;
            d[n2] = i(i({}, t4.options.typeKey || "type", Date), "immutable", m);
          }
          h && !t4.paths[h] && (d[h] = Date), t4.add(d), t4.pre("save", function(t5) {
            var e4 = u(this, "$__.saveOptions.timestamps");
            if (e4 === false)
              return t5();
            l(this, e4, y, n2, h), t5();
          }), t4.methods.initializeTimestamps = function() {
            var t5 = y != null ? y() : this.constructor.base.now();
            if (n2 && !this.get(n2) && this.$set(n2, t5), h && !this.get(h) && this.$set(h, t5), this.$isSubdocument)
              return this;
            var e4, r4 = function(t6, e5) {
              var r5 = typeof Symbol != "undefined" && t6[Symbol.iterator] || t6["@@iterator"];
              if (!r5) {
                if (Array.isArray(t6) || (r5 = function(t7, e6) {
                  if (t7) {
                    if (typeof t7 == "string")
                      return o(t7, e6);
                    var r6 = {}.toString.call(t7).slice(8, -1);
                    return r6 === "Object" && t7.constructor && (r6 = t7.constructor.name), r6 === "Map" || r6 === "Set" ? Array.from(t7) : r6 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r6) ? o(t7, e6) : undefined;
                  }
                }(t6)) || e5 && t6 && typeof t6.length == "number") {
                  r5 && (t6 = r5);
                  var n3 = 0, i3 = function() {};
                  return { s: i3, n: function() {
                    return n3 >= t6.length ? { done: true } : { done: false, value: t6[n3++] };
                  }, e: function(t7) {
                    throw t7;
                  }, f: i3 };
                }
                throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
              }
              var s2, a2 = true, u2 = false;
              return { s: function() {
                r5 = r5.call(t6);
              }, n: function() {
                var t7 = r5.next();
                return a2 = t7.done, t7;
              }, e: function(t7) {
                u2 = true, s2 = t7;
              }, f: function() {
                try {
                  a2 || r5.return == null || r5.return();
                } finally {
                  if (u2)
                    throw s2;
                }
              } };
            }(this.$getAllSubdocs());
            try {
              for (r4.s();!(e4 = r4.n()).done; ) {
                var i2 = e4.value;
                i2.initializeTimestamps && i2.initializeTimestamps();
              }
            } catch (t6) {
              r4.e(t6);
            } finally {
              r4.f();
            }
            return this;
          }, g[f.builtInMiddleware] = true;
          var v = { query: true, model: false };
          t4.pre("findOneAndReplace", v, g), t4.pre("findOneAndUpdate", v, g), t4.pre("replaceOne", v, g), t4.pre("update", v, g), t4.pre("updateOne", v, g), t4.pre("updateMany", v, g);
        }
        function g(t5) {
          var e4 = y != null ? y() : this.model.base.now();
          p.has(this.op) && this.getUpdate() == null && this.setUpdate({}), a(e4, n2, h, this.getUpdate(), this._mongooseOptions, p.has(this.op)), s(e4, this.getUpdate(), this.model.schema), t5();
        }
      };
    }, 2134: (t3, e2, r2) => {
      var n = r2(5832).hp;
      function o(t4) {
        return o = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, o(t4);
      }
      function i(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function s(t4) {
        for (var e3 = 1;e3 < arguments.length; e3++) {
          var r3 = arguments[e3] != null ? arguments[e3] : {};
          e3 % 2 ? i(Object(r3), true).forEach(function(e4) {
            a(t4, e4, r3[e4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : i(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      function a(t4, e3, r3) {
        return (e3 = function(t5) {
          var e4 = function(t6) {
            if (o(t6) != "object" || !t6)
              return t6;
            var e5 = t6[Symbol.toPrimitive];
            if (e5 !== undefined) {
              var r4 = e5.call(t6, "string");
              if (o(r4) != "object")
                return r4;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t6);
          }(t5);
          return o(e4) == "symbol" ? e4 : e4 + "";
        }(e3)) in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      var u = r2(6365), c = r2(6426), l = c.CastError, f = r2(8250), p = r2(4327), h = r2(8768), y = r2(9460), d = f.UUID_FORMAT, b = u.Binary;
      function m(t4) {
        var e3;
        return typeof t4 != "string" && t4 != null ? (e3 = t4.toString("hex")).substring(0, 8) + "-" + e3.substring(8, 12) + "-" + e3.substring(12, 16) + "-" + e3.substring(16, 20) + "-" + e3.substring(20, 32) : t4;
      }
      function v(t4, e3) {
        c.call(this, t4, e3, "UUID"), this.getters.push(function(t5) {
          return t5 != null && t5.$__ != null ? t5 : n.isBuffer(t5) ? m(t5) : t5 instanceof b ? m(t5.buffer) : h.isPOJO(t5) && t5.type === "Buffer" && Array.isArray(t5.data) ? m(n.from(t5.data)) : t5;
        });
      }
      function g(t4) {
        return this.cast(t4);
      }
      function _(t4) {
        var e3 = this;
        return t4.map(function(t5) {
          return e3.cast(t5);
        });
      }
      v.schemaName = "UUID", v.defaultOptions = {}, v.prototype = Object.create(c.prototype), v.prototype.constructor = v, v._cast = f, v.get = c.get, v.set = c.set, v.setters = [], v.cast = function(t4) {
        return arguments.length === 0 || (t4 === false && (t4 = this._defaultCaster), this._cast = t4), this._cast;
      }, v._checkRequired = function(t4) {
        return t4 != null;
      }, v.checkRequired = c.checkRequired, v.prototype.checkRequired = function(t4) {
        return n.isBuffer(t4) && (t4 = m(t4)), t4 != null && d.test(t4);
      }, v.prototype.cast = function(t4, e3, r3, n2, o2) {
        if (h.isNonBuiltinObject(t4) && c._isRef(this, t4, e3, r3))
          return this._castRef(t4, e3, r3, o2);
        var i2;
        i2 = typeof this._castFunction == "function" ? this._castFunction : typeof this.constructor.cast == "function" ? this.constructor.cast() : v.cast();
        try {
          return i2(t4);
        } catch (e4) {
          throw new l(v.schemaName, t4, this.path, e4, this);
        }
      };
      var w = s(s({}, c.prototype.$conditionalHandlers), {}, { $bitsAllClear: y, $bitsAnyClear: y, $bitsAllSet: y, $bitsAnySet: y, $all: _, $gt: g, $gte: g, $in: _, $lt: g, $lte: g, $ne: g, $nin: _ });
      Object.defineProperty(v.prototype, "$conditionalHandlers", { enumerable: false, value: w }), v.prototype.castForQuery = function(t4, e3, r3) {
        var n2;
        if (t4 != null) {
          if (!(n2 = this.$conditionalHandlers[t4]))
            throw new Error("Can't use " + t4 + " with UUID.");
          return n2.call(this, e3, r3);
        }
        try {
          return this.applySetters(e3, r3);
        } catch (t5) {
          throw t5 instanceof l && t5.path === this.path && this.$fullPath != null && (t5.path = this.$fullPath), t5;
        }
      }, v.prototype.toJSONSchema = function(t4) {
        var e3 = this.options.required && typeof this.options.required != "function";
        return p("string", "binData", t4 == null ? undefined : t4.useBsonType, e3);
      }, v.prototype.autoEncryptionType = function() {
        return "binData";
      }, t3.exports = v;
    }, 2151: (t3) => {
      t3.exports = Math.round;
    }, 2268: (t3) => {
      t3.exports = TypeError;
    }, 2273: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var o = r2(668), i = typeof Symbol == "function" && n(Symbol("foo")) === "symbol", s = Object.prototype.toString, a = Array.prototype.concat, u = r2(6750), c = r2(3191)(), l = function(t4, e3, r3, n2) {
        if (e3 in t4) {
          if (n2 === true) {
            if (t4[e3] === r3)
              return;
          } else if (typeof (o2 = n2) != "function" || s.call(o2) !== "[object Function]" || !n2())
            return;
        }
        var o2;
        c ? u(t4, e3, r3, true) : u(t4, e3, r3);
      }, f = function(t4, e3) {
        var r3 = arguments.length > 2 ? arguments[2] : {}, n2 = o(e3);
        i && (n2 = a.call(n2, Object.getOwnPropertySymbols(e3)));
        for (var s2 = 0;s2 < n2.length; s2 += 1)
          l(t4, n2[s2], e3[n2[s2]], r3[n2[s2]]);
      };
      f.supportsDescriptors = !!c, t3.exports = f;
    }, 2307: (t3, e2, r2) => {
      var n = r2(5832).hp;
      function o(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function i(t4) {
        for (var e3 = 1;e3 < arguments.length; e3++) {
          var r3 = arguments[e3] != null ? arguments[e3] : {};
          e3 % 2 ? o(Object(r3), true).forEach(function(e4) {
            s(t4, e4, r3[e4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : o(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      function s(t4, e3, r3) {
        return (e3 = function(t5) {
          var e4 = function(t6) {
            if (a(t6) != "object" || !t6)
              return t6;
            var e5 = t6[Symbol.toPrimitive];
            if (e5 !== undefined) {
              var r4 = e5.call(t6, "string");
              if (a(r4) != "object")
                return r4;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t6);
          }(t5);
          return a(e4) == "symbol" ? e4 : e4 + "";
        }(e3)) in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      function a(t4) {
        return a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, a(t4);
      }
      var u = r2(6365), c = r2(2945), l = r2(6426), f = r2(4327), p = r2(9460), h = r2(8768), y = u.Binary, d = l.CastError;
      function b(t4, e3) {
        l.call(this, t4, e3, "Buffer");
      }
      function m(t4, e3) {
        return this.castForQuery(null, t4, e3);
      }
      b.schemaName = "Buffer", b.defaultOptions = {}, b.prototype = Object.create(l.prototype), b.prototype.constructor = b, b.prototype.OptionsConstructor = c, b._checkRequired = function(t4) {
        return !(!t4 || !t4.length);
      }, b.set = l.set, b.setters = [], b.get = l.get, b.checkRequired = l.checkRequired, b.prototype.checkRequired = function(t4, e3) {
        return l._isRef(this, t4, e3, true) ? !!t4 : this.constructor._checkRequired(t4);
      }, b.prototype.cast = function(t4, e3, r3, o2, i2) {
        var s2;
        if (l._isRef(this, t4, e3, r3)) {
          if (t4 && t4.isMongooseBuffer)
            return t4;
          if (n.isBuffer(t4))
            return t4 && t4.isMongooseBuffer || (t4 = new u(t4, [this.path, e3]), this.options.subtype != null && (t4._subtype = this.options.subtype)), t4;
          if (t4 instanceof y) {
            if (s2 = new u(t4.value(true), [this.path, e3]), typeof t4.sub_type != "number")
              throw new d("Buffer", t4, this.path, null, this);
            return s2._subtype = t4.sub_type, s2;
          }
          if (t4 == null || h.isNonBuiltinObject(t4))
            return this._castRef(t4, e3, r3, i2);
        }
        if (t4 && t4._id && (t4 = t4._id), t4 && t4.isMongooseBuffer)
          return t4;
        if (n.isBuffer(t4))
          return t4 && t4.isMongooseBuffer || (t4 = new u(t4, [this.path, e3]), this.options.subtype != null && (t4._subtype = this.options.subtype)), t4;
        if (t4 instanceof y) {
          if (s2 = new u(t4.value(true), [this.path, e3]), typeof t4.sub_type != "number")
            throw new d("Buffer", t4, this.path, null, this);
          return s2._subtype = t4.sub_type, s2;
        }
        if (t4 === null)
          return t4;
        var c2 = a(t4);
        if (c2 === "string" || c2 === "number" || Array.isArray(t4) || c2 === "object" && t4.type === "Buffer" && Array.isArray(t4.data))
          return c2 === "number" && (t4 = [t4]), s2 = new u(t4, [this.path, e3]), this.options.subtype != null && (s2._subtype = this.options.subtype), s2;
        if (h.isPOJO(t4) && (t4.$binary instanceof y || typeof t4.$binary == "string")) {
          var f2 = this.cast(n.from(t4.$binary, "base64"));
          if (t4.$type != null)
            return f2._subtype = t4.$type, f2;
        }
        throw new d("Buffer", t4, this.path, null, this);
      }, b.prototype.subtype = function(t4) {
        return this.options.subtype = t4, this;
      };
      var v = i(i({}, l.prototype.$conditionalHandlers), {}, { $bitsAllClear: p, $bitsAnyClear: p, $bitsAllSet: p, $bitsAnySet: p, $gt: m, $gte: m, $lt: m, $lte: m });
      Object.defineProperty(b.prototype, "$conditionalHandlers", { enumerable: false, value: v }), b.prototype.castForQuery = function(t4, e3, r3) {
        var n2, o2;
        if (t4 != null) {
          if (!(n2 = this.$conditionalHandlers[t4]))
            throw new Error("Can't use " + t4 + " with Buffer.");
          return n2.call(this, e3);
        }
        try {
          o2 = this.applySetters(e3, r3);
        } catch (t5) {
          throw t5 instanceof d && t5.path === this.path && this.$fullPath != null && (t5.path = this.$fullPath), t5;
        }
        return o2 ? o2.toObject({ transform: false, virtuals: false }) : o2;
      }, b.prototype.toJSONSchema = function(t4) {
        var e3 = this.options.required && typeof this.options.required != "function";
        return f("string", "binData", t4 == null ? undefined : t4.useBsonType, e3);
      }, b.prototype.autoEncryptionType = function() {
        return "binData";
      }, t3.exports = b;
    }, 2345: (t3, e2, r2) => {
      function n(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function o(t4) {
        for (var e3 = 1;e3 < arguments.length; e3++) {
          var r3 = arguments[e3] != null ? arguments[e3] : {};
          e3 % 2 ? n(Object(r3), true).forEach(function(e4) {
            i(t4, e4, r3[e4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : n(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      function i(t4, e3, r3) {
        return (e3 = function(t5) {
          var e4 = function(t6) {
            if (s(t6) != "object" || !t6)
              return t6;
            var e5 = t6[Symbol.toPrimitive];
            if (e5 !== undefined) {
              var r4 = e5.call(t6, "string");
              if (s(r4) != "object")
                return r4;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t6);
          }(t5);
          return s(e4) == "symbol" ? e4 : e4 + "";
        }(e3)) in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      function s(t4) {
        return s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, s(t4);
      }
      var a = r2(3672), u = r2(3731), c = r2(6426), l = r2(2477), f = r2(4327), p = r2(8260), h = r2(8768), y = c.CastError;
      function d(t4, e3) {
        c.call(this, t4, e3, "Date");
      }
      function b(t4) {
        return this.cast(t4);
      }
      d.schemaName = "Date", d.defaultOptions = {}, d.prototype = Object.create(c.prototype), d.prototype.constructor = d, d.prototype.OptionsConstructor = u, d._cast = l, d.set = c.set, d.setters = [], d.get = c.get, d.cast = function(t4) {
        return arguments.length === 0 || (t4 === false && (t4 = this._defaultCaster), this._cast = t4), this._cast;
      }, d._defaultCaster = function(t4) {
        if (t4 != null && !(t4 instanceof Date))
          throw new Error;
        return t4;
      }, d.prototype.expires = function(t4) {
        return p(this._index) !== "Object" && (this._index = {}), this._index.expires = t4, h.expires(this._index), this;
      }, d._checkRequired = function(t4) {
        return t4 instanceof Date;
      }, d.checkRequired = c.checkRequired, d.prototype.checkRequired = function(t4, e3) {
        return s(t4) === "object" && c._isRef(this, t4, e3, true) ? t4 != null : (typeof this.constructor.checkRequired == "function" ? this.constructor.checkRequired() : d.checkRequired())(t4);
      }, d.prototype.min = function(t4, e3) {
        if (this.minValidator && (this.validators = this.validators.filter(function(t5) {
          return t5.validator !== this.minValidator;
        }, this)), t4) {
          var r3 = e3 || a.messages.Date.min;
          typeof r3 == "string" && (r3 = r3.replace(/{MIN}/, t4 === Date.now ? "Date.now()" : t4.toString()));
          var n2 = this;
          this.validators.push({ validator: this.minValidator = function(e4) {
            var r4 = t4;
            typeof t4 == "function" && t4 !== Date.now && (r4 = r4.call(this));
            var o2 = r4 === Date.now ? r4() : n2.cast(r4);
            return e4 === null || e4.valueOf() >= o2.valueOf();
          }, message: r3, type: "min", min: t4 });
        }
        return this;
      }, d.prototype.max = function(t4, e3) {
        if (this.maxValidator && (this.validators = this.validators.filter(function(t5) {
          return t5.validator !== this.maxValidator;
        }, this)), t4) {
          var r3 = e3 || a.messages.Date.max;
          typeof r3 == "string" && (r3 = r3.replace(/{MAX}/, t4 === Date.now ? "Date.now()" : t4.toString()));
          var n2 = this;
          this.validators.push({ validator: this.maxValidator = function(e4) {
            var r4 = t4;
            typeof r4 == "function" && r4 !== Date.now && (r4 = r4.call(this));
            var o2 = r4 === Date.now ? r4() : n2.cast(r4);
            return e4 === null || e4.valueOf() <= o2.valueOf();
          }, message: r3, type: "max", max: t4 });
        }
        return this;
      }, d.prototype.cast = function(t4) {
        var e3;
        e3 = typeof this._castFunction == "function" ? this._castFunction : typeof this.constructor.cast == "function" ? this.constructor.cast() : d.cast();
        try {
          return e3(t4);
        } catch (e4) {
          throw new y("date", t4, this.path, e4, this);
        }
      };
      var m = o(o({}, c.prototype.$conditionalHandlers), {}, { $gt: b, $gte: b, $lt: b, $lte: b });
      Object.defineProperty(d.prototype, "$conditionalHandlers", { enumerable: false, value: m }), d.prototype.castForQuery = function(t4, e3, r3) {
        if (t4 == null)
          try {
            return this.applySetters(e3, r3);
          } catch (t5) {
            throw t5 instanceof y && t5.path === this.path && this.$fullPath != null && (t5.path = this.$fullPath), t5;
          }
        var n2 = this.$conditionalHandlers[t4];
        if (!n2)
          throw new Error("Can't use " + t4 + " with Date.");
        return n2.call(this, e3);
      }, d.prototype.toJSONSchema = function(t4) {
        var e3 = this.options.required && typeof this.options.required != "function";
        return f("string", "date", t4 == null ? undefined : t4.useBsonType, e3);
      }, d.prototype.autoEncryptionType = function() {
        return "date";
      }, t3.exports = d;
    }, 2354: (t3, e2, r2) => {
      var n = r2(6730);
      t3.exports = Function.prototype.bind || n;
    }, 2400: (t3, e2, r2) => {
      var n = r2(5832).hp;
      function o(t4) {
        return function(t5) {
          if (Array.isArray(t5))
            return y(t5);
        }(t4) || function(t5) {
          if (typeof Symbol != "undefined" && t5[Symbol.iterator] != null || t5["@@iterator"] != null)
            return Array.from(t5);
        }(t4) || h(t4) || function() {
          throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }();
      }
      function i() {
        var t4, e3, r3 = typeof Symbol == "function" ? Symbol : {}, n2 = r3.iterator || "@@iterator", o2 = r3.toStringTag || "@@toStringTag";
        function a2(r4, n3, o3, i2) {
          var a3 = n3 && n3.prototype instanceof c2 ? n3 : c2, l3 = Object.create(a3.prototype);
          return s(l3, "_invoke", function(r5, n4, o4) {
            var i3, s2, a4, c3 = 0, l4 = o4 || [], f3 = false, p3 = { p: 0, n: 0, v: t4, a: h3, f: h3.bind(t4, 4), d: function(e4, r6) {
              return i3 = e4, s2 = 0, a4 = t4, p3.n = r6, u2;
            } };
            function h3(r6, n5) {
              for (s2 = r6, a4 = n5, e3 = 0;!f3 && c3 && !o5 && e3 < l4.length; e3++) {
                var o5, i4 = l4[e3], h4 = p3.p, y3 = i4[2];
                r6 > 3 ? (o5 = y3 === n5) && (a4 = i4[(s2 = i4[4]) ? 5 : (s2 = 3, 3)], i4[4] = i4[5] = t4) : i4[0] <= h4 && ((o5 = r6 < 2 && h4 < i4[1]) ? (s2 = 0, p3.v = n5, p3.n = i4[1]) : h4 < y3 && (o5 = r6 < 3 || i4[0] > n5 || n5 > y3) && (i4[4] = r6, i4[5] = n5, p3.n = y3, s2 = 0));
              }
              if (o5 || r6 > 1)
                return u2;
              throw f3 = true, n5;
            }
            return function(o5, l5, y3) {
              if (c3 > 1)
                throw TypeError("Generator is already running");
              for (f3 && l5 === 1 && h3(l5, y3), s2 = l5, a4 = y3;(e3 = s2 < 2 ? t4 : a4) || !f3; ) {
                i3 || (s2 ? s2 < 3 ? (s2 > 1 && (p3.n = -1), h3(s2, a4)) : p3.n = a4 : p3.v = a4);
                try {
                  if (c3 = 2, i3) {
                    if (s2 || (o5 = "next"), e3 = i3[o5]) {
                      if (!(e3 = e3.call(i3, a4)))
                        throw TypeError("iterator result is not an object");
                      if (!e3.done)
                        return e3;
                      a4 = e3.value, s2 < 2 && (s2 = 0);
                    } else
                      s2 === 1 && (e3 = i3.return) && e3.call(i3), s2 < 2 && (a4 = TypeError("The iterator does not provide a '" + o5 + "' method"), s2 = 1);
                    i3 = t4;
                  } else if ((e3 = (f3 = p3.n < 0) ? a4 : r5.call(n4, p3)) !== u2)
                    break;
                } catch (e4) {
                  i3 = t4, s2 = 1, a4 = e4;
                } finally {
                  c3 = 1;
                }
              }
              return { value: e3, done: f3 };
            };
          }(r4, o3, i2), true), l3;
        }
        var u2 = {};
        function c2() {}
        function l2() {}
        function f2() {}
        e3 = Object.getPrototypeOf;
        var p2 = [][n2] ? e3(e3([][n2]())) : (s(e3 = {}, n2, function() {
          return this;
        }), e3), h2 = f2.prototype = c2.prototype = Object.create(p2);
        function y2(t5) {
          return Object.setPrototypeOf ? Object.setPrototypeOf(t5, f2) : (t5.__proto__ = f2, s(t5, o2, "GeneratorFunction")), t5.prototype = Object.create(h2), t5;
        }
        return l2.prototype = f2, s(h2, "constructor", f2), s(f2, "constructor", l2), l2.displayName = "GeneratorFunction", s(f2, o2, "GeneratorFunction"), s(h2), s(h2, o2, "Generator"), s(h2, n2, function() {
          return this;
        }), s(h2, "toString", function() {
          return "[object Generator]";
        }), (i = function() {
          return { w: a2, m: y2 };
        })();
      }
      function s(t4, e3, r3, n2) {
        var o2 = Object.defineProperty;
        try {
          o2({}, "", {});
        } catch (t5) {
          o2 = 0;
        }
        s = function(t5, e4, r4, n3) {
          function i2(e5, r5) {
            s(t5, e5, function(t6) {
              return this._invoke(e5, r5, t6);
            });
          }
          e4 ? o2 ? o2(t5, e4, { value: r4, enumerable: !n3, configurable: !n3, writable: !n3 }) : t5[e4] = r4 : (i2("next", 0), i2("throw", 1), i2("return", 2));
        }, s(t4, e3, r3, n2);
      }
      function a(t4, e3, r3, n2, o2, i2, s2) {
        try {
          var a2 = t4[i2](s2), u2 = a2.value;
        } catch (t5) {
          return void r3(t5);
        }
        a2.done ? e3(u2) : Promise.resolve(u2).then(n2, o2);
      }
      function u(t4) {
        return function() {
          var e3 = this, r3 = arguments;
          return new Promise(function(n2, o2) {
            var i2 = t4.apply(e3, r3);
            function s2(t5) {
              a(i2, n2, o2, s2, u2, "next", t5);
            }
            function u2(t5) {
              a(i2, n2, o2, s2, u2, "throw", t5);
            }
            s2(undefined);
          });
        };
      }
      function c(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function l(t4) {
        for (var e3 = 1;e3 < arguments.length; e3++) {
          var r3 = arguments[e3] != null ? arguments[e3] : {};
          e3 % 2 ? c(Object(r3), true).forEach(function(e4) {
            f(t4, e4, r3[e4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : c(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      function f(t4, e3, r3) {
        return (e3 = function(t5) {
          var e4 = function(t6) {
            if (d(t6) != "object" || !t6)
              return t6;
            var e5 = t6[Symbol.toPrimitive];
            if (e5 !== undefined) {
              var r4 = e5.call(t6, "string");
              if (d(r4) != "object")
                return r4;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t6);
          }(t5);
          return d(e4) == "symbol" ? e4 : e4 + "";
        }(e3)) in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      function p(t4, e3) {
        var r3 = typeof Symbol != "undefined" && t4[Symbol.iterator] || t4["@@iterator"];
        if (!r3) {
          if (Array.isArray(t4) || (r3 = h(t4)) || e3 && t4 && typeof t4.length == "number") {
            r3 && (t4 = r3);
            var n2 = 0, o2 = function() {};
            return { s: o2, n: function() {
              return n2 >= t4.length ? { done: true } : { done: false, value: t4[n2++] };
            }, e: function(t5) {
              throw t5;
            }, f: o2 };
          }
          throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        var i2, s2 = true, a2 = false;
        return { s: function() {
          r3 = r3.call(t4);
        }, n: function() {
          var t5 = r3.next();
          return s2 = t5.done, t5;
        }, e: function(t5) {
          a2 = true, i2 = t5;
        }, f: function() {
          try {
            s2 || r3.return == null || r3.return();
          } finally {
            if (a2)
              throw i2;
          }
        } };
      }
      function h(t4, e3) {
        if (t4) {
          if (typeof t4 == "string")
            return y(t4, e3);
          var r3 = {}.toString.call(t4).slice(8, -1);
          return r3 === "Object" && t4.constructor && (r3 = t4.constructor.name), r3 === "Map" || r3 === "Set" ? Array.from(t4) : r3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? y(t4, e3) : undefined;
        }
      }
      function y(t4, e3) {
        (e3 == null || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = Array(e3);r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      function d(t4) {
        return d = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, d(t4);
      }
      var b, m, v, g = r2(1417), _ = r2(3550).EventEmitter, w = r2(4224), O = r2(6365), S = r2(3672), $ = r2(5022), j = r2(6140), P = r2(3441), A = r2(1350), E = r2(1635), x = r2(7058), T = r2(8995), k = r2(6949), N = r2(9538), I = r2(6814), B = r2(5335), M = r2(4473), D = r2(4450), R = r2(2068).w, U = r2(2068).X, C = r2(1226), F = r2(7430).B, L = r2(5152), V = r2(791), q = r2(2692), J = r2(3216), z = r2(2746), K = r2(3305), H = r2(7300), W = r2(1793), G = r2(5188), Q = r2(7352).inspect, Y = r2(3303)._, Z = r2(1849), X = r2(6451), tt = r2(5678), et = r2(6223), rt = r2(3892), nt = r2(8768), ot = r2(542), it = nt.deepEqual, st = nt.isMongooseObject, at = r2(7930).arrayAtomicsBackupSymbol, ut = r2(7930).arrayAtomicsSymbol, ct = r2(7930).documentArrayParent, lt = r2(7930).documentIsModified, ft = r2(7930).documentModifiedPaths, pt = r2(7930).documentSchemaSymbol, ht = r2(7930).getSymbol, yt = r2(7930).modelSymbol, dt = r2(7930).populateModelSymbol, bt = r2(7930).scopeSymbol, mt = r2(7160).schemaMixedSymbol, vt = r2(5346), gt = r2(7930).sessionNewDocuments, _t = nt.specialProperties;
      function wt(t4, e3, r3, n2) {
        if (d(r3) === "object" && r3 != null && (r3 = (n2 = r3).skipId), n2 = Object.assign({}, n2), this.$__schema == null) {
          var o2 = nt.isObject(e3) && !e3.instanceOfSchema ? new x(e3) : e3;
          this.$__setSchema(o2), e3 = r3, r3 = n2, n2 = arguments[4] || {};
        }
        if (this.$__ = new w, n2.isNew != null && n2.isNew !== true && (this.$isNew = n2.isNew), n2.priorDoc != null && (this.$__.priorDoc = n2.priorDoc), r3 && (this.$__.skipId = r3), t4 != null && d(t4) !== "object")
          throw new A(t4, "obj", "Document");
        var i2 = true;
        n2.defaults !== undefined && (this.$__.defaults = n2.defaults, i2 = n2.defaults);
        var s2 = this.$__schema;
        typeof e3 == "boolean" || e3 === "throw" ? (e3 !== true && (this.$__.strictMode = e3), e3 = undefined) : s2.options.strict !== true && (this.$__.strictMode = s2.options.strict);
        var a2, u2 = p(s2.requiredPaths(true));
        try {
          for (u2.s();!(a2 = u2.n()).done; ) {
            var c2 = a2.value;
            this.$__.activePaths.require(c2);
          }
        } catch (t5) {
          u2.e(t5);
        } finally {
          u2.f();
        }
        var l2 = null;
        nt.isPOJO(e3) && Object.keys(e3).length > 0 && (l2 = W(e3), this.$__.selected = e3, this.$__.exclude = l2);
        var f2 = l2 === false && e3 ? I(e3) : null;
        if (this._doc == null && (this.$__buildDoc(t4, e3, r3, l2, f2, false), i2 && B(this, e3, l2, f2, true, null, { skipParentChangeTracking: true })), t4 && (this.$__original_set ? this.$__original_set(t4, undefined, true, n2) : this.$set(t4, undefined, true, n2), t4 instanceof wt && (this.$isNew = t4.$isNew)), n2.willInit && i2 ? n2.skipDefaults && (this.$__.skipDefaults = n2.skipDefaults) : i2 && B(this, e3, l2, f2, false, n2.skipDefaults), !this.$__.strictMode && t4) {
          var h2 = this;
          Object.keys(this._doc).forEach(function(t5) {
            t5 in s2.tree || t5 in s2.methods || t5 in s2.virtuals || t5.startsWith("$") || U({ prop: t5, subprops: null, prototype: h2 });
          });
        }
        (function(t5) {
          var e4 = t5.$__schema && t5.$__schema.callQueue;
          if (e4.length) {
            var r4, n3 = p(e4);
            try {
              for (n3.s();!(r4 = n3.n()).done; ) {
                var o3 = r4.value;
                o3[0] !== "pre" && o3[0] !== "post" && o3[0] !== "on" && t5[o3[0]].apply(t5, o3[1]);
              }
            } catch (t6) {
              n3.e(t6);
            } finally {
              n3.f();
            }
          }
        })(this);
      }
      for (var Ot in wt.prototype.$isMongooseDocumentPrototype = true, Object.defineProperty(wt.prototype, "isNew", { get: function() {
        return this.$isNew;
      }, set: function(t4) {
        this.$isNew = t4;
      } }), Object.defineProperty(wt.prototype, "errors", { get: function() {
        return this.$errors;
      }, set: function(t4) {
        this.$errors = t4;
      } }), wt.prototype.$isNew = true, nt.each(["on", "once", "emit", "listeners", "removeListener", "setMaxListeners", "removeAllListeners", "addListener"], function(t4) {
        wt.prototype[t4] = function() {
          if (!this.$__.emitter) {
            if (t4 === "emit")
              return;
            this.$__.emitter = new _, this.$__.emitter.setMaxListeners(0);
          }
          return this.$__.emitter[t4].apply(this.$__.emitter, arguments);
        }, wt.prototype["$".concat(t4)] = wt.prototype[t4];
      }), wt.prototype.constructor = wt, _.prototype)
        wt[Ot] = _.prototype[Ot];
      function St(t4, e3, r3) {
        if (t4 != null)
          for (var n2 = Object.keys(r3.$__schema.paths), o2 = n2.length, i2 = e3.indexOf(".") === -1 ? [e3] : e3.split("."), s2 = 0;s2 < o2; ++s2) {
            var a2 = "", u2 = n2[s2];
            if (u2.startsWith(e3 + ".")) {
              var c2 = r3.$__schema.paths[u2], l2 = c2.splitPath().slice(i2.length), f2 = l2.length;
              if (c2.defaultValue !== undefined)
                for (var p2 = t4, h2 = 0;h2 < f2 && p2 != null; ++h2) {
                  var y2 = l2[h2];
                  if (h2 === f2 - 1) {
                    if (p2[y2] !== undefined)
                      break;
                    try {
                      var d2 = c2.getDefault(r3, false);
                      d2 !== undefined && (p2[y2] = d2);
                    } catch (t5) {
                      r3.invalidate(e3 + "." + a2, t5);
                      break;
                    }
                    break;
                  }
                  a2 += (a2.length ? "." : "") + y2, p2[y2] = p2[y2] || {}, p2 = p2[y2];
                }
            }
          }
      }
      function $t(t4, e3, r3, n2, o2) {
        o2 = o2 || "", e3.$__ != null && (e3 = e3._doc);
        for (var i2, s2, a2, u2 = Object.keys(e3), c2 = u2.length, l2 = t4.$__.strictMode, f2 = t4.$__schema, p2 = 0;p2 < c2; ++p2)
          if (a2 = u2[p2], !_t.has(a2) && (s2 = o2 ? o2 + a2 : a2, i2 = f2.path(s2), !f2.$isRootDiscriminator || t4.$__isSelected(s2))) {
            var h2 = e3[a2];
            if (!i2 && nt.isPOJO(h2))
              r3[a2] || (r3[a2] = {}, l2 || (a2 in f2.tree) || (a2 in f2.methods) || (a2 in f2.virtuals) || (t4[a2] = r3[a2])), $t(t4, h2, r3[a2], n2, s2 + ".");
            else if (i2) {
              if (r3.hasOwnProperty(a2) && h2 !== undefined && !n2.hydratedPopulatedDocs && delete r3[a2], h2 === null)
                r3[a2] = i2._castNullish(null);
              else if (h2 !== undefined) {
                var y2 = h2.$__ == null ? null : h2.$__.wasPopulated;
                if (!i2 || y2 || n2.hydratedPopulatedDocs)
                  if (i2 && n2.hydratedPopulatedDocs) {
                    var d2;
                    r3[a2] = i2.cast(h2, t4, true, undefined, { hydratedPopulatedDocs: true }), r3[a2] && r3[a2].$__ && r3[a2].$__.wasPopulated ? t4.$populated(s2, r3[a2].$__.wasPopulated.value, r3[a2].$__.wasPopulated.options) : Array.isArray(r3[a2]) && r3[a2].length && (d2 = r3[a2][0]) !== null && d2 !== undefined && (d2 = d2.$__) !== null && d2 !== undefined && d2.wasPopulated && t4.$populated(s2, r3[a2].map(function(t5) {
                      var e4;
                      return t5 == null || (e4 = t5.$__) === null || e4 === undefined || (e4 = e4.wasPopulated) === null || e4 === undefined ? undefined : e4.value;
                    }).filter(function(t5) {
                      return t5 != null;
                    }), r3[a2][0].$__.wasPopulated.options);
                  } else
                    r3[a2] = h2;
                else
                  try {
                    n2 && n2.setters ? r3[a2] = i2.applySetters(h2, t4, false) : r3[a2] = i2.cast(h2, t4, true);
                  } catch (e4) {
                    t4.invalidate(e4.path, new N({ path: e4.path, message: e4.message, type: "cast", value: e4.value, reason: e4 }));
                  }
              }
              t4.$isModified(s2) || t4.$__.activePaths.init(s2);
            } else
              r3[a2] = h2, l2 || o2 || (t4[a2] = h2);
          }
      }
      function jt(t4) {
        if (t4 == null)
          return true;
        if (d(t4) !== "object" || Array.isArray(t4))
          return false;
        for (var e3 = 0, r3 = Object.keys(t4);e3 < r3.length; e3++)
          if (!jt(t4[r3[e3]]))
            return false;
        return true;
      }
      function Pt(t4, e3, r3, n2) {
        var o2 = {};
        (function(t5) {
          var e4 = Object.keys(t5.$__.activePaths.getStatePaths("require")), r4 = 0, n3 = e4.length;
          for (r4 = 0;r4 < n3; ++r4) {
            var o3 = e4[r4], i3 = t5.$__schema.path(o3);
            if (i3 != null && typeof i3.originalRequiredValue == "function") {
              t5.$__.cachedRequired = t5.$__.cachedRequired || {};
              try {
                t5.$__.cachedRequired[o3] = i3.originalRequiredValue.call(t5, t5);
              } catch (e5) {
                t5.invalidate(o3, e5);
              }
            }
          }
        })(t4);
        var i2 = new Set(Object.keys(t4.$__.activePaths.getStatePaths("require")).filter(function(e4) {
          return !(!t4.$__isSelected(e4) && !t4.$isModified(e4)) && !e4.endsWith(".$*") && (t4.$__.cachedRequired == null || !(e4 in t4.$__.cachedRequired) || t4.$__.cachedRequired[e4]);
        }));
        function s2(t5) {
          t5.endsWith(".$*") || i2.add(t5);
        }
        if (Object.keys(t4.$__.activePaths.getStatePaths("init")).forEach(s2), Object.keys(t4.$__.activePaths.getStatePaths("modify")).forEach(s2), Object.keys(t4.$__.activePaths.getStatePaths("default")).forEach(s2), !n2) {
          for (var a2 = [], u2 = 0, c2 = Object.keys(t4.$__schema.paths);u2 < c2.length; u2++) {
            var l2 = c2[u2], f2 = t4.$__schema.path(l2);
            if (f2.$isSingleNested) {
              var h2 = t4.$get(l2);
              h2 && a2.push(h2);
            } else if (f2.$isMongooseDocumentArray) {
              var y2 = t4.$get(l2);
              if (y2 && y2.length) {
                var d2, b2 = p(y2);
                try {
                  for (b2.s();!(d2 = b2.n()).done; ) {
                    var m2 = d2.value;
                    m2 && a2.push(m2);
                  }
                } catch (t5) {
                  b2.e(t5);
                } finally {
                  b2.f();
                }
              }
            }
          }
          for (var v2 = t4.modifiedPaths(), g2 = 0, _2 = a2;g2 < _2.length; g2++) {
            var w2 = _2[g2];
            if (w2.$basePath) {
              var O2, S2 = w2.$__pathRelativeToParent(), $2 = p(w2.modifiedPaths());
              try {
                for ($2.s();!(O2 = $2.n()).done; ) {
                  var j2 = O2.value;
                  i2.delete(S2 + "." + j2);
                }
              } catch (t5) {
                $2.e(t5);
              } finally {
                $2.f();
              }
              var P2 = w2.$parent();
              if (P2 == null)
                throw new Error("Cannot validate subdocument that does not have a parent");
              !t4.$isModified(S2, null, v2) || P2.$__.activePaths.getStatePaths("modify").hasOwnProperty(S2) || P2.$isDefault(S2) || (i2.add(S2), t4.$__.pathsToScopes == null && (t4.$__.pathsToScopes = {}), t4.$__.pathsToScopes[S2] = w2.$isDocumentArrayElement ? w2.__parentArray : w2.$parent(), o2[S2] = { skipSchemaValidators: true }, w2.$isDocumentArrayElement && w2.__index != null && (o2[S2].index = w2.__index));
            }
          }
        }
        var A2, E2 = p(i2);
        try {
          for (E2.s();!(A2 = E2.n()).done; ) {
            var x2 = A2.value, T2 = t4.$__schema.path(x2);
            if (T2) {
              if (T2.$isMongooseDocumentArray) {
                var k2, N2 = p(i2);
                try {
                  for (N2.s();!(k2 = N2.n()).done; ) {
                    var I2 = k2.value;
                    (I2 == null || I2.startsWith(T2.path + ".")) && i2.delete(I2);
                  }
                } catch (t5) {
                  N2.e(t5);
                } finally {
                  N2.f();
                }
              }
              (T2.caster || T2.validators.length !== 0 || T2.$parentSchemaDocArray) && (!T2.$isMongooseArray || T2.$isMongooseDocumentArray || T2.$embeddedSchemaType.$isMongooseArray || T2.validators.length !== 0 || T2.$embeddedSchemaType.validators.length !== 0) || i2.delete(x2);
            }
          }
        } catch (t5) {
          E2.e(t5);
        } finally {
          E2.f();
        }
        Array.isArray(e3) ? i2 = function(t5, e4) {
          var r4, n3 = new Set(e4), o3 = new Map([]), i3 = p(e4);
          try {
            for (i3.s();!(r4 = i3.n()).done; ) {
              var s3 = r4.value;
              if (s3.indexOf(".") !== -1)
                for (var a3 = s3.split("."), u3 = a3[0], c3 = 1;c3 < a3.length; ++c3)
                  o3.set(u3, s3), u3 = u3 + "." + a3[c3];
            }
          } catch (t6) {
            i3.e(t6);
          } finally {
            i3.f();
          }
          var l3, f3 = new Set, h3 = p(t5);
          try {
            for (h3.s();!(l3 = h3.n()).done; ) {
              var y3 = l3.value;
              n3.has(y3) ? f3.add(y3) : o3.has(y3) && f3.add(o3.get(y3));
            }
          } catch (t6) {
            h3.e(t6);
          } finally {
            h3.f();
          }
          return f3;
        }(i2, e3) : Array.isArray(r3) && (i2 = function(t5, e4) {
          return e4 = new Set(e4), t5 = Array.from(t5).filter(function(t6) {
            return !e4.has(t6);
          }), new Set(t5);
        }(i2, r3)), function(t5, e4) {
          var r4, n3 = p(e4);
          try {
            for (n3.s();!(r4 = n3.n()).done; ) {
              var o3 = r4.value, i3 = t5.$__schema.path(o3);
              i3 && i3.$isMongooseArray && (Array.isArray(i3) || !i3.$isMongooseDocumentArray || i3 && i3.schemaOptions && i3.schemaOptions.required) && (!i3.$isMongooseArray || i3.$isMongooseDocumentArray || i3.$embeddedSchemaType.$isMongooseArray || i3.$embeddedSchemaType.validators.length !== 0) && At(t5.$__getValue(o3), e4, o3);
            }
          } catch (t6) {
            n3.e(t6);
          } finally {
            n3.f();
          }
        }(t4, i2);
        var B2, M2 = { skipArrays: true }, D2 = p(i2);
        try {
          for (D2.s();!(B2 = D2.n()).done; ) {
            var R2 = B2.value;
            if (t4.$__schema.nested[R2]) {
              var U2 = t4.$__getValue(R2);
              st(U2) && (U2 = U2.toObject({ transform: false }));
              var C2 = F(U2, R2, M2, t4.$__schema);
              Object.keys(C2).filter(function(e4) {
                return !t4.$__schema.singleNestedPaths.hasOwnProperty(e4);
              }).forEach(s2);
            }
          }
        } catch (t5) {
          D2.e(t5);
        } finally {
          D2.f();
        }
        var L2, V2 = p(i2);
        try {
          for (V2.s();!(L2 = V2.n()).done; ) {
            var q2 = L2.value, J2 = t4.$__schema.path(q2);
            if (J2 && (J2.$parentSchemaDocArray && typeof J2.$parentSchemaDocArray.path == "string" && i2.add(J2.$parentSchemaDocArray.path), J2.$isSchemaMap)) {
              var z2 = t4.$__getValue(q2);
              if (z2 != null) {
                var K2, H2 = p(z2.keys());
                try {
                  for (H2.s();!(K2 = H2.n()).done; ) {
                    var W2 = K2.value;
                    i2.add(q2 + "." + W2);
                  }
                } catch (t5) {
                  H2.e(t5);
                } finally {
                  H2.f();
                }
              }
            }
          }
        } catch (t5) {
          V2.e(t5);
        } finally {
          V2.f();
        }
        return [i2 = Array.from(i2), o2];
      }
      function At(t4, e3, r3) {
        if (t4 != null)
          for (var n2 = t4.length, o2 = 0;o2 < n2; ++o2)
            Array.isArray(t4[o2]) ? At(t4[o2], e3, r3 + "." + o2) : e3.add(r3 + "." + o2);
      }
      function Et(t4, e3, r3, n2) {
        var o2, i2, s2, a2 = t4.$__schema, u2 = a2.virtuals, c2 = Object.keys(u2), l2 = c2.length, f2 = l2, p2 = t4._doc, h2 = typeof (n2 && n2.aliases) != "boolean" || n2.aliases;
        r3 = r3 || {};
        var y2 = null;
        if (Array.isArray(r3.virtuals))
          y2 = new Set(r3.virtuals);
        else if (r3.virtuals && r3.virtuals.pathsToSkip) {
          y2 = new Set(c2);
          for (var d2 = 0;d2 < r3.virtuals.pathsToSkip.length; d2++)
            y2.has(r3.virtuals.pathsToSkip[d2]) && y2.delete(r3.virtuals.pathsToSkip[d2]);
        }
        if (!p2)
          return e3;
        for (l2 = 0;l2 < f2; ++l2)
          if (o2 = c2[l2], (y2 == null || y2.has(o2)) && (h2 || !a2.aliases.hasOwnProperty(o2))) {
            if (i2 = o2, r3.path != null) {
              if (!o2.startsWith(r3.path + "."))
                continue;
              i2 = o2.substring(r3.path.length + 1);
            }
            if (i2.indexOf(".") !== -1 || i2 !== o2) {
              var b2 = i2.split(".");
              if ((s2 = D(t4.get(o2), r3)) !== undefined) {
                var m2 = b2.length;
                p2 = e3;
                for (var v2 = 0;v2 < m2 - 1; ++v2)
                  p2[b2[v2]] = p2[b2[v2]] || {}, p2 = p2[b2[v2]];
                p2[b2[m2 - 1]] = s2;
              }
            } else {
              if ((s2 = u2[o2].applyGetters(undefined, t4)) === undefined)
                continue;
              s2 = D(s2, r3), e3[i2] = s2;
            }
          }
        return e3;
      }
      function xt(t4, e3) {
        if (ot(e3))
          throw new Error("`transform` function must be synchronous, but the transform on path `" + t4 + "` returned a promise.");
      }
      function Tt(t4, e3, r3) {
        var n2 = t4.$populated(e3, true);
        if (!n2 && t4.$__.selected) {
          var o2 = e3.split(".")[0];
          if (t4.$__.selected[o2 + ".$"])
            return o2;
        }
        if (n2 && nt.isMongooseArray(r3) && (n2.options.match || n2.options.options && nt.object.hasOwnProperty(n2.options.options, "limit") || n2.options.options && n2.options.options.skip || n2.options.select && (n2.options.select._id === 0 || /\s?-_id\s?/.test(n2.options.select)))) {
          var i2 = r3[ut];
          if (Object.keys(i2).length === 0 || i2.$set || i2.$pop)
            return e3;
        }
      }
      function kt(t4, e3, r3, n2, o2, i2) {
        if (i2 || (i2 = "$set"), r3[i2] || (r3[i2] = {}), r3[i2][n2.path] = o2, t4.$__schema.options.versionKey !== false && !function(t5, e4) {
          var r4 = t5.$__schema.options.skipVersioning;
          return !!r4 && r4[e4 = e4.replace(/\.\d+\./, ".")];
        }(t4, n2.path) && 3 & ~t4.$__.version && !t4.$__schema.options.optimisticConcurrency) {
          switch (i2) {
            case "$set":
            case "$unset":
            case "$pop":
            case "$pull":
            case "$pullAll":
            case "$push":
            case "$addToSet":
            case "$inc":
              break;
            default:
              return;
          }
          i2 === "$push" || i2 === "$addToSet" || i2 === "$pullAll" || i2 === "$pull" ? /\.\d+\.|\.\d+$/.test(n2.path) ? t4.$__.version = 3 : t4.$__.version = 2 : /^\$p/.test(i2) || Array.isArray(o2) ? t4.$__.version = 3 : /\.\d+\.|\.\d+$/.test(n2.path) && (t4.$__.version = 1);
        }
      }
      function Nt(t4, e3, r3, n2, o2) {
        if (!r3.$set || !r3.$set[n2.path])
          if (typeof o2.$__getAtomics != "function") {
            var i2, s2, a2 = o2[ut], u2 = Object.keys(a2), c2 = u2.length;
            if (c2 === 0)
              return nt.isMongooseObject(o2) ? o2 = o2.toObject({ depopulate: 1, _isNested: true }) : o2.valueOf && (o2 = o2.valueOf()), kt(t4, 0, r3, n2, o2);
            for (;c2--; )
              i2 = a2[s2 = u2[c2]], nt.isMongooseObject(i2) ? i2 = i2.toObject({ depopulate: true, transform: false, _isNested: true }) : Array.isArray(i2) ? i2 = i2.map(l2) : i2.valueOf && (i2 = i2.valueOf()), s2 === "$addToSet" && (i2 = { $each: i2 }), kt(t4, 0, r3, n2, i2, s2);
          } else
            o2.$__getAtomics().forEach(function(e4) {
              var o3 = e4[0], i3 = e4[1];
              kt(t4, 0, r3, n2, i3, o3);
            });
        function l2(t5) {
          return nt.isMongooseObject(t5) ? t5.toObject({ depopulate: 1, _isNested: true }) : t5;
        }
      }
      wt.prototype.$__schema, wt.prototype.schema, Object.defineProperty(wt.prototype, "$locals", { configurable: false, enumerable: false, get: function() {
        return this.$__.locals == null && (this.$__.locals = {}), this.$__.locals;
      }, set: function(t4) {
        this.$__.locals = t4;
      } }), wt.prototype.isNew, Object.defineProperty(wt.prototype, "$where", { configurable: false, enumerable: false, writable: true }), wt.prototype.id, wt.prototype.$errors, Object.defineProperty(wt.prototype, "$op", { get: function() {
        return this.$__.op || null;
      }, set: function(t4) {
        this.$__.op = t4;
      } }), wt.prototype.$__buildDoc = function(t4, e3, r3, n2, o2) {
        for (var i2 = {}, s2 = Object.keys(this.$__schema.paths).filter(function(t5) {
          return !t5.includes("$*");
        }), a2 = s2.length, u2 = 0;u2 < a2; ++u2) {
          var c2 = s2[u2];
          if (c2 === "_id") {
            if (r3)
              continue;
            if (t4 && "_id" in t4)
              continue;
          }
          for (var l2 = this.$__schema.paths[c2].splitPath(), f2 = l2.length, p2 = f2 - 1, h2 = "", y2 = i2, d2 = false, b2 = 0;b2 < f2; ++b2) {
            var m2 = l2[b2];
            if (h2.length ? h2 += "." + m2 : h2 = m2, n2 === true) {
              if (h2 in e3)
                break;
            } else if (n2 === false && e3 && !d2) {
              if (h2 in e3)
                d2 = true;
              else if (!o2[h2])
                break;
            }
            b2 < p2 && (y2 = y2[m2] || (y2[m2] = {}));
          }
        }
        this._doc = i2;
      }, wt.prototype.toBSON = function() {
        return this.toObject(Y);
      }, wt.prototype.init = function(t4, e3, r3) {
        return typeof e3 == "function" && (r3 = e3, e3 = null), this.$__init(t4, e3), r3 && r3(null, this), this;
      }, wt.prototype.$init = function() {
        return this.constructor.prototype.init.apply(this, arguments);
      }, wt.prototype.$__init = function(t4, e3) {
        if (this.$isNew = false, e3 = e3 || {}, t4._id != null && e3.populated && e3.populated.length) {
          var r3, n2 = String(t4._id), o2 = p(e3.populated);
          try {
            for (o2.s();!(r3 = o2.n()).done; ) {
              var i2 = r3.value;
              if (i2.isVirtual ? this.$populated(i2.path, nt.getValue(i2.path, t4), i2) : this.$populated(i2.path, i2._docs[n2], i2), i2._childDocs != null) {
                var s2, a2 = p(i2._childDocs);
                try {
                  for (a2.s();!(s2 = a2.n()).done; ) {
                    var u2 = s2.value;
                    u2 != null && u2.$__ != null && (u2.$__.parent = this);
                  }
                } catch (t5) {
                  a2.e(t5);
                } finally {
                  a2.f();
                }
                i2._childDocs = [];
              }
            }
          } catch (t5) {
            o2.e(t5);
          } finally {
            o2.f();
          }
        }
        $t(this, t4, this._doc, e3), Z(this, e3.populated), this.$emit("init", this), this.constructor.emit("init", this);
        var c2 = this.$__.exclude === false && this.$__.selected ? I(this.$__.selected) : null;
        return B(this, this.$__.selected, this.$__.exclude, c2, false, this.$__.skipDefaults), this;
      }, wt.prototype.updateOne = function(t4, e3, r3) {
        var n2 = this.constructor.updateOne({ _id: this._doc._id }, t4, e3), o2 = this;
        return n2.pre(function(t5) {
          o2.constructor._middleware.execPre("updateOne", o2, [o2], t5);
        }), n2.post(function(t5) {
          o2.constructor._middleware.execPost("updateOne", o2, [o2], {}, t5);
        }), this.$session() != null && (("session" in n2.options) || (n2.options.session = this.$session())), r3 != null ? n2.exec(r3) : n2;
      }, wt.prototype.replaceOne = function() {
        var t4 = Array.prototype.slice.call(arguments);
        return t4.unshift({ _id: this._doc._id }), this.constructor.replaceOne.apply(this.constructor, t4);
      }, wt.prototype.$session = function(t4) {
        if (arguments.length === 0)
          return this.$__.session != null && this.$__.session.hasEnded ? (this.$__.session = null, null) : this.$__.session;
        if (t4 != null && t4.hasEnded)
          throw new S("Cannot set a document's session to a session that has ended. Make sure you haven't called `endSession()` on the session you are passing to `$session()`.");
        if (t4 != null || this.$__.session != null) {
          if (this.$__.session = t4, !this.$isSubdocument) {
            var e3, r3 = p(this.$getAllSubdocs());
            try {
              for (r3.s();!(e3 = r3.n()).done; )
                e3.value.$session(t4);
            } catch (t5) {
              r3.e(t5);
            } finally {
              r3.f();
            }
          }
          return t4;
        }
      }, wt.prototype.$timestamps = function(t4) {
        return arguments.length === 0 ? this.$__.timestamps != null ? this.$__.timestamps : this.$__schema ? this.$__schema.options.timestamps : undefined : (t4 !== this.$timestamps() && (this.$__.timestamps = t4), this);
      }, wt.prototype.overwrite = function(t4) {
        for (var e3 = 0, r3 = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(t4))));e3 < r3.length; e3++) {
          var n2 = r3[e3];
          n2 !== "_id" && (this.$__schema.options.versionKey && n2 === this.$__schema.options.versionKey || this.$__schema.options.discriminatorKey && n2 === this.$__schema.options.discriminatorKey || this.$set(n2, t4[n2]));
        }
        return this;
      }, wt.prototype.$set = function(t4, e3, r3, n2) {
        var o2 = this;
        nt.isPOJO(r3) && (n2 = r3, r3 = undefined);
        var i2, s2, a2, u2, c2 = n2 && n2.merge, h2 = r3 && r3 !== true, y2 = r3 === true, b2 = 0, m2 = n2 && "strict" in n2, v2 = m2 ? n2.strict : this.$__.strictMode;
        if (h2 && ((this.$__.adhocPaths || (this.$__.adhocPaths = {}))[t4] = this.$__schema.interpretAsType(t4, r3, this.$__schema.options)), t4 == null) {
          var g2 = [e3, t4];
          t4 = g2[0], e3 = g2[1];
        } else if (typeof t4 != "string") {
          if (t4 instanceof wt && (t4 = t4.$__isNested ? t4.toObject() : t4.$__schema === this.$__schema ? Et(t4, l({}, t4._doc)) : t4._doc), t4 == null) {
            var _2 = [e3, t4];
            t4 = _2[0], e3 = _2[1];
          }
          u2 = e3 ? e3 + "." : "";
          var w2 = (i2 = V(this.$__schema, t4)).length, O2 = n2 && n2._skipMinimizeTopLevel || false;
          if (w2 === 0 && O2)
            return delete n2._skipMinimizeTopLevel, e3 && this.$set(e3, {}), this;
          n2 = Object.assign({}, n2, { _skipMinimizeTopLevel: false });
          for (var j2 = 0;j2 < w2; ++j2) {
            a2 = i2[j2];
            var A2 = u2 ? u2 + a2 : a2;
            s2 = this.$__schema.pathType(A2);
            var E2 = t4[a2];
            if (r3 !== true || u2 || E2 == null || s2 !== "nested" || this._doc[a2] == null || delete this._doc[a2], nt.isNonBuiltinObject(E2) && s2 === "nested")
              this.$set(A2, E2, y2, n2), St(this.$get(A2), A2, this);
            else if (v2) {
              if (y2 && E2 === undefined && this.$get(A2) !== undefined)
                continue;
              if (s2 === "adhocOrUndefined" && (s2 = L(this, A2, { typeOnly: true })), s2 === "real" || s2 === "virtual")
                this.$set(A2, E2, y2, n2);
              else if (s2 === "nested" && E2 instanceof wt)
                this.$set(A2, E2.toObject({ transform: false }), y2, n2);
              else {
                if (v2 === "throw")
                  throw s2 === "nested" ? new P(a2, E2) : new T(a2);
                s2 === "nested" && E2 == null && this.$set(A2, E2, y2, n2);
              }
            } else
              this.$set(A2, E2, y2, n2);
          }
          for (var x2 = {}, k2 = Object.keys(this.$__schema.tree), N2 = 0, I2 = k2.length;N2 < I2; ++N2)
            (a2 = k2[N2]) && this._doc.hasOwnProperty(a2) && (x2[a2] = undefined);
          return this._doc = Object.assign(x2, this._doc), this;
        }
        var B2 = this.$__schema.pathType(t4), D2 = null;
        if (B2 === "adhocOrUndefined" && (D2 = t4.indexOf(".") === -1 ? [t4] : t4.split("."), B2 = L(this, D2, { typeOnly: true })), B2 === "adhocOrUndefined" && !m2) {
          D2 == null && (D2 = t4.indexOf(".") === -1 ? [t4] : t4.split("."));
          var R2 = q(this.$__schema, D2);
          R2 !== undefined && (v2 = R2);
        }
        e3 = J(e3, true);
        var U2, C2 = o2.$__.priorDoc != null ? o2.$__.priorDoc.$__getValue(t4) : y2 ? undefined : o2.$__getValue(t4);
        if (B2 === "nested" && e3) {
          if (d(e3) === "object" && e3 != null) {
            if (e3.$__ != null && (e3 = e3.toObject(Y)), e3 == null)
              return this.invalidate(t4, new S.CastError("Object", e3, t4)), this;
            var F2 = this.$isModified(t4), z2 = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(t4);
            if (this.$__.savedState != null && !this.$isNew && !this.$__.savedState.hasOwnProperty(t4)) {
              var K2 = this.$__getValue(t4);
              this.$__.savedState[t4] = K2;
              for (var H2 = 0, W2 = Object.keys(K2 || {});H2 < W2.length; H2++) {
                var G2 = W2[H2];
                this.$__.savedState[t4 + "." + G2] = K2[G2];
              }
            }
            if (c2)
              return this.$set(e3, t4, y2, n2);
            this.$__setValue(t4, null), M(this, t4);
            var Q2 = V(this.$__schema, e3, t4);
            this.$__setValue(t4, {});
            var Z2, X2 = p(Q2);
            try {
              for (X2.s();!(Z2 = X2.n()).done; ) {
                var et2 = Z2.value;
                this.$set(t4 + "." + et2, e3[et2], y2, l(l({}, n2), {}, { _skipMarkModified: true }));
              }
            } catch (t5) {
              X2.e(t5);
            } finally {
              X2.f();
            }
            return C2 == null || F2 && !z2 || !nt.deepEqual(z2 ? this.$__.savedState[t4] : C2, e3) ? this.markModified(t4) : this.unmarkModified(t4), this;
          }
          return this.invalidate(t4, new S.CastError("Object", e3, t4)), this;
        }
        if (D2 == null && (D2 = t4.indexOf(".") === -1 ? [t4] : t4.split(".")), typeof this.$__schema.aliases[D2[0]] == "string" && (D2[0] = this.$__schema.aliases[D2[0]]), B2 === "adhocOrUndefined" && v2) {
          var rt2;
          for (b2 = 0;b2 < D2.length; ++b2) {
            var ot2 = D2.slice(0, b2 + 1).join(".");
            if (b2 + 1 < D2.length && this.$__schema.pathType(ot2) === "virtual")
              return tt.set(t4, e3, this), this;
            if ((U2 = this.$__schema.path(ot2)) != null) {
              if (U2 instanceof $) {
                rt2 = true;
                break;
              }
              if (U2.$isSchemaMap && U2.$__schemaType instanceof $ && b2 < D2.length - 1) {
                rt2 = true, U2 = U2.$__schemaType;
                break;
              }
            }
          }
          if (U2 == null && (U2 = L(this, t4)), !rt2 && !U2) {
            if (v2 === "throw")
              throw new T(t4);
            return this;
          }
        } else {
          if (B2 === "virtual")
            return (U2 = this.$__schema.virtualpath(t4)).applySetters(e3, this), this;
          U2 = this.$__path(t4);
        }
        var it2, st2 = this._doc, at2 = "";
        for (b2 = 0;b2 < D2.length - 1; ++b2)
          st2 = st2 instanceof Map ? st2.get(D2[b2]) : st2[D2[b2]], at2 += (at2.length !== 0 ? "." : "") + D2[b2], st2 || (this.$set(at2, {}), this.$__isSelected(at2) || this.unmarkModified(at2), st2 = this.$__getValue(at2));
        if (D2.length <= 1)
          it2 = t4;
        else {
          var ut2 = D2.length;
          for (b2 = 0;b2 < ut2; ++b2) {
            var ct2 = D2.slice(0, b2 + 1).join(".");
            if (this.$get(ct2, null, { getters: false }) === null) {
              it2 = ct2;
              break;
            }
          }
          it2 || (it2 = t4);
        }
        if (!U2)
          return this.$__set(it2, t4, n2, y2, D2, U2, e3, C2), B2 === "nested" && e3 == null && M(this, t4), this;
        if ((U2.$isSingleNested || U2.$isMongooseArray) && function(t5, e4) {
          if (t5.$__.validationError) {
            for (var r4 = 0, n3 = Object.keys(t5.$__.validationError.errors);r4 < n3.length; r4++) {
              var o3 = n3[r4];
              o3.startsWith(e4 + ".") && delete t5.$__.validationError.errors[o3];
            }
            Object.keys(t5.$__.validationError.errors).length === 0 && (t5.$__.validationError = null);
          }
        }(this, t4), e3 != null && c2 && U2.$isSingleNested) {
          e3 instanceof wt && (e3 = e3.toObject({ virtuals: false, transform: false }));
          for (var lt2 = 0, ft2 = Object.keys(e3);lt2 < ft2.length; lt2++) {
            var pt2 = ft2[lt2];
            this.$set(t4 + "." + pt2, e3[pt2], y2, n2);
          }
          return this;
        }
        var ht2 = true;
        try {
          var bt2, mt2 = function() {
            if (U2.options == null)
              return false;
            if (!(e3 instanceof wt))
              return false;
            var t5 = e3.constructor, r4 = typeof U2.options.ref != "function" || U2.options.ref[yt] ? U2.options.ref : U2.options.ref.call(o2, o2), n3 = (r4 == null ? undefined : r4.modelName) || r4;
            if (n3 != null && (n3 === t5.modelName || n3 === t5.baseModelName))
              return true;
            var i3 = U2.options.refPath;
            if (i3 == null)
              return false;
            var s3 = e3.get(i3);
            return s3 === t5.modelName || s3 === t5.baseModelName;
          }(), _t2 = false;
          if (mt2 && e3 instanceof wt && (!e3.$__.wasPopulated || nt.deepEqual(e3.$__.wasPopulated.value, e3._doc._id))) {
            var Ot2 = U2 && U2.$isSingleNested ? U2.cast(e3, this) : e3._doc._id;
            this.$populated(t4, Ot2, f({}, dt, e3.constructor)), e3.$__.wasPopulated = { value: Ot2 }, _t2 = true;
          }
          var $t2 = this.$__schema.options.typeKey;
          if (U2.options && Array.isArray(U2.options[$t2]) && U2.options[$t2].length && U2.options[$t2][0] && U2.options[$t2][0].ref && function(t5, e4) {
            if (!Array.isArray(t5))
              return false;
            if (t5.length === 0)
              return false;
            var r4, n3 = p(t5);
            try {
              for (n3.s();!(r4 = n3.n()).done; ) {
                var o3 = r4.value;
                if (!(o3 instanceof wt))
                  return false;
                if (o3.constructor.modelName == null)
                  return false;
                if (o3.constructor.modelName != e4 && o3.constructor.baseModelName != e4)
                  return false;
              }
            } catch (t6) {
              n3.e(t6);
            } finally {
              n3.f();
            }
            return true;
          }(e3, U2.options[$t2][0].ref)) {
            bt2 = f({}, dt, e3[0].constructor), this.$populated(t4, e3.map(function(t5) {
              return t5._doc._id;
            }), bt2);
            var jt2, Pt2 = p(e3);
            try {
              for (Pt2.s();!(jt2 = Pt2.n()).done; ) {
                var At2 = jt2.value;
                At2.$__.wasPopulated = { value: At2._doc._id };
              }
            } catch (t5) {
              Pt2.e(t5);
            } finally {
              Pt2.f();
            }
            _t2 = true;
          }
          if (!mt2 || !U2.$isSingleNested || !e3.$__) {
            var xt2 = this;
            this.$__schema.singleNestedPaths[t4] != null && D2.length > 1 && (xt2 = vt(this, D2, this.schema)), e3 = n2 != null && n2.overwriteImmutable ? U2.applySetters(e3, xt2, false, C2, { path: t4, overwriteImmutable: true }) : U2.applySetters(e3, xt2, false, C2, { path: t4 });
          }
          if (Array.isArray(e3) && !Array.isArray(U2) && U2.$isMongooseDocumentArray && e3.length !== 0 && e3[0] != null && e3[0].$__ != null && e3[0].$__.populated != null) {
            for (var Tt2 = Object.keys(e3[0].$__.populated), kt2 = function() {
              var r4 = It[Nt2];
              o2.$populated(t4 + "." + r4, e3.map(function(t5) {
                return t5.$populated(r4);
              }), e3[0].$__.populated[r4].options);
            }, Nt2 = 0, It = Tt2;Nt2 < It.length; Nt2++)
              kt2();
            _t2 = true;
          }
          if (!_t2 && this.$__.populated) {
            if (Array.isArray(e3) && this.$__.populated[t4])
              for (var Bt = 0;Bt < e3.length; ++Bt)
                e3[Bt] instanceof wt && e3.set(Bt, e3[Bt]._doc._id, true);
            delete this.$__.populated[t4];
          }
          e3 != null && U2.$isSingleNested && function(t5, e4, r4) {
            var n3 = e4.schema;
            if (n3 != null)
              for (var o3 = 0, i3 = Object.keys(n3.paths);o3 < i3.length; o3++) {
                var s3 = i3[o3], a3 = n3.paths[s3];
                if (a3.$immutableSetter != null) {
                  var u3 = r4 == null ? undefined : r4.$__getValue(s3);
                  a3.$immutableSetter.call(t5, u3);
                }
              }
          }(e3, U2, C2), this.$markValid(t4);
        } catch (r4) {
          r4 instanceof S.StrictModeError && r4.isImmutableError ? this.invalidate(t4, r4) : r4 instanceof S.CastError ? (this.invalidate(r4.path, r4), r4.$originalErrorPath && this.invalidate(t4, new S.CastError(U2.instance, e3, t4, r4.$originalErrorPath))) : this.invalidate(t4, new S.CastError(U2.instance, e3, t4, r4)), ht2 = false;
        }
        if (ht2) {
          var Mt, Dt = null, Rt = null;
          if (!y2) {
            var Ut = this.$isSubdocument ? this.ownerDocument() : this;
            Dt = Ut.$__.savedState, Rt = this.$isSubdocument ? this.$__.fullPath + "." + t4 : t4, Ut.$__saveInitialState(Rt);
          }
          this.$__set(it2, t4, n2, y2, D2, U2, e3, C2);
          var Ct = !((Mt = this.$__.session) === null || Mt === undefined || !Mt.transaction), Ft = this.$__.session && this.$__.session[gt] && this.$__.session[gt].has(this) && this.$__.session[gt].get(this).modifiedPaths && !this.$__.session[gt].get(this).modifiedPaths.has(Rt);
          Dt != null && Dt.hasOwnProperty(Rt) && (!Ct || Ft) && nt.deepEqual(e3, Dt[Rt]) && this.unmarkModified(t4);
        }
        return (U2.$isSingleNested && (this.isDirectModified(t4) || e3 == null) || U2.$isSchemaMap && e3 == null) && M(this, t4), this;
      }, wt.prototype.set = wt.prototype.$set, wt.prototype.$__shouldModify = function(t4, e3, r3, n2, o2, i2, s2, a2) {
        return !(r3 && r3._skipMarkModified || !this.$isNew && !(e3 in this.$__.activePaths.getStatePaths("modify")) && (s2 !== undefined || this.$__isSelected(e3)) && (s2 === undefined && (e3 in this.$__.activePaths.getStatePaths("default")) || this.$populated(e3) && s2 instanceof wt && it(s2._doc._id, a2) || it(s2, a2 !== undefined ? a2 : nt.getValue(e3, this)) && (n2 || s2 == null || !(e3 in this.$__.activePaths.getStatePaths("default")) || !it(s2, i2.getDefault(this, n2)))));
      }, wt.prototype.$__set = function(t4, e3, n2, o2, i2, s2, a2, u2) {
        v = v || r2(6547);
        var c2 = this.$__shouldModify(t4, e3, n2, o2, i2, s2, a2, u2);
        c2 ? (this.$__.primitiveAtomics && this.$__.primitiveAtomics[e3] && (delete this.$__.primitiveAtomics[e3], Object.keys(this.$__.primitiveAtomics).length === 0 && delete this.$__.primitiveAtomics), this.markModified(t4), m || (m = r2(7557)), a2 && nt.isMongooseArray(a2) && (a2._registerAtomic("$set", a2), nt.isMongooseDocumentArray(a2) && a2.forEach(function(t5) {
          t5 && t5.__parentArray && (t5.__parentArray = a2);
        }))) : Array.isArray(a2) && Array.isArray(u2) && nt.isMongooseArray(a2) && nt.isMongooseArray(u2) && (a2[ut] = u2[ut], a2[at] = u2[at], nt.isMongooseDocumentArray(a2) && a2.forEach(function(t5) {
          t5 != null && (t5.$isNew = false);
        }));
        for (var l2 = this._doc, f2 = 0, p2 = i2.length, h2 = "";f2 < p2; f2++) {
          var y2 = f2 + 1 === p2;
          if (h2 += h2 ? "." + i2[f2] : i2[f2], !_t.has(i2[f2]))
            if (y2)
              l2 instanceof Map ? l2.set(i2[f2], a2) : l2.$isSingleNested ? ((i2[f2] in l2) || (l2[i2[f2]] = a2), l2._doc[i2[f2]] = a2, c2 && l2.markModified(i2[f2])) : l2[i2[f2]] = a2;
            else {
              var d2 = l2 instanceof Map, b2 = d2 ? l2.get(i2[f2]) : l2[i2[f2]];
              nt.isPOJO(b2) || b2 && b2 instanceof v || b2 && !Array.isArray(b2) && b2.$isSingleNested || b2 && Array.isArray(b2) ? l2 = b2 : b2 == null ? (b2 = {}, d2 ? l2.set(i2[f2], b2) : l2[i2[f2]] = b2, l2 = b2) : l2 = b2;
            }
        }
      }, wt.prototype.$__getValue = function(t4) {
        if (typeof t4 != "string" && !Array.isArray(t4))
          throw new TypeError('Invalid `path`. Must be either string or array. Got "'.concat(t4, '" (type ').concat(d(t4), ")"));
        return nt.getValue(t4, this._doc);
      }, wt.prototype.$inc = function(t4, e3) {
        var r3 = this;
        if (e3 == null && (e3 = 1), Array.isArray(t4))
          return t4.forEach(function(t5) {
            return r3.$inc(t5, e3);
          }), this;
        var n2 = this.$__path(t4);
        if (n2 == null) {
          if (this.$__.strictMode === "throw")
            throw new T(t4);
          if (this.$__.strictMode === true)
            return this;
        } else if (n2.instance !== "Number")
          return this.invalidate(t4, new S.CastError(n2.instance, e3, t4)), this;
        var o2 = this.$__getValue(t4) || 0, i2 = false, s2 = null, a2 = e3;
        try {
          e3 = n2.cast(e3), a2 = (s2 = n2.applySetters(o2 + e3, this)) - o2, i2 = true;
        } catch (r4) {
          this.invalidate(t4, new S.CastError("number", e3, t4, r4));
        }
        return i2 && (this.$__.primitiveAtomics = this.$__.primitiveAtomics || {}, this.$__.primitiveAtomics[t4] == null ? this.$__.primitiveAtomics[t4] = { $inc: a2 } : this.$__.primitiveAtomics[t4].$inc += a2, this.markModified(t4), this.$__setValue(t4, s2)), this;
      }, wt.prototype.$__setValue = function(t4, e3) {
        return nt.setValue(t4, e3, this._doc), this;
      }, wt.prototype.get = function(t4, e3, r3) {
        var n2;
        r3 == null && (r3 = {}), e3 && (n2 = this.$__schema.interpretAsType(t4, e3, this.$__schema.options));
        var o2 = r3.noDottedPath, i2 = o2 ? this.$__schema.paths[t4] : this.$__path(t4);
        if (i2 == null && (i2 = this.$__schema.virtualpath(t4)) != null)
          return i2.applyGetters(undefined, this);
        if (o2) {
          var s2 = this._doc[t4];
          return n2 && (s2 = n2.cast(s2)), i2 != null && r3.getters !== false ? i2.applyGetters(s2, this) : s2;
        }
        if (i2 != null && i2.instance === "Mixed") {
          var a2 = this.$__schema.virtualpath(t4);
          a2 != null && (i2 = a2);
        }
        var u2 = t4.indexOf(".") !== -1, c2 = this._doc, l2 = u2 ? t4.split(".") : [t4];
        typeof this.$__schema.aliases[l2[0]] == "string" && (l2[0] = this.$__schema.aliases[l2[0]]);
        for (var f2 = 0, p2 = l2.length;f2 < p2; f2++)
          c2 && c2._doc && (c2 = c2._doc), c2 = c2 == null ? undefined : c2 instanceof Map ? c2.get(l2[f2], { getters: false }) : f2 === p2 - 1 ? nt.getValue(l2[f2], c2) : c2[l2[f2]];
        if (n2 && (c2 = n2.cast(c2)), i2 != null && r3.getters !== false)
          c2 = i2.applyGetters(c2, this);
        else if (this.$__schema.nested[t4] && r3.virtuals)
          return Et(this, D(c2) || {}, { path: t4 });
        return c2;
      }, wt.prototype[ht] = wt.prototype.get, wt.prototype.$get = wt.prototype.get, wt.prototype.$__path = function(t4) {
        var e3 = this.$__.adhocPaths;
        return (e3 && e3.hasOwnProperty(t4) ? e3[t4] : null) || this.$__schema.path(t4);
      }, wt.prototype.markModified = function(t4, e3) {
        this.$__saveInitialState(t4), this.$__.activePaths.modify(t4), e3 == null || this.$isSubdocument || (this.$__.pathsToScopes = this.$__pathsToScopes || {}, this.$__.pathsToScopes[t4] = e3);
      }, wt.prototype.$__saveInitialState = function(t4) {
        var e3 = this.$__.savedState, r3 = t4;
        if (e3 != null) {
          var n2 = r3.indexOf("."), o2 = n2 === -1 ? r3 : r3.slice(0, n2);
          e3.hasOwnProperty(o2) || (e3[o2] = D(this.$__getValue(o2)));
        }
      }, wt.prototype.unmarkModified = function(t4) {
        this.$__.activePaths.init(t4), this.$__.pathsToScopes != null && delete this.$__.pathsToScopes[t4];
      }, wt.prototype.$ignore = function(t4) {
        this.$__.activePaths.ignore(t4);
      }, wt.prototype.directModifiedPaths = function() {
        return Object.keys(this.$__.activePaths.getStatePaths("modify"));
      }, wt.prototype.$isEmpty = function(t4) {
        var e3 = { minimize: true, virtuals: false, getters: false, transform: false };
        if (arguments.length !== 0) {
          var r3 = this.$get(t4);
          return r3 == null || d(r3) === "object" && (nt.isPOJO(r3) ? jt(r3) : Object.keys(r3.toObject(e3)).length === 0);
        }
        return Object.keys(this.toObject(e3)).length === 0;
      }, wt.prototype.modifiedPaths = function(t4) {
        t4 = t4 || {};
        var e3 = Object.keys(this.$__.activePaths.getStatePaths("modify")), r3 = new Set, n2 = 0, o2 = 0, i2 = e3.length;
        for (n2 = 0;n2 < i2; ++n2) {
          var s2 = e3[n2], a2 = et(s2), u2 = a2.length;
          for (o2 = 0;o2 < u2; ++o2)
            r3.add(a2[o2]);
          if (t4.includeChildren) {
            var c2 = 0, l2 = this.$get(s2);
            if (d(l2) === "object" && l2 !== null) {
              l2._doc && (l2 = l2._doc);
              var f2 = l2.length;
              if (Array.isArray(l2))
                for (c2 = 0;c2 < f2; ++c2) {
                  var p2 = s2 + "." + c2;
                  if (!r3.has(p2) && (r3.add(p2), l2[c2] != null && l2[c2].$__)) {
                    var h2 = l2[c2].modifiedPaths(), y2 = 0, b2 = h2.length;
                    for (y2 = 0;y2 < b2; ++y2)
                      r3.add(p2 + "." + h2[y2]);
                  }
                }
              else {
                var m2 = Object.keys(l2), v2 = 0, g2 = m2.length;
                for (v2 = 0;v2 < g2; ++v2)
                  r3.add(s2 + "." + m2[v2]);
              }
            }
          }
        }
        return Array.from(r3);
      }, wt.prototype[ft] = wt.prototype.modifiedPaths, wt.prototype.isModified = function(t4, e3, r3) {
        var n2 = this;
        if (t4) {
          var o2 = e3 && e3.ignoreAtomics, i2 = this.$__.activePaths.states.modify;
          if (i2 == null)
            return false;
          typeof t4 == "string" && (t4 = t4.indexOf(" ") === -1 ? [t4] : t4.split(" "));
          var s2, a2 = p(t4);
          try {
            for (a2.s();!(s2 = a2.n()).done; )
              if (i2[s2.value] != null)
                return true;
          } catch (t5) {
            a2.e(t5);
          } finally {
            a2.f();
          }
          var u2 = r3 || this[ft](), c2 = t4.some(function(t5) {
            return !!~u2.indexOf(t5);
          }), l2 = Object.keys(i2);
          return o2 && (l2 = l2.filter(function(t5) {
            var e4 = n2.$__getValue(t5);
            return e4 == null || e4[ut] == null || e4[ut].$set !== undefined;
          })), c2 || t4.some(function(t5) {
            return l2.some(function(e4) {
              return e4 === t5 || t5.startsWith(e4 + ".");
            });
          });
        }
        return this.$__.activePaths.some("modify");
      }, wt.prototype.$isModified = wt.prototype.isModified, wt.prototype[lt] = wt.prototype.isModified, wt.prototype.$isDefault = function(t4) {
        var e3 = this;
        if (t4 == null)
          return this.$__.activePaths.some("default");
        if (typeof t4 == "string" && t4.indexOf(" ") === -1)
          return this.$__.activePaths.getStatePaths("default").hasOwnProperty(t4);
        var r3 = t4;
        return Array.isArray(r3) || (r3 = r3.split(" ")), r3.some(function(t5) {
          return e3.$__.activePaths.getStatePaths("default").hasOwnProperty(t5);
        });
      }, wt.prototype.$isDeleted = function(t4) {
        return arguments.length === 0 ? !!this.$__.isDeleted : (this.$__.isDeleted = !!t4, this);
      }, wt.prototype.isDirectModified = function(t4) {
        var e3 = this;
        if (t4 == null)
          return this.$__.activePaths.some("modify");
        if (typeof t4 == "string" && t4.indexOf(" ") === -1) {
          var r3 = this.$__.activePaths.getStatePaths("modify").hasOwnProperty(t4);
          if (r3 || t4.indexOf(".") === -1)
            return r3;
          for (var n2 = t4.split("."), o2 = 0;o2 < n2.length - 1; ++o2) {
            var i2 = n2.slice(0, o2 + 1).join("."), s2 = this.$get(i2);
            if (s2 != null && s2.$__ != null && s2.isDirectModified(n2.slice(o2 + 1).join(".")))
              return true;
          }
          return false;
        }
        var a2 = t4;
        return typeof a2 == "string" && (a2 = a2.split(" ")), a2.some(function(t5) {
          return e3.isDirectModified(t5);
        });
      }, wt.prototype.isInit = function(t4) {
        var e3 = this;
        if (t4 == null)
          return this.$__.activePaths.some("init");
        if (typeof t4 == "string" && t4.indexOf(" ") === -1)
          return this.$__.activePaths.getStatePaths("init").hasOwnProperty(t4);
        var r3 = t4;
        return Array.isArray(r3) || (r3 = r3.split(" ")), r3.some(function(t5) {
          return e3.$__.activePaths.getStatePaths("init").hasOwnProperty(t5);
        });
      }, wt.prototype.isSelected = function(t4) {
        var e3 = this;
        if (this.$__.selected == null)
          return true;
        if (!t4)
          return false;
        if (t4 === "_id")
          return this.$__.selected._id !== 0;
        if (t4.indexOf(" ") !== -1 && (t4 = t4.split(" ")), Array.isArray(t4))
          return t4.some(function(t5) {
            return e3.$__isSelected(t5);
          });
        var r3 = Object.keys(this.$__.selected), n2 = null;
        if (r3.length === 1 && r3[0] === "_id")
          return this.$__.selected._id === 0;
        for (var o2 = 0, i2 = r3;o2 < i2.length; o2++) {
          var s2 = i2[o2];
          if (s2 !== "_id" && H(this.$__.selected[s2])) {
            n2 = !!this.$__.selected[s2];
            break;
          }
        }
        if (n2 === null)
          return true;
        if (t4 in this.$__.selected)
          return n2;
        for (var a2 = t4 + ".", u2 = 0, c2 = r3;u2 < c2.length; u2++) {
          var l2 = c2[u2];
          if (l2 !== "_id") {
            if (l2.startsWith(a2))
              return n2 || l2 !== a2;
            if (a2.startsWith(l2 + "."))
              return n2;
          }
        }
        return !n2;
      }, wt.prototype.$__isSelected = wt.prototype.isSelected, wt.prototype.isDirectSelected = function(t4) {
        var e3 = this;
        if (this.$__.selected == null)
          return true;
        if (t4 === "_id")
          return this.$__.selected._id !== 0;
        if (t4.indexOf(" ") !== -1 && (t4 = t4.split(" ")), Array.isArray(t4))
          return t4.some(function(t5) {
            return e3.isDirectSelected(t5);
          });
        var r3 = Object.keys(this.$__.selected), n2 = null;
        if (r3.length === 1 && r3[0] === "_id")
          return this.$__.selected._id === 0;
        for (var o2 = 0, i2 = r3;o2 < i2.length; o2++) {
          var s2 = i2[o2];
          if (s2 !== "_id" && H(this.$__.selected[s2])) {
            n2 = !!this.$__.selected[s2];
            break;
          }
        }
        return n2 === null || (this.$__.selected.hasOwnProperty(t4) ? n2 : !n2);
      }, wt.prototype.validate = function() {
        var t4 = u(i().m(function t(e3, r3) {
          var n2, o2, s2 = this, a2 = arguments;
          return i().w(function(t5) {
            for (;; )
              switch (t5.n) {
                case 0:
                  if (typeof e3 != "function" && typeof r3 != "function" && typeof a2[2] != "function") {
                    t5.n = 1;
                    break;
                  }
                  throw new S("Document.prototype.validate() no longer accepts a callback");
                case 1:
                  if (this.$op = "validate", a2.length === 1 && (d(a2[0]) !== "object" || Array.isArray(a2[0]) || (r3 = a2[0], e3 = null)), r3 && typeof r3.pathsToSkip == "string" && (n2 = r3.pathsToSkip.indexOf(" ") === -1, r3.pathsToSkip = n2 ? [r3.pathsToSkip] : r3.pathsToSkip.split(" ")), o2 = r3 && r3._skipParallelValidateCheck, this.$isSubdocument == null) {
                    t5.n = 2;
                    break;
                  }
                  t5.n = 4;
                  break;
                case 2:
                  if (!this.$__.validating || o2) {
                    t5.n = 3;
                    break;
                  }
                  throw new E(this);
                case 3:
                  o2 || (this.$__.validating = true);
                case 4:
                  return t5.a(2, new Promise(function(t6, n3) {
                    s2.$__validate(e3, r3, function(e4) {
                      if (s2.$op = null, s2.$__.validating = null, e4 != null)
                        return n3(e4);
                      t6();
                    });
                  }));
              }
          }, t, this);
        }));
        return function(e3, r3) {
          return t4.apply(this, arguments);
        };
      }(), wt.prototype.$validate = wt.prototype.validate, wt.prototype.$__validate = function(t4, e3, r3) {
        var n2, i2 = this;
        this.$__.saveOptions && this.$__.saveOptions.pathsToSave && !t4 ? t4 = o(this.$__.saveOptions.pathsToSave) : typeof t4 == "function" ? (r3 = t4, e3 = null, t4 = null) : typeof e3 == "function" && (r3 = e3, e3 = null);
        var s2, a2 = e3 && d(e3) === "object" && "validateModifiedOnly" in e3, u2 = e3 && e3.pathsToSkip || null;
        s2 = a2 ? !!e3.validateModifiedOnly : this.$__schema.options.validateModifiedOnly;
        var c2 = e3 && e3.validateAllPaths;
        if (c2) {
          if (u2)
            throw new TypeError("Cannot set both `validateAllPaths` and `pathsToSkip`");
          if (t4)
            throw new TypeError("Cannot set both `validateAllPaths` and `pathsToValidate`");
          if (a2 && s2)
            throw new TypeError("Cannot set both `validateAllPaths` and `validateModifiedOnly`");
        }
        var f2, h2, y2 = this, b2 = function() {
          var t5 = i2.$__.validationError;
          if (i2.$__.validationError = null, i2.$__.validating = null, s2 && t5 != null) {
            for (var e4 = 0, r4 = Object.keys(t5.errors);e4 < r4.length; e4++) {
              var n3 = r4[e4];
              i2.$isModified(n3) || delete t5.errors[n3];
            }
            Object.keys(t5.errors).length === 0 && (t5 = undefined);
          }
          if (i2.$__.cachedRequired = {}, i2.$emit("validate", y2), i2.constructor.emit("validate", y2), t5) {
            for (var o2 in t5.errors)
              !i2[ct] && t5.errors[o2] instanceof S.CastError && i2.invalidate(o2, t5.errors[o2]);
            return t5;
          }
        };
        if (c2) {
          var m2, v2 = p(f2 = new Set(Object.keys(this.$__schema.paths)));
          try {
            for (v2.s();!(m2 = v2.n()).done; ) {
              var g2 = m2.value, _2 = this.$__schema.path(g2);
              if (_2 && _2.$isMongooseArray) {
                var w2 = this.$__getValue(g2);
                w2 && At(w2, f2, g2);
              }
            }
          } catch (t5) {
            v2.e(t5);
          } finally {
            v2.f();
          }
          f2 = o(f2), h2 = {};
        } else {
          var O2 = Pt(this, t4, u2, e3 && e3._nestedValidate);
          f2 = s2 ? O2[0].filter(function(t5) {
            return i2.$isModified(t5);
          }) : O2[0], h2 = O2[1];
        }
        if (typeof t4 == "string" && (t4 = t4.split(" ")), f2.length === 0)
          return z(function() {
            var t5 = b2();
            if (t5)
              return y2.$__schema.s.hooks.execPost("validate:error", y2, [y2], { error: t5 }, function(t6) {
                r3(t6);
              });
            r3(null, y2);
          });
        var $2 = {}, j2 = 0, P2 = (n2 = this.$__.saveOptions) === null || n2 === undefined ? undefined : n2.pathsToSave;
        if (Array.isArray(P2)) {
          P2 = new Set(P2);
          var A2, E2 = p(f2);
          try {
            for (E2.s();!(A2 = E2.n()).done; ) {
              var x2 = A2.value;
              P2.has(x2) && I2(x2);
            }
          } catch (t5) {
            E2.e(t5);
          } finally {
            E2.f();
          }
        } else {
          var T2, N2 = p(f2);
          try {
            for (N2.s();!(T2 = N2.n()).done; )
              I2(T2.value);
          } catch (t5) {
            N2.e(t5);
          } finally {
            N2.f();
          }
        }
        function I2(t5) {
          t5 == null || $2[t5] || ($2[t5] = true, j2++, z(function() {
            var e4 = y2.$__schema.path(t5);
            if (!e4)
              return --j2 || B2();
            if (y2.$isValid(t5)) {
              if (e4[mt] != null && t5 !== e4.path)
                return --j2 || B2();
              var r4, n3 = y2.$__getValue(t5);
              (r4 = y2.$populated(t5)) ? n3 = r4 : n3 != null && n3.$__ != null && n3.$__.wasPopulated && (n3 = n3._doc._id);
              var o2 = y2.$__.pathsToScopes != null && t5 in y2.$__.pathsToScopes ? y2.$__.pathsToScopes[t5] : y2, i3 = l(l({}, h2[t5]), {}, { path: t5, validateAllPaths: c2, _nestedValidate: true });
              e4.doValidate(n3, function(r5) {
                if (r5) {
                  if ((e4.$isSingleNested || e4.$isArraySubdocument || e4.$isMongooseDocumentArray) && r5 instanceof k)
                    return --j2 || B2();
                  y2.invalidate(t5, r5, undefined, true);
                }
                --j2 || B2();
              }, o2, i3);
            } else
              --j2 || B2();
          }));
        }
        function B2() {
          var t5 = b2();
          if (t5)
            return y2.$__schema.s.hooks.execPost("validate:error", y2, [y2], { error: t5 }, function(t6) {
              r3(t6);
            });
          r3(null, y2);
        }
      }, wt.prototype.validateSync = function(t4, e3) {
        var r3, n2 = this, i2 = this;
        arguments.length !== 1 || d(arguments[0]) !== "object" || Array.isArray(arguments[0]) || (e3 = arguments[0], t4 = null), r3 = e3 && d(e3) === "object" && "validateModifiedOnly" in e3 ? !!e3.validateModifiedOnly : this.$__schema.options.validateModifiedOnly;
        var s2, a2, u2 = e3 && e3.pathsToSkip, c2 = e3 && e3.validateAllPaths;
        if (c2) {
          if (u2)
            throw new TypeError("Cannot set both `validateAllPaths` and `pathsToSkip`");
          if (t4)
            throw new TypeError("Cannot set both `validateAllPaths` and `pathsToValidate`");
        }
        if (typeof t4 == "string") {
          var l2 = t4.indexOf(" ") === -1;
          t4 = l2 ? [t4] : t4.split(" ");
        } else
          typeof u2 == "string" && u2.indexOf(" ") !== -1 && (u2 = u2.split(" "));
        if (c2) {
          var f2, h2 = p(s2 = new Set(Object.keys(this.$__schema.paths)));
          try {
            for (h2.s();!(f2 = h2.n()).done; ) {
              var y2 = f2.value, b2 = this.$__schema.path(y2);
              if (b2 && b2.$isMongooseArray) {
                var m2 = this.$__getValue(y2);
                m2 && At(m2, s2, y2);
              }
            }
          } catch (A3) {
            h2.e(A3);
          } finally {
            h2.f();
          }
          s2 = o(s2), a2 = {};
        } else {
          var v2 = Pt(this, t4, u2);
          s2 = r3 ? v2[0].filter(function(t5) {
            return n2.$isModified(t5);
          }) : v2[0], a2 = v2[1];
        }
        for (var g2 = {}, _2 = 0, w2 = s2.length;_2 < w2; ++_2) {
          var O2 = s2[_2];
          if (!g2[O2]) {
            g2[O2] = true;
            var $2 = i2.$__schema.path(O2);
            if ($2 && i2.$isValid(O2)) {
              var j2 = i2.$__getValue(O2), P2 = $2.doValidateSync(j2, i2, { skipSchemaValidators: a2[O2], path: O2, validateModifiedOnly: r3, validateAllPaths: c2 });
              if (P2) {
                if (($2.$isSingleNested || $2.$isArraySubdocument || $2.$isMongooseDocumentArray) && P2 instanceof k)
                  continue;
                i2.invalidate(O2, P2, undefined, true);
              }
            }
          }
        }
        var A2 = i2.$__.validationError;
        if (i2.$__.validationError = undefined, i2.$emit("validate", i2), i2.constructor.emit("validate", i2), A2)
          for (var E2 in A2.errors)
            A2.errors[E2] instanceof S.CastError && i2.invalidate(E2, A2.errors[E2]);
        return A2;
      }, wt.prototype.invalidate = function(t4, e3, r3, n2) {
        if (this.$__.validationError || (this.$__.validationError = new k(this)), !this.$__.validationError.errors[t4])
          return e3 && typeof e3 != "string" || (e3 = new N({ path: t4, message: e3, type: n2 || "user defined", value: r3 })), this.$__.validationError === e3 || this.$__.validationError.addError(t4, e3), this.$__.validationError;
      }, wt.prototype.$markValid = function(t4) {
        this.$__.validationError && this.$__.validationError.errors[t4] && (delete this.$__.validationError.errors[t4], Object.keys(this.$__.validationError.errors).length === 0 && (this.$__.validationError = null));
      }, wt.prototype.$isValid = function(t4) {
        var e3 = this;
        return this.$__.validationError == null || Object.keys(this.$__.validationError.errors).length === 0 || t4 != null && (t4.indexOf(" ") !== -1 && (t4 = t4.split(" ")), Array.isArray(t4) ? t4.some(function(t5) {
          return e3.$__.validationError.errors[t5] == null;
        }) : this.$__.validationError.errors[t4] == null);
      }, wt.prototype.$__reset = function() {
        var t4, e3 = this.$isSubdocument ? null : this.$getAllSubdocs({ useCache: true });
        if (e3 && e3.length > 0) {
          var r3, n2 = p(e3);
          try {
            for (n2.s();!(r3 = n2.n()).done; )
              r3.value.$__reset();
          } catch (t5) {
            n2.e(t5);
          } finally {
            n2.f();
          }
        }
        return this.$__dirty().forEach(function(t5) {
          var e4 = t5.value;
          e4 && e4[ut] && (e4[at] = e4[ut], e4[ut] = {});
        }), this.$__.backup = {}, this.$__.backup.activePaths = { modify: Object.assign({}, this.$__.activePaths.getStatePaths("modify")), default: Object.assign({}, this.$__.activePaths.getStatePaths("default")) }, this.$__.backup.validationError = this.$__.validationError, this.$__.backup.errors = this.$errors, this.$__.activePaths.clear("modify"), this.$__.activePaths.clear("default"), this.$__.validationError = undefined, this.$errors = undefined, t4 = this, this.$__schema.requiredPaths().forEach(function(e4) {
          t4.$__.activePaths.require(e4);
        }), this;
      }, wt.prototype.$__undoReset = function() {
        if (this.$__.backup != null && this.$__.backup.activePaths != null) {
          this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify, this.$__.activePaths.states.default = this.$__.backup.activePaths.default, this.$__.validationError = this.$__.backup.validationError, this.$errors = this.$__.backup.errors;
          var t4, e3 = p(this.$__dirty());
          try {
            for (e3.s();!(t4 = e3.n()).done; ) {
              var r3 = t4.value.value;
              r3 && r3[ut] && r3[at] && (r3[ut] = r3[at]);
            }
          } catch (t5) {
            e3.e(t5);
          } finally {
            e3.f();
          }
          if (!this.$isSubdocument) {
            var n2, o2 = p(this.$getAllSubdocs());
            try {
              for (o2.s();!(n2 = o2.n()).done; )
                n2.value.$__undoReset();
            } catch (t5) {
              o2.e(t5);
            } finally {
              o2.f();
            }
          }
        }
      }, wt.prototype.$__dirty = function() {
        var t4 = this, e3 = this.$__.activePaths.map("modify", function(e4) {
          return { path: e4, value: t4.$__getValue(e4), schema: t4.$__path(e4) };
        });
        e3 = e3.concat(this.$__.activePaths.map("default", function(e4) {
          if (e4 !== "_id" && t4.$__getValue(e4) != null)
            return { path: e4, value: t4.$__getValue(e4), schema: t4.$__path(e4) };
        }));
        var r3 = new Map(e3.filter(function(t5) {
          return t5 != null;
        }).map(function(t5) {
          return [t5.path, t5.value];
        })), n2 = [];
        return e3.forEach(function(t5) {
          if (t5) {
            for (var e4 = null, o2 = et(t5.path), i2 = 0;i2 < o2.length - 1; i2++)
              if (r3.has(o2[i2])) {
                e4 = r3.get(o2[i2]);
                break;
              }
            e4 == null ? n2.push(t5) : e4 != null && e4[ut] != null && e4.hasAtomics() && (e4[ut] = {}, e4[ut].$set = e4);
          }
        }), n2;
      }, wt.prototype.$__setSchema = function(t4) {
        R(t4.tree, this, undefined, t4.options);
        for (var e3 = 0, r3 = Object.keys(t4.virtuals);e3 < r3.length; e3++) {
          var n2 = r3[e3];
          t4.virtuals[n2]._applyDefaultGetters();
        }
        t4.path("schema") == null && (this.schema = t4), this.$__schema = t4, this[pt] = t4;
      }, wt.prototype.$__getArrayPathsToValidate = function() {
        return b || (b = r2(4878)), this.$__.activePaths.map("init", "modify", function(t4) {
          return this.$__getValue(t4);
        }.bind(this)).filter(function(t4) {
          return t4 && Array.isArray(t4) && nt.isMongooseDocumentArray(t4) && t4.length;
        }).reduce(function(t4, e3) {
          return t4.concat(e3);
        }, []).filter(function(t4) {
          return t4;
        });
      }, wt.prototype.$getAllSubdocs = function(t4) {
        var e3;
        if (t4 != null && t4.useCache && (e3 = this.$__.saveOptions) !== null && e3 !== undefined && e3.__subdocs)
          return this.$__.saveOptions.__subdocs;
        b || (b = r2(4878)), v = v || r2(6547);
        var n2 = [];
        return function t(e4) {
          var r3, o2 = [], i2 = p(e4.$__schema.childSchemas);
          try {
            for (i2.s();!(r3 = i2.n()).done; ) {
              var s2 = r3.value.model, a2 = e4.$__getValue(s2.path);
              if (a2 != null) {
                if (a2.$__ && o2.push(a2), Array.isArray(a2)) {
                  var u2, c2 = p(a2);
                  try {
                    for (c2.s();!(u2 = c2.n()).done; ) {
                      var l2 = u2.value;
                      l2 != null && l2.$__ && o2.push(l2);
                    }
                  } catch (t5) {
                    c2.e(t5);
                  } finally {
                    c2.f();
                  }
                }
                if (a2 instanceof Map) {
                  var f2, h2 = p(a2.values());
                  try {
                    for (h2.s();!(f2 = h2.n()).done; ) {
                      var y2 = f2.value;
                      y2 != null && y2.$__ && o2.push(y2);
                    }
                  } catch (t5) {
                    h2.e(t5);
                  } finally {
                    h2.f();
                  }
                }
              }
            }
          } catch (t5) {
            i2.e(t5);
          } finally {
            i2.f();
          }
          for (var d2 = 0, b2 = o2;d2 < b2.length; d2++)
            t(b2[d2]);
          n2.push.apply(n2, o2);
        }(this), this.$__.saveOptions && (this.$__.saveOptions.__subdocs = n2), n2;
      }, wt.prototype.$__handleReject = function(t4) {
        this.$listeners("error").length ? this.$emit("error", t4) : this.constructor.listeners && this.constructor.listeners("error").length && this.constructor.emit("error", t4);
      }, wt.prototype.$toObject = function(t4, e3) {
        var r3, n2, o2, i2, s2, a2, u2, c2, f2, p2, h2, y2, b2, m2, v2, g2 = this.$__schema._defaultToObjectOptions(e3), _2 = this.$__hasOnlyPrimitiveValues();
        (t4 = nt.isPOJO(t4) ? l({}, t4) : {})._calledWithOptions = t4._calledWithOptions || l({}, t4), v2 = t4._calledWithOptions.minimize != null ? t4.minimize : ((r3 = this.$__schemaTypeOptions) === null || r3 === undefined ? undefined : r3.minimize) != null ? this.$__schemaTypeOptions.minimize : g2 != null && g2.minimize != null ? g2.minimize : this.$__schema.options.minimize, t4.minimize = v2, _2 || (t4._seen = t4._seen || new Map);
        var w2 = (n2 = (o2 = (i2 = t4._calledWithOptions.depopulate) !== null && i2 !== undefined ? i2 : g2 == null ? undefined : g2.depopulate) !== null && o2 !== undefined ? o2 : t4.depopulate) !== null && n2 !== undefined && n2;
        if (w2 && t4._isNested && this.$__.wasPopulated)
          return D(this.$__.wasPopulated.value || this._doc._id, t4);
        if (w2 && (t4.depopulate = true), g2 != null)
          for (var O2 = 0, S2 = Object.keys(g2);O2 < S2.length; O2++) {
            var $2 = S2[O2];
            t4[$2] == null && (t4[$2] = g2[$2]);
          }
        t4._isNested = true, t4.json = e3, t4.minimize = v2;
        var j2 = t4._parentOptions;
        t4._parentOptions = this.$isSubdocument ? t4 : null;
        var P2, A2 = (s2 = (a2 = (u2 = t4._calledWithOptions.schemaFieldsOnly) !== null && u2 !== undefined ? u2 : t4.schemaFieldsOnly) !== null && a2 !== undefined ? a2 : g2.schemaFieldsOnly) !== null && s2 !== undefined && s2;
        if (_2 && !t4.flattenObjectIds)
          P2 = this.$__toObjectShallow(A2);
        else if (A2) {
          P2 = {};
          for (var E2 = 0, x2 = Object.keys(this.$__schema.paths);E2 < x2.length; E2++) {
            var T2 = x2[E2], k2 = this.$__getValue(T2);
            if (k2 !== undefined) {
              var N2 = T2, I2 = P2;
              if (T2.indexOf(".") !== -1) {
                var B2 = T2.split(".");
                N2 = B2[B2.length - 1];
                for (var M2 = 0;M2 < B2.length - 1; ++M2) {
                  var R2;
                  I2[B2[M2]] = (R2 = I2[B2[M2]]) !== null && R2 !== undefined ? R2 : {}, I2 = I2[B2[M2]];
                }
              }
              I2[N2] = k2 !== null ? D(k2, t4) : null;
            }
          }
        } else
          P2 = D(this._doc, t4) || {};
        var U2 = (c2 = (f2 = (p2 = t4._calledWithOptions.getters) !== null && p2 !== undefined ? p2 : t4.getters) !== null && f2 !== undefined ? f2 : g2.getters) !== null && c2 !== undefined && c2;
        U2 && (function(t5, e4) {
          var r4, n3, o3 = t5.$__schema, i3 = Object.keys(o3.paths), s3 = i3.length, a3 = t5._doc;
          if (!a3)
            return e4;
          for (;s3--; ) {
            var u3 = (r4 = i3[s3]).split("."), c3 = u3.length, l2 = c3 - 1, f3 = e4, p3 = undefined;
            if (a3 = t5._doc, t5.$__isSelected(r4))
              for (var h3 = 0;h3 < c3 && (n3 = a3[p3 = u3[h3]], f3 == null || d(f3) === "object"); ++h3) {
                if (h3 === l2) {
                  if (f3[p3] = o3.paths[r4].applyGetters(f3[p3], t5), Array.isArray(f3[p3]) && o3.paths[r4].$embeddedSchemaType)
                    for (var y3 = 0;y3 < f3[p3].length; ++y3)
                      f3[p3][y3] = o3.paths[r4].$embeddedSchemaType.applyGetters(f3[p3][y3], t5);
                } else {
                  if (n3 == null) {
                    p3 in a3 && (f3[p3] = n3);
                    break;
                  }
                  f3 = f3[p3] || (f3[p3] = {});
                }
                a3 = n3;
              }
          }
        }(this, P2), t4.minimize && (P2 = X(P2) || {}));
        var C2 = (h2 = (y2 = (b2 = t4._calledWithOptions.virtuals) !== null && b2 !== undefined ? b2 : g2.virtuals) !== null && y2 !== undefined ? y2 : j2 == null ? undefined : j2.virtuals) !== null && h2 !== undefined ? h2 : undefined;
        (C2 || U2 && C2 !== false) && Et(this, P2, t4, t4), t4.versionKey === false && this.$__schema.options.versionKey && delete P2[this.$__schema.options.versionKey];
        var F2 = (m2 = t4._calledWithOptions.transform) === null || m2 === undefined || m2, L2 = undefined;
        if (F2 === true ? L2 = g2.transform : typeof F2 == "function" && (L2 = F2), F2 && function(t5, e4) {
          var r4 = t5.$__schema, n3 = Object.keys(r4.paths || {});
          if (!t5._doc)
            return e4;
          for (var o3 = 0, i3 = n3;o3 < i3.length; o3++) {
            var s3, a3, u3, c3, l2, f3 = i3[o3], p3 = r4.paths[f3], h3 = (s3 = p3.options.transform) !== null && s3 !== undefined ? s3 : (a3 = p3.constructor) === null || a3 === undefined || (a3 = a3.defaultOptions) === null || a3 === undefined ? undefined : a3.transform, y3 = (u3 = (c3 = p3.$embeddedSchemaType) === null || c3 === undefined || (c3 = c3.options) === null || c3 === undefined ? undefined : c3.transform) !== null && u3 !== undefined ? u3 : (l2 = p3.$embeddedSchemaType) === null || l2 === undefined || (l2 = l2.constructor) === null || l2 === undefined || (l2 = l2.defaultOptions) === null || l2 === undefined ? undefined : l2.transform;
            if (typeof h3 == "function") {
              var d2 = t5.$get(f3);
              if (d2 === undefined)
                continue;
              var b3 = h3.call(t5, d2);
              xt(f3, b3), nt.setValue(f3, b3, e4);
            } else if (typeof y3 == "function") {
              var m3 = t5.$get(f3);
              if (m3 === undefined)
                continue;
              for (var v3 = [].concat(m3), g3 = 0;g3 < v3.length; ++g3) {
                var _3 = y3.call(t5, v3[g3]);
                v3[g3] = _3, xt(f3, _3);
              }
              e4[f3] = v3;
            }
          }
        }(this, P2), t4.useProjection && function(t5, e4) {
          var r4 = t5.$__schema, n3 = Object.keys(r4.paths || {});
          if (!t5._doc)
            return e4;
          var o3 = t5.$__.selected;
          if (o3 === undefined && (o3 = {}, rt.applyPaths(o3, r4)), o3 == null || Object.keys(o3).length === 0)
            return e4;
          for (var i3 = 0, s3 = n3;i3 < s3.length; i3++) {
            var a3 = s3[i3];
            o3[a3] == null || o3[a3] || delete e4[a3];
          }
        }(this, P2), typeof L2 == "function") {
          var V2 = L2(this, P2, t4);
          V2 !== undefined && (P2 = V2);
        }
        return P2;
      }, wt.prototype.$__toObjectShallow = function(t4) {
        var e3 = {};
        if (this._doc != null) {
          var r3, n2 = p(t4 ? Object.keys(this.$__schema.paths) : Object.keys(this._doc));
          try {
            for (n2.s();!(r3 = n2.n()).done; ) {
              var o2 = r3.value, i2 = this._doc[o2];
              i2 instanceof Date ? e3[o2] = new Date(i2) : i2 !== undefined && (e3[o2] = i2);
            }
          } catch (t5) {
            n2.e(t5);
          } finally {
            n2.f();
          }
        }
        return e3;
      }, wt.prototype.toObject = function(t4) {
        return this.$toObject(t4);
      }, wt.prototype.toJSON = function(t4) {
        return this.$toObject(t4, true);
      }, wt.prototype.ownerDocument = function() {
        return this;
      }, wt.prototype.parent = function() {
        return this.$isSubdocument || this.$__.wasPopulated ? this.$__.parent : this;
      }, wt.prototype.$parent = wt.prototype.parent, wt.prototype.inspect = function(t4) {
        var e3;
        nt.isPOJO(t4) && ((e3 = t4).minimize = false);
        var r3 = arguments.length > 0 ? this.toObject(e3) : this.toObject();
        return r3 == null ? "MongooseDocument { " + r3 + " }" : r3;
      }, Q.custom && (wt.prototype[Q.custom] = wt.prototype.inspect), wt.prototype.toString = function() {
        var t4 = this.inspect();
        return typeof t4 == "string" ? t4 : Q(t4);
      }, wt.prototype.equals = function(t4) {
        if (!t4)
          return false;
        var e3 = this.$__getValue("_id"), r3 = t4.$__ != null ? t4.$__getValue("_id") : t4;
        return e3 || r3 ? e3 && e3.equals ? e3.equals(r3) : e3 === r3 : it(this, t4);
      }, wt.prototype.populate = function() {
        var t4 = u(i().m(function t() {
          var e3, r3, n2, o2, s2, a2, u2, c2, l2, f2, h2 = arguments;
          return i().w(function(t5) {
            for (;; )
              switch (t5.n) {
                case 0:
                  if (e3 = {}, typeof (r3 = Array.prototype.slice.call(h2))[r3.length - 1] != "function") {
                    t5.n = 1;
                    break;
                  }
                  throw new S("Document.prototype.populate() no longer accepts a callback");
                case 1:
                  if (r3.length !== 0) {
                    n2 = nt.populate.apply(null, r3), o2 = p(n2);
                    try {
                      for (o2.s();!(s2 = o2.n()).done; )
                        a2 = s2.value, e3[a2.path] = a2;
                    } catch (t6) {
                      o2.e(t6);
                    } finally {
                      o2.f();
                    }
                  }
                  return u2 = nt.object.vals(e3), c2 = this.constructor, this.$__isNested && (c2 = this.$__[bt].constructor, l2 = this.$__.nestedPath, u2.forEach(function(t6) {
                    t6.path = l2 + "." + t6.path;
                  })), this.$session() != null && (f2 = this.$session(), u2.forEach(function(t6) {
                    t6.options != null ? "session" in t6.options || (t6.options.session = f2) : t6.options = { session: f2 };
                  })), u2.forEach(function(t6) {
                    t6._localModel = c2;
                  }), t5.a(2, c2.populate(this, u2));
              }
          }, t, this);
        }));
        return function() {
          return t4.apply(this, arguments);
        };
      }(), wt.prototype.$getPopulatedDocs = function() {
        var t4 = [];
        this.$__.populated != null && (t4 = t4.concat(Object.keys(this.$__.populated)));
        var e3, r3 = [], n2 = p(t4);
        try {
          for (n2.s();!(e3 = n2.n()).done; ) {
            var o2 = e3.value, i2 = this.$get(o2);
            Array.isArray(i2) ? r3 = r3.concat(i2) : i2 instanceof wt && r3.push(i2);
          }
        } catch (t5) {
          n2.e(t5);
        } finally {
          n2.f();
        }
        return r3;
      }, wt.prototype.populated = function(t4, e3, r3) {
        if (e3 == null || e3 === true) {
          if (!this.$__.populated)
            return;
          if (typeof t4 != "string")
            return;
          var n2 = t4.endsWith(".$*") ? t4.replace(/\.\$\*$/, "") : t4, o2 = this.$__.populated[n2];
          return o2 ? e3 === true ? o2 : o2.value : undefined;
        }
        this.$__.populated || (this.$__.populated = {}), this.$__.populated[t4] = { value: e3, options: r3 };
        for (var i2 = t4.split("."), s2 = 0;s2 < i2.length - 1; ++s2) {
          var a2 = i2.slice(0, s2 + 1).join("."), u2 = this.$get(a2);
          if (u2 != null && u2.$__ != null && this.$populated(a2)) {
            var c2 = i2.slice(s2 + 1).join(".");
            u2.$populated(c2, e3, r3);
            break;
          }
        }
        return e3;
      }, wt.prototype.$populated = wt.prototype.populated, wt.prototype.$assertPopulated = function(t4, e3) {
        var r3 = this;
        if (Array.isArray(t4))
          return t4.forEach(function(t5) {
            return r3.$assertPopulated(t5, e3);
          }), this;
        if (arguments.length > 1 && this.$set(e3), !this.$populated(t4))
          throw new S('Expected path "'.concat(t4, '" to be populated'));
        return this;
      }, wt.prototype.depopulate = function(t4) {
        var e3;
        typeof t4 == "string" && (t4 = t4.indexOf(" ") === -1 ? [t4] : t4.split(" "));
        var r3 = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [], n2 = this.$__ && this.$__.populated || {};
        if (arguments.length === 0) {
          var o2, i2 = p(r3);
          try {
            for (i2.s();!(o2 = i2.n()).done; ) {
              var s2 = o2.value;
              delete this.$$populatedVirtuals[s2], delete this._doc[s2], delete n2[s2];
            }
          } catch (t5) {
            i2.e(t5);
          } finally {
            i2.f();
          }
          for (var a2 = 0, u2 = Object.keys(n2);a2 < u2.length; a2++) {
            var c2 = u2[a2];
            if (e3 = this.$populated(c2))
              if (delete n2[c2], Array.isArray(e3)) {
                var l2 = nt.getValue(c2, this._doc);
                if (l2.isMongooseArray)
                  for (var f2 = l2.__array, h2 = 0;h2 < f2.length; ++h2) {
                    var y2 = f2[h2];
                    y2 != null && (f2[h2] = y2 instanceof wt ? y2._doc._id : y2._id);
                  }
                else
                  nt.setValue(c2, e3, this._doc);
              } else
                nt.setValue(c2, e3, this._doc);
          }
          return this;
        }
        var d2, b2 = p(t4);
        try {
          for (b2.s();!(d2 = b2.n()).done; ) {
            var m2 = d2.value;
            if (e3 = this.$populated(m2), delete n2[m2], r3.indexOf(m2) !== -1)
              delete this.$$populatedVirtuals[m2], delete this._doc[m2];
            else if (e3)
              if (Array.isArray(e3)) {
                var v2 = nt.getValue(m2, this._doc);
                if (v2.isMongooseArray)
                  for (var g2 = v2.__array, _2 = 0;_2 < g2.length; ++_2) {
                    var w2 = g2[_2];
                    w2 != null && (g2[_2] = w2 instanceof wt ? w2._doc._id : w2._id);
                  }
                else
                  nt.setValue(m2, e3, this._doc);
              } else
                nt.setValue(m2, e3, this._doc);
          }
        } catch (t5) {
          b2.e(t5);
        } finally {
          b2.f();
        }
        return this;
      }, wt.prototype.$__fullPath = function(t4) {
        return t4 || "";
      }, wt.prototype.getChanges = function() {
        var t4 = this.$__delta();
        return t4 ? t4[1] : {};
      }, wt.prototype.$__delta = function() {
        var t4 = this, e3 = this.$__dirty(), r3 = this.$__schema.options.optimisticConcurrency;
        if (r3)
          if (Array.isArray(r3)) {
            var o2 = new Set(r3);
            this.modifiedPaths().find(function(t5) {
              return o2.has(t5);
            }) && (this.$__.version = e3.length ? 3 : 1);
          } else
            this.$__.version = e3.length ? 3 : 1;
        if (e3.length || this.$__.version === 3) {
          var i2 = {}, s2 = {}, a2 = e3.length, u2 = [], c2 = 0;
          for (i2._id = this._doc._id, (i2 && i2._id && i2._id.$__ || null) != null && (i2._id = i2._id.toObject({ transform: false, depopulate: true }));c2 < a2; ++c2) {
            var l2 = e3[c2], f2 = l2.value, p2 = Tt(this, l2.path, f2);
            if (p2)
              u2.push(p2);
            else {
              if (!this.$populated(l2.path, true) && this.$__.selected) {
                var h2 = l2.path.split("."), y2 = h2[0];
                if (this.$__.selected[y2] && this.$__.selected[y2].$elemMatch) {
                  if (!(h2.length > 1 && h2[1] == 0 && i2[y2] === undefined)) {
                    u2.push(l2.path);
                    continue;
                  }
                  i2[y2] = this.$__.selected[y2], h2[1] = "$", l2.path = h2.join(".");
                }
              }
              if (this.$isDefault(l2.path) && this.$__.selected) {
                if (l2.path.indexOf(".") === -1 && G(this.$__.selected, l2.path))
                  continue;
                if (et(l2.path).find(function(e4) {
                  return G(t4.$__.isSelected, e4);
                }))
                  continue;
              }
              if (!u2.length)
                if (f2 === undefined)
                  kt(this, 0, s2, l2, 1, "$unset");
                else if (f2 === null)
                  kt(this, 0, s2, l2, null);
                else if (nt.isMongooseArray(f2) && f2.$path() && f2[ut])
                  Nt(this, 0, s2, l2, f2);
                else if (f2[O.pathSymbol] && n.isBuffer(f2))
                  kt(this, 0, s2, l2, f2 = f2.toObject());
                else if (this.$__.primitiveAtomics && this.$__.primitiveAtomics[l2.path] != null) {
                  var d2 = this.$__.primitiveAtomics[l2.path], b2 = C(d2);
                  kt(this, 0, s2, l2, d2[b2], b2);
                } else
                  kt(this, 0, s2, l2, f2 = D(f2, { depopulate: true, transform: false, virtuals: false, getters: false, omitUndefined: true, _isNested: true }));
            }
          }
          return u2.length ? new g(u2) : (this.$__.version && this.$__version(i2, s2), Object.keys(s2).length === 0 ? [i2, null] : [i2, s2]);
        }
      }, wt.prototype.$clone = function() {
        var t4 = new (0, this.constructor);
        if (t4.$isNew = this.$isNew, this._doc && (t4._doc = D(this._doc, { retainDocuments: true })), this.$__) {
          var e3, r3 = new (0, this.$__.constructor), n2 = p(Object.getOwnPropertyNames(this.$__));
          try {
            for (n2.s();!(e3 = n2.n()).done; ) {
              var o2 = e3.value;
              o2 !== "activePaths" && (r3[o2] = D(this.$__[o2]));
            }
          } catch (t5) {
            n2.e(t5);
          } finally {
            n2.f();
          }
          Object.assign(r3.activePaths, D(l({}, this.$__.activePaths))), t4.$__ = r3;
        }
        return t4;
      }, wt.prototype.$createModifiedPathsSnapshot = function() {
        var t4 = new WeakMap;
        if (!this.$isSubdocument) {
          var e3, r3 = p(this.$getAllSubdocs());
          try {
            for (r3.s();!(e3 = r3.n()).done; ) {
              var n2 = e3.value;
              t4.set(n2, n2.$__.activePaths.clone());
            }
          } catch (t5) {
            r3.e(t5);
          } finally {
            r3.f();
          }
        }
        return new j(t4, this.$__.activePaths.clone(), this.$__.version);
      }, wt.prototype.$restoreModifiedPathsSnapshot = function(t4) {
        if (this.$__.activePaths = t4.activePaths.clone(), this.$__.version = t4.version, !this.$isSubdocument) {
          var e3, r3 = p(this.$getAllSubdocs());
          try {
            for (r3.s();!(e3 = r3.n()).done; ) {
              var n2 = e3.value;
              t4.subdocSnapshot.has(n2) && (n2.$__.activePaths = t4.subdocSnapshot.get(n2));
            }
          } catch (t5) {
            r3.e(t5);
          } finally {
            r3.f();
          }
        }
        return this;
      }, wt.prototype.$clearModifiedPaths = function() {
        if (this.$__.activePaths.clear("modify"), this.$__.activePaths.clear("init"), this.$__.version = 0, !this.$isSubdocument) {
          var t4, e3 = p(this.$getAllSubdocs());
          try {
            for (e3.s();!(t4 = e3.n()).done; )
              t4.value.$clearModifiedPaths();
          } catch (t5) {
            e3.e(t5);
          } finally {
            e3.f();
          }
        }
        return this;
      }, wt.prototype.$__hasOnlyPrimitiveValues = function() {
        return !this.$__.populated && !this.$__.wasPopulated && (this._doc == null || Object.values(this._doc).every(function(t4) {
          return t4 == null || d(t4) !== "object" || nt.isNativeObject(t4) && !Array.isArray(t4) || K(t4, "ObjectId") || K(t4, "Decimal128");
        }));
      }, wt.VERSION_WHERE = 1, wt.VERSION_INC = 2, wt.VERSION_ALL = 3, wt.ValidationError = k, t3.exports = wt;
    }, 2401: (t3) => {
      t3.exports = Math.floor;
    }, 2402: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o(t4) {
        return o = typeof Symbol == "function" && n(Symbol.iterator) === "symbol" ? function(t5) {
          return n(t5);
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : n(t5);
        }, o(t4);
      }
      var i, s, a = r2(3743).codes, u = a.ERR_AMBIGUOUS_ARGUMENT, c = a.ERR_INVALID_ARG_TYPE, l = a.ERR_INVALID_ARG_VALUE, f = a.ERR_INVALID_RETURN_VALUE, p = a.ERR_MISSING_ARGS, h = r2(9068), y = r2(7352).inspect, d = r2(7352).types, b = d.isPromise, m = d.isRegExp, v = Object.assign ? Object.assign : r2(6182).assign, g = Object.is ? Object.is : r2(2064);
      function _() {
        var t4 = r2(6193);
        i = t4.isDeepEqual, s = t4.isDeepStrictEqual;
      }
      new Map;
      var w = false, O = t3.exports = P, S = {};
      function $(t4) {
        if (t4.message instanceof Error)
          throw t4.message;
        throw new h(t4);
      }
      function j(t4, e3, r3, n2) {
        if (!r3) {
          var o2 = false;
          if (e3 === 0)
            o2 = true, n2 = "No value argument passed to `assert.ok()`";
          else if (n2 instanceof Error)
            throw n2;
          var i2 = new h({ actual: r3, expected: true, message: n2, operator: "==", stackStartFn: t4 });
          throw i2.generatedMessage = o2, i2;
        }
      }
      function P() {
        for (var t4 = arguments.length, e3 = new Array(t4), r3 = 0;r3 < t4; r3++)
          e3[r3] = arguments[r3];
        j.apply(undefined, [P, e3.length].concat(e3));
      }
      O.fail = function t(e3, r3, n2, o2, i2) {
        var s2, a2 = arguments.length;
        if (a2 === 0 ? s2 = "Failed" : a2 === 1 ? (n2 = e3, e3 = undefined) : (w === false && (w = true, ({ env: {} }.emitWarning ? { env: {} }.emitWarning : console.warn.bind(console))("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094")), a2 === 2 && (o2 = "!=")), n2 instanceof Error)
          throw n2;
        var u2 = { actual: e3, expected: r3, operator: o2 === undefined ? "fail" : o2, stackStartFn: i2 || t };
        n2 !== undefined && (u2.message = n2);
        var c2 = new h(u2);
        throw s2 && (c2.message = s2, c2.generatedMessage = true), c2;
      }, O.AssertionError = h, O.ok = P, O.equal = function t(e3, r3, n2) {
        if (arguments.length < 2)
          throw new p("actual", "expected");
        e3 != r3 && $({ actual: e3, expected: r3, message: n2, operator: "==", stackStartFn: t });
      }, O.notEqual = function t(e3, r3, n2) {
        if (arguments.length < 2)
          throw new p("actual", "expected");
        e3 == r3 && $({ actual: e3, expected: r3, message: n2, operator: "!=", stackStartFn: t });
      }, O.deepEqual = function t(e3, r3, n2) {
        if (arguments.length < 2)
          throw new p("actual", "expected");
        i === undefined && _(), i(e3, r3) || $({ actual: e3, expected: r3, message: n2, operator: "deepEqual", stackStartFn: t });
      }, O.notDeepEqual = function t(e3, r3, n2) {
        if (arguments.length < 2)
          throw new p("actual", "expected");
        i === undefined && _(), i(e3, r3) && $({ actual: e3, expected: r3, message: n2, operator: "notDeepEqual", stackStartFn: t });
      }, O.deepStrictEqual = function t(e3, r3, n2) {
        if (arguments.length < 2)
          throw new p("actual", "expected");
        i === undefined && _(), s(e3, r3) || $({ actual: e3, expected: r3, message: n2, operator: "deepStrictEqual", stackStartFn: t });
      }, O.notDeepStrictEqual = function t(e3, r3, n2) {
        if (arguments.length < 2)
          throw new p("actual", "expected");
        i === undefined && _(), s(e3, r3) && $({ actual: e3, expected: r3, message: n2, operator: "notDeepStrictEqual", stackStartFn: t });
      }, O.strictEqual = function t(e3, r3, n2) {
        if (arguments.length < 2)
          throw new p("actual", "expected");
        g(e3, r3) || $({ actual: e3, expected: r3, message: n2, operator: "strictEqual", stackStartFn: t });
      }, O.notStrictEqual = function t(e3, r3, n2) {
        if (arguments.length < 2)
          throw new p("actual", "expected");
        g(e3, r3) && $({ actual: e3, expected: r3, message: n2, operator: "notStrictEqual", stackStartFn: t });
      };
      var A = function t(e3, r3, n2) {
        var o2 = this;
        (function(t4, e4) {
          if (!(t4 instanceof e4))
            throw new TypeError("Cannot call a class as a function");
        })(this, t), r3.forEach(function(t4) {
          t4 in e3 && (n2 !== undefined && typeof n2[t4] == "string" && m(e3[t4]) && e3[t4].test(n2[t4]) ? o2[t4] = n2[t4] : o2[t4] = e3[t4]);
        });
      };
      function E(t4, e3, r3, n2) {
        if (typeof e3 != "function") {
          if (m(e3))
            return e3.test(t4);
          if (arguments.length === 2)
            throw new c("expected", ["Function", "RegExp"], e3);
          if (o(t4) !== "object" || t4 === null) {
            var a2 = new h({ actual: t4, expected: e3, message: r3, operator: "deepStrictEqual", stackStartFn: n2 });
            throw a2.operator = n2.name, a2;
          }
          var u2 = Object.keys(e3);
          if (e3 instanceof Error)
            u2.push("name", "message");
          else if (u2.length === 0)
            throw new l("error", e3, "may not be an empty object");
          return i === undefined && _(), u2.forEach(function(o2) {
            typeof t4[o2] == "string" && m(e3[o2]) && e3[o2].test(t4[o2]) || function(t5, e4, r4, n3, o3, i2) {
              if (!(r4 in t5) || !s(t5[r4], e4[r4])) {
                if (!n3) {
                  var a3 = new A(t5, o3), u3 = new A(e4, o3, t5), c2 = new h({ actual: a3, expected: u3, operator: "deepStrictEqual", stackStartFn: i2 });
                  throw c2.actual = t5, c2.expected = e4, c2.operator = i2.name, c2;
                }
                $({ actual: t5, expected: e4, message: n3, operator: i2.name, stackStartFn: i2 });
              }
            }(t4, e3, o2, r3, u2, n2);
          }), true;
        }
        return e3.prototype !== undefined && t4 instanceof e3 || !Error.isPrototypeOf(e3) && e3.call({}, t4) === true;
      }
      function x(t4) {
        if (typeof t4 != "function")
          throw new c("fn", "Function", t4);
        try {
          t4();
        } catch (t5) {
          return t5;
        }
        return S;
      }
      function T(t4) {
        return b(t4) || t4 !== null && o(t4) === "object" && typeof t4.then == "function" && typeof t4.catch == "function";
      }
      function k(t4) {
        return Promise.resolve().then(function() {
          var e3;
          if (typeof t4 == "function") {
            if (!T(e3 = t4()))
              throw new f("instance of Promise", "promiseFn", e3);
          } else {
            if (!T(t4))
              throw new c("promiseFn", ["Function", "Promise"], t4);
            e3 = t4;
          }
          return Promise.resolve().then(function() {
            return e3;
          }).then(function() {
            return S;
          }).catch(function(t5) {
            return t5;
          });
        });
      }
      function N(t4, e3, r3, n2) {
        if (typeof r3 == "string") {
          if (arguments.length === 4)
            throw new c("error", ["Object", "Error", "Function", "RegExp"], r3);
          if (o(e3) === "object" && e3 !== null) {
            if (e3.message === r3)
              throw new u("error/message", 'The error message "'.concat(e3.message, '" is identical to the message.'));
          } else if (e3 === r3)
            throw new u("error/message", 'The error "'.concat(e3, '" is identical to the message.'));
          n2 = r3, r3 = undefined;
        } else if (r3 != null && o(r3) !== "object" && typeof r3 != "function")
          throw new c("error", ["Object", "Error", "Function", "RegExp"], r3);
        if (e3 === S) {
          var i2 = "";
          r3 && r3.name && (i2 += " (".concat(r3.name, ")")), i2 += n2 ? ": ".concat(n2) : ".";
          var s2 = t4.name === "rejects" ? "rejection" : "exception";
          $({ actual: undefined, expected: r3, operator: t4.name, message: "Missing expected ".concat(s2).concat(i2), stackStartFn: t4 });
        }
        if (r3 && !E(e3, r3, n2, t4))
          throw e3;
      }
      function I(t4, e3, r3, n2) {
        if (e3 !== S) {
          if (typeof r3 == "string" && (n2 = r3, r3 = undefined), !r3 || E(e3, r3)) {
            var o2 = n2 ? ": ".concat(n2) : ".", i2 = t4.name === "doesNotReject" ? "rejection" : "exception";
            $({ actual: e3, expected: r3, operator: t4.name, message: "Got unwanted ".concat(i2).concat(o2, `
`) + 'Actual message: "'.concat(e3 && e3.message, '"'), stackStartFn: t4 });
          }
          throw e3;
        }
      }
      function B() {
        for (var t4 = arguments.length, e3 = new Array(t4), r3 = 0;r3 < t4; r3++)
          e3[r3] = arguments[r3];
        j.apply(undefined, [B, e3.length].concat(e3));
      }
      O.throws = function t(e3) {
        for (var r3 = arguments.length, n2 = new Array(r3 > 1 ? r3 - 1 : 0), o2 = 1;o2 < r3; o2++)
          n2[o2 - 1] = arguments[o2];
        N.apply(undefined, [t, x(e3)].concat(n2));
      }, O.rejects = function t(e3) {
        for (var r3 = arguments.length, n2 = new Array(r3 > 1 ? r3 - 1 : 0), o2 = 1;o2 < r3; o2++)
          n2[o2 - 1] = arguments[o2];
        return k(e3).then(function(e4) {
          return N.apply(undefined, [t, e4].concat(n2));
        });
      }, O.doesNotThrow = function t(e3) {
        for (var r3 = arguments.length, n2 = new Array(r3 > 1 ? r3 - 1 : 0), o2 = 1;o2 < r3; o2++)
          n2[o2 - 1] = arguments[o2];
        I.apply(undefined, [t, x(e3)].concat(n2));
      }, O.doesNotReject = function t(e3) {
        for (var r3 = arguments.length, n2 = new Array(r3 > 1 ? r3 - 1 : 0), o2 = 1;o2 < r3; o2++)
          n2[o2 - 1] = arguments[o2];
        return k(e3).then(function(e4) {
          return I.apply(undefined, [t, e4].concat(n2));
        });
      }, O.ifError = function t(e3) {
        if (e3 != null) {
          var r3 = "ifError got unwanted exception: ";
          o(e3) === "object" && typeof e3.message == "string" ? e3.message.length === 0 && e3.constructor ? r3 += e3.constructor.name : r3 += e3.message : r3 += y(e3);
          var n2 = new h({ actual: e3, expected: null, operator: "ifError", message: r3, stackStartFn: t }), i2 = e3.stack;
          if (typeof i2 == "string") {
            var s2 = i2.split(`
`);
            s2.shift();
            for (var a2 = n2.stack.split(`
`), u2 = 0;u2 < s2.length; u2++) {
              var c2 = a2.indexOf(s2[u2]);
              if (c2 !== -1) {
                a2 = a2.slice(0, c2);
                break;
              }
            }
            n2.stack = "".concat(a2.join(`
`), `
`).concat(s2.join(`
`));
          }
          throw n2;
        }
      }, O.strict = v(B, O, { equal: O.strictEqual, deepEqual: O.deepStrictEqual, notEqual: O.notStrictEqual, notDeepEqual: O.notDeepStrictEqual }), O.strict.strict = O.strict;
    }, 2403: (t3) => {
      t3.exports = typeof Reflect != "undefined" && Reflect.getPrototypeOf || null;
    }, 2423: (t3) => {
      t3.exports = function(t4, e2) {
        var r2 = t4.discriminatorMapping && t4.discriminatorMapping.value;
        if (r2 && !("sparse" in e2)) {
          var n = t4.options.discriminatorKey;
          e2.partialFilterExpression = e2.partialFilterExpression || {}, e2.partialFilterExpression[n] = r2;
        }
        return e2;
      };
    }, 2477: (t3, e2, r2) => {
      var n = r2(2402);
      t3.exports = function(t4) {
        return t4 == null || t4 === "" ? null : t4 instanceof Date ? (n.ok(!isNaN(t4.valueOf())), t4) : (n.ok(typeof t4 != "boolean"), e3 = t4 instanceof Number || typeof t4 == "number" ? new Date(t4) : typeof t4 == "string" && !isNaN(Number(t4)) && (Number(t4) >= 275761 || Number(t4) < -271820) ? new Date(Number(t4)) : typeof t4.valueOf == "function" ? new Date(t4.valueOf()) : new Date(t4), isNaN(e3.valueOf()) ? void n.ok(false) : e3);
        var e3;
      };
    }, 2481: (t3, e2, r2) => {
      var n = r2(4756);
      t3.exports = function() {
        return typeof Object.is == "function" ? Object.is : n;
      };
    }, 2486: (t3, e2) => {
      e2.read = function(t4, e3, r2, n, o) {
        var i, s, a = 8 * o - n - 1, u = (1 << a) - 1, c = u >> 1, l = -7, f = r2 ? o - 1 : 0, p = r2 ? -1 : 1, h = t4[e3 + f];
        for (f += p, i = h & (1 << -l) - 1, h >>= -l, l += a;l > 0; i = 256 * i + t4[e3 + f], f += p, l -= 8)
          ;
        for (s = i & (1 << -l) - 1, i >>= -l, l += n;l > 0; s = 256 * s + t4[e3 + f], f += p, l -= 8)
          ;
        if (i === 0)
          i = 1 - c;
        else {
          if (i === u)
            return s ? NaN : 1 / 0 * (h ? -1 : 1);
          s += Math.pow(2, n), i -= c;
        }
        return (h ? -1 : 1) * s * Math.pow(2, i - n);
      }, e2.write = function(t4, e3, r2, n, o, i) {
        var s, a, u, c = 8 * i - o - 1, l = (1 << c) - 1, f = l >> 1, p = o === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, h = n ? 0 : i - 1, y = n ? 1 : -1, d = e3 < 0 || e3 === 0 && 1 / e3 < 0 ? 1 : 0;
        for (e3 = Math.abs(e3), isNaN(e3) || e3 === 1 / 0 ? (a = isNaN(e3) ? 1 : 0, s = l) : (s = Math.floor(Math.log(e3) / Math.LN2), e3 * (u = Math.pow(2, -s)) < 1 && (s--, u *= 2), (e3 += s + f >= 1 ? p / u : p * Math.pow(2, 1 - f)) * u >= 2 && (s++, u /= 2), s + f >= l ? (a = 0, s = l) : s + f >= 1 ? (a = (e3 * u - 1) * Math.pow(2, o), s += f) : (a = e3 * Math.pow(2, f - 1) * Math.pow(2, o), s = 0));o >= 8; t4[r2 + h] = 255 & a, h += y, a /= 256, o -= 8)
          ;
        for (s = s << o | a, c += o;c > 0; t4[r2 + h] = 255 & s, h += y, s /= 256, c -= 8)
          ;
        t4[r2 + h - y] |= 128 * d;
      };
    }, 2497: (t3, e2, r2) => {
      var n = r2(1243).isMongooseArray;
      t3.exports = function(t4) {
        return t4 != null && (n(t4) || t4.$__ != null || t4.isMongooseBuffer || t4.$isMongooseMap);
      };
    }, 2555: (t3) => {
      t3.exports = function(t4) {
        if (Array.isArray(t4)) {
          if (!t4.every(function(t5) {
            return typeof t5 == "number" || typeof t5 == "string";
          }))
            throw new Error("$type array values must be strings or numbers");
          return t4;
        }
        if (typeof t4 != "number" && typeof t4 != "string")
          throw new Error("$type parameter must be number, string, or array of numbers and strings");
        return t4;
      };
    }, 2580: (t3, e2, r2) => {
      var n = r2(2400), o = r2(3550).EventEmitter, i = r2(3672), s = r2(7058), a = r2(5549), u = i.ValidationError, c = r2(4957), l = r2(608);
      function f(t4, e3, r3, o2, u2) {
        if (!(this instanceof f))
          return new f(t4, e3, r3, o2, u2);
        if (l(e3) && !e3.instanceOfSchema && (e3 = new s(e3)), e3 = this.schema || e3, !this.schema && e3.options._id && (t4 = t4 || {})._id === undefined && (t4._id = new a), !e3)
          throw new i.MissingSchemaError;
        for (var p in this.$__setSchema(e3), n.call(this, t4, r3, o2, u2), c(this, e3, { decorateDoc: true }), e3.methods)
          this[p] = e3.methods[p];
        for (var h in e3.statics)
          this[h] = e3.statics[h];
      }
      f.prototype = Object.create(n.prototype), f.prototype.constructor = f, f.events = new o, f.$emitter = new o, ["on", "once", "emit", "listeners", "removeListener", "setMaxListeners", "removeAllListeners", "addListener"].forEach(function(t4) {
        f[t4] = function() {
          return f.$emitter[t4].apply(f.$emitter, arguments);
        };
      }), f.ValidationError = u, t3.exports = f;
    }, 2653: (t3) => {
      t3.exports = ["Float16Array", "Float32Array", "Float64Array", "Int8Array", "Int16Array", "Int32Array", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "BigInt64Array", "BigUint64Array"];
    }, 2692: (t3) => {
      t3.exports = function(t4, e2) {
        if (e2.length !== 1) {
          for (var r2 = e2[0], n = undefined, o = 0;o < e2.length - 1; ++o) {
            var i = t4.path(r2);
            i && i.schema ? (n = i.schema.options.strict, t4 = i.schema, r2 = i.$isMongooseDocumentArray && !isNaN(e2[o + 1]) ? "" : e2[o + 1]) : r2 += r2.length ? "." + e2[o + 1] : e2[o + 1];
          }
          return n;
        }
      };
    }, 2696: (t3, e2, r2) => {
      var n = r2(3305);
      t3.exports = function(t4, e3) {
        return typeof t4 == "string" && typeof e3 == "string" || typeof t4 == "number" && typeof e3 == "number" ? t4 === e3 : !(!n(t4, "ObjectId") || !n(e3, "ObjectId")) && t4.toString() === e3.toString();
      };
    }, 2724: (t3, e2, r2) => {
      var n = r2(3071), o = r2(9344), i = n("RegExp.prototype.exec"), s = r2(2268);
      t3.exports = function(t4) {
        if (!o(t4))
          throw new s("`regex` must be a RegExp");
        return function(e3) {
          return i(t4, e3) !== null;
        };
      };
    }, 2746: (t3) => {
      var e2 = typeof { env: {} }.nextTick == "function" ? { env: {} }.nextTick.bind({ env: {} }) : function(t4) {
        return setTimeout(t4, 0);
      };
      t3.exports = function(t4) {
        return e2(t4);
      };
    }, 2789: (t3) => {
      function e2(t4) {
        return e2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      t3.exports = function(t4) {
        if (t4 == null || e2(t4) !== "object")
          return false;
        var r2 = Object.getPrototypeOf(t4);
        return !r2 || r2.constructor.name === "Object";
      };
    }, 2793: (t3) => {
      t3.exports = new Set(["__proto__", "constructor", "prototype"]);
    }, 2822: (t3, e2, r2) => {
      t3.exports = r2(6353).Double;
    }, 2824: (t3, e2, r2) => {
      var n = r2(7930).objectIdSymbol, o = r2(8768);
      function i() {
        var t4, e3;
        if (this.$__.shardval) {
          e3 = (t4 = Object.keys(this.$__.shardval)).length, this.$where = this.$where || {};
          for (var r3 = 0;r3 < e3; ++r3)
            this.$where[t4[r3]] = this.$__.shardval[t4[r3]];
        }
      }
      function s() {
        var t4 = this.$__schema.options.shardKey || this.$__schema.options.shardkey;
        if (o.isPOJO(t4))
          for (var e3, r3 = this.$__.shardval = {}, i2 = Object.keys(t4), s2 = i2.length, a = 0;a < s2; ++a)
            (e3 = this.$__getValue(i2[a])) == null ? r3[i2[a]] = e3 : o.isMongooseObject(e3) ? r3[i2[a]] = e3.toObject({ depopulate: true, _isNested: true }) : e3 instanceof Date || e3[n] ? r3[i2[a]] = e3 : typeof e3.valueOf == "function" ? r3[i2[a]] = e3.valueOf() : r3[i2[a]] = e3;
      }
      t3.exports = function(t4) {
        t4.post("init", function() {
          return s.call(this), this;
        }), t4.pre("save", function(t5) {
          i.call(this), t5();
        }), t4.pre("remove", function(t5) {
          i.call(this), t5();
        }), t4.post("save", function() {
          s.call(this);
        });
      }, t3.exports.storeShard = s;
    }, 2900: (t3, e2, r2) => {
      var n = r2(8260);
      t3.exports = function(t4) {
        if (n(t4) !== "TopologyDescription")
          return false;
        var e3 = Array.from(t4.servers.values());
        return e3.length > 0 && e3.every(function(t5) {
          return t5.type === "Unknown";
        });
      };
    }, 2914: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var o = r2(7860), i = ["__proto__", "constructor", "prototype"];
      function s(t4, e3, r3, n2, o2, i2) {
        for (var a2, u = 0;u < t4.length && u < e3.length; ++u)
          a2 = t4[u], Array.isArray(a2) && Array.isArray(e3[u]) ? s(a2, e3[u], r3, n2, o2, i2) : a2 && (n2 ? n2(a2, r3, i2(e3[u])) : (a2[o2] && (a2 = a2[o2]), a2[r3] = i2(e3[u])));
      }
      function a(t4) {
        return t4;
      }
      e2.get = function(t4, r3, i2, s2) {
        var u;
        typeof i2 == "function" && (i2.length < 2 ? (s2 = i2, i2 = undefined) : (u = i2, i2 = undefined)), s2 || (s2 = a);
        var c = typeof t4 == "string" ? o(t4) : t4;
        if (!Array.isArray(c))
          throw new TypeError("Invalid `path`. Must be either string or array");
        for (var l, f = r3, p = 0;p < c.length; ++p) {
          if (l = c[p], typeof c[p] != "string" && typeof c[p] != "number")
            throw new TypeError("Each segment of path to `get()` must be a string or number, got " + n(c[p]));
          if (Array.isArray(f) && !/^\d+$/.test(l)) {
            var h = c.slice(p);
            return [].concat(f).map(function(t5) {
              return t5 ? e2.get(h, t5, i2 || u, s2) : s2(undefined);
            });
          }
          if (u)
            f = u(f, l);
          else {
            var y = i2 && f[i2] ? f[i2] : f;
            f = y instanceof Map ? y.get(l) : y[l];
          }
          if (!f)
            return s2(f);
        }
        return s2(f);
      }, e2.has = function(t4, e3) {
        var r3 = typeof t4 == "string" ? o(t4) : t4;
        if (!Array.isArray(r3))
          throw new TypeError("Invalid `path`. Must be either string or array");
        for (var i2 = r3.length, s2 = e3, a2 = 0;a2 < i2; ++a2) {
          if (typeof r3[a2] != "string" && typeof r3[a2] != "number")
            throw new TypeError("Each segment of path to `has()` must be a string or number, got " + n(r3[a2]));
          if (s2 == null || n(s2) !== "object" || !(r3[a2] in s2))
            return false;
          s2 = s2[r3[a2]];
        }
        return true;
      }, e2.unset = function(t4, e3) {
        var r3 = typeof t4 == "string" ? o(t4) : t4;
        if (!Array.isArray(r3))
          throw new TypeError("Invalid `path`. Must be either string or array");
        for (var s2 = r3.length, a2 = e3, u = 0;u < s2; ++u) {
          if (a2 == null || n(a2) !== "object" || !(r3[u] in a2))
            return false;
          if (typeof r3[u] != "string" && typeof r3[u] != "number")
            throw new TypeError("Each segment of path to `unset()` must be a string or number, got " + n(r3[u]));
          if (i.indexOf(r3[u]) !== -1)
            return false;
          if (u === s2 - 1)
            return delete a2[r3[u]], true;
          a2 = a2 instanceof Map ? a2.get(r3[u]) : a2[r3[u]];
        }
        return true;
      }, e2.set = function(t4, r3, u, c, l, f) {
        var p;
        typeof c == "function" && (c.length < 2 ? (l = c, c = undefined) : (p = c, c = undefined)), l || (l = a);
        var h = typeof t4 == "string" ? o(t4) : t4;
        if (!Array.isArray(h))
          throw new TypeError("Invalid `path`. Must be either string or array");
        if (u != null) {
          for (var y = 0;y < h.length; ++y) {
            if (typeof h[y] != "string" && typeof h[y] != "number")
              throw new TypeError("Each segment of path to `set()` must be a string or number, got " + n(h[y]));
            if (i.indexOf(h[y]) !== -1)
              return;
          }
          for (var d, b = f || /\$/.test(t4) && f !== false, m = u, v = (y = 0, h.length - 1);y < v; ++y)
            if ((d = h[y]) != "$") {
              if (Array.isArray(m) && !/^\d+$/.test(d)) {
                var g = h.slice(y);
                if (!b && Array.isArray(r3))
                  for (var _ = 0;_ < m.length && _ < r3.length; ++_)
                    e2.set(g, r3[_], m[_], c || p, l, b);
                else
                  for (_ = 0;_ < m.length; ++_)
                    e2.set(g, r3, m[_], c || p, l, b);
                return;
              }
              if (p)
                m = p(m, d);
              else {
                var w = c && m[c] ? m[c] : m;
                m = w instanceof Map ? w.get(d) : w[d];
              }
              if (!m)
                return;
            } else if (y == v - 1)
              break;
          if (d = h[v], c && m[c] && (m = m[c]), Array.isArray(m) && !/^\d+$/.test(d))
            if (!b && Array.isArray(r3))
              s(m, r3, d, p, c, l);
            else
              for (_ = 0;_ < m.length; ++_) {
                var O = m[_];
                O && (p ? p(O, d, l(r3)) : (O[c] && (O = O[c]), O[d] = l(r3)));
              }
          else
            p ? p(m, d, l(r3)) : m instanceof Map ? m.set(d, l(r3)) : m[d] = l(r3);
        }
      }, e2.stringToParts = o;
    }, 2945: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (o = function() {
          return !!t4;
        })();
      }
      function i(t4) {
        return i = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, i(t4);
      }
      function s(t4, e3) {
        return s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s(t4, e3);
      }
      var a = function(t4) {
        function e3() {
          return function(t5, e4) {
            if (!(t5 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), function(t5, e4, r4) {
            return e4 = i(e4), function(t6, e5) {
              if (e5 && (n(e5) == "object" || typeof e5 == "function"))
                return e5;
              if (e5 !== undefined)
                throw new TypeError("Derived constructors may only return object or undefined");
              return function(t7) {
                if (t7 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t7;
              }(t6);
            }(t5, o() ? Reflect.construct(e4, r4 || [], i(t5).constructor) : e4.apply(t5, r4));
          }(this, e3, arguments);
        }
        return function(t5, e4) {
          if (typeof e4 != "function" && e4 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(8879)), u = r2(5761);
      Object.defineProperty(a.prototype, "subtype", u), t3.exports = a;
    }, 3071: (t3, e2, r2) => {
      var n = r2(6400), o = r2(8863), i = o([n("%String.prototype.indexOf%")]);
      t3.exports = function(t4, e3) {
        var r3 = n(t4, !!e3);
        return typeof r3 == "function" && i(t4, ".prototype.") > -1 ? o([r3]) : r3;
      };
    }, 3091: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function i(t4) {
        for (var e3 = 1;e3 < arguments.length; e3++) {
          var r3 = arguments[e3] != null ? arguments[e3] : {};
          e3 % 2 ? o(Object(r3), true).forEach(function(e4) {
            s(t4, e4, r3[e4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : o(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      function s(t4, e3, r3) {
        return (e3 = function(t5) {
          var e4 = function(t6) {
            if (n(t6) != "object" || !t6)
              return t6;
            var e5 = t6[Symbol.toPrimitive];
            if (e5 !== undefined) {
              var r4 = e5.call(t6, "string");
              if (n(r4) != "object")
                return r4;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t6);
          }(t5);
          return n(e4) == "symbol" ? e4 : e4 + "";
        }(e3)) in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      var a, u = r2(4625), c = r2(6426), l = r2(863), f = r2(4327), p = r2(8260), h = r2(5549), y = r2(3305), d = r2(8768), b = c.CastError;
      function m(t4, e3) {
        var r3 = typeof t4 == "string" && t4.length === 24 && /^[a-f0-9]+$/i.test(t4), n2 = e3 && e3.suppressWarning;
        !r3 && t4 !== undefined || n2 || d.warn("mongoose: To create a new ObjectId please try `Mongoose.Types.ObjectId` instead of using `Mongoose.Schema.ObjectId`. Set the `suppressWarning` option if you're trying to create a hex char path in your schema."), c.call(this, t4, e3, "ObjectId");
      }
      function v(t4) {
        return this.cast(t4);
      }
      m.schemaName = "ObjectId", m.defaultOptions = {}, m.prototype = Object.create(c.prototype), m.prototype.constructor = m, m.prototype.OptionsConstructor = u, m.get = c.get, m.set = c.set, m.setters = [], m.prototype.auto = function(t4) {
        return t4 && (this.default(_), this.set(w)), this;
      }, m._checkRequired = function(t4) {
        return y(t4, "ObjectId");
      }, m._cast = l, m.cast = function(t4) {
        return arguments.length === 0 || (t4 === false && (t4 = this._defaultCaster), this._cast = t4), this._cast;
      }, m._defaultCaster = function(t4) {
        if (!y(t4, "ObjectId"))
          throw new Error(t4 + " is not an instance of ObjectId");
        return t4;
      }, m.checkRequired = c.checkRequired, m.prototype.checkRequired = function(t4, e3) {
        return c._isRef(this, t4, e3, true) ? !!t4 : (typeof this.constructor.checkRequired == "function" ? this.constructor.checkRequired() : m.checkRequired())(t4);
      }, m.prototype.cast = function(t4, e3, r3, n2, o2) {
        if (!y(t4, "ObjectId") && c._isRef(this, t4, e3, r3)) {
          if ((p(t4) || "").toLowerCase() === "objectid")
            return new h(t4.toHexString());
          if (t4 == null || d.isNonBuiltinObject(t4))
            return this._castRef(t4, e3, r3, o2);
        }
        var i2;
        i2 = typeof this._castFunction == "function" ? this._castFunction : typeof this.constructor.cast == "function" ? this.constructor.cast() : m.cast();
        try {
          return i2(t4);
        } catch (e4) {
          throw new b("ObjectId", t4, this.path, e4, this);
        }
      };
      var g = i(i({}, c.prototype.$conditionalHandlers), {}, { $gt: v, $gte: v, $lt: v, $lte: v });
      function _() {
        return new h;
      }
      function w(t4) {
        return a || (a = r2(2400)), this instanceof a && t4 === undefined ? new h : t4;
      }
      Object.defineProperty(m.prototype, "$conditionalHandlers", { enumerable: false, value: g }), _.$runBeforeSetters = true, m.prototype.toJSONSchema = function(t4) {
        var e3 = this.options.required && typeof this.options.required != "function" || this.path === "_id";
        return f("string", "objectId", t4 == null ? undefined : t4.useBsonType, e3);
      }, m.prototype.autoEncryptionType = function() {
        return "objectId";
      }, t3.exports = m;
    }, 3123: (t3) => {
      t3.exports = Function.prototype.call;
    }, 3191: (t3, e2, r2) => {
      var n = r2(988), o = function() {
        return !!n;
      };
      o.hasArrayLengthDefineBug = function() {
        if (!n)
          return null;
        try {
          return n([], "length", { value: 1 }).length !== 1;
        } catch (t4) {
          return true;
        }
      }, t3.exports = o;
    }, 3216: (t3, e2, r2) => {
      function n(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function o(t4) {
        for (var e3 = 1;e3 < arguments.length; e3++) {
          var r3 = arguments[e3] != null ? arguments[e3] : {};
          e3 % 2 ? n(Object(r3), true).forEach(function(e4) {
            i(t4, e4, r3[e4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : n(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      function i(t4, e3, r3) {
        return (e3 = function(t5) {
          var e4 = function(t6) {
            if (s(t6) != "object" || !t6)
              return t6;
            var e5 = t6[Symbol.toPrimitive];
            if (e5 !== undefined) {
              var r4 = e5.call(t6, "string");
              if (s(r4) != "object")
                return r4;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t6);
          }(t5);
          return s(e4) == "symbol" ? e4 : e4 + "";
        }(e3)) in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      function s(t4) {
        return s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, s(t4);
      }
      var a = r2(8768), u = new Set(["__index", "__parentArray", "_doc"]);
      t3.exports = function(t4, e3) {
        if (a.isPOJO(t4) && t4.$__ != null && t4._doc != null) {
          if (e3) {
            for (var r3 = {}, n2 = 0, i2 = Object.keys(t4);n2 < i2.length; n2++) {
              var c = i2[n2];
              s(c) !== "symbol" && c[0] !== "$" && (u.has(c) || (r3[c] = t4[c]));
            }
            return o(o({}, t4._doc), r3);
          }
          return t4._doc;
        }
        return t4;
      };
    }, 3279: (t3) => {
      t3.exports = Function.prototype.apply;
    }, 3303: (t3, e2) => {
      e2._ = { transform: false, virtuals: false, getters: false, _skipDepopulateTopLevel: true, depopulate: true, flattenDecimals: false, useProjection: false, versionKey: true, flattenObjectIds: false };
    }, 3305: (t3) => {
      t3.exports = function(t4, e2) {
        return t4 != null && t4._bsontype === e2;
      };
    }, 3318: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function i(t4) {
        for (var e3 = 1;e3 < arguments.length; e3++) {
          var r3 = arguments[e3] != null ? arguments[e3] : {};
          e3 % 2 ? o(Object(r3), true).forEach(function(e4) {
            s(t4, e4, r3[e4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : o(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      function s(t4, e3, r3) {
        return (e3 = function(t5) {
          var e4 = function(t6) {
            if (n(t6) != "object" || !t6)
              return t6;
            var e5 = t6[Symbol.toPrimitive];
            if (e5 !== undefined) {
              var r4 = e5.call(t6, "string");
              if (n(r4) != "object")
                return r4;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t6);
          }(t5);
          return n(e4) == "symbol" ? e4 : e4 + "";
        }(e3)) in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      var a = r2(3609), u = r2(6426), c = r2(4058), l = r2(4327);
      function f(t4, e3) {
        u.call(this, t4, e3, "BigInt");
      }
      f.schemaName = "BigInt", f.defaultOptions = {}, f.prototype = Object.create(u.prototype), f.prototype.constructor = f, f._cast = c, f.set = u.set, f.setters = [], f.get = u.get, f.cast = function(t4) {
        return arguments.length === 0 || (t4 === false && (t4 = this._defaultCaster), this._cast = t4), this._cast;
      }, f._checkRequired = function(t4) {
        return t4 != null;
      }, f.checkRequired = u.checkRequired, f.prototype.checkRequired = function(t4) {
        return this.constructor._checkRequired(t4);
      }, f.prototype.cast = function(t4) {
        var e3;
        e3 = typeof this._castFunction == "function" ? this._castFunction : typeof this.constructor.cast == "function" ? this.constructor.cast() : f.cast();
        try {
          return e3(t4);
        } catch (e4) {
          throw new a("BigInt", t4, this.path, e4, this);
        }
      };
      var p = i(i({}, u.prototype.$conditionalHandlers), {}, { $gt: h, $gte: h, $lt: h, $lte: h });
      function h(t4, e3) {
        return this.castForQuery(null, t4, e3);
      }
      Object.defineProperty(f.prototype, "$conditionalHandlers", { enumerable: false, value: p }), f.prototype.castForQuery = function(t4, e3, r3) {
        var n2;
        if (t4 != null)
          return (n2 = this.$conditionalHandlers[t4]) ? n2.call(this, e3) : this.applySetters(e3, r3);
        try {
          return this.applySetters(e3, r3);
        } catch (t5) {
          throw t5 instanceof a && t5.path === this.path && this.$fullPath != null && (t5.path = this.$fullPath), t5;
        }
      }, f.prototype._castNullish = function(t4) {
        return t4 === undefined || (typeof this.constructor.cast == "function" ? this.constructor.cast() : f.cast()), t4;
      }, f.prototype.toJSONSchema = function(t4) {
        var e3 = this.options.required && typeof this.options.required != "function";
        return l("string", "long", t4 == null ? undefined : t4.useBsonType, e3);
      }, f.prototype.autoEncryptionType = function() {
        return "long";
      }, t3.exports = f;
    }, 3381: (t3) => {
      function e2() {
        return this._id != null ? this._id.toString() : null;
      }
      t3.exports = function(t4) {
        return !t4.paths.id && t4.paths._id && t4.options.id ? (t4.aliases && t4.aliases.id || t4.virtual("id").get(e2), t4) : t4;
      };
    }, 3388: (t3) => {
      t3.exports = typeof Reflect != "undefined" && Reflect && Reflect.apply;
    }, 3414: (t3) => {
      t3.exports = Number.isNaN || function(t4) {
        return t4 != t4;
      };
    }, 3426: (t3, e2, r2) => {
      var n = r2(2653), o = typeof globalThis == "undefined" ? r2.g : globalThis;
      t3.exports = function() {
        for (var t4 = [], e3 = 0;e3 < n.length; e3++)
          typeof o[n[e3]] == "function" && (t4[t4.length] = n[e3]);
        return t4;
      };
    }, 3441: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (o = function() {
          return !!t4;
        })();
      }
      function i(t4) {
        return i = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, i(t4);
      }
      function s(t4, e3) {
        return s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s(t4, e3);
      }
      var a = function(t4) {
        function e3(t5, r4) {
          var s2;
          (function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          })(this, e3);
          var a2 = Array.isArray(r4) ? "array" : "primitive value";
          return (s2 = function(t6, e4, r5) {
            return e4 = i(e4), function(t7, e5) {
              if (e5 && (n(e5) == "object" || typeof e5 == "function"))
                return e5;
              if (e5 !== undefined)
                throw new TypeError("Derived constructors may only return object or undefined");
              return function(t8) {
                if (t8 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t8;
              }(t7);
            }(t6, o() ? Reflect.construct(e4, r5 || [], i(t6).constructor) : e4.apply(t6, r5));
          }(this, e3, ["Tried to set nested object field `" + t5 + "` to ".concat(a2, " `") + r4 + "`"])).path = t5, s2;
        }
        return function(t5, e4) {
          if (typeof e4 != "function" && e4 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(8213));
      Object.defineProperty(a.prototype, "name", { value: "ObjectExpectedError" }), t3.exports = a;
    }, 3550: (t3) => {
      function e2(t4) {
        return e2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      var r2, n = (typeof Reflect == "undefined" ? "undefined" : e2(Reflect)) === "object" ? Reflect : null, o = n && typeof n.apply == "function" ? n.apply : function(t4, e3, r3) {
        return Function.prototype.apply.call(t4, e3, r3);
      };
      r2 = n && typeof n.ownKeys == "function" ? n.ownKeys : Object.getOwnPropertySymbols ? function(t4) {
        return Object.getOwnPropertyNames(t4).concat(Object.getOwnPropertySymbols(t4));
      } : function(t4) {
        return Object.getOwnPropertyNames(t4);
      };
      var i = Number.isNaN || function(t4) {
        return t4 != t4;
      };
      function s() {
        s.init.call(this);
      }
      t3.exports = s, t3.exports.once = function(t4, e3) {
        return new Promise(function(r3, n2) {
          function o2(r4) {
            t4.removeListener(e3, i2), n2(r4);
          }
          function i2() {
            typeof t4.removeListener == "function" && t4.removeListener("error", o2), r3([].slice.call(arguments));
          }
          b(t4, e3, i2, { once: true }), e3 !== "error" && function(t5, e4) {
            typeof t5.on == "function" && b(t5, "error", e4, { once: true });
          }(t4, o2);
        });
      }, s.EventEmitter = s, s.prototype._events = undefined, s.prototype._eventsCount = 0, s.prototype._maxListeners = undefined;
      var a = 10;
      function u(t4) {
        if (typeof t4 != "function")
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + e2(t4));
      }
      function c(t4) {
        return t4._maxListeners === undefined ? s.defaultMaxListeners : t4._maxListeners;
      }
      function l(t4, e3, r3, n2) {
        var o2, i2, s2, a2;
        if (u(r3), (i2 = t4._events) === undefined ? (i2 = t4._events = Object.create(null), t4._eventsCount = 0) : (i2.newListener !== undefined && (t4.emit("newListener", e3, r3.listener ? r3.listener : r3), i2 = t4._events), s2 = i2[e3]), s2 === undefined)
          s2 = i2[e3] = r3, ++t4._eventsCount;
        else if (typeof s2 == "function" ? s2 = i2[e3] = n2 ? [r3, s2] : [s2, r3] : n2 ? s2.unshift(r3) : s2.push(r3), (o2 = c(t4)) > 0 && s2.length > o2 && !s2.warned) {
          s2.warned = true;
          var l2 = new Error("Possible EventEmitter memory leak detected. " + s2.length + " " + String(e3) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          l2.name = "MaxListenersExceededWarning", l2.emitter = t4, l2.type = e3, l2.count = s2.length, a2 = l2, console && console.warn && console.warn(a2);
        }
        return t4;
      }
      function f() {
        if (!this.fired)
          return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
      }
      function p(t4, e3, r3) {
        var n2 = { fired: false, wrapFn: undefined, target: t4, type: e3, listener: r3 }, o2 = f.bind(n2);
        return o2.listener = r3, n2.wrapFn = o2, o2;
      }
      function h(t4, e3, r3) {
        var n2 = t4._events;
        if (n2 === undefined)
          return [];
        var o2 = n2[e3];
        return o2 === undefined ? [] : typeof o2 == "function" ? r3 ? [o2.listener || o2] : [o2] : r3 ? function(t5) {
          for (var e4 = new Array(t5.length), r4 = 0;r4 < e4.length; ++r4)
            e4[r4] = t5[r4].listener || t5[r4];
          return e4;
        }(o2) : d(o2, o2.length);
      }
      function y(t4) {
        var e3 = this._events;
        if (e3 !== undefined) {
          var r3 = e3[t4];
          if (typeof r3 == "function")
            return 1;
          if (r3 !== undefined)
            return r3.length;
        }
        return 0;
      }
      function d(t4, e3) {
        for (var r3 = new Array(e3), n2 = 0;n2 < e3; ++n2)
          r3[n2] = t4[n2];
        return r3;
      }
      function b(t4, r3, n2, o2) {
        if (typeof t4.on == "function")
          o2.once ? t4.once(r3, n2) : t4.on(r3, n2);
        else {
          if (typeof t4.addEventListener != "function")
            throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + e2(t4));
          t4.addEventListener(r3, function e(i2) {
            o2.once && t4.removeEventListener(r3, e), n2(i2);
          });
        }
      }
      Object.defineProperty(s, "defaultMaxListeners", { enumerable: true, get: function() {
        return a;
      }, set: function(t4) {
        if (typeof t4 != "number" || t4 < 0 || i(t4))
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t4 + ".");
        a = t4;
      } }), s.init = function() {
        this._events !== undefined && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || undefined;
      }, s.prototype.setMaxListeners = function(t4) {
        if (typeof t4 != "number" || t4 < 0 || i(t4))
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t4 + ".");
        return this._maxListeners = t4, this;
      }, s.prototype.getMaxListeners = function() {
        return c(this);
      }, s.prototype.emit = function(t4) {
        for (var e3 = [], r3 = 1;r3 < arguments.length; r3++)
          e3.push(arguments[r3]);
        var n2 = t4 === "error", i2 = this._events;
        if (i2 !== undefined)
          n2 = n2 && i2.error === undefined;
        else if (!n2)
          return false;
        if (n2) {
          var s2;
          if (e3.length > 0 && (s2 = e3[0]), s2 instanceof Error)
            throw s2;
          var a2 = new Error("Unhandled error." + (s2 ? " (" + s2.message + ")" : ""));
          throw a2.context = s2, a2;
        }
        var u2 = i2[t4];
        if (u2 === undefined)
          return false;
        if (typeof u2 == "function")
          o(u2, this, e3);
        else {
          var c2 = u2.length, l2 = d(u2, c2);
          for (r3 = 0;r3 < c2; ++r3)
            o(l2[r3], this, e3);
        }
        return true;
      }, s.prototype.addListener = function(t4, e3) {
        return l(this, t4, e3, false);
      }, s.prototype.on = s.prototype.addListener, s.prototype.prependListener = function(t4, e3) {
        return l(this, t4, e3, true);
      }, s.prototype.once = function(t4, e3) {
        return u(e3), this.on(t4, p(this, t4, e3)), this;
      }, s.prototype.prependOnceListener = function(t4, e3) {
        return u(e3), this.prependListener(t4, p(this, t4, e3)), this;
      }, s.prototype.removeListener = function(t4, e3) {
        var r3, n2, o2, i2, s2;
        if (u(e3), (n2 = this._events) === undefined)
          return this;
        if ((r3 = n2[t4]) === undefined)
          return this;
        if (r3 === e3 || r3.listener === e3)
          --this._eventsCount === 0 ? this._events = Object.create(null) : (delete n2[t4], n2.removeListener && this.emit("removeListener", t4, r3.listener || e3));
        else if (typeof r3 != "function") {
          for (o2 = -1, i2 = r3.length - 1;i2 >= 0; i2--)
            if (r3[i2] === e3 || r3[i2].listener === e3) {
              s2 = r3[i2].listener, o2 = i2;
              break;
            }
          if (o2 < 0)
            return this;
          o2 === 0 ? r3.shift() : function(t5, e4) {
            for (;e4 + 1 < t5.length; e4++)
              t5[e4] = t5[e4 + 1];
            t5.pop();
          }(r3, o2), r3.length === 1 && (n2[t4] = r3[0]), n2.removeListener !== undefined && this.emit("removeListener", t4, s2 || e3);
        }
        return this;
      }, s.prototype.off = s.prototype.removeListener, s.prototype.removeAllListeners = function(t4) {
        var e3, r3, n2;
        if ((r3 = this._events) === undefined)
          return this;
        if (r3.removeListener === undefined)
          return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : r3[t4] !== undefined && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete r3[t4]), this;
        if (arguments.length === 0) {
          var o2, i2 = Object.keys(r3);
          for (n2 = 0;n2 < i2.length; ++n2)
            (o2 = i2[n2]) !== "removeListener" && this.removeAllListeners(o2);
          return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
        }
        if (typeof (e3 = r3[t4]) == "function")
          this.removeListener(t4, e3);
        else if (e3 !== undefined)
          for (n2 = e3.length - 1;n2 >= 0; n2--)
            this.removeListener(t4, e3[n2]);
        return this;
      }, s.prototype.listeners = function(t4) {
        return h(this, t4, true);
      }, s.prototype.rawListeners = function(t4) {
        return h(this, t4, false);
      }, s.listenerCount = function(t4, e3) {
        return typeof t4.listenerCount == "function" ? t4.listenerCount(e3) : y.call(t4, e3);
      }, s.prototype.listenerCount = y, s.prototype.eventNames = function() {
        return this._eventsCount > 0 ? r2(this._events) : [];
      };
    }, 3609: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o(t4, e3) {
        for (var r3 = 0;r3 < e3.length; r3++) {
          var n2 = e3[r3];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t4, i(n2.key), n2);
        }
      }
      function i(t4) {
        var e3 = function(t5) {
          if (n(t5) != "object" || !t5)
            return t5;
          var e4 = t5[Symbol.toPrimitive];
          if (e4 !== undefined) {
            var r3 = e4.call(t5, "string");
            if (n(r3) != "object")
              return r3;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t5);
        }(t4);
        return n(e3) == "symbol" ? e3 : e3 + "";
      }
      function s(t4, e3, r3) {
        return e3 = c(e3), function(t5, e4) {
          if (e4 && (n(e4) == "object" || typeof e4 == "function"))
            return e4;
          if (e4 !== undefined)
            throw new TypeError("Derived constructors may only return object or undefined");
          return a(t5);
        }(t4, u() ? Reflect.construct(e3, r3 || [], c(t4).constructor) : e3.apply(t4, r3));
      }
      function a(t4) {
        if (t4 === undefined)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t4;
      }
      function u() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (u = function() {
          return !!t4;
        })();
      }
      function c(t4) {
        return c = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, c(t4);
      }
      function l(t4, e3) {
        return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, l(t4, e3);
      }
      var f = r2(8213), p = r2(7352), h = function(t4) {
        function e3(t5, r4, n3, o2, i2) {
          var u2;
          if (function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), arguments.length > 0) {
            var c2 = d(r4);
            (u2 = s(this, e3, [m(null, t5, r4, n3, b(i2), c2, o2)])).init(t5, r4, n3, o2, i2);
          } else
            u2 = s(this, e3, [m()]);
          return a(u2);
        }
        return function(t5, e4) {
          if (typeof e4 != "function" && e4 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && l(t5, e4);
        }(e3, t4), r3 = e3, (n2 = [{ key: "toJSON", value: function() {
          return { stringValue: this.stringValue, valueType: this.valueType, kind: this.kind, value: this.value, path: this.path, reason: this.reason, name: this.name, message: this.message };
        } }, { key: "init", value: function(t5, e4, r4, n3, o2) {
          this.stringValue = y(e4), this.messageFormat = b(o2), this.kind = t5, this.value = e4, this.path = r4, this.reason = n3, this.valueType = d(e4);
        } }, { key: "copy", value: function(t5) {
          this.messageFormat = t5.messageFormat, this.stringValue = t5.stringValue, this.kind = t5.kind, this.value = t5.value, this.path = t5.path, this.reason = t5.reason, this.message = t5.message, this.valueType = t5.valueType;
        } }, { key: "setModel", value: function(t5) {
          this.message = m(t5, this.kind, this.value, this.path, this.messageFormat, this.valueType);
        } }]) && o(r3.prototype, n2), Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3, n2;
      }(f);
      function y(t4) {
        var e3 = p.inspect(t4);
        return (e3 = e3.replace(/^'|'$/g, '"')).startsWith('"') || (e3 = '"' + e3 + '"'), e3;
      }
      function d(t4) {
        if (t4 == null)
          return "" + t4;
        var e3 = n(t4);
        return e3 !== "object" || typeof t4.constructor != "function" ? e3 : t4.constructor.name;
      }
      function b(t4) {
        var e3 = t4 && t4._castErrorMessage || null;
        if (typeof e3 == "string" || typeof e3 == "function")
          return e3;
      }
      function m(t4, e3, r3, n2, o2, i2, s2) {
        if (typeof o2 == "string") {
          var a2 = y(r3), u2 = o2.replace("{KIND}", e3).replace("{VALUE}", a2).replace("{PATH}", n2);
          return t4 != null && (u2 = u2.replace("{MODEL}", t4.modelName)), u2;
        }
        if (typeof o2 == "function")
          return o2(r3, n2, t4, e3);
        var c2 = "Cast to " + e3 + " failed for value " + y(r3) + (i2 ? " (type " + i2 + ")" : "") + ' at path "' + n2 + '"';
        return t4 != null && (c2 += ' for model "' + t4.modelName + '"'), s2 != null && typeof s2.constructor == "function" && s2.constructor.name !== "AssertionError" && s2.constructor.name !== "Error" && (c2 += ' because of "' + s2.constructor.name + '"'), c2;
      }
      Object.defineProperty(h.prototype, "name", { value: "CastError" }), t3.exports = h;
    }, 3622: (t3) => {
      function e2(t4) {
        return e2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      t3.exports = function(t4, r2, n) {
        if (t4 == null)
          return t4;
        if (t4._doc != null && (t4 = t4._doc), arguments.length >= 3) {
          if (e2(t4) !== "object")
            return;
          if (n === undefined)
            return;
          return t4 instanceof Map ? t4.set(r2, n) : t4[r2] = n, n;
        }
        return r2 === "$*" ? t4 instanceof Map ? Array.from(t4.values()) : Object.keys(t4).map(function(e3) {
          return t4[e3];
        }) : t4 instanceof Map ? t4.get(r2) : t4[r2];
      };
    }, 3644: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (o = function() {
          return !!t4;
        })();
      }
      function i(t4) {
        return i = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, i(t4);
      }
      function s(t4, e3) {
        return s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s(t4, e3);
      }
      var a = function(t4) {
        function e3(t5) {
          return function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), function(t6, e4, r4) {
            return e4 = i(e4), function(t7, e5) {
              if (e5 && (n(e5) == "object" || typeof e5 == "function"))
                return e5;
              if (e5 !== undefined)
                throw new TypeError("Derived constructors may only return object or undefined");
              return function(t8) {
                if (t8 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t8;
              }(t7);
            }(t6, o() ? Reflect.construct(e4, r4 || [], i(t6).constructor) : e4.apply(t6, r4));
          }(this, e3, ["Cannot overwrite `" + t5 + "` model once compiled."]);
        }
        return function(t5, e4) {
          if (typeof e4 != "function" && e4 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(8213));
      Object.defineProperty(a.prototype, "name", { value: "OverwriteModelError" }), t3.exports = a;
    }, 3660: (t3, e2, r2) => {
      function n(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function o(t4) {
        for (var e3 = 1;e3 < arguments.length; e3++) {
          var r3 = arguments[e3] != null ? arguments[e3] : {};
          e3 % 2 ? n(Object(r3), true).forEach(function(e4) {
            i(t4, e4, r3[e4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : n(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      function i(t4, e3, r3) {
        return (e3 = function(t5) {
          var e4 = function(t6) {
            if (s(t6) != "object" || !t6)
              return t6;
            var e5 = t6[Symbol.toPrimitive];
            if (e5 !== undefined) {
              var r4 = e5.call(t6, "string");
              if (s(r4) != "object")
                return r4;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t6);
          }(t5);
          return s(e4) == "symbol" ? e4 : e4 + "";
        }(e3)) in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      function s(t4) {
        return s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, s(t4);
      }
      var a = r2(3672), u = r2(1007), c = r2(6426), l = r2(7768), f = r2(4327), p = r2(9460), h = r2(8768), y = c.CastError;
      function d(t4, e3) {
        c.call(this, t4, e3, "Number");
      }
      function b(t4) {
        return this.cast(t4);
      }
      d.get = c.get, d.set = c.set, d.setters = [], d._cast = l, d.cast = function(t4) {
        return arguments.length === 0 || (t4 === false && (t4 = this._defaultCaster), this._cast = t4), this._cast;
      }, d._defaultCaster = function(t4) {
        if (typeof t4 != "number")
          throw new Error;
        return t4;
      }, d.schemaName = "Number", d.defaultOptions = {}, d.prototype = Object.create(c.prototype), d.prototype.constructor = d, d.prototype.OptionsConstructor = u, d._checkRequired = function(t4) {
        return typeof t4 == "number" || t4 instanceof Number;
      }, d.checkRequired = c.checkRequired, d.prototype.checkRequired = function(t4, e3) {
        return s(t4) === "object" && c._isRef(this, t4, e3, true) ? t4 != null : (typeof this.constructor.checkRequired == "function" ? this.constructor.checkRequired() : d.checkRequired())(t4);
      }, d.prototype.min = function(t4, e3) {
        if (this.minValidator && (this.validators = this.validators.filter(function(t5) {
          return t5.validator !== this.minValidator;
        }, this)), t4 != null) {
          var r3 = e3 || a.messages.Number.min;
          r3 = r3.replace(/{MIN}/, t4), this.validators.push({ validator: this.minValidator = function(e4) {
            return e4 == null || e4 >= t4;
          }, message: r3, type: "min", min: t4 });
        }
        return this;
      }, d.prototype.max = function(t4, e3) {
        if (this.maxValidator && (this.validators = this.validators.filter(function(t5) {
          return t5.validator !== this.maxValidator;
        }, this)), t4 != null) {
          var r3 = e3 || a.messages.Number.max;
          r3 = r3.replace(/{MAX}/, t4), this.validators.push({ validator: this.maxValidator = function(e4) {
            return e4 == null || e4 <= t4;
          }, message: r3, type: "max", max: t4 });
        }
        return this;
      }, d.prototype.enum = function(t4, e3) {
        return this.enumValidator && (this.validators = this.validators.filter(function(t5) {
          return t5.validator !== this.enumValidator;
        }, this)), Array.isArray(t4) || (h.isPOJO(t4) && t4.values != null ? (e3 = t4.message, t4 = t4.values) : typeof t4 == "number" && (t4 = Array.prototype.slice.call(arguments), e3 = null), h.isPOJO(t4) && (t4 = Object.values(t4)), e3 = e3 || a.messages.Number.enum), e3 = e3 == null ? a.messages.Number.enum : e3, this.enumValidator = function(e4) {
          return e4 == null || t4.indexOf(e4) !== -1;
        }, this.validators.push({ validator: this.enumValidator, message: e3, type: "enum", enumValues: t4 }), this;
      }, d.prototype.cast = function(t4, e3, r3, n2, o2) {
        if (typeof t4 != "number" && c._isRef(this, t4, e3, r3) && (t4 == null || h.isNonBuiltinObject(t4)))
          return this._castRef(t4, e3, r3, o2);
        var i2, s2 = t4 && t4._id !== undefined ? t4._id : t4;
        i2 = typeof this._castFunction == "function" ? this._castFunction : typeof this.constructor.cast == "function" ? this.constructor.cast() : d.cast();
        try {
          return i2(s2);
        } catch (t5) {
          throw new y("Number", s2, this.path, t5, this);
        }
      };
      var m = o(o({}, c.prototype.$conditionalHandlers), {}, { $bitsAllClear: p, $bitsAnyClear: p, $bitsAllSet: p, $bitsAnySet: p, $gt: b, $gte: b, $lt: b, $lte: b, $mod: function(t4) {
        var e3 = this;
        return Array.isArray(t4) ? t4.map(function(t5) {
          return e3.cast(t5);
        }) : [this.cast(t4)];
      } });
      Object.defineProperty(d.prototype, "$conditionalHandlers", { enumerable: false, value: m }), d.prototype.castForQuery = function(t4, e3, r3) {
        var n2;
        if (t4 != null) {
          if (!(n2 = this.$conditionalHandlers[t4]))
            throw new y("number", e3, this.path, null, this);
          return n2.call(this, e3, r3);
        }
        try {
          e3 = this.applySetters(e3, r3);
        } catch (t5) {
          throw t5 instanceof y && t5.path === this.path && this.$fullPath != null && (t5.path = this.$fullPath), t5;
        }
        return e3;
      }, d.prototype.toJSONSchema = function(t4) {
        var e3 = this.options.required && typeof this.options.required != "function" || this.path === "_id";
        return f("number", "number", t4 == null ? undefined : t4.useBsonType, e3);
      }, t3.exports = d;
    }, 3672: (t3, e2, r2) => {
      var n = r2(8213);
      t3.exports = n, n.messages = r2(766), n.Messages = n.messages, n.CastError = r2(3609), n.DocumentNotFoundError = r2(1129), n.ValidationError = r2(6949), n.ValidatorError = r2(9538), n.VersionError = r2(6996), n.ParallelSaveError = r2(3940), n.OverwriteModelError = r2(3644), n.MissingSchemaError = r2(8063), n.MongooseBulkSaveIncompleteError = r2(8517), n.MongooseServerSelectionError = r2(7219), n.DivergentArrayError = r2(1417), n.StrictModeError = r2(8995), n.StrictPopulateError = r2(6801);
    }, 3696: (t3) => {
      t3.exports = function(t4, e2) {
        return t4 == null ? null : typeof t4 == "boolean" ? e2 : typeof t4[e2] == "boolean" ? t4[e2] ? e2 : null : (e2 in t4) ? t4[e2] : e2;
      };
    }, 3703: (t3) => {
      function e2(t4, e3) {
        (e3 == null || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n = Array(e3);r3 < e3; r3++)
          n[r3] = t4[r3];
        return n;
      }
      function r2(t4, e3) {
        return t4 == null ? t4 : t4 instanceof Map ? t4.get(e3) : t4[e3];
      }
      t3.exports = function(t4, n, o) {
        var i, s = false;
        if (typeof n == "string") {
          if (n.indexOf(".") === -1) {
            var a = r2(t4, n);
            return a == null ? o : a;
          }
          i = n.split(".");
        } else if (s = true, (i = n).length === 1) {
          var u = r2(t4, i[0]);
          return u == null ? o : u;
        }
        var c, l = n, f = t4, p = function(t5, r3) {
          var n2 = typeof Symbol != "undefined" && t5[Symbol.iterator] || t5["@@iterator"];
          if (!n2) {
            if (Array.isArray(t5) || (n2 = function(t6, r4) {
              if (t6) {
                if (typeof t6 == "string")
                  return e2(t6, r4);
                var n3 = {}.toString.call(t6).slice(8, -1);
                return n3 === "Object" && t6.constructor && (n3 = t6.constructor.name), n3 === "Map" || n3 === "Set" ? Array.from(t6) : n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3) ? e2(t6, r4) : undefined;
              }
            }(t5)) || r3 && t5 && typeof t5.length == "number") {
              n2 && (t5 = n2);
              var o2 = 0, i2 = function() {};
              return { s: i2, n: function() {
                return o2 >= t5.length ? { done: true } : { done: false, value: t5[o2++] };
              }, e: function(t6) {
                throw t6;
              }, f: i2 };
            }
            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }
          var s2, a2 = true, u2 = false;
          return { s: function() {
            n2 = n2.call(t5);
          }, n: function() {
            var t6 = n2.next();
            return a2 = t6.done, t6;
          }, e: function(t6) {
            u2 = true, s2 = t6;
          }, f: function() {
            try {
              a2 || n2.return == null || n2.return();
            } finally {
              if (u2)
                throw s2;
            }
          } };
        }(i);
        try {
          for (p.s();!(c = p.n()).done; ) {
            var h = c.value;
            if (f == null)
              return o;
            if (!s && f[l] != null)
              return f[l];
            f = r2(f, h), s || (l = l.substr(h.length + 1));
          }
        } catch (t5) {
          p.e(t5);
        } finally {
          p.f();
        }
        return f == null ? o : f;
      };
    }, 3704: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var o = r2(2402), i = r2(6353), s = r2(3305);
      t3.exports = function(t4) {
        if (t4 == null || t4 === "")
          return null;
        var e3;
        if (s(t4, "Long"))
          e3 = t4.toNumber();
        else if (typeof t4 == "string")
          try {
            return i.Double.fromString(t4);
          } catch (t5) {
            o.ok(false);
          }
        else if (n(t4) === "object") {
          var r3, a = (r3 = t4.valueOf()) !== null && r3 !== undefined ? r3 : t4.toString();
          if (typeof a == "string")
            try {
              return i.Double.fromString(t4);
            } catch (t5) {
              o.ok(false);
            }
          else
            e3 = Number(a);
        } else
          e3 = Number(t4);
        return new i.Double(e3);
      };
    }, 3731: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (o = function() {
          return !!t4;
        })();
      }
      function i(t4) {
        return i = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, i(t4);
      }
      function s(t4, e3) {
        return s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s(t4, e3);
      }
      var a = function(t4) {
        function e3() {
          return function(t5, e4) {
            if (!(t5 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), function(t5, e4, r4) {
            return e4 = i(e4), function(t6, e5) {
              if (e5 && (n(e5) == "object" || typeof e5 == "function"))
                return e5;
              if (e5 !== undefined)
                throw new TypeError("Derived constructors may only return object or undefined");
              return function(t7) {
                if (t7 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t7;
              }(t6);
            }(t5, o() ? Reflect.construct(e4, r4 || [], i(t5).constructor) : e4.apply(t5, r4));
          }(this, e3, arguments);
        }
        return function(t5, e4) {
          if (typeof e4 != "function" && e4 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(8879)), u = r2(5761);
      Object.defineProperty(a.prototype, "min", u), Object.defineProperty(a.prototype, "max", u), Object.defineProperty(a.prototype, "expires", u), t3.exports = a;
    }, 3743: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o(t4) {
        return o = typeof Symbol == "function" && n(Symbol.iterator) === "symbol" ? function(t5) {
          return n(t5);
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : n(t5);
        }, o(t4);
      }
      function i(t4) {
        return i = Object.setPrototypeOf ? Object.getPrototypeOf : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, i(t4);
      }
      function s(t4, e3) {
        return s = Object.setPrototypeOf || function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s(t4, e3);
      }
      var a, u, c = {};
      function l(t4, e3, r3) {
        r3 || (r3 = Error);
        var n2 = function(r4) {
          function n3(r5, s2, a2) {
            var u2;
            return function(t5, e4) {
              if (!(t5 instanceof e4))
                throw new TypeError("Cannot call a class as a function");
            }(this, n3), u2 = function(t5, e4) {
              return !e4 || o(e4) !== "object" && typeof e4 != "function" ? function(t6) {
                if (t6 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t6;
              }(t5) : e4;
            }(this, i(n3).call(this, function(t5, r6, n4) {
              return typeof e3 == "string" ? e3 : e3(t5, r6, n4);
            }(r5, s2, a2))), u2.code = t4, u2;
          }
          return function(t5, e4) {
            if (typeof e4 != "function" && e4 !== null)
              throw new TypeError("Super expression must either be null or a function");
            t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), e4 && s(t5, e4);
          }(n3, r4), n3;
        }(r3);
        c[t4] = n2;
      }
      function f(t4, e3) {
        if (Array.isArray(t4)) {
          var r3 = t4.length;
          return t4 = t4.map(function(t5) {
            return String(t5);
          }), r3 > 2 ? "one of ".concat(e3, " ").concat(t4.slice(0, r3 - 1).join(", "), ", or ") + t4[r3 - 1] : r3 === 2 ? "one of ".concat(e3, " ").concat(t4[0], " or ").concat(t4[1]) : "of ".concat(e3, " ").concat(t4[0]);
        }
        return "of ".concat(e3, " ").concat(String(t4));
      }
      l("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), l("ERR_INVALID_ARG_TYPE", function(t4, e3, n2) {
        var i2, s2, u2, c2, l2;
        if (a === undefined && (a = r2(2402)), a(typeof t4 == "string", "'name' must be a string"), typeof e3 == "string" && (s2 = "not ", e3.substr(0, 4) === s2) ? (i2 = "must not be", e3 = e3.replace(/^not /, "")) : i2 = "must be", function(t5, e4, r3) {
          return (r3 === undefined || r3 > t5.length) && (r3 = t5.length), t5.substring(r3 - 9, r3) === e4;
        }(t4, " argument"))
          u2 = "The ".concat(t4, " ").concat(i2, " ").concat(f(e3, "type"));
        else {
          var p = (typeof l2 != "number" && (l2 = 0), l2 + 1 > (c2 = t4).length || c2.indexOf(".", l2) === -1 ? "argument" : "property");
          u2 = 'The "'.concat(t4, '" ').concat(p, " ").concat(i2, " ").concat(f(e3, "type"));
        }
        return u2 + ". Received type ".concat(o(n2));
      }, TypeError), l("ERR_INVALID_ARG_VALUE", function(t4, e3) {
        var n2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "is invalid";
        u === undefined && (u = r2(7352));
        var o2 = u.inspect(e3);
        return o2.length > 128 && (o2 = "".concat(o2.slice(0, 128), "...")), "The argument '".concat(t4, "' ").concat(n2, ". Received ").concat(o2);
      }, TypeError, RangeError), l("ERR_INVALID_RETURN_VALUE", function(t4, e3, r3) {
        var n2;
        return n2 = r3 && r3.constructor && r3.constructor.name ? "instance of ".concat(r3.constructor.name) : "type ".concat(o(r3)), "Expected ".concat(t4, ' to be returned from the "').concat(e3, '"') + " function but got ".concat(n2, ".");
      }, TypeError), l("ERR_MISSING_ARGS", function() {
        for (var t4 = arguments.length, e3 = new Array(t4), n2 = 0;n2 < t4; n2++)
          e3[n2] = arguments[n2];
        a === undefined && (a = r2(2402)), a(e3.length > 0, "At least one arg needs to be specified");
        var o2 = "The ", i2 = e3.length;
        switch (e3 = e3.map(function(t5) {
          return '"'.concat(t5, '"');
        }), i2) {
          case 1:
            o2 += "".concat(e3[0], " argument");
            break;
          case 2:
            o2 += "".concat(e3[0], " and ").concat(e3[1], " arguments");
            break;
          default:
            o2 += e3.slice(0, i2 - 1).join(", "), o2 += ", and ".concat(e3[i2 - 1], " arguments");
        }
        return "".concat(o2, " must be specified");
      }, TypeError), t3.exports.codes = c;
    }, 3777: (t3, e2, r2) => {
      var n = r2(9809), o = Object.prototype.toString, i = Object.prototype.hasOwnProperty;
      t3.exports = function(t4, e3, r3) {
        if (!n(e3))
          throw new TypeError("iterator must be a function");
        var s, a;
        arguments.length >= 3 && (s = r3), a = t4, o.call(a) === "[object Array]" ? function(t5, e4, r4) {
          for (var n2 = 0, o2 = t5.length;n2 < o2; n2++)
            i.call(t5, n2) && (r4 == null ? e4(t5[n2], n2, t5) : e4.call(r4, t5[n2], n2, t5));
        }(t4, e3, s) : typeof t4 == "string" ? function(t5, e4, r4) {
          for (var n2 = 0, o2 = t5.length;n2 < o2; n2++)
            r4 == null ? e4(t5.charAt(n2), n2, t5) : e4.call(r4, t5.charAt(n2), n2, t5);
        }(t4, e3, s) : function(t5, e4, r4) {
          for (var n2 in t5)
            i.call(t5, n2) && (r4 == null ? e4(t5[n2], n2, t5) : e4.call(r4, t5[n2], n2, t5));
        }(t4, e3, s);
      };
    }, 3892: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o(t4, e3) {
        var r3 = typeof Symbol != "undefined" && t4[Symbol.iterator] || t4["@@iterator"];
        if (!r3) {
          if (Array.isArray(t4) || (r3 = function(t5, e4) {
            if (t5) {
              if (typeof t5 == "string")
                return i(t5, e4);
              var r4 = {}.toString.call(t5).slice(8, -1);
              return r4 === "Object" && t5.constructor && (r4 = t5.constructor.name), r4 === "Map" || r4 === "Set" ? Array.from(t5) : r4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r4) ? i(t5, e4) : undefined;
            }
          }(t4)) || e3 && t4 && typeof t4.length == "number") {
            r3 && (t4 = r3);
            var n2 = 0, o2 = function() {};
            return { s: o2, n: function() {
              return n2 >= t4.length ? { done: true } : { done: false, value: t4[n2++] };
            }, e: function(t5) {
              throw t5;
            }, f: o2 };
          }
          throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        var s2, a2 = true, u2 = false;
        return { s: function() {
          r3 = r3.call(t4);
        }, n: function() {
          var t5 = r3.next();
          return a2 = t5.done, t5;
        }, e: function(t5) {
          u2 = true, s2 = t5;
        }, f: function() {
          try {
            a2 || r3.return == null || r3.return();
          } finally {
            if (u2)
              throw s2;
          }
        } };
      }
      function i(t4, e3) {
        (e3 == null || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = Array(e3);r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      function s(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function a(t4) {
        for (var e3 = 1;e3 < arguments.length; e3++) {
          var r3 = arguments[e3] != null ? arguments[e3] : {};
          e3 % 2 ? s(Object(r3), true).forEach(function(e4) {
            u(t4, e4, r3[e4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : s(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      function u(t4, e3, r3) {
        return (e3 = function(t5) {
          var e4 = function(t6) {
            if (n(t6) != "object" || !t6)
              return t6;
            var e5 = t6[Symbol.toPrimitive];
            if (e5 !== undefined) {
              var r4 = e5.call(t6, "string");
              if (n(r4) != "object")
                return r4;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t6);
          }(t5);
          return n(e4) == "symbol" ? e4 : e4 + "";
        }(e3)) in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      var c = r2(6948), l = r2(3916), f = r2(3703), p = r2(1058), h = r2(7300), y = r2(4450), d = r2(6665);
      e2.preparePopulationOptionsMQ = function(t4, e3) {
        var r3, n2 = t4._mongooseOptions.populate, o2 = Object.keys(n2).reduce(function(t5, e4) {
          return t5.concat([n2[e4]]);
        }, []);
        e3.lean != null && o2.filter(function(t5) {
          return (t5 && t5.options && t5.options.lean) == null;
        }).forEach((r3 = e3.lean, function(t5) {
          t5.options || (t5.options = {}), r3 != null && Array.isArray(r3.virtuals) && ((r3 = Object.assign({}, r3)).virtuals = r3.virtuals.filter(function(e4) {
            return typeof e4 == "string" && e4.startsWith(t5.path + ".");
          }).map(function(e4) {
            return e4.slice(t5.path.length + 1);
          })), t5.options.lean = r3;
        }));
        var i2 = t4 && t4.options && t4.options.session || null;
        i2 != null && o2.forEach(function(t5) {
          t5.options != null ? "session" in t5.options || (t5.options.session = i2) : t5.options = { session: i2 };
        });
        for (var s2 = t4._fieldsForExec(), u2 = 0;u2 < o2.length; ++u2)
          o2[u2] instanceof c ? o2[u2] = new c(a(a({}, o2[u2]), {}, { _queryProjection: s2, _localModel: t4.model })) : (o2[u2]._queryProjection = s2, o2[u2]._localModel = t4.model);
        return o2;
      }, e2.createModel = function(t4, r3, n2, o2, i2) {
        t4.hooks.execPreSync("createModel", r3);
        var s2 = t4.schema ? t4.schema.discriminatorMapping : null, a2 = s2 && s2.isRoot ? s2.key : null, u2 = r3[a2];
        if (a2 && u2 && t4.discriminators) {
          var c2 = t4.discriminators[u2] || p(t4.discriminators, u2);
          if (c2) {
            var l2 = y(o2);
            return e2.applyPaths(l2, c2.schema), new c2(undefined, l2, true);
          }
        }
        var f2 = { skipId: true, isNew: false, willInit: true };
        return i2 != null && "defaults" in i2 && (f2.defaults = i2.defaults), new t4(undefined, n2, f2);
      }, e2.createModelAndInit = function(t4, r3, n2, o2, i2, s2, a2) {
        var u2 = s2 ? { populated: s2 } : undefined, c2 = e2.createModel(t4, r3, n2, o2, i2);
        try {
          c2.$init(r3, u2, a2);
        } catch (t5) {
          a2(t5, c2);
        }
      }, e2.applyPaths = function(t4, e3, r3) {
        var i2, s2, a2 = new Set;
        if (t4) {
          s2 = Object.keys(t4);
          for (var u2 = [], c2 = 0;c2 < s2.length; ++c2) {
            var p2 = s2[c2];
            s2[c2][0] === "-" && (delete t4[p2], p2 === "-_id" ? t4._id = 0 : u2.push(p2.slice(1)));
          }
          s2 = Object.keys(t4);
          for (var y2 = 0;y2 < s2.length; ++y2)
            if (s2[y2][0] !== "+") {
              var b = t4[s2[y2]];
              if (h(b) && !(s2[y2] === "_id" && s2.length > 1) && (!(s2[y2] === e3.options.discriminatorKey && s2.length > 1 && b != null) || b)) {
                i2 = !b;
                break;
              }
            }
          for (var m = 0, v = u2;m < v.length; m++) {
            var g = v[m], _ = e3.path(g);
            _ && _.selected && i2 === false ? _ && _.selected && i2 === false && a2.add(g) : (t4[g] = 0, i2 = true);
          }
        }
        var w = [], O = [], S = [];
        switch (function e(r4, n2) {
          if (n2 || (n2 = ""), S.indexOf(r4) !== -1)
            return [];
          S.push(r4);
          var o2 = [];
          return r4.eachPath(function(r5, s3) {
            if (n2 && (r5 = n2 + "." + r5), s3.$isSchemaMap || r5.endsWith(".$*")) {
              var a3 = t4 && "+" + r5 in t4;
              s3.options && s3.options.select === false && !a3 && O.push(r5);
            } else {
              var u3 = D(r5, s3);
              if (u3 != null || Array.isArray(s3) || !s3.$isMongooseArray || s3.$isMongooseDocumentArray || (u3 = D(r5, s3.caster)), u3 != null && o2.push(u3), s3.schema) {
                var c3 = e(s3.schema, r5);
                i2 === false && l(t4, r5, s3.schema, w, c3);
              }
            }
          }), S.pop(), o2;
        }(e3), i2) {
          case true:
            var $, j = o(O);
            try {
              for (j.s();!($ = j.n()).done; ) {
                var P = $.value;
                t4[P] = 0;
              }
            } catch (t5) {
              j.e(t5);
            } finally {
              j.f();
            }
            break;
          case false:
            e3 && e3.paths._id && e3.paths._id.options && e3.paths._id.options.select === false && (t4._id = 0);
            var A, E = o(w);
            try {
              for (E.s();!(A = E.n()).done; ) {
                var x = A.value;
                a2.has(x) || d(t4, x) || (t4[x] = t4[x] || 1);
              }
            } catch (t5) {
              E.e(t5);
            } finally {
              E.f();
            }
            break;
          case undefined:
            if (t4 == null)
              break;
            for (var T = 0, k = Object.keys(t4 || {});T < k.length; T++) {
              var N = k[T];
              N.startsWith("+") && delete t4[N];
            }
            var I, B = o(O);
            try {
              for (B.s();!(I = B.n()).done; ) {
                var M = I.value;
                t4[M] == null && (t4[M] = 0);
              }
            } catch (t5) {
              B.e(t5);
            } finally {
              B.f();
            }
        }
        function D(o2, a3) {
          if (t4 != null && typeof a3.selected == "boolean")
            if (a3.selected === false && t4[o2])
              r3 && (t4[o2] = 0);
            else if (i2 || !a3.selected || o2 !== e3.options.discriminatorKey || t4[o2] == null || t4[o2]) {
              if (i2 !== false || !a3.selected || t4[o2] == null || t4[o2]) {
                var u3 = "+" + o2;
                if (t4 && u3 in t4)
                  return delete t4[u3], void (i2 === false && s2.length > 1 && !~s2.indexOf(o2) && !r3 ? t4[o2] = 1 : i2 == null && r3 && a3.selected === false && (t4[o2] = 0));
                for (var c3 = o2.split("."), l2 = "", p3 = 0;p3 < c3.length; ++p3)
                  if (l2 += l2.length ? "." + c3[p3] : c3[p3], O.indexOf(l2) !== -1)
                    return;
                if (!i2 && a3 && a3.options && a3.options.$skipDiscriminatorCheck)
                  for (var h2 = "", y3 = 0;y3 < c3.length; ++y3) {
                    h2 += (h2.length === 0 ? "" : ".") + c3[y3];
                    var d2 = f(t4, h2, false) || f(t4, h2 + ".$", false);
                    if (d2 && n(d2) !== "object")
                      return;
                  }
                return (a3.selected ? w : O).push(o2), o2;
              }
              delete t4[o2];
            } else
              delete t4[o2];
        }
      };
    }, 3900: (t3, e2, r2) => {
      var n = r2(6400), o = r2(6750), i = r2(3191)(), s = r2(1464), a = r2(2268), u = n("%Math.floor%");
      t3.exports = function(t4, e3) {
        if (typeof t4 != "function")
          throw new a("`fn` is not a function");
        if (typeof e3 != "number" || e3 < 0 || e3 > 4294967295 || u(e3) !== e3)
          throw new a("`length` must be a positive 32-bit integer");
        var r3 = arguments.length > 2 && !!arguments[2], n2 = true, c = true;
        if ("length" in t4 && s) {
          var l = s(t4, "length");
          l && !l.configurable && (n2 = false), l && !l.writable && (c = false);
        }
        return (n2 || c || !r3) && (i ? o(t4, "length", e3, true, true) : o(t4, "length", e3)), t4;
      };
    }, 3916: (t3) => {
      t3.exports = function(t4, e2, r2, n, o) {
        var i = Object.keys(t4).reduce(function(t5, r3) {
          return t5 || r3.startsWith(e2 + ".");
        }, false), s = e2 + "." + r2.options.discriminatorKey;
        i || o.length !== 1 || o[0] !== s || n.splice(n.indexOf(s), 1);
      };
    }, 3940: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (o = function() {
          return !!t4;
        })();
      }
      function i(t4) {
        return i = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, i(t4);
      }
      function s(t4, e3) {
        return s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s(t4, e3);
      }
      var a = function(t4) {
        function e3(t5) {
          return function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), function(t6, e4, r4) {
            return e4 = i(e4), function(t7, e5) {
              if (e5 && (n(e5) == "object" || typeof e5 == "function"))
                return e5;
              if (e5 !== undefined)
                throw new TypeError("Derived constructors may only return object or undefined");
              return function(t8) {
                if (t8 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t8;
              }(t7);
            }(t6, o() ? Reflect.construct(e4, r4 || [], i(t6).constructor) : e4.apply(t6, r4));
          }(this, e3, ["Can't save() the same doc multiple times in parallel. Document: " + t5._doc._id]);
        }
        return function(t5, e4) {
          if (typeof e4 != "function" && e4 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(8213));
      Object.defineProperty(a.prototype, "name", { value: "ParallelSaveError" }), t3.exports = a;
    }, 4009: (t3, e2, r2) => {
      var n = r2(8213), o = r2(5188), i = r2(3622), s = r2(5678), a = r2(7352), u = r2(8768), c = /(\.\d+$|\.\d+\.)/g;
      t3.exports = function(t4, e3, r3, l, f) {
        if (t4 == null)
          return [];
        if (typeof t4 == "string" && f != null && o(f, t4))
          throw new n("refPath `" + t4 + "` must not be excluded in projection, got " + a.inspect(f));
        if (c.test(r3)) {
          var p = r3.split(c);
          if (p[p.length - 1] === "")
            throw new Error("Can't populate individual element in an array");
          for (var h = "", y = t4, d = 0;d < p.length; d += 2) {
            var b = p[d];
            if (!y.startsWith(b + ".")) {
              if (d === p.length - 1) {
                h += y, y = "";
                break;
              }
              throw new Error("Could not normalize ref path, chunk " + b + " not in populated path");
            }
            h += y.substring(0, b.length) + p[d + 1], y = y.substring(b.length + 1);
          }
          var m = s.get(h, e3, i), v = Array.isArray(m) ? m : [m];
          return u.array.flatten(v);
        }
        var g = s.get(t4, e3, i);
        return l != null && l.virtuals.hasOwnProperty(t4) ? [l.virtuals[t4].applyGetters(undefined, e3)] : Array.isArray(g) ? g : [g];
      };
    }, 4026: (t3, e2) => {
      e2.Collection = function() {
        throw new Error("Cannot create a collection from browser library");
      }, e2.Connection = function() {
        throw new Error("Cannot create a connection from browser library");
      }, e2.BulkWriteResult = function() {};
    }, 4058: (t3, e2, r2) => {
      var n = r2(6353).Long, o = 9223372036854775807n, i = -9223372036854775808n, s = "Mongoose only supports BigInts between ".concat(i, " and ").concat(o, " because MongoDB does not support arbitrary precision integers");
      t3.exports = function(t4) {
        if (t4 == null)
          return t4;
        if (t4 === "")
          return null;
        if (typeof t4 == "bigint") {
          if (t4 > o || t4 < i)
            throw new Error(s);
          return t4;
        }
        if (t4 instanceof n)
          return t4.toBigInt();
        if (typeof t4 == "string" || typeof t4 == "number") {
          if ((t4 = BigInt(t4)) > o || t4 < i)
            throw new Error(s);
          return t4;
        }
        throw new Error('Cannot convert value to BigInt: "'.concat(t4, '"'));
      };
    }, 4070: (t3, e2, r2) => {
      function n(t4, e3) {
        (e3 == null || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = Array(e3);r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      var o = r2(8260);
      t3.exports = function(t4) {
        if (o(t4) !== "TopologyDescription")
          return false;
        if (t4.servers.size === 0)
          return false;
        var e3, r3 = function(t5, e4) {
          var r4 = typeof Symbol != "undefined" && t5[Symbol.iterator] || t5["@@iterator"];
          if (!r4) {
            if (Array.isArray(t5) || (r4 = function(t6, e5) {
              if (t6) {
                if (typeof t6 == "string")
                  return n(t6, e5);
                var r5 = {}.toString.call(t6).slice(8, -1);
                return r5 === "Object" && t6.constructor && (r5 = t6.constructor.name), r5 === "Map" || r5 === "Set" ? Array.from(t6) : r5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? n(t6, e5) : undefined;
              }
            }(t5)) || e4 && t5 && typeof t5.length == "number") {
              r4 && (t5 = r4);
              var o2 = 0, i2 = function() {};
              return { s: i2, n: function() {
                return o2 >= t5.length ? { done: true } : { done: false, value: t5[o2++] };
              }, e: function(t6) {
                throw t6;
              }, f: i2 };
            }
            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }
          var s, a = true, u = false;
          return { s: function() {
            r4 = r4.call(t5);
          }, n: function() {
            var t6 = r4.next();
            return a = t6.done, t6;
          }, e: function(t6) {
            u = true, s = t6;
          }, f: function() {
            try {
              a || r4.return == null || r4.return();
            } finally {
              if (u)
                throw s;
            }
          } };
        }(t4.servers.values());
        try {
          for (r3.s();!(e3 = r3.n()).done; ) {
            var i = e3.value;
            if (i.host.endsWith(".mongodb.net") === false || i.port !== 27017)
              return false;
          }
        } catch (t5) {
          r3.e(t5);
        } finally {
          r3.f();
        }
        return true;
      };
    }, 4183: (t3, e2, r2) => {
      var n = r2(118);
      t3.exports = function() {
        return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : n;
      };
    }, 4224: (t3, e2, r2) => {
      var n = r2(6511).ctor("require", "modify", "init", "default", "ignore");
      function o() {
        this.activePaths = new n;
      }
      t3.exports = o, o.prototype.strictMode = true, o.prototype.fullPath = undefined, o.prototype.selected = undefined, o.prototype.shardval = undefined, o.prototype.saveError = undefined, o.prototype.validationError = undefined, o.prototype.adhocPaths = undefined, o.prototype.removing = undefined, o.prototype.inserting = undefined, o.prototype.saving = undefined, o.prototype.version = undefined, o.prototype._id = undefined, o.prototype.ownerDocument = undefined, o.prototype.populate = undefined, o.prototype.populated = undefined, o.prototype.primitiveAtomics = undefined, o.prototype.wasPopulated = false, o.prototype.scope = undefined, o.prototype.session = null, o.prototype.pathsToScopes = null, o.prototype.cachedRequired = null;
    }, 4301: (t3, e2, r2) => {
      var n = r2(9539), o = r2(2793), i = r2(3305), s = r2(5549), a = r2(608);
      t3.exports = function t(e3, r3, u, c) {
        var l, f = Object.keys(r3), p = 0, h = f.length;
        if (u = u || "", !(c = c || new WeakSet).has(r3)) {
          for (c.add(r3);p < h; )
            if (l = f[p++], (u || l !== "discriminators" && l !== "base" && l !== "_applyDiscriminators" && l !== "_userProvidedOptions" && l !== "options" && l !== "tree") && !(u === "tree" && r3 != null && r3.instanceOfSchema || o.has(l))) {
              if (e3[l] == null)
                e3[l] = r3[l];
              else if (a(r3[l])) {
                if (a(e3[l]) || (e3[l] = {}), r3[l] != null) {
                  if (r3[l].$isSingleNested && e3[l].$isMongooseDocumentArray || r3[l].$isMongooseDocumentArray && e3[l].$isSingleNested || r3[l].$isMongooseDocumentArrayElement && e3[l].$isMongooseDocumentArrayElement)
                    continue;
                  if (r3[l].instanceOfSchema) {
                    e3[l].instanceOfSchema ? n(e3[l], r3[l].clone(), true) : e3[l] = r3[l].clone();
                    continue;
                  }
                  if (i(r3[l], "ObjectId")) {
                    e3[l] = new s(r3[l]);
                    continue;
                  }
                }
                t(e3[l], r3[l], u ? u + "." + l : l, c);
              }
            }
          r3 != null && r3.instanceOfSchema && (e3.tree = Object.assign({}, r3.tree, e3.tree));
        }
      };
    }, 4327: (t3) => {
      t3.exports = function(t4, e2, r2, n) {
        return r2 ? n ? { bsonType: e2 } : { bsonType: [e2, "null"] } : n ? { type: t4 } : { type: [t4, "null"] };
      };
    }, 4432: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o(t4) {
        if (t4 != null) {
          var e3 = t4[typeof Symbol == "function" && Symbol.iterator || "@@iterator"], r3 = 0;
          if (e3)
            return e3.call(t4);
          if (typeof t4.next == "function")
            return t4;
          if (!isNaN(t4.length))
            return { next: function() {
              return t4 && r3 >= t4.length && (t4 = undefined), { value: t4 && t4[r3++], done: !t4 };
            } };
        }
        throw new TypeError(n(t4) + " is not iterable");
      }
      function i() {
        var t4, e3, r3 = typeof Symbol == "function" ? Symbol : {}, n2 = r3.iterator || "@@iterator", o2 = r3.toStringTag || "@@toStringTag";
        function a2(r4, n3, o3, i2) {
          var a3 = n3 && n3.prototype instanceof c2 ? n3 : c2, l3 = Object.create(a3.prototype);
          return s(l3, "_invoke", function(r5, n4, o4) {
            var i3, s2, a4, c3 = 0, l4 = o4 || [], f3 = false, p2 = { p: 0, n: 0, v: t4, a: h2, f: h2.bind(t4, 4), d: function(e4, r6) {
              return i3 = e4, s2 = 0, a4 = t4, p2.n = r6, u2;
            } };
            function h2(r6, n5) {
              for (s2 = r6, a4 = n5, e3 = 0;!f3 && c3 && !o5 && e3 < l4.length; e3++) {
                var o5, i4 = l4[e3], h3 = p2.p, y2 = i4[2];
                r6 > 3 ? (o5 = y2 === n5) && (a4 = i4[(s2 = i4[4]) ? 5 : (s2 = 3, 3)], i4[4] = i4[5] = t4) : i4[0] <= h3 && ((o5 = r6 < 2 && h3 < i4[1]) ? (s2 = 0, p2.v = n5, p2.n = i4[1]) : h3 < y2 && (o5 = r6 < 3 || i4[0] > n5 || n5 > y2) && (i4[4] = r6, i4[5] = n5, p2.n = y2, s2 = 0));
              }
              if (o5 || r6 > 1)
                return u2;
              throw f3 = true, n5;
            }
            return function(o5, l5, y2) {
              if (c3 > 1)
                throw TypeError("Generator is already running");
              for (f3 && l5 === 1 && h2(l5, y2), s2 = l5, a4 = y2;(e3 = s2 < 2 ? t4 : a4) || !f3; ) {
                i3 || (s2 ? s2 < 3 ? (s2 > 1 && (p2.n = -1), h2(s2, a4)) : p2.n = a4 : p2.v = a4);
                try {
                  if (c3 = 2, i3) {
                    if (s2 || (o5 = "next"), e3 = i3[o5]) {
                      if (!(e3 = e3.call(i3, a4)))
                        throw TypeError("iterator result is not an object");
                      if (!e3.done)
                        return e3;
                      a4 = e3.value, s2 < 2 && (s2 = 0);
                    } else
                      s2 === 1 && (e3 = i3.return) && e3.call(i3), s2 < 2 && (a4 = TypeError("The iterator does not provide a '" + o5 + "' method"), s2 = 1);
                    i3 = t4;
                  } else if ((e3 = (f3 = p2.n < 0) ? a4 : r5.call(n4, p2)) !== u2)
                    break;
                } catch (e4) {
                  i3 = t4, s2 = 1, a4 = e4;
                } finally {
                  c3 = 1;
                }
              }
              return { value: e3, done: f3 };
            };
          }(r4, o3, i2), true), l3;
        }
        var u2 = {};
        function c2() {}
        function l2() {}
        function f2() {}
        e3 = Object.getPrototypeOf;
        var p = [][n2] ? e3(e3([][n2]())) : (s(e3 = {}, n2, function() {
          return this;
        }), e3), h = f2.prototype = c2.prototype = Object.create(p);
        function y(t5) {
          return Object.setPrototypeOf ? Object.setPrototypeOf(t5, f2) : (t5.__proto__ = f2, s(t5, o2, "GeneratorFunction")), t5.prototype = Object.create(h), t5;
        }
        return l2.prototype = f2, s(h, "constructor", f2), s(f2, "constructor", l2), l2.displayName = "GeneratorFunction", s(f2, o2, "GeneratorFunction"), s(h), s(h, o2, "Generator"), s(h, n2, function() {
          return this;
        }), s(h, "toString", function() {
          return "[object Generator]";
        }), (i = function() {
          return { w: a2, m: y };
        })();
      }
      function s(t4, e3, r3, n2) {
        var o2 = Object.defineProperty;
        try {
          o2({}, "", {});
        } catch (t5) {
          o2 = 0;
        }
        s = function(t5, e4, r4, n3) {
          function i2(e5, r5) {
            s(t5, e5, function(t6) {
              return this._invoke(e5, r5, t6);
            });
          }
          e4 ? o2 ? o2(t5, e4, { value: r4, enumerable: !n3, configurable: !n3, writable: !n3 }) : t5[e4] = r4 : (i2("next", 0), i2("throw", 1), i2("return", 2));
        }, s(t4, e3, r3, n2);
      }
      function a(t4, e3) {
        var r3 = typeof Symbol != "undefined" && t4[Symbol.iterator] || t4["@@iterator"];
        if (!r3) {
          if (Array.isArray(t4) || (r3 = function(t5, e4) {
            if (t5) {
              if (typeof t5 == "string")
                return u(t5, e4);
              var r4 = {}.toString.call(t5).slice(8, -1);
              return r4 === "Object" && t5.constructor && (r4 = t5.constructor.name), r4 === "Map" || r4 === "Set" ? Array.from(t5) : r4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r4) ? u(t5, e4) : undefined;
            }
          }(t4)) || e3 && t4 && typeof t4.length == "number") {
            r3 && (t4 = r3);
            var n2 = 0, o2 = function() {};
            return { s: o2, n: function() {
              return n2 >= t4.length ? { done: true } : { done: false, value: t4[n2++] };
            }, e: function(t5) {
              throw t5;
            }, f: o2 };
          }
          throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        var i2, s2 = true, a2 = false;
        return { s: function() {
          r3 = r3.call(t4);
        }, n: function() {
          var t5 = r3.next();
          return s2 = t5.done, t5;
        }, e: function(t5) {
          a2 = true, i2 = t5;
        }, f: function() {
          try {
            s2 || r3.return == null || r3.return();
          } finally {
            if (a2)
              throw i2;
          }
        } };
      }
      function u(t4, e3) {
        (e3 == null || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = Array(e3);r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      function c(t4, e3, r3, n2, o2, i2, s2) {
        try {
          var a2 = t4[i2](s2), u2 = a2.value;
        } catch (t5) {
          return void r3(t5);
        }
        a2.done ? e3(u2) : Promise.resolve(u2).then(n2, o2);
      }
      function l(t4) {
        return function() {
          var e3 = this, r3 = arguments;
          return new Promise(function(n2, o2) {
            var i2 = t4.apply(e3, r3);
            function s2(t5) {
              c(i2, n2, o2, s2, a2, "next", t5);
            }
            function a2(t5) {
              c(i2, n2, o2, s2, a2, "throw", t5);
            }
            s2(undefined);
          });
        };
      }
      var f = r2(5782);
      t3.exports = function(t4) {
        var e3 = true;
        t4.s.hooks.pre("save", false, function(t5) {
          if (this.$isSubdocument)
            t5();
          else {
            var e4 = this, r3 = this.$getAllSubdocs({ useCache: true });
            r3.length ? f(r3, function(t6, e5) {
              t6.$__schema.s.hooks.execPre("save", t6, function(t7) {
                e5(t7);
              });
            }, function(r4) {
              if (e4.$__.saveOptions && (e4.$__.saveOptions.__subdocs = null), r4)
                return e4.$__schema.s.hooks.execPost("save:error", e4, [e4], { error: r4 }, function(e5) {
                  t5(e5);
                });
              t5();
            }) : t5();
          }
        }, null, e3), t4.s.hooks.post("save", function() {
          var t5 = l(i().m(function t() {
            var e4, r3, n2, s2, u2, c2;
            return i().w(function(t6) {
              for (;; )
                switch (t6.p = t6.n) {
                  case 0:
                    if ((e4 = this.$__.removedSubdocs) && e4.length) {
                      t6.n = 1;
                      break;
                    }
                    return t6.a(2);
                  case 1:
                    r3 = [], n2 = a(e4), t6.p = 2, u2 = i().m(function t() {
                      var e5;
                      return i().w(function(t7) {
                        for (;; )
                          switch (t7.n) {
                            case 0:
                              e5 = s2.value, r3.push(new Promise(function(t8, r4) {
                                e5.$__schema.s.hooks.execPost("deleteOne", e5, [e5], function(e6) {
                                  if (e6)
                                    return r4(e6);
                                  t8();
                                });
                              }));
                            case 1:
                              return t7.a(2);
                          }
                      }, t);
                    }), n2.s();
                  case 3:
                    if ((s2 = n2.n()).done) {
                      t6.n = 5;
                      break;
                    }
                    return t6.d(o(u2()), 4);
                  case 4:
                    t6.n = 3;
                    break;
                  case 5:
                    t6.n = 7;
                    break;
                  case 6:
                    t6.p = 6, c2 = t6.v, n2.e(c2);
                  case 7:
                    return t6.p = 7, n2.f(), t6.f(7);
                  case 8:
                    return this.$__.removedSubdocs = null, t6.n = 9, Promise.all(r3);
                  case 9:
                    return t6.a(2);
                }
            }, t, this, [[2, 6, 7, 8]]);
          }));
          return function() {
            return t5.apply(this, arguments);
          };
        }()), t4.s.hooks.post("save", function() {
          var t5 = l(i().m(function t() {
            var e4, r3, n2, s2, u2, c2, l2, f2, p = this;
            return i().w(function(t6) {
              for (;; )
                switch (t6.p = t6.n) {
                  case 0:
                    if (!this.$isSubdocument) {
                      t6.n = 1;
                      break;
                    }
                    return t6.a(2);
                  case 1:
                    if (e4 = this, (r3 = this.$getAllSubdocs({ useCache: true })).length) {
                      t6.n = 2;
                      break;
                    }
                    return t6.a(2);
                  case 2:
                    n2 = [], s2 = a(r3), t6.p = 3, c2 = i().m(function t() {
                      var e5;
                      return i().w(function(t7) {
                        for (;; )
                          switch (t7.n) {
                            case 0:
                              e5 = u2.value, n2.push(new Promise(function(t8, r4) {
                                e5.$__schema.s.hooks.execPost("save", e5, [e5], function(e6) {
                                  if (e6)
                                    return r4(e6);
                                  t8();
                                });
                              }));
                            case 1:
                              return t7.a(2);
                          }
                      }, t);
                    }), s2.s();
                  case 4:
                    if ((u2 = s2.n()).done) {
                      t6.n = 6;
                      break;
                    }
                    return t6.d(o(c2()), 5);
                  case 5:
                    t6.n = 4;
                    break;
                  case 6:
                    t6.n = 8;
                    break;
                  case 7:
                    t6.p = 7, l2 = t6.v, s2.e(l2);
                  case 8:
                    return t6.p = 8, s2.f(), t6.f(8);
                  case 9:
                    return t6.p = 9, t6.n = 10, Promise.all(n2);
                  case 10:
                    t6.n = 12;
                    break;
                  case 11:
                    return t6.p = 11, f2 = t6.v, t6.n = 12, new Promise(function(t7, r4) {
                      p.$__schema.s.hooks.execPost("save:error", e4, [e4], { error: f2 }, function(e5) {
                        if (e5)
                          return r4(e5);
                        t7();
                      });
                    });
                  case 12:
                    return t6.a(2);
                }
            }, t, this, [[9, 11], [3, 7, 8, 9]]);
          }));
          return function() {
            return t5.apply(this, arguments);
          };
        }(), null, e3);
      };
    }, 4450: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var o = r2(9639), i = r2(5549), s = r2(2793), a = r2(2497), u = r2(9696), c = r2(3305), l = r2(1243).isMongooseArray, f = r2(608), p = r2(2789), h = r2(7930), y = r2(7291).trustedSymbol, d = r2(6353);
      function b(t4, e3, r3) {
        if (t4 == null)
          return t4;
        if (c(t4, "Double"))
          return new d.Double(t4.value);
        if (typeof t4 == "number" || typeof t4 == "string" || typeof t4 == "boolean" || typeof t4 == "bigint")
          return t4;
        if (Array.isArray(t4))
          return function(t5, e4) {
            var r4 = 0, n2 = t5.length, o2 = new Array(n2);
            for (r4 = 0;r4 < n2; ++r4)
              o2[r4] = b(t5[r4], e4, true);
            return o2;
          }(l(t4) ? t4.__array : t4, e3);
        if (a(t4)) {
          if (e3 && e3.retainDocuments && t4.$__ != null) {
            var s2 = t4.$clone();
            return t4.__index != null && (s2.__index = t4.__index), t4.__parentArray != null && (s2.__parentArray = t4.__parentArray), s2.$__parent = t4.$__parent, s2;
          }
          return p(t4) && t4.$__ != null && t4._doc != null ? t4._doc : e3 && e3.json && typeof t4.toJSON == "function" ? t4.toJSON(e3) : t4.toObject(e3);
        }
        var y2, v, g = t4.constructor;
        if (g)
          switch (u(g)) {
            case "Object":
              return m(t4, e3, r3);
            case "Date":
              return new g(+t4);
            case "RegExp":
              return y2 = t4, (v = new RegExp(y2.source, y2.flags)).lastIndex !== y2.lastIndex && (v.lastIndex = y2.lastIndex), v;
          }
        return c(t4, "ObjectId") ? e3 && e3.flattenObjectIds ? t4.toJSON() : new i(t4.id) : c(t4, "Decimal128") ? e3 && e3.flattenDecimals ? t4.toJSON() : o.fromString(t4.toString()) : !g && f(t4) ? m(t4, e3, r3) : n(t4) === "object" && t4[h.schemaTypeSymbol] ? t4.clone() : e3 && e3.bson && typeof t4.toBSON == "function" ? t4 : typeof t4.valueOf == "function" ? t4.valueOf() : m(t4, e3, r3);
      }
      function m(t4, e3, r3) {
        var n2, o2 = e3 && e3.minimize, i2 = e3 && e3.omitUndefined, a2 = e3 && e3._seen, u2 = {};
        if (a2 && a2.has(t4))
          return a2.get(t4);
        a2 && a2.set(t4, u2), y in t4 && (e3 == null ? undefined : e3.copyTrustedSymbol) !== false && (u2[y] = t4[y]);
        for (var c2 = Object.keys(t4), l2 = c2.length, f2 = 0;f2 < l2; ++f2) {
          var p2 = c2[f2];
          if (!s.has(p2)) {
            var h2 = b(t4[p2], e3, false);
            o2 !== false && !i2 || h2 !== undefined ? o2 === true && h2 === undefined || (n2 || (n2 = true), u2[p2] = h2) : delete u2[p2];
          }
        }
        return o2 && !r3 ? n2 && u2 : u2;
      }
      t3.exports = b;
    }, 4473: (t3) => {
      function e2(t4, r2) {
        var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set;
        if (n.has(t4))
          throw new Error("Infinite subdocument loop: subdoc with _id " + t4._id + " is a parent of itself");
        var o = t4.$parent(), i = t4.$__pathRelativeToParent(undefined, false) + "." + r2;
        o.$__.activePaths.clearPath(i), o.$isSubdocument && e2(o, i, n);
      }
      t3.exports = function(t4, r2, n) {
        var o = (n = n || {}).skipDocArrays, i = 0;
        if (!t4)
          return i;
        for (var s = 0, a = Object.keys(t4.$__.activePaths.getStatePaths("modify"));s < a.length; s++) {
          var u = a[s];
          if (o) {
            var c = t4.$__schema.path(u);
            if (c && c.$isMongooseDocumentArray)
              continue;
          }
          u.startsWith(r2 + ".") && (t4.$__.activePaths.clearPath(u), ++i, t4.$isSubdocument && e2(t4, u));
        }
        return i;
      };
    }, 4561: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (o = function() {
          return !!t4;
        })();
      }
      function i(t4) {
        return i = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, i(t4);
      }
      function s(t4, e3) {
        return s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s(t4, e3);
      }
      var a = function(t4) {
        function e3() {
          return function(t5, e4) {
            if (!(t5 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), function(t5, e4, r4) {
            return e4 = i(e4), function(t6, e5) {
              if (e5 && (n(e5) == "object" || typeof e5 == "function"))
                return e5;
              if (e5 !== undefined)
                throw new TypeError("Derived constructors may only return object or undefined");
              return function(t7) {
                if (t7 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t7;
              }(t6);
            }(t5, o() ? Reflect.construct(e4, r4 || [], i(t5).constructor) : e4.apply(t5, r4));
          }(this, e3, arguments);
        }
        return function(t5, e4) {
          if (typeof e4 != "function" && e4 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(8879)), u = r2(5761);
      Object.defineProperty(a.prototype, "excludeIndexes", u), Object.defineProperty(a.prototype, "_id", u), t3.exports = a;
    }, 4592: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (o = function() {
          return !!t4;
        })();
      }
      function i(t4) {
        return i = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, i(t4);
      }
      function s(t4, e3) {
        return s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s(t4, e3);
      }
      var a = function(t4) {
        function e3() {
          return function(t5, e4) {
            if (!(t5 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), function(t5, e4, r4) {
            return e4 = i(e4), function(t6, e5) {
              if (e5 && (n(e5) == "object" || typeof e5 == "function"))
                return e5;
              if (e5 !== undefined)
                throw new TypeError("Derived constructors may only return object or undefined");
              return function(t7) {
                if (t7 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t7;
              }(t6);
            }(t5, o() ? Reflect.construct(e4, r4 || [], i(t5).constructor) : e4.apply(t5, r4));
          }(this, e3, arguments);
        }
        return function(t5, e4) {
          if (typeof e4 != "function" && e4 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(8879)), u = r2(5761);
      Object.defineProperty(a.prototype, "enum", u), Object.defineProperty(a.prototype, "of", u), Object.defineProperty(a.prototype, "castNonArrays", u), t3.exports = a;
    }, 4625: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (o = function() {
          return !!t4;
        })();
      }
      function i(t4) {
        return i = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, i(t4);
      }
      function s(t4, e3) {
        return s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s(t4, e3);
      }
      var a = function(t4) {
        function e3() {
          return function(t5, e4) {
            if (!(t5 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), function(t5, e4, r4) {
            return e4 = i(e4), function(t6, e5) {
              if (e5 && (n(e5) == "object" || typeof e5 == "function"))
                return e5;
              if (e5 !== undefined)
                throw new TypeError("Derived constructors may only return object or undefined");
              return function(t7) {
                if (t7 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t7;
              }(t6);
            }(t5, o() ? Reflect.construct(e4, r4 || [], i(t5).constructor) : e4.apply(t5, r4));
          }(this, e3, arguments);
        }
        return function(t5, e4) {
          if (typeof e4 != "function" && e4 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(8879)), u = r2(5761);
      Object.defineProperty(a.prototype, "auto", u), Object.defineProperty(a.prototype, "populate", u), t3.exports = a;
    }, 4756: (t3) => {
      var e2 = function(t4) {
        return t4 != t4;
      };
      t3.exports = function(t4, r2) {
        return t4 === 0 && r2 === 0 ? 1 / t4 == 1 / r2 : t4 === r2 || !(!e2(t4) || !e2(r2));
      };
    }, 4829: (t3, e2, r2) => {
      t3.exports = r2(8533);
    }, 4859: (t3, e2, r2) => {
      var n = r2(5832).hp;
      function o(t4, e3) {
        var r3 = typeof Symbol != "undefined" && t4[Symbol.iterator] || t4["@@iterator"];
        if (!r3) {
          if (Array.isArray(t4) || (r3 = function(t5, e4) {
            if (t5) {
              if (typeof t5 == "string")
                return i(t5, e4);
              var r4 = {}.toString.call(t5).slice(8, -1);
              return r4 === "Object" && t5.constructor && (r4 = t5.constructor.name), r4 === "Map" || r4 === "Set" ? Array.from(t5) : r4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r4) ? i(t5, e4) : undefined;
            }
          }(t4)) || e3 && t4 && typeof t4.length == "number") {
            r3 && (t4 = r3);
            var n2 = 0, o2 = function() {};
            return { s: o2, n: function() {
              return n2 >= t4.length ? { done: true } : { done: false, value: t4[n2++] };
            }, e: function(t5) {
              throw t5;
            }, f: o2 };
          }
          throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        var s2, a2 = true, u2 = false;
        return { s: function() {
          r3 = r3.call(t4);
        }, n: function() {
          var t5 = r3.next();
          return a2 = t5.done, t5;
        }, e: function(t5) {
          u2 = true, s2 = t5;
        }, f: function() {
          try {
            a2 || r3.return == null || r3.return();
          } finally {
            if (u2)
              throw s2;
          }
        } };
      }
      function i(t4, e3) {
        (e3 == null || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = Array(e3);r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      var s = r2(8920), a = r2(2400), u = r2(863), c = r2(1058), l = r2(3303)._, f = r2(8768), p = r2(3305), h = r2(7930).arrayParentSymbol, y = r2(7930).arrayPathSymbol, d = r2(7930).arraySchemaSymbol, b = r2(7930).documentArrayParent, m = Array.prototype.toString, v = { toBSON: function() {
        return this.toObject(l);
      }, toString: function() {
        return m.call(this.__array.map(function(t4) {
          return t4 != null && t4.$__ != null ? t4.toString() : t4;
        }));
      }, getArrayParent: function() {
        return this[h];
      }, _cast: function(t4, e3, r3) {
        if (this[d] == null)
          return t4;
        var o2 = this[d].casterConstructor;
        if ((o2.$isMongooseDocumentArray ? f.isMongooseDocumentArray(t4) : t4 instanceof o2) || t4 && t4.constructor && t4.constructor.baseCasterConstructor === o2)
          return t4[b] && t4.__parentArray || (t4[b] = this[h], t4.__parentArray = this), t4.$setIndex(e3), t4;
        if (t4 == null)
          return null;
        if ((n.isBuffer(t4) || p(t4, "ObjectId") || !f.isObject(t4)) && (t4 = { _id: t4 }), t4 && o2.discriminators && o2.schema && o2.schema.options && o2.schema.options.discriminatorKey)
          if (typeof t4[o2.schema.options.discriminatorKey] == "string" && o2.discriminators[t4[o2.schema.options.discriminatorKey]])
            o2 = o2.discriminators[t4[o2.schema.options.discriminatorKey]];
          else {
            var i2 = c(o2.discriminators, t4[o2.schema.options.discriminatorKey]);
            i2 && (o2 = i2);
          }
        if (o2.$isMongooseDocumentArray)
          return o2.cast(t4, this, undefined, undefined, e3);
        var s2 = new o2(t4, this, r3, undefined, e3);
        return s2.isNew = true, s2;
      }, id: function(t4) {
        var e3, r3, n2;
        try {
          e3 = u(t4).toString();
        } catch (t5) {
          e3 = null;
        }
        var i2, s2 = o(this);
        try {
          for (s2.s();!(i2 = s2.n()).done; ) {
            var c2 = i2.value;
            if (c2 && (n2 = c2.get("_id")) != null) {
              if (n2 instanceof a) {
                if (r3 || (r3 = String(t4)), r3 == n2._id)
                  return c2;
              } else if (p(t4, "ObjectId") || p(n2, "ObjectId")) {
                if (e3 == n2)
                  return c2;
              } else if (t4 == n2 || f.deepEqual(t4, n2))
                return c2;
            }
          }
        } catch (t5) {
          s2.e(t5);
        } finally {
          s2.f();
        }
        return null;
      }, toObject: function(t4) {
        return [].concat(this.map(function(e3) {
          return e3 == null ? null : typeof e3.toObject != "function" ? e3 : e3.toObject(t4);
        }));
      }, $toObject: function() {
        return this.constructor.prototype.toObject.apply(this, arguments);
      }, push: function() {
        var t4 = s.push.apply(this, arguments);
        return g(this), t4;
      }, pull: function() {
        var t4 = s.pull.apply(this, arguments);
        return g(this), t4;
      }, shift: function() {
        var t4 = s.shift.apply(this, arguments);
        return g(this), t4;
      }, splice: function() {
        var t4 = s.splice.apply(this, arguments);
        return g(this), t4;
      }, inspect: function() {
        return this.toObject();
      }, create: function(t4) {
        var e3 = this[d].casterConstructor;
        if (t4 && e3.discriminators && e3.schema && e3.schema.options && e3.schema.options.discriminatorKey)
          if (typeof t4[e3.schema.options.discriminatorKey] == "string" && e3.discriminators[t4[e3.schema.options.discriminatorKey]])
            e3 = e3.discriminators[t4[e3.schema.options.discriminatorKey]];
          else {
            var r3 = c(e3.discriminators, t4[e3.schema.options.discriminatorKey]);
            r3 && (e3 = r3);
          }
        return new e3(t4, this);
      }, notify: function(t4) {
        var e3 = this;
        return function r(n2, o2) {
          for (var i2 = (o2 = o2 || e3).length;i2--; )
            o2[i2] != null && (t4 === "save" && (n2 = e3[i2]), f.isMongooseArray(o2[i2]) ? r(n2, o2[i2]) : o2[i2] && o2[i2].emit(t4, n2));
        };
      }, set: function(t4, e3, r3) {
        var n2 = this.__array;
        if (r3)
          return n2[t4] = e3, this;
        var o2 = v._cast.call(this, e3, t4);
        return v._markModified.call(this, t4), n2[t4] = o2, this;
      }, _markModified: function(t4, e3) {
        var r3, n2 = this[h];
        if (n2) {
          if (r3 = this[y], arguments.length && (r3 = e3 != null ? r3 + "." + t4.__index + "." + e3 : r3 + "." + t4), r3 != null && r3.endsWith(".$"))
            return this;
          n2.markModified(r3, arguments.length !== 0 ? t4 : n2);
        }
        return this;
      } };
      function g(t4) {
        var e3 = t4[h];
        if (e3 && e3.$__.populated != null) {
          var r3, n2 = o(Object.keys(e3.$__.populated).filter(function(e4) {
            return e4.startsWith(t4[y] + ".");
          }));
          try {
            var i2 = function() {
              var n3 = r3.value, o2 = n3.slice((t4[y] + ".").length);
              if (!Array.isArray(e3.$__.populated[n3].value))
                return 1;
              e3.$__.populated[n3].value = t4.map(function(t5) {
                return t5.$populated(o2);
              });
            };
            for (n2.s();!(r3 = n2.n()).done; )
              i2();
          } catch (t5) {
            n2.e(t5);
          } finally {
            n2.f();
          }
        }
      }
      t3.exports = v;
    }, 4878: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o(t4, e3, r3) {
        return (e3 = function(t5) {
          var e4 = function(t6) {
            if (n(t6) != "object" || !t6)
              return t6;
            var e5 = t6[Symbol.toPrimitive];
            if (e5 !== undefined) {
              var r4 = e5.call(t6, "string");
              if (n(r4) != "object")
                return r4;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t6);
          }(t5);
          return n(e4) == "symbol" ? e4 : e4 + "";
        }(e3)) in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      var i = r2(8920), s = r2(4859), a = r2(7930).arrayAtomicsSymbol, u = r2(7930).arrayAtomicsBackupSymbol, c = r2(7930).arrayParentSymbol, l = r2(7930).arrayPathSymbol, f = r2(7930).arraySchemaSymbol, p = Array.prototype.push, h = /^\d+$/;
      t3.exports = function(t4, e3, r3, n2) {
        var y = [], d = o(o(o(o(o({}, a, {}), u, undefined), l, e3), f, undefined), c, undefined);
        if (Array.isArray(t4) && (t4[l] === e3 && t4[c] === r3 && (d[a] = Object.assign({}, t4[a])), t4.forEach(function(t5) {
          p.call(y, t5);
        })), d[l] = e3, d.__array = y, r3 && r3.$__)
          for (d[c] = r3, d[f] = r3.$__schema.path(e3);d[f] != null && d[f].$isMongooseArray && !d[f].$isMongooseDocumentArray; )
            d[f] = d[f].casterConstructor;
        var b = new Proxy(y, { get: function(t5, e4) {
          return e4 === "isMongooseArray" || e4 === "isMongooseArrayProxy" || e4 === "isMongooseDocumentArray" || e4 === "isMongooseDocumentArrayProxy" || (d.hasOwnProperty(e4) ? d[e4] : s.hasOwnProperty(e4) ? s[e4] : n2 && n2.virtuals && n2.virtuals.hasOwnProperty(e4) ? n2.virtuals[e4].applyGetters(undefined, t5) : i.hasOwnProperty(e4) ? i[e4] : y[e4]);
        }, set: function(t5, e4, r4) {
          return typeof e4 == "string" && h.test(e4) ? s.set.call(b, e4, r4, false) : d.hasOwnProperty(e4) ? d[e4] = r4 : n2 && n2.virtuals && n2.virtuals.hasOwnProperty(e4) ? n2.virtuals[e4].applySetters(r4, t5) : y[e4] = r4, true;
        } });
        return b;
      };
    }, 4957: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function i(t4) {
        for (var e3 = 1;e3 < arguments.length; e3++) {
          var r3 = arguments[e3] != null ? arguments[e3] : {};
          e3 % 2 ? o(Object(r3), true).forEach(function(e4) {
            s(t4, e4, r3[e4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : o(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      function s(t4, e3, r3) {
        return (e3 = function(t5) {
          var e4 = function(t6) {
            if (n(t6) != "object" || !t6)
              return t6;
            var e5 = t6[Symbol.toPrimitive];
            if (e5 !== undefined) {
              var r4 = e5.call(t6, "string");
              if (n(r4) != "object")
                return r4;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t6);
          }(t5);
          return n(e4) == "symbol" ? e4 : e4 + "";
        }(e3)) in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      var a = r2(7160), u = r2(5268);
      t3.exports = l, l.middlewareFunctions = ["deleteOne", "save", "validate", "remove", "updateOne", "init"];
      var c = new Set(l.middlewareFunctions.flatMap(function(t4) {
        return [t4, "$__".concat(t4)];
      }));
      function l(t4, e3, r3) {
        var n2 = { useErrorHandlers: true, numCallbackParams: 1, nullResultByDefault: true, contextParameter: true }, o2 = (r3 = r3 || {}).decorateDoc ? t4 : t4.prototype;
        t4.$appliedHooks = true;
        for (var s2 = 0, f = Object.keys(e3.paths);s2 < f.length; s2++) {
          var p = f[s2], h = e3.paths[p], y = null;
          if (h.$isSingleNested)
            y = h.caster;
          else {
            if (!h.$isMongooseDocumentArray)
              continue;
            y = h.Constructor;
          }
          if (!y.$appliedHooks && (l(y, h.schema, i(i({}, r3), {}, { isChildSchema: true })), y.discriminators != null))
            for (var d = 0, b = Object.keys(y.discriminators);d < b.length; d++) {
              var m = b[d];
              l(y.discriminators[m], y.discriminators[m].schema, r3);
            }
        }
        var v = e3.s.hooks.filter(function(t5) {
          return t5.name === "updateOne" || t5.name === "deleteOne" ? !!t5.document : t5.name === "remove" || t5.name === "init" ? t5.document == null || !!t5.document : t5.query == null && t5.document == null || t5.document !== false;
        }).filter(function(t5) {
          return !e3.methods[t5.name] || !t5.fn[a.builtInMiddleware];
        });
        t4._middleware = v, o2.$__originalValidate = o2.$__originalValidate || o2.$__validate;
        for (var g = 0, _ = r3 && r3.isChildSchema ? ["save", "validate", "deleteOne"] : ["save", "validate"];g < _.length; g++) {
          var w = _[g], O = w === "validate" ? "$__originalValidate" : "$__".concat(w), S = v.createWrapper(w, o2[O], null, n2);
          o2["$__".concat(w)] = S;
        }
        o2.$__init = v.createWrapperSync("init", o2.$__init, null, n2);
        for (var $ = Object.keys(e3.methods), j = Object.assign({}, n2, { checkForPromise: true }), P = function() {
          var e4 = E[A];
          if (c.has(e4))
            return 0;
          if (!v.hasHooks(e4))
            return 0;
          var r4 = o2[e4];
          o2[e4] = function() {
            var r5 = this, n3 = Array.prototype.slice.call(arguments), o3 = n3.slice(-1).pop(), i2 = typeof o3 == "function" ? n3.slice(0, n3.length - 1) : n3;
            return u(o3, function(t5) {
              return r5["$__".concat(e4)].apply(r5, i2.concat([t5]));
            }, t4.events);
          }, o2["$__".concat(e4)] = v.createWrapper(e4, r4, null, j);
        }, A = 0, E = $;A < E.length; A++)
          P();
      }
    }, 5022: (t3, e2, r2) => {
      var n = r2(6426), o = r2(7160), i = r2(608), s = r2(8768);
      function a(t4, e3) {
        if (e3 && e3.default) {
          var r3 = e3.default;
          Array.isArray(r3) && r3.length === 0 ? e3.default = Array : !e3.shared && i(r3) && Object.keys(r3).length === 0 && (e3.default = function() {
            return {};
          });
        }
        n.call(this, t4, e3, "Mixed"), this[o.schemaMixedSymbol] = true;
      }
      a.schemaName = "Mixed", a.defaultOptions = {}, a.prototype = Object.create(n.prototype), a.prototype.constructor = a, a.get = n.get, a.set = n.set, a.setters = [], a.prototype.cast = function(t4) {
        return t4 instanceof Error ? s.errorToPOJO(t4) : t4;
      }, a.prototype.castForQuery = function(t4, e3) {
        return e3;
      }, a.prototype.toJSONSchema = function(t4) {
        return {};
      }, t3.exports = a;
    }, 5098: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function i(t4) {
        for (var e3 = 1;e3 < arguments.length; e3++) {
          var r3 = arguments[e3] != null ? arguments[e3] : {};
          e3 % 2 ? o(Object(r3), true).forEach(function(e4) {
            s(t4, e4, r3[e4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : o(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      function s(t4, e3, r3) {
        return (e3 = function(t5) {
          var e4 = function(t6) {
            if (n(t6) != "object" || !t6)
              return t6;
            var e5 = t6[Symbol.toPrimitive];
            if (e5 !== undefined) {
              var r4 = e5.call(t6, "string");
              if (n(r4) != "object")
                return r4;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t6);
          }(t5);
          return n(e4) == "symbol" ? e4 : e4 + "";
        }(e3)) in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      var a, u = r2(3609), c = r2(3550).EventEmitter, l = r2(3441), f = r2(7494), p = r2(6426), h = r2(5335), y = r2(8499), d = r2(5558).G, b = r2(4327), m = r2(1469), v = r2(9604), g = r2(7910), _ = r2(1313), w = r2(3303)._, O = r2(1793), S = r2(8768), $ = r2(5537);
      function j(t4, e3, r3) {
        if (t4.options.timeseries)
          throw new $(e3, "timeseries");
        var n2 = j.defaultOptions && j.defaultOptions._id;
        n2 != null && ((r3 = r3 || {})._id = n2), t4 = _(t4, r3), this.caster = P(t4, null, r3), this.caster.path = e3, this.caster.prototype.$basePath = e3, this.schema = t4, this.$isSingleNested = true, this.base = t4.base, p.call(this, e3, r3, "Embedded");
      }
      function P(t4, e3, n2) {
        a || (a = r2(9380));
        var o2 = function(t5, e4, r3) {
          this.$__parent = r3, a.apply(this, arguments), r3 != null && this.$session(r3.$session());
        };
        t4._preCompile();
        var i2 = e3 != null ? e3.prototype : a.prototype;
        for (var s2 in (o2.prototype = Object.create(i2)).$__setSchema(t4), o2.prototype.constructor = o2, o2.prototype.$__schemaTypeOptions = n2, o2.$__required = n2 == null ? undefined : n2.required, o2.base = t4.base, o2.schema = t4, o2.$isSingleNested = true, o2.events = new c, o2.prototype.toBSON = function() {
          return this.toObject(w);
        }, t4.methods)
          o2.prototype[s2] = t4.methods[s2];
        for (var u2 in t4.statics)
          o2[u2] = t4.statics[u2];
        for (var l2 in c.prototype)
          o2[l2] = c.prototype[l2];
        return o2;
      }
      t3.exports = j, j.prototype = Object.create(p.prototype), j.prototype.constructor = j, j.prototype.OptionsConstructor = f;
      var A = i({}, p.prototype.$conditionalHandlers);
      A.$geoWithin = function(t4, e3) {
        return { $geometry: this.castForQuery(null, t4.$geometry, e3) };
      }, A.$near = A.$nearSphere = v.cast$near, A.$within = A.$geoWithin = v.cast$within, A.$geoIntersects = v.cast$geoIntersects, A.$minDistance = d, A.$maxDistance = d, A.$exists = y, Object.defineProperty(j.prototype, "$conditionalHandlers", { enumerable: false, value: A }), j.prototype.cast = function(t4, e3, r3, o2, i2) {
        if (t4 && t4.$isSingleNested && t4.parent === e3)
          return t4;
        if (t4 != null && (n(t4) !== "object" || Array.isArray(t4)))
          throw new l(this.path, t4);
        var s2, a2 = this.schema.path(this.schema.options.discriminatorKey), u2 = a2 == null ? null : a2.getDefault(e3), c2 = g(this.caster, t4, u2), f2 = e3 && e3.$__ && e3.$__.selected, p2 = this.path, y2 = f2 == null ? null : Object.keys(f2).reduce(function(t5, e4) {
          return e4.startsWith(p2 + ".") && ((t5 = t5 || {})[e4.substring(p2.length + 1)] = f2[e4]), t5;
        }, null);
        if (!r3)
          return i2 = Object.assign({}, i2, { priorDoc: o2 }), Object.keys(t4).length === 0 ? new c2({}, y2, e3, undefined, i2) : new c2(t4, y2, e3, undefined, i2);
        delete (s2 = new c2(undefined, y2, e3, false, { defaults: false })).$__.defaults, s2.$init(t4);
        var d2 = O(y2);
        return h(s2, y2, d2), s2;
      }, j.prototype.castForQuery = function(t4, e3, r3, n2) {
        var o2;
        if (t4 != null) {
          if (!(o2 = this.$conditionalHandlers[t4]))
            throw new Error("Can't use " + t4);
          return o2.call(this, e3);
        }
        if (e3 == null)
          return e3;
        var i2 = g(this.caster, e3);
        if (e3 instanceof i2)
          return e3;
        this.options.runSetters && (e3 = this._applySetters(e3, r3));
        var s2 = n2 != null && n2.strict != null ? n2.strict : undefined;
        try {
          e3 = new i2(e3, s2);
        } catch (t5) {
          if (!(t5 instanceof u))
            throw new u("Embedded", e3, this.path, t5, this);
          throw t5;
        }
        return e3;
      }, j.prototype.doValidate = function(t4, e3, r3, n2) {
        var o2 = g(this.caster, t4);
        if (!t4 || t4 instanceof o2 || (t4 = new o2(t4, null, r3 != null && r3.$__ != null ? r3 : null)), n2 && n2.skipSchemaValidators)
          return t4 ? t4.validate().then(function() {
            return e3(null);
          }, function(t5) {
            return e3(t5);
          }) : e3(null);
        p.prototype.doValidate.call(this, t4, function(r4) {
          return r4 ? e3(r4) : t4 ? void t4.validate().then(function() {
            return e3(null);
          }, function(t5) {
            return e3(t5);
          }) : e3(null);
        }, r3, n2);
      }, j.prototype.doValidateSync = function(t4, e3, r3) {
        if (!r3 || !r3.skipSchemaValidators) {
          var n2 = p.prototype.doValidateSync.call(this, t4, e3);
          if (n2)
            return n2;
        }
        if (t4)
          return t4.validateSync();
      }, j.prototype.discriminator = function(t4, e3, r3) {
        r3 = r3 || {};
        var n2 = S.isPOJO(r3) ? r3.value : r3, o2 = typeof r3.clone != "boolean" || r3.clone;
        return e3.instanceOfSchema && o2 && (e3 = e3.clone()), e3 = m(this.caster, t4, e3, n2, null, null, r3.overwriteExisting), this.caster.discriminators[t4] = P(e3, this.caster), this.caster.discriminators[t4];
      }, j.defaultOptions = {}, j.set = p.set, j.setters = [], j.get = p.get, j.prototype.toJSON = function() {
        return { path: this.path, options: this.options };
      }, j.prototype.clone = function() {
        var t4 = new this.constructor(this.schema, this.path, i(i({}, this.options), {}, { _skipApplyDiscriminators: true }));
        return t4.validators = this.validators.slice(), this.requiredValidator !== undefined && (t4.requiredValidator = this.requiredValidator), t4.caster.discriminators = Object.assign({}, this.caster.discriminators), t4._appliedDiscriminators = this._appliedDiscriminators, t4;
      }, j.prototype.toJSONSchema = function(t4) {
        var e3 = this.options.required && typeof this.options.required != "function";
        return i(i({}, this.schema.toJSONSchema(t4)), b("object", "object", t4 == null ? undefined : t4.useBsonType, e3));
      };
    }, 5110: (t3) => {
      var e2 = new Set(["$ref", "$id", "$db"]);
      t3.exports = function(t4) {
        return t4[0] === "$" && !e2.has(t4);
      };
    }, 5152: (t3, e2, r2) => {
      var n = r2(3703), o = r2(7425);
      t3.exports = function t(e3, r3, i) {
        for (var s = (i = i || {}).typeOnly, a = Array.isArray(r3) ? r3 : r3.indexOf(".") === -1 ? [r3] : r3.split("."), u = null, c = "adhocOrUndefined", l = o(e3.schema, e3.get(e3.schema.options.discriminatorKey)) || e3.schema, f = 0;f < a.length; ++f) {
          var p = a.slice(0, f + 1).join(".");
          if ((u = l.path(p)) != null) {
            if (u.instance === "Mixed")
              return s ? "real" : u;
            if (c = l.pathType(p), (u.$isSingleNested || u.$isMongooseDocumentArrayElement) && u.schema.discriminators != null) {
              var h = u.schema.discriminators, y = e3.get(p + "." + n(u, "schema.options.discriminatorKey"));
              if (y == null || h[y] == null)
                continue;
              var d = a.slice(f + 1).join(".");
              return t(e3.get(p), d, i);
            }
          } else
            c = "adhocOrUndefined";
        }
        return s ? c : u;
      };
    }, 5188: (t3, e2, r2) => {
      var n = r2(7300);
      t3.exports = function(t4, e3) {
        if (t4 == null)
          return false;
        if (e3 === "_id")
          return t4._id === 0;
        for (var r3 = null, o = 0, i = Object.keys(t4);o < i.length; o++) {
          var s = i[o];
          if (n(t4[s])) {
            r3 = t4[e3] === 1 ? "inclusive" : "exclusive";
            break;
          }
        }
        return r3 === "inclusive" ? t4[e3] !== 1 : r3 === "exclusive" && t4[e3] === 0;
      };
    }, 5268: (t3, e2, r2) => {
      var n = r2(2746), o = Symbol("mongoose#emitted");
      t3.exports = function(t4, e3, i, s) {
        if (typeof t4 == "function")
          try {
            return e3(function(e4) {
              if (e4 == null)
                t4.apply(this, arguments);
              else {
                i != null && i.listeners != null && i.listeners("error").length > 0 && !e4[o] && (e4[o] = true, i.emit("error", e4));
                try {
                  t4(e4);
                } catch (e5) {
                  return n(function() {
                    throw e5;
                  });
                }
              }
            });
          } catch (e4) {
            return i != null && i.listeners != null && i.listeners("error").length > 0 && !e4[o] && (e4[o] = true, i.emit("error", e4)), t4(e4);
          }
        return new (s = s || r2.g.Promise)(function(t5, r3) {
          e3(function(e4, n2) {
            return e4 != null ? (i != null && i.listeners != null && i.listeners("error").length > 0 && !e4[o] && (e4[o] = true, i.emit("error", e4)), r3(e4)) : arguments.length > 2 ? t5(Array.prototype.slice.call(arguments, 1)) : void t5(n2);
          });
        });
      };
    }, 5289: (t3) => {
      t3.exports = function(t4) {
        switch (t4) {
          case "p":
            t4 = "primary";
            break;
          case "pp":
            t4 = "primaryPreferred";
            break;
          case "s":
            t4 = "secondary";
            break;
          case "sp":
            t4 = "secondaryPreferred";
            break;
          case "n":
            t4 = "nearest";
        }
        return t4;
      };
    }, 5335: (t3, e2, r2) => {
      var n = r2(1091);
      function o(t4, e3, r3) {
        t4.$__.activePaths.default(e3), !r3 && t4.$isSubdocument && t4.$isSingleNested && t4.$parent() != null && t4.$parent().$__.activePaths.default(t4.$__pathRelativeToParent(e3));
      }
      t3.exports = function(t4, e3, r3, i, s, a, u) {
        for (var c = Object.keys(t4.$__schema.paths), l = c.length, f = u && u.skipParentChangeTracking, p = 0;p < l; ++p) {
          var h = undefined, y = "", d = c[p];
          if (d !== "_id" || !t4.$__.skipId) {
            var b = t4.$__schema.paths[d], m = b.splitPath(), v = m.length;
            if (m[v - 1] !== "$*")
              for (var g = false, _ = t4._doc, w = 0;w < v && _ != null; ++w) {
                var O = m[w];
                if (y += (y.length ? "." : "") + O, r3 === true) {
                  if (y in e3)
                    break;
                } else if (r3 === false && e3 && !g) {
                  var S = b.$isSingleNested || b.$isMongooseDocumentArray;
                  if (y in e3 && !n(e3[y]) || w === v - 1 && S && i != null && i[y])
                    g = true;
                  else if (i != null && !i[y])
                    break;
                }
                if (w === v - 1) {
                  if (_[O] !== undefined)
                    break;
                  if (s != null) {
                    if (typeof b.defaultValue == "function") {
                      if (!b.defaultValue.$runBeforeSetters && s)
                        break;
                      if (b.defaultValue.$runBeforeSetters && !s)
                        break;
                    } else if (!s)
                      continue;
                  }
                  if (a && a[y])
                    break;
                  if (e3 && r3 !== null) {
                    if (r3 === true) {
                      if (d in e3)
                        continue;
                      try {
                        h = b.getDefault(t4, false);
                      } catch (e4) {
                        t4.invalidate(d, e4);
                        break;
                      }
                      h !== undefined && (_[O] = h, o(t4, d, f));
                    } else if (g) {
                      try {
                        h = b.getDefault(t4, false);
                      } catch (e4) {
                        t4.invalidate(d, e4);
                        break;
                      }
                      h !== undefined && (_[O] = h, o(t4, d, f));
                    }
                  } else {
                    try {
                      h = b.getDefault(t4, false);
                    } catch (e4) {
                      t4.invalidate(d, e4);
                      break;
                    }
                    h !== undefined && (_[O] = h, o(t4, d, f));
                  }
                } else
                  _ = _[O];
              }
          }
        }
      };
    }, 5346: (t3) => {
      t3.exports = function(t4, e2, r2) {
        for (var n = e2[0], o = r2, i = t4, s = 0;s < e2.length - 1; ++s) {
          var a = o.path(n);
          if (a && a.schema) {
            var u = i.get(n);
            if (o = a.schema, n = e2[s + 1], Array.isArray(u) && !isNaN(n) && (u = u[n], n = ""), u == null)
              break;
            i = u;
          } else
            n += n.length ? "." + e2[s + 1] : e2[s + 1];
        }
        return i;
      };
    }, 5413: (t3, e2, r2) => {
      var n = r2(3305), o = r2(2402);
      t3.exports = function(t4) {
        if (t4 == null)
          return t4;
        if (t4 === "")
          return null;
        var e3 = n(t4, "Long") ? t4.toNumber() : Number(t4);
        if (e3 === (0 | e3) && e3 >= -2147483648 && e3 <= 2147483647)
          return e3;
        o.ok(false);
      };
    }, 5477: (t3, e2, r2) => {
      var n = r2(2354), o = r2(3279), i = r2(3123), s = r2(3388);
      t3.exports = s || n.call(i, o);
    }, 5484: (t3) => {
      function e2(t4) {
        return e2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      t3.exports = function() {
        if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
          return false;
        if (e2(Symbol.iterator) === "symbol")
          return true;
        var t4 = {}, r2 = Symbol("test"), n = Object(r2);
        if (typeof r2 == "string")
          return false;
        if (Object.prototype.toString.call(r2) !== "[object Symbol]")
          return false;
        if (Object.prototype.toString.call(n) !== "[object Symbol]")
          return false;
        for (var o in t4[r2] = 42, t4)
          return false;
        if (typeof Object.keys == "function" && Object.keys(t4).length !== 0)
          return false;
        if (typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t4).length !== 0)
          return false;
        var i = Object.getOwnPropertySymbols(t4);
        if (i.length !== 1 || i[0] !== r2)
          return false;
        if (!Object.prototype.propertyIsEnumerable.call(t4, r2))
          return false;
        if (typeof Object.getOwnPropertyDescriptor == "function") {
          var s = Object.getOwnPropertyDescriptor(t4, r2);
          if (s.value !== 42 || s.enumerable !== true)
            return false;
        }
        return true;
      };
    }, 5497: (t3, e2, r2) => {
      var n = r2(8260);
      t3.exports = function(t4) {
        if (n(t4) !== "TopologyDescription")
          return false;
        var e3 = Array.from(t4.servers.values());
        return e3.length > 0 && e3.every(function(t5) {
          return t5.error && t5.error.message.indexOf("Client network socket disconnected before secure TLS connection was established") !== -1;
        });
      };
    }, 5510: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var o = typeof Symbol != "undefined" && Symbol, i = r2(5484);
      t3.exports = function() {
        return typeof o == "function" && typeof Symbol == "function" && n(o("foo")) === "symbol" && n(Symbol("bar")) === "symbol" && i();
      };
    }, 5537: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (o = function() {
          return !!t4;
        })();
      }
      function i(t4) {
        return i = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, i(t4);
      }
      function s(t4, e3) {
        return s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s(t4, e3);
      }
      var a = function(t4) {
        function e3(t5, r4) {
          return function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), function(t6, e4, r5) {
            return e4 = i(e4), function(t7, e5) {
              if (e5 && (n(e5) == "object" || typeof e5 == "function"))
                return e5;
              if (e5 !== undefined)
                throw new TypeError("Derived constructors may only return object or undefined");
              return function(t8) {
                if (t8 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t8;
              }(t7);
            }(t6, o() ? Reflect.construct(e4, r5 || [], i(t6).constructor) : e4.apply(t6, r5));
          }(this, e3, ['Cannot create use schema for property "'.concat(t5, '" because the schema has the ').concat(r4, " option enabled.")]);
        }
        return function(t5, e4) {
          if (typeof e4 != "function" && e4 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(8213));
      Object.defineProperty(a.prototype, "name", { value: "InvalidSchemaOptionError" }), t3.exports = a;
    }, 5549: (t3, e2, r2) => {
      var n = r2(6353).ObjectId, o = r2(7930).objectIdSymbol;
      Object.defineProperty(n.prototype, "_id", { enumerable: false, configurable: true, get: function() {
        return this;
      } }), n.prototype.hasOwnProperty("valueOf") || (n.prototype.valueOf = function() {
        return this.toString();
      }), n.prototype[o] = true, t3.exports = n;
    }, 5558: (t3, e2, r2) => {
      var n = r2(3660);
      function o(t4) {
        return n.cast()(t4);
      }
      e2.G = o, e2.p = function t(e3, r3) {
        e3.forEach(function(n2, i) {
          Array.isArray(n2) ? t(n2, r3) : e3[i] = o.call(r3, n2);
        });
      };
    }, 5678: (t3, e2, r2) => {
      t3.exports = r2(2914);
    }, 5761: (t3) => {
      t3.exports = Object.freeze({ enumerable: true, configurable: true, writable: true, value: undefined });
    }, 5782: (t3) => {
      function e2(t4, e3) {
        (e3 == null || e3 > t4.length) && (e3 = t4.length);
        for (var r2 = 0, n = Array(e3);r2 < e3; r2++)
          n[r2] = t4[r2];
        return n;
      }
      t3.exports = function(t4, r2, n) {
        if (t4.length === 0)
          return n();
        var o, i = t4.length, s = null, a = function(t5, r3) {
          var n2 = typeof Symbol != "undefined" && t5[Symbol.iterator] || t5["@@iterator"];
          if (!n2) {
            if (Array.isArray(t5) || (n2 = function(t6, r4) {
              if (t6) {
                if (typeof t6 == "string")
                  return e2(t6, r4);
                var n3 = {}.toString.call(t6).slice(8, -1);
                return n3 === "Object" && t6.constructor && (n3 = t6.constructor.name), n3 === "Map" || n3 === "Set" ? Array.from(t6) : n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3) ? e2(t6, r4) : undefined;
              }
            }(t5)) || r3 && t5 && typeof t5.length == "number") {
              n2 && (t5 = n2);
              var o2 = 0, i2 = function() {};
              return { s: i2, n: function() {
                return o2 >= t5.length ? { done: true } : { done: false, value: t5[o2++] };
              }, e: function(t6) {
                throw t6;
              }, f: i2 };
            }
            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }
          var s2, a2 = true, u = false;
          return { s: function() {
            n2 = n2.call(t5);
          }, n: function() {
            var t6 = n2.next();
            return a2 = t6.done, t6;
          }, e: function(t6) {
            u = true, s2 = t6;
          }, f: function() {
            try {
              a2 || n2.return == null || n2.return();
            } finally {
              if (u)
                throw s2;
            }
          } };
        }(t4);
        try {
          for (a.s();!(o = a.n()).done; )
            r2(o.value, function(t5) {
              if (s == null)
                return t5 != null ? n(s = t5) : --i <= 0 ? n() : undefined;
            });
        } catch (s2) {
          a.e(s2);
        } finally {
          a.f();
        }
      };
    }, 5804: (t3, e2, r2) => {
      var n = r2(2354), o = r2(3279), i = r2(5477);
      t3.exports = function() {
        return i(n, o, arguments);
      };
    }, 5807: (t3) => {
      t3.exports = Object.getOwnPropertyDescriptor;
    }, 5825: (t3, e2, r2) => {
      var n = r2(8093);
      t3.exports = n.getPrototypeOf || null;
    }, 5832: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var o = r2(6775), i = r2(2486), s = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
      e2.hp = c, e2.IS = 50;
      var a = 2147483647;
      function u(t4) {
        if (t4 > a)
          throw new RangeError('The value "' + t4 + '" is invalid for option "size"');
        var e3 = new Uint8Array(t4);
        return Object.setPrototypeOf(e3, c.prototype), e3;
      }
      function c(t4, e3, r3) {
        if (typeof t4 == "number") {
          if (typeof e3 == "string")
            throw new TypeError('The "string" argument must be of type string. Received type number');
          return p(t4);
        }
        return l(t4, e3, r3);
      }
      function l(t4, e3, r3) {
        if (typeof t4 == "string")
          return function(t5, e4) {
            if (typeof e4 == "string" && e4 !== "" || (e4 = "utf8"), !c.isEncoding(e4))
              throw new TypeError("Unknown encoding: " + e4);
            var r4 = 0 | b(t5, e4), n2 = u(r4), o3 = n2.write(t5, e4);
            return o3 !== r4 && (n2 = n2.slice(0, o3)), n2;
          }(t4, e3);
        if (ArrayBuffer.isView(t4))
          return function(t5) {
            if (V(t5, Uint8Array)) {
              var e4 = new Uint8Array(t5);
              return y(e4.buffer, e4.byteOffset, e4.byteLength);
            }
            return h(t5);
          }(t4);
        if (t4 == null)
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + n(t4));
        if (V(t4, ArrayBuffer) || t4 && V(t4.buffer, ArrayBuffer))
          return y(t4, e3, r3);
        if (typeof SharedArrayBuffer != "undefined" && (V(t4, SharedArrayBuffer) || t4 && V(t4.buffer, SharedArrayBuffer)))
          return y(t4, e3, r3);
        if (typeof t4 == "number")
          throw new TypeError('The "value" argument must not be of type number. Received type number');
        var o2 = t4.valueOf && t4.valueOf();
        if (o2 != null && o2 !== t4)
          return c.from(o2, e3, r3);
        var i2 = function(t5) {
          if (c.isBuffer(t5)) {
            var e4 = 0 | d(t5.length), r4 = u(e4);
            return r4.length === 0 || t5.copy(r4, 0, 0, e4), r4;
          }
          return t5.length !== undefined ? typeof t5.length != "number" || q(t5.length) ? u(0) : h(t5) : t5.type === "Buffer" && Array.isArray(t5.data) ? h(t5.data) : undefined;
        }(t4);
        if (i2)
          return i2;
        if (typeof Symbol != "undefined" && Symbol.toPrimitive != null && typeof t4[Symbol.toPrimitive] == "function")
          return c.from(t4[Symbol.toPrimitive]("string"), e3, r3);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + n(t4));
      }
      function f(t4) {
        if (typeof t4 != "number")
          throw new TypeError('"size" argument must be of type number');
        if (t4 < 0)
          throw new RangeError('The value "' + t4 + '" is invalid for option "size"');
      }
      function p(t4) {
        return f(t4), u(t4 < 0 ? 0 : 0 | d(t4));
      }
      function h(t4) {
        for (var e3 = t4.length < 0 ? 0 : 0 | d(t4.length), r3 = u(e3), n2 = 0;n2 < e3; n2 += 1)
          r3[n2] = 255 & t4[n2];
        return r3;
      }
      function y(t4, e3, r3) {
        if (e3 < 0 || t4.byteLength < e3)
          throw new RangeError('"offset" is outside of buffer bounds');
        if (t4.byteLength < e3 + (r3 || 0))
          throw new RangeError('"length" is outside of buffer bounds');
        var n2;
        return n2 = e3 === undefined && r3 === undefined ? new Uint8Array(t4) : r3 === undefined ? new Uint8Array(t4, e3) : new Uint8Array(t4, e3, r3), Object.setPrototypeOf(n2, c.prototype), n2;
      }
      function d(t4) {
        if (t4 >= a)
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + a.toString(16) + " bytes");
        return 0 | t4;
      }
      function b(t4, e3) {
        if (c.isBuffer(t4))
          return t4.length;
        if (ArrayBuffer.isView(t4) || V(t4, ArrayBuffer))
          return t4.byteLength;
        if (typeof t4 != "string")
          throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + n(t4));
        var r3 = t4.length, o2 = arguments.length > 2 && arguments[2] === true;
        if (!o2 && r3 === 0)
          return 0;
        for (var i2 = false;; )
          switch (e3) {
            case "ascii":
            case "latin1":
            case "binary":
              return r3;
            case "utf8":
            case "utf-8":
              return C(t4).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return 2 * r3;
            case "hex":
              return r3 >>> 1;
            case "base64":
              return F(t4).length;
            default:
              if (i2)
                return o2 ? -1 : C(t4).length;
              e3 = ("" + e3).toLowerCase(), i2 = true;
          }
      }
      function m(t4, e3, r3) {
        var n2 = false;
        if ((e3 === undefined || e3 < 0) && (e3 = 0), e3 > this.length)
          return "";
        if ((r3 === undefined || r3 > this.length) && (r3 = this.length), r3 <= 0)
          return "";
        if ((r3 >>>= 0) <= (e3 >>>= 0))
          return "";
        for (t4 || (t4 = "utf8");; )
          switch (t4) {
            case "hex":
              return k(this, e3, r3);
            case "utf8":
            case "utf-8":
              return A(this, e3, r3);
            case "ascii":
              return x(this, e3, r3);
            case "latin1":
            case "binary":
              return T(this, e3, r3);
            case "base64":
              return P(this, e3, r3);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return N(this, e3, r3);
            default:
              if (n2)
                throw new TypeError("Unknown encoding: " + t4);
              t4 = (t4 + "").toLowerCase(), n2 = true;
          }
      }
      function v(t4, e3, r3) {
        var n2 = t4[e3];
        t4[e3] = t4[r3], t4[r3] = n2;
      }
      function g(t4, e3, r3, n2, o2) {
        if (t4.length === 0)
          return -1;
        if (typeof r3 == "string" ? (n2 = r3, r3 = 0) : r3 > 2147483647 ? r3 = 2147483647 : r3 < -2147483648 && (r3 = -2147483648), q(r3 = +r3) && (r3 = o2 ? 0 : t4.length - 1), r3 < 0 && (r3 = t4.length + r3), r3 >= t4.length) {
          if (o2)
            return -1;
          r3 = t4.length - 1;
        } else if (r3 < 0) {
          if (!o2)
            return -1;
          r3 = 0;
        }
        if (typeof e3 == "string" && (e3 = c.from(e3, n2)), c.isBuffer(e3))
          return e3.length === 0 ? -1 : _(t4, e3, r3, n2, o2);
        if (typeof e3 == "number")
          return e3 &= 255, typeof Uint8Array.prototype.indexOf == "function" ? o2 ? Uint8Array.prototype.indexOf.call(t4, e3, r3) : Uint8Array.prototype.lastIndexOf.call(t4, e3, r3) : _(t4, [e3], r3, n2, o2);
        throw new TypeError("val must be string, number or Buffer");
      }
      function _(t4, e3, r3, n2, o2) {
        var i2, s2 = 1, a2 = t4.length, u2 = e3.length;
        if (n2 !== undefined && ((n2 = String(n2).toLowerCase()) === "ucs2" || n2 === "ucs-2" || n2 === "utf16le" || n2 === "utf-16le")) {
          if (t4.length < 2 || e3.length < 2)
            return -1;
          s2 = 2, a2 /= 2, u2 /= 2, r3 /= 2;
        }
        function c2(t5, e4) {
          return s2 === 1 ? t5[e4] : t5.readUInt16BE(e4 * s2);
        }
        if (o2) {
          var l2 = -1;
          for (i2 = r3;i2 < a2; i2++)
            if (c2(t4, i2) === c2(e3, l2 === -1 ? 0 : i2 - l2)) {
              if (l2 === -1 && (l2 = i2), i2 - l2 + 1 === u2)
                return l2 * s2;
            } else
              l2 !== -1 && (i2 -= i2 - l2), l2 = -1;
        } else
          for (r3 + u2 > a2 && (r3 = a2 - u2), i2 = r3;i2 >= 0; i2--) {
            for (var f2 = true, p2 = 0;p2 < u2; p2++)
              if (c2(t4, i2 + p2) !== c2(e3, p2)) {
                f2 = false;
                break;
              }
            if (f2)
              return i2;
          }
        return -1;
      }
      function w(t4, e3, r3, n2) {
        r3 = Number(r3) || 0;
        var o2 = t4.length - r3;
        n2 ? (n2 = Number(n2)) > o2 && (n2 = o2) : n2 = o2;
        var i2 = e3.length;
        n2 > i2 / 2 && (n2 = i2 / 2);
        for (var s2 = 0;s2 < n2; ++s2) {
          var a2 = parseInt(e3.substr(2 * s2, 2), 16);
          if (q(a2))
            return s2;
          t4[r3 + s2] = a2;
        }
        return s2;
      }
      function O(t4, e3, r3, n2) {
        return L(C(e3, t4.length - r3), t4, r3, n2);
      }
      function S(t4, e3, r3, n2) {
        return L(function(t5) {
          for (var e4 = [], r4 = 0;r4 < t5.length; ++r4)
            e4.push(255 & t5.charCodeAt(r4));
          return e4;
        }(e3), t4, r3, n2);
      }
      function $(t4, e3, r3, n2) {
        return L(F(e3), t4, r3, n2);
      }
      function j(t4, e3, r3, n2) {
        return L(function(t5, e4) {
          for (var r4, n3, o2, i2 = [], s2 = 0;s2 < t5.length && !((e4 -= 2) < 0); ++s2)
            n3 = (r4 = t5.charCodeAt(s2)) >> 8, o2 = r4 % 256, i2.push(o2), i2.push(n3);
          return i2;
        }(e3, t4.length - r3), t4, r3, n2);
      }
      function P(t4, e3, r3) {
        return e3 === 0 && r3 === t4.length ? o.fromByteArray(t4) : o.fromByteArray(t4.slice(e3, r3));
      }
      function A(t4, e3, r3) {
        r3 = Math.min(t4.length, r3);
        for (var n2 = [], o2 = e3;o2 < r3; ) {
          var i2, s2, a2, u2, c2 = t4[o2], l2 = null, f2 = c2 > 239 ? 4 : c2 > 223 ? 3 : c2 > 191 ? 2 : 1;
          if (o2 + f2 <= r3)
            switch (f2) {
              case 1:
                c2 < 128 && (l2 = c2);
                break;
              case 2:
                (192 & (i2 = t4[o2 + 1])) == 128 && (u2 = (31 & c2) << 6 | 63 & i2) > 127 && (l2 = u2);
                break;
              case 3:
                i2 = t4[o2 + 1], s2 = t4[o2 + 2], (192 & i2) == 128 && (192 & s2) == 128 && (u2 = (15 & c2) << 12 | (63 & i2) << 6 | 63 & s2) > 2047 && (u2 < 55296 || u2 > 57343) && (l2 = u2);
                break;
              case 4:
                i2 = t4[o2 + 1], s2 = t4[o2 + 2], a2 = t4[o2 + 3], (192 & i2) == 128 && (192 & s2) == 128 && (192 & a2) == 128 && (u2 = (15 & c2) << 18 | (63 & i2) << 12 | (63 & s2) << 6 | 63 & a2) > 65535 && u2 < 1114112 && (l2 = u2);
            }
          l2 === null ? (l2 = 65533, f2 = 1) : l2 > 65535 && (l2 -= 65536, n2.push(l2 >>> 10 & 1023 | 55296), l2 = 56320 | 1023 & l2), n2.push(l2), o2 += f2;
        }
        return function(t5) {
          var e4 = t5.length;
          if (e4 <= E)
            return String.fromCharCode.apply(String, t5);
          for (var r4 = "", n3 = 0;n3 < e4; )
            r4 += String.fromCharCode.apply(String, t5.slice(n3, n3 += E));
          return r4;
        }(n2);
      }
      c.TYPED_ARRAY_SUPPORT = function() {
        try {
          var t4 = new Uint8Array(1), e3 = { foo: function() {
            return 42;
          } };
          return Object.setPrototypeOf(e3, Uint8Array.prototype), Object.setPrototypeOf(t4, e3), t4.foo() === 42;
        } catch (t5) {
          return false;
        }
      }(), c.TYPED_ARRAY_SUPPORT || typeof console == "undefined" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(c.prototype, "parent", { enumerable: true, get: function() {
        if (c.isBuffer(this))
          return this.buffer;
      } }), Object.defineProperty(c.prototype, "offset", { enumerable: true, get: function() {
        if (c.isBuffer(this))
          return this.byteOffset;
      } }), c.poolSize = 8192, c.from = function(t4, e3, r3) {
        return l(t4, e3, r3);
      }, Object.setPrototypeOf(c.prototype, Uint8Array.prototype), Object.setPrototypeOf(c, Uint8Array), c.alloc = function(t4, e3, r3) {
        return function(t5, e4, r4) {
          return f(t5), t5 <= 0 ? u(t5) : e4 !== undefined ? typeof r4 == "string" ? u(t5).fill(e4, r4) : u(t5).fill(e4) : u(t5);
        }(t4, e3, r3);
      }, c.allocUnsafe = function(t4) {
        return p(t4);
      }, c.allocUnsafeSlow = function(t4) {
        return p(t4);
      }, c.isBuffer = function(t4) {
        return t4 != null && t4._isBuffer === true && t4 !== c.prototype;
      }, c.compare = function(t4, e3) {
        if (V(t4, Uint8Array) && (t4 = c.from(t4, t4.offset, t4.byteLength)), V(e3, Uint8Array) && (e3 = c.from(e3, e3.offset, e3.byteLength)), !c.isBuffer(t4) || !c.isBuffer(e3))
          throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (t4 === e3)
          return 0;
        for (var r3 = t4.length, n2 = e3.length, o2 = 0, i2 = Math.min(r3, n2);o2 < i2; ++o2)
          if (t4[o2] !== e3[o2]) {
            r3 = t4[o2], n2 = e3[o2];
            break;
          }
        return r3 < n2 ? -1 : n2 < r3 ? 1 : 0;
      }, c.isEncoding = function(t4) {
        switch (String(t4).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      }, c.concat = function(t4, e3) {
        if (!Array.isArray(t4))
          throw new TypeError('"list" argument must be an Array of Buffers');
        if (t4.length === 0)
          return c.alloc(0);
        var r3;
        if (e3 === undefined)
          for (e3 = 0, r3 = 0;r3 < t4.length; ++r3)
            e3 += t4[r3].length;
        var n2 = c.allocUnsafe(e3), o2 = 0;
        for (r3 = 0;r3 < t4.length; ++r3) {
          var i2 = t4[r3];
          if (V(i2, Uint8Array))
            o2 + i2.length > n2.length ? c.from(i2).copy(n2, o2) : Uint8Array.prototype.set.call(n2, i2, o2);
          else {
            if (!c.isBuffer(i2))
              throw new TypeError('"list" argument must be an Array of Buffers');
            i2.copy(n2, o2);
          }
          o2 += i2.length;
        }
        return n2;
      }, c.byteLength = b, c.prototype._isBuffer = true, c.prototype.swap16 = function() {
        var t4 = this.length;
        if (t4 % 2 != 0)
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (var e3 = 0;e3 < t4; e3 += 2)
          v(this, e3, e3 + 1);
        return this;
      }, c.prototype.swap32 = function() {
        var t4 = this.length;
        if (t4 % 4 != 0)
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (var e3 = 0;e3 < t4; e3 += 4)
          v(this, e3, e3 + 3), v(this, e3 + 1, e3 + 2);
        return this;
      }, c.prototype.swap64 = function() {
        var t4 = this.length;
        if (t4 % 8 != 0)
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (var e3 = 0;e3 < t4; e3 += 8)
          v(this, e3, e3 + 7), v(this, e3 + 1, e3 + 6), v(this, e3 + 2, e3 + 5), v(this, e3 + 3, e3 + 4);
        return this;
      }, c.prototype.toString = function() {
        var t4 = this.length;
        return t4 === 0 ? "" : arguments.length === 0 ? A(this, 0, t4) : m.apply(this, arguments);
      }, c.prototype.toLocaleString = c.prototype.toString, c.prototype.equals = function(t4) {
        if (!c.isBuffer(t4))
          throw new TypeError("Argument must be a Buffer");
        return this === t4 || c.compare(this, t4) === 0;
      }, c.prototype.inspect = function() {
        var t4 = "", r3 = e2.IS;
        return t4 = this.toString("hex", 0, r3).replace(/(.{2})/g, "$1 ").trim(), this.length > r3 && (t4 += " ... "), "<Buffer " + t4 + ">";
      }, s && (c.prototype[s] = c.prototype.inspect), c.prototype.compare = function(t4, e3, r3, o2, i2) {
        if (V(t4, Uint8Array) && (t4 = c.from(t4, t4.offset, t4.byteLength)), !c.isBuffer(t4))
          throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + n(t4));
        if (e3 === undefined && (e3 = 0), r3 === undefined && (r3 = t4 ? t4.length : 0), o2 === undefined && (o2 = 0), i2 === undefined && (i2 = this.length), e3 < 0 || r3 > t4.length || o2 < 0 || i2 > this.length)
          throw new RangeError("out of range index");
        if (o2 >= i2 && e3 >= r3)
          return 0;
        if (o2 >= i2)
          return -1;
        if (e3 >= r3)
          return 1;
        if (this === t4)
          return 0;
        for (var s2 = (i2 >>>= 0) - (o2 >>>= 0), a2 = (r3 >>>= 0) - (e3 >>>= 0), u2 = Math.min(s2, a2), l2 = this.slice(o2, i2), f2 = t4.slice(e3, r3), p2 = 0;p2 < u2; ++p2)
          if (l2[p2] !== f2[p2]) {
            s2 = l2[p2], a2 = f2[p2];
            break;
          }
        return s2 < a2 ? -1 : a2 < s2 ? 1 : 0;
      }, c.prototype.includes = function(t4, e3, r3) {
        return this.indexOf(t4, e3, r3) !== -1;
      }, c.prototype.indexOf = function(t4, e3, r3) {
        return g(this, t4, e3, r3, true);
      }, c.prototype.lastIndexOf = function(t4, e3, r3) {
        return g(this, t4, e3, r3, false);
      }, c.prototype.write = function(t4, e3, r3, n2) {
        if (e3 === undefined)
          n2 = "utf8", r3 = this.length, e3 = 0;
        else if (r3 === undefined && typeof e3 == "string")
          n2 = e3, r3 = this.length, e3 = 0;
        else {
          if (!isFinite(e3))
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
          e3 >>>= 0, isFinite(r3) ? (r3 >>>= 0, n2 === undefined && (n2 = "utf8")) : (n2 = r3, r3 = undefined);
        }
        var o2 = this.length - e3;
        if ((r3 === undefined || r3 > o2) && (r3 = o2), t4.length > 0 && (r3 < 0 || e3 < 0) || e3 > this.length)
          throw new RangeError("Attempt to write outside buffer bounds");
        n2 || (n2 = "utf8");
        for (var i2 = false;; )
          switch (n2) {
            case "hex":
              return w(this, t4, e3, r3);
            case "utf8":
            case "utf-8":
              return O(this, t4, e3, r3);
            case "ascii":
            case "latin1":
            case "binary":
              return S(this, t4, e3, r3);
            case "base64":
              return $(this, t4, e3, r3);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return j(this, t4, e3, r3);
            default:
              if (i2)
                throw new TypeError("Unknown encoding: " + n2);
              n2 = ("" + n2).toLowerCase(), i2 = true;
          }
      }, c.prototype.toJSON = function() {
        return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
      };
      var E = 4096;
      function x(t4, e3, r3) {
        var n2 = "";
        r3 = Math.min(t4.length, r3);
        for (var o2 = e3;o2 < r3; ++o2)
          n2 += String.fromCharCode(127 & t4[o2]);
        return n2;
      }
      function T(t4, e3, r3) {
        var n2 = "";
        r3 = Math.min(t4.length, r3);
        for (var o2 = e3;o2 < r3; ++o2)
          n2 += String.fromCharCode(t4[o2]);
        return n2;
      }
      function k(t4, e3, r3) {
        var n2 = t4.length;
        (!e3 || e3 < 0) && (e3 = 0), (!r3 || r3 < 0 || r3 > n2) && (r3 = n2);
        for (var o2 = "", i2 = e3;i2 < r3; ++i2)
          o2 += J[t4[i2]];
        return o2;
      }
      function N(t4, e3, r3) {
        for (var n2 = t4.slice(e3, r3), o2 = "", i2 = 0;i2 < n2.length - 1; i2 += 2)
          o2 += String.fromCharCode(n2[i2] + 256 * n2[i2 + 1]);
        return o2;
      }
      function I(t4, e3, r3) {
        if (t4 % 1 != 0 || t4 < 0)
          throw new RangeError("offset is not uint");
        if (t4 + e3 > r3)
          throw new RangeError("Trying to access beyond buffer length");
      }
      function B(t4, e3, r3, n2, o2, i2) {
        if (!c.isBuffer(t4))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (e3 > o2 || e3 < i2)
          throw new RangeError('"value" argument is out of bounds');
        if (r3 + n2 > t4.length)
          throw new RangeError("Index out of range");
      }
      function M(t4, e3, r3, n2, o2, i2) {
        if (r3 + n2 > t4.length)
          throw new RangeError("Index out of range");
        if (r3 < 0)
          throw new RangeError("Index out of range");
      }
      function D(t4, e3, r3, n2, o2) {
        return e3 = +e3, r3 >>>= 0, o2 || M(t4, 0, r3, 4), i.write(t4, e3, r3, n2, 23, 4), r3 + 4;
      }
      function R(t4, e3, r3, n2, o2) {
        return e3 = +e3, r3 >>>= 0, o2 || M(t4, 0, r3, 8), i.write(t4, e3, r3, n2, 52, 8), r3 + 8;
      }
      c.prototype.slice = function(t4, e3) {
        var r3 = this.length;
        (t4 = ~~t4) < 0 ? (t4 += r3) < 0 && (t4 = 0) : t4 > r3 && (t4 = r3), (e3 = e3 === undefined ? r3 : ~~e3) < 0 ? (e3 += r3) < 0 && (e3 = 0) : e3 > r3 && (e3 = r3), e3 < t4 && (e3 = t4);
        var n2 = this.subarray(t4, e3);
        return Object.setPrototypeOf(n2, c.prototype), n2;
      }, c.prototype.readUintLE = c.prototype.readUIntLE = function(t4, e3, r3) {
        t4 >>>= 0, e3 >>>= 0, r3 || I(t4, e3, this.length);
        for (var n2 = this[t4], o2 = 1, i2 = 0;++i2 < e3 && (o2 *= 256); )
          n2 += this[t4 + i2] * o2;
        return n2;
      }, c.prototype.readUintBE = c.prototype.readUIntBE = function(t4, e3, r3) {
        t4 >>>= 0, e3 >>>= 0, r3 || I(t4, e3, this.length);
        for (var n2 = this[t4 + --e3], o2 = 1;e3 > 0 && (o2 *= 256); )
          n2 += this[t4 + --e3] * o2;
        return n2;
      }, c.prototype.readUint8 = c.prototype.readUInt8 = function(t4, e3) {
        return t4 >>>= 0, e3 || I(t4, 1, this.length), this[t4];
      }, c.prototype.readUint16LE = c.prototype.readUInt16LE = function(t4, e3) {
        return t4 >>>= 0, e3 || I(t4, 2, this.length), this[t4] | this[t4 + 1] << 8;
      }, c.prototype.readUint16BE = c.prototype.readUInt16BE = function(t4, e3) {
        return t4 >>>= 0, e3 || I(t4, 2, this.length), this[t4] << 8 | this[t4 + 1];
      }, c.prototype.readUint32LE = c.prototype.readUInt32LE = function(t4, e3) {
        return t4 >>>= 0, e3 || I(t4, 4, this.length), (this[t4] | this[t4 + 1] << 8 | this[t4 + 2] << 16) + 16777216 * this[t4 + 3];
      }, c.prototype.readUint32BE = c.prototype.readUInt32BE = function(t4, e3) {
        return t4 >>>= 0, e3 || I(t4, 4, this.length), 16777216 * this[t4] + (this[t4 + 1] << 16 | this[t4 + 2] << 8 | this[t4 + 3]);
      }, c.prototype.readIntLE = function(t4, e3, r3) {
        t4 >>>= 0, e3 >>>= 0, r3 || I(t4, e3, this.length);
        for (var n2 = this[t4], o2 = 1, i2 = 0;++i2 < e3 && (o2 *= 256); )
          n2 += this[t4 + i2] * o2;
        return n2 >= (o2 *= 128) && (n2 -= Math.pow(2, 8 * e3)), n2;
      }, c.prototype.readIntBE = function(t4, e3, r3) {
        t4 >>>= 0, e3 >>>= 0, r3 || I(t4, e3, this.length);
        for (var n2 = e3, o2 = 1, i2 = this[t4 + --n2];n2 > 0 && (o2 *= 256); )
          i2 += this[t4 + --n2] * o2;
        return i2 >= (o2 *= 128) && (i2 -= Math.pow(2, 8 * e3)), i2;
      }, c.prototype.readInt8 = function(t4, e3) {
        return t4 >>>= 0, e3 || I(t4, 1, this.length), 128 & this[t4] ? -1 * (255 - this[t4] + 1) : this[t4];
      }, c.prototype.readInt16LE = function(t4, e3) {
        t4 >>>= 0, e3 || I(t4, 2, this.length);
        var r3 = this[t4] | this[t4 + 1] << 8;
        return 32768 & r3 ? 4294901760 | r3 : r3;
      }, c.prototype.readInt16BE = function(t4, e3) {
        t4 >>>= 0, e3 || I(t4, 2, this.length);
        var r3 = this[t4 + 1] | this[t4] << 8;
        return 32768 & r3 ? 4294901760 | r3 : r3;
      }, c.prototype.readInt32LE = function(t4, e3) {
        return t4 >>>= 0, e3 || I(t4, 4, this.length), this[t4] | this[t4 + 1] << 8 | this[t4 + 2] << 16 | this[t4 + 3] << 24;
      }, c.prototype.readInt32BE = function(t4, e3) {
        return t4 >>>= 0, e3 || I(t4, 4, this.length), this[t4] << 24 | this[t4 + 1] << 16 | this[t4 + 2] << 8 | this[t4 + 3];
      }, c.prototype.readFloatLE = function(t4, e3) {
        return t4 >>>= 0, e3 || I(t4, 4, this.length), i.read(this, t4, true, 23, 4);
      }, c.prototype.readFloatBE = function(t4, e3) {
        return t4 >>>= 0, e3 || I(t4, 4, this.length), i.read(this, t4, false, 23, 4);
      }, c.prototype.readDoubleLE = function(t4, e3) {
        return t4 >>>= 0, e3 || I(t4, 8, this.length), i.read(this, t4, true, 52, 8);
      }, c.prototype.readDoubleBE = function(t4, e3) {
        return t4 >>>= 0, e3 || I(t4, 8, this.length), i.read(this, t4, false, 52, 8);
      }, c.prototype.writeUintLE = c.prototype.writeUIntLE = function(t4, e3, r3, n2) {
        t4 = +t4, e3 >>>= 0, r3 >>>= 0, n2 || B(this, t4, e3, r3, Math.pow(2, 8 * r3) - 1, 0);
        var o2 = 1, i2 = 0;
        for (this[e3] = 255 & t4;++i2 < r3 && (o2 *= 256); )
          this[e3 + i2] = t4 / o2 & 255;
        return e3 + r3;
      }, c.prototype.writeUintBE = c.prototype.writeUIntBE = function(t4, e3, r3, n2) {
        t4 = +t4, e3 >>>= 0, r3 >>>= 0, n2 || B(this, t4, e3, r3, Math.pow(2, 8 * r3) - 1, 0);
        var o2 = r3 - 1, i2 = 1;
        for (this[e3 + o2] = 255 & t4;--o2 >= 0 && (i2 *= 256); )
          this[e3 + o2] = t4 / i2 & 255;
        return e3 + r3;
      }, c.prototype.writeUint8 = c.prototype.writeUInt8 = function(t4, e3, r3) {
        return t4 = +t4, e3 >>>= 0, r3 || B(this, t4, e3, 1, 255, 0), this[e3] = 255 & t4, e3 + 1;
      }, c.prototype.writeUint16LE = c.prototype.writeUInt16LE = function(t4, e3, r3) {
        return t4 = +t4, e3 >>>= 0, r3 || B(this, t4, e3, 2, 65535, 0), this[e3] = 255 & t4, this[e3 + 1] = t4 >>> 8, e3 + 2;
      }, c.prototype.writeUint16BE = c.prototype.writeUInt16BE = function(t4, e3, r3) {
        return t4 = +t4, e3 >>>= 0, r3 || B(this, t4, e3, 2, 65535, 0), this[e3] = t4 >>> 8, this[e3 + 1] = 255 & t4, e3 + 2;
      }, c.prototype.writeUint32LE = c.prototype.writeUInt32LE = function(t4, e3, r3) {
        return t4 = +t4, e3 >>>= 0, r3 || B(this, t4, e3, 4, 4294967295, 0), this[e3 + 3] = t4 >>> 24, this[e3 + 2] = t4 >>> 16, this[e3 + 1] = t4 >>> 8, this[e3] = 255 & t4, e3 + 4;
      }, c.prototype.writeUint32BE = c.prototype.writeUInt32BE = function(t4, e3, r3) {
        return t4 = +t4, e3 >>>= 0, r3 || B(this, t4, e3, 4, 4294967295, 0), this[e3] = t4 >>> 24, this[e3 + 1] = t4 >>> 16, this[e3 + 2] = t4 >>> 8, this[e3 + 3] = 255 & t4, e3 + 4;
      }, c.prototype.writeIntLE = function(t4, e3, r3, n2) {
        if (t4 = +t4, e3 >>>= 0, !n2) {
          var o2 = Math.pow(2, 8 * r3 - 1);
          B(this, t4, e3, r3, o2 - 1, -o2);
        }
        var i2 = 0, s2 = 1, a2 = 0;
        for (this[e3] = 255 & t4;++i2 < r3 && (s2 *= 256); )
          t4 < 0 && a2 === 0 && this[e3 + i2 - 1] !== 0 && (a2 = 1), this[e3 + i2] = (t4 / s2 | 0) - a2 & 255;
        return e3 + r3;
      }, c.prototype.writeIntBE = function(t4, e3, r3, n2) {
        if (t4 = +t4, e3 >>>= 0, !n2) {
          var o2 = Math.pow(2, 8 * r3 - 1);
          B(this, t4, e3, r3, o2 - 1, -o2);
        }
        var i2 = r3 - 1, s2 = 1, a2 = 0;
        for (this[e3 + i2] = 255 & t4;--i2 >= 0 && (s2 *= 256); )
          t4 < 0 && a2 === 0 && this[e3 + i2 + 1] !== 0 && (a2 = 1), this[e3 + i2] = (t4 / s2 | 0) - a2 & 255;
        return e3 + r3;
      }, c.prototype.writeInt8 = function(t4, e3, r3) {
        return t4 = +t4, e3 >>>= 0, r3 || B(this, t4, e3, 1, 127, -128), t4 < 0 && (t4 = 255 + t4 + 1), this[e3] = 255 & t4, e3 + 1;
      }, c.prototype.writeInt16LE = function(t4, e3, r3) {
        return t4 = +t4, e3 >>>= 0, r3 || B(this, t4, e3, 2, 32767, -32768), this[e3] = 255 & t4, this[e3 + 1] = t4 >>> 8, e3 + 2;
      }, c.prototype.writeInt16BE = function(t4, e3, r3) {
        return t4 = +t4, e3 >>>= 0, r3 || B(this, t4, e3, 2, 32767, -32768), this[e3] = t4 >>> 8, this[e3 + 1] = 255 & t4, e3 + 2;
      }, c.prototype.writeInt32LE = function(t4, e3, r3) {
        return t4 = +t4, e3 >>>= 0, r3 || B(this, t4, e3, 4, 2147483647, -2147483648), this[e3] = 255 & t4, this[e3 + 1] = t4 >>> 8, this[e3 + 2] = t4 >>> 16, this[e3 + 3] = t4 >>> 24, e3 + 4;
      }, c.prototype.writeInt32BE = function(t4, e3, r3) {
        return t4 = +t4, e3 >>>= 0, r3 || B(this, t4, e3, 4, 2147483647, -2147483648), t4 < 0 && (t4 = 4294967295 + t4 + 1), this[e3] = t4 >>> 24, this[e3 + 1] = t4 >>> 16, this[e3 + 2] = t4 >>> 8, this[e3 + 3] = 255 & t4, e3 + 4;
      }, c.prototype.writeFloatLE = function(t4, e3, r3) {
        return D(this, t4, e3, true, r3);
      }, c.prototype.writeFloatBE = function(t4, e3, r3) {
        return D(this, t4, e3, false, r3);
      }, c.prototype.writeDoubleLE = function(t4, e3, r3) {
        return R(this, t4, e3, true, r3);
      }, c.prototype.writeDoubleBE = function(t4, e3, r3) {
        return R(this, t4, e3, false, r3);
      }, c.prototype.copy = function(t4, e3, r3, n2) {
        if (!c.isBuffer(t4))
          throw new TypeError("argument should be a Buffer");
        if (r3 || (r3 = 0), n2 || n2 === 0 || (n2 = this.length), e3 >= t4.length && (e3 = t4.length), e3 || (e3 = 0), n2 > 0 && n2 < r3 && (n2 = r3), n2 === r3)
          return 0;
        if (t4.length === 0 || this.length === 0)
          return 0;
        if (e3 < 0)
          throw new RangeError("targetStart out of bounds");
        if (r3 < 0 || r3 >= this.length)
          throw new RangeError("Index out of range");
        if (n2 < 0)
          throw new RangeError("sourceEnd out of bounds");
        n2 > this.length && (n2 = this.length), t4.length - e3 < n2 - r3 && (n2 = t4.length - e3 + r3);
        var o2 = n2 - r3;
        return this === t4 && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(e3, r3, n2) : Uint8Array.prototype.set.call(t4, this.subarray(r3, n2), e3), o2;
      }, c.prototype.fill = function(t4, e3, r3, n2) {
        if (typeof t4 == "string") {
          if (typeof e3 == "string" ? (n2 = e3, e3 = 0, r3 = this.length) : typeof r3 == "string" && (n2 = r3, r3 = this.length), n2 !== undefined && typeof n2 != "string")
            throw new TypeError("encoding must be a string");
          if (typeof n2 == "string" && !c.isEncoding(n2))
            throw new TypeError("Unknown encoding: " + n2);
          if (t4.length === 1) {
            var o2 = t4.charCodeAt(0);
            (n2 === "utf8" && o2 < 128 || n2 === "latin1") && (t4 = o2);
          }
        } else
          typeof t4 == "number" ? t4 &= 255 : typeof t4 == "boolean" && (t4 = Number(t4));
        if (e3 < 0 || this.length < e3 || this.length < r3)
          throw new RangeError("Out of range index");
        if (r3 <= e3)
          return this;
        var i2;
        if (e3 >>>= 0, r3 = r3 === undefined ? this.length : r3 >>> 0, t4 || (t4 = 0), typeof t4 == "number")
          for (i2 = e3;i2 < r3; ++i2)
            this[i2] = t4;
        else {
          var s2 = c.isBuffer(t4) ? t4 : c.from(t4, n2), a2 = s2.length;
          if (a2 === 0)
            throw new TypeError('The value "' + t4 + '" is invalid for argument "value"');
          for (i2 = 0;i2 < r3 - e3; ++i2)
            this[i2 + e3] = s2[i2 % a2];
        }
        return this;
      };
      var U = /[^+/0-9A-Za-z-_]/g;
      function C(t4, e3) {
        var r3;
        e3 = e3 || 1 / 0;
        for (var n2 = t4.length, o2 = null, i2 = [], s2 = 0;s2 < n2; ++s2) {
          if ((r3 = t4.charCodeAt(s2)) > 55295 && r3 < 57344) {
            if (!o2) {
              if (r3 > 56319) {
                (e3 -= 3) > -1 && i2.push(239, 191, 189);
                continue;
              }
              if (s2 + 1 === n2) {
                (e3 -= 3) > -1 && i2.push(239, 191, 189);
                continue;
              }
              o2 = r3;
              continue;
            }
            if (r3 < 56320) {
              (e3 -= 3) > -1 && i2.push(239, 191, 189), o2 = r3;
              continue;
            }
            r3 = 65536 + (o2 - 55296 << 10 | r3 - 56320);
          } else
            o2 && (e3 -= 3) > -1 && i2.push(239, 191, 189);
          if (o2 = null, r3 < 128) {
            if ((e3 -= 1) < 0)
              break;
            i2.push(r3);
          } else if (r3 < 2048) {
            if ((e3 -= 2) < 0)
              break;
            i2.push(r3 >> 6 | 192, 63 & r3 | 128);
          } else if (r3 < 65536) {
            if ((e3 -= 3) < 0)
              break;
            i2.push(r3 >> 12 | 224, r3 >> 6 & 63 | 128, 63 & r3 | 128);
          } else {
            if (!(r3 < 1114112))
              throw new Error("Invalid code point");
            if ((e3 -= 4) < 0)
              break;
            i2.push(r3 >> 18 | 240, r3 >> 12 & 63 | 128, r3 >> 6 & 63 | 128, 63 & r3 | 128);
          }
        }
        return i2;
      }
      function F(t4) {
        return o.toByteArray(function(t5) {
          if ((t5 = (t5 = t5.split("=")[0]).trim().replace(U, "")).length < 2)
            return "";
          for (;t5.length % 4 != 0; )
            t5 += "=";
          return t5;
        }(t4));
      }
      function L(t4, e3, r3, n2) {
        for (var o2 = 0;o2 < n2 && !(o2 + r3 >= e3.length || o2 >= t4.length); ++o2)
          e3[o2 + r3] = t4[o2];
        return o2;
      }
      function V(t4, e3) {
        return t4 instanceof e3 || t4 != null && t4.constructor != null && t4.constructor.name != null && t4.constructor.name === e3.name;
      }
      function q(t4) {
        return t4 != t4;
      }
      var J = function() {
        for (var t4 = "0123456789abcdef", e3 = new Array(256), r3 = 0;r3 < 16; ++r3)
          for (var n2 = 16 * r3, o2 = 0;o2 < 16; ++o2)
            e3[n2 + o2] = t4[r3] + t4[o2];
        return e3;
      }();
    }, 5889: (t3, e2, r2) => {
      function n(t4, e3) {
        var r3 = typeof Symbol != "undefined" && t4[Symbol.iterator] || t4["@@iterator"];
        if (!r3) {
          if (Array.isArray(t4) || (r3 = o(t4)) || e3 && t4 && typeof t4.length == "number") {
            r3 && (t4 = r3);
            var n2 = 0, i2 = function() {};
            return { s: i2, n: function() {
              return n2 >= t4.length ? { done: true } : { done: false, value: t4[n2++] };
            }, e: function(t5) {
              throw t5;
            }, f: i2 };
          }
          throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        var s2, a2 = true, u2 = false;
        return { s: function() {
          r3 = r3.call(t4);
        }, n: function() {
          var t5 = r3.next();
          return a2 = t5.done, t5;
        }, e: function(t5) {
          u2 = true, s2 = t5;
        }, f: function() {
          try {
            a2 || r3.return == null || r3.return();
          } finally {
            if (u2)
              throw s2;
          }
        } };
      }
      function o(t4, e3) {
        if (t4) {
          if (typeof t4 == "string")
            return i(t4, e3);
          var r3 = {}.toString.call(t4).slice(8, -1);
          return r3 === "Object" && t4.constructor && (r3 = t4.constructor.name), r3 === "Map" || r3 === "Set" ? Array.from(t4) : r3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? i(t4, e3) : undefined;
        }
      }
      function i(t4, e3) {
        (e3 == null || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = Array(e3);r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      var s = r2(7930).arrayAtomicsSymbol, a = r2(7930).sessionNewDocuments, u = r2(8768);
      function c(t4, e3) {
        return t4 = t4 || {}, e3.$pullAll != null && (t4.$pullAll = (t4.$pullAll || []).concat(e3.$pullAll)), e3.$push != null && (t4.$push = t4.$push || {}, t4.$push.$each = (t4.$push.$each || []).concat(e3.$push.$each)), e3.$addToSet != null && (t4.$addToSet = (t4.$addToSet || []).concat(e3.$addToSet)), e3.$set != null && (t4.$set = Array.isArray(e3.$set) ? function(t5) {
          if (Array.isArray(t5))
            return i(t5);
        }(r3 = e3.$set) || function(t5) {
          if (typeof Symbol != "undefined" && t5[Symbol.iterator] != null || t5["@@iterator"] != null)
            return Array.from(t5);
        }(r3) || o(r3) || function() {
          throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }() : Object.assign({}, e3.$set)), t4;
        var r3;
      }
      t3.exports = function(t4) {
        t4.pre("save", function() {
          var t5 = this.$session();
          if (t5 != null && t5.transaction != null && t5[a] != null && !t5[a].has(this)) {
            var e3 = {};
            this.isNew && (e3.isNew = true), this.$__schema.options.versionKey && (e3.versionKey = this.get(this.$__schema.options.versionKey)), e3.modifiedPaths = new Set(Object.keys(this.$__.activePaths.getStatePaths("modify"))), e3.atomics = function(t6, e4) {
              var r3 = new Map;
              e4 = e4 || new Map;
              var o2, i2 = n(Object.keys(t6.$__.activePaths.init).concat(Object.keys(t6.$__.activePaths.modify)));
              try {
                for (i2.s();!(o2 = i2.n()).done; ) {
                  var a2 = o2.value, l = t6.$__getValue(a2);
                  if (l != null && Array.isArray(l) && u.isMongooseDocumentArray(l) && l.length && l[s] != null && Object.keys(l[s]).length !== 0) {
                    var f = e4.get(a2) || {};
                    r3.set(a2, c(f, l[s]));
                  }
                }
              } catch (t7) {
                i2.e(t7);
              } finally {
                i2.f();
              }
              var p, h = n(t6.$__dirty());
              try {
                for (h.s();!(p = h.n()).done; ) {
                  var y = p.value, d = y.path, b = y.value;
                  if (b != null && b[s] != null && Object.keys(b[s]).length !== 0) {
                    var m = e4.get(d) || {};
                    r3.set(d, c(m, b[s]));
                  }
                }
              } catch (t7) {
                h.e(t7);
              } finally {
                h.f();
              }
              return r3;
            }(this), t5[a].set(this, e3);
          }
        });
      };
    }, 5899: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var o = r2(953)(), i = r2(3071)("Object.prototype.toString"), s = function(t4) {
        return !(o && t4 && n(t4) === "object" && (Symbol.toStringTag in t4)) && i(t4) === "[object Arguments]";
      }, a = function(t4) {
        return !!s(t4) || t4 !== null && n(t4) === "object" && "length" in t4 && typeof t4.length == "number" && t4.length >= 0 && i(t4) !== "[object Array]" && "callee" in t4 && i(t4.callee) === "[object Function]";
      }, u = function() {
        return s(arguments);
      }();
      s.isLegacyArguments = a, t3.exports = u ? s : a;
    }, 5994: (t3, e2, r2) => {
      var n = Function.prototype.call, o = Object.prototype.hasOwnProperty, i = r2(2354);
      t3.exports = i.call(n, o);
    }, 6062: (t3, e2, r2) => {
      var n = r2(9122), o = r2(2273), i = r2(118), s = r2(4183), a = r2(7878), u = n(s(), Number);
      o(u, { getPolyfill: s, implementation: i, shim: a }), t3.exports = u;
    }, 6140: (t3) => {
      function e2(t4) {
        return e2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      function r2(t4, e3) {
        for (var r3 = 0;r3 < e3.length; r3++) {
          var n2 = e3[r3];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t4, o(n2.key), n2);
        }
      }
      function n(t4, e3, n2) {
        return e3 && r2(t4.prototype, e3), n2 && r2(t4, n2), Object.defineProperty(t4, "prototype", { writable: false }), t4;
      }
      function o(t4) {
        var r3 = function(t5) {
          if (e2(t5) != "object" || !t5)
            return t5;
          var r4 = t5[Symbol.toPrimitive];
          if (r4 !== undefined) {
            var n2 = r4.call(t5, "string");
            if (e2(n2) != "object")
              return n2;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t5);
        }(t4);
        return e2(r3) == "symbol" ? r3 : r3 + "";
      }
      t3.exports = n(function t(e3, r3, n2) {
        (function(t4, e4) {
          if (!(t4 instanceof e4))
            throw new TypeError("Cannot call a class as a function");
        })(this, t), this.subdocSnapshot = e3, this.activePaths = r3, this.version = n2;
      });
    }, 6155: (t3) => {
      function e2(t4) {
        return e2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      t3.exports = function(t4) {
        for (var r2 = Object.keys(t4), n = true, o = 0, i = r2.length;o < i; ++o)
          if (e2(t4[r2[o]]) === "object" && t4[r2[o]] !== null) {
            n = false;
            break;
          }
        return n;
      };
    }, 6182: (t3) => {
      function e2(t4, e3) {
        if (t4 == null)
          throw new TypeError("Cannot convert first argument to object");
        for (var r2 = Object(t4), n = 1;n < arguments.length; n++) {
          var o = arguments[n];
          if (o != null)
            for (var i = Object.keys(Object(o)), s = 0, a = i.length;s < a; s++) {
              var u = i[s], c = Object.getOwnPropertyDescriptor(o, u);
              c !== undefined && c.enumerable && (r2[u] = o[u]);
            }
        }
        return r2;
      }
      t3.exports = { assign: e2, polyfill: function() {
        Object.assign || Object.defineProperty(Object, "assign", { enumerable: false, configurable: true, writable: true, value: e2 });
      } };
    }, 6193: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o(t4, e3) {
        return function(t5) {
          if (Array.isArray(t5))
            return t5;
        }(t4) || function(t5, e4) {
          var r3 = [], n2 = true, o2 = false, i2 = undefined;
          try {
            for (var s2, a2 = t5[Symbol.iterator]();!(n2 = (s2 = a2.next()).done) && (r3.push(s2.value), !e4 || r3.length !== e4); n2 = true)
              ;
          } catch (t6) {
            o2 = true, i2 = t6;
          } finally {
            try {
              n2 || a2.return == null || a2.return();
            } finally {
              if (o2)
                throw i2;
            }
          }
          return r3;
        }(t4, e3) || function() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }();
      }
      function i(t4) {
        return i = typeof Symbol == "function" && n(Symbol.iterator) === "symbol" ? function(t5) {
          return n(t5);
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : n(t5);
        }, i(t4);
      }
      var s = /a/g.flags !== undefined, a = function(t4) {
        var e3 = [];
        return t4.forEach(function(t5) {
          return e3.push(t5);
        }), e3;
      }, u = function(t4) {
        var e3 = [];
        return t4.forEach(function(t5, r3) {
          return e3.push([r3, t5]);
        }), e3;
      }, c = Object.is ? Object.is : r2(2064), l = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
        return [];
      }, f = Number.isNaN ? Number.isNaN : r2(6062);
      function p(t4) {
        return t4.call.bind(t4);
      }
      var h = p(Object.prototype.hasOwnProperty), y = p(Object.prototype.propertyIsEnumerable), d = p(Object.prototype.toString), b = r2(7352).types, m = b.isAnyArrayBuffer, v = b.isArrayBufferView, g = b.isDate, _ = b.isMap, w = b.isRegExp, O = b.isSet, S = b.isNativeError, $ = b.isBoxedPrimitive, j = b.isNumberObject, P = b.isStringObject, A = b.isBooleanObject, E = b.isBigIntObject, x = b.isSymbolObject, T = b.isFloat32Array, k = b.isFloat64Array;
      function N(t4) {
        if (t4.length === 0 || t4.length > 10)
          return true;
        for (var e3 = 0;e3 < t4.length; e3++) {
          var r3 = t4.charCodeAt(e3);
          if (r3 < 48 || r3 > 57)
            return true;
        }
        return t4.length === 10 && t4 >= Math.pow(2, 32);
      }
      function I(t4) {
        return Object.keys(t4).filter(N).concat(l(t4).filter(Object.prototype.propertyIsEnumerable.bind(t4)));
      }
      function B(t4, e3) {
        if (t4 === e3)
          return 0;
        for (var r3 = t4.length, n2 = e3.length, o2 = 0, i2 = Math.min(r3, n2);o2 < i2; ++o2)
          if (t4[o2] !== e3[o2]) {
            r3 = t4[o2], n2 = e3[o2];
            break;
          }
        return r3 < n2 ? -1 : n2 < r3 ? 1 : 0;
      }
      function M(t4, e3, r3, n2) {
        if (t4 === e3)
          return t4 !== 0 || !r3 || c(t4, e3);
        if (r3) {
          if (i(t4) !== "object")
            return typeof t4 == "number" && f(t4) && f(e3);
          if (i(e3) !== "object" || t4 === null || e3 === null)
            return false;
          if (Object.getPrototypeOf(t4) !== Object.getPrototypeOf(e3))
            return false;
        } else {
          if (t4 === null || i(t4) !== "object")
            return (e3 === null || i(e3) !== "object") && t4 == e3;
          if (e3 === null || i(e3) !== "object")
            return false;
        }
        var o2, a2, u2, l2, p2 = d(t4);
        if (p2 !== d(e3))
          return false;
        if (Array.isArray(t4)) {
          if (t4.length !== e3.length)
            return false;
          var h2 = I(t4), y2 = I(e3);
          return h2.length === y2.length && R(t4, e3, r3, n2, 1, h2);
        }
        if (p2 === "[object Object]" && (!_(t4) && _(e3) || !O(t4) && O(e3)))
          return false;
        if (g(t4)) {
          if (!g(e3) || Date.prototype.getTime.call(t4) !== Date.prototype.getTime.call(e3))
            return false;
        } else if (w(t4)) {
          if (!w(e3) || (u2 = t4, l2 = e3, !(s ? u2.source === l2.source && u2.flags === l2.flags : RegExp.prototype.toString.call(u2) === RegExp.prototype.toString.call(l2))))
            return false;
        } else if (S(t4) || t4 instanceof Error) {
          if (t4.message !== e3.message || t4.name !== e3.name)
            return false;
        } else {
          if (v(t4)) {
            if (r3 || !T(t4) && !k(t4)) {
              if (!function(t5, e4) {
                return t5.byteLength === e4.byteLength && B(new Uint8Array(t5.buffer, t5.byteOffset, t5.byteLength), new Uint8Array(e4.buffer, e4.byteOffset, e4.byteLength)) === 0;
              }(t4, e3))
                return false;
            } else if (!function(t5, e4) {
              if (t5.byteLength !== e4.byteLength)
                return false;
              for (var r4 = 0;r4 < t5.byteLength; r4++)
                if (t5[r4] !== e4[r4])
                  return false;
              return true;
            }(t4, e3))
              return false;
            var b2 = I(t4), N2 = I(e3);
            return b2.length === N2.length && R(t4, e3, r3, n2, 0, b2);
          }
          if (O(t4))
            return !(!O(e3) || t4.size !== e3.size) && R(t4, e3, r3, n2, 2);
          if (_(t4))
            return !(!_(e3) || t4.size !== e3.size) && R(t4, e3, r3, n2, 3);
          if (m(t4)) {
            if (a2 = e3, (o2 = t4).byteLength !== a2.byteLength || B(new Uint8Array(o2), new Uint8Array(a2)) !== 0)
              return false;
          } else if ($(t4) && !function(t5, e4) {
            return j(t5) ? j(e4) && c(Number.prototype.valueOf.call(t5), Number.prototype.valueOf.call(e4)) : P(t5) ? P(e4) && String.prototype.valueOf.call(t5) === String.prototype.valueOf.call(e4) : A(t5) ? A(e4) && Boolean.prototype.valueOf.call(t5) === Boolean.prototype.valueOf.call(e4) : E(t5) ? E(e4) && BigInt.prototype.valueOf.call(t5) === BigInt.prototype.valueOf.call(e4) : x(e4) && Symbol.prototype.valueOf.call(t5) === Symbol.prototype.valueOf.call(e4);
          }(t4, e3))
            return false;
        }
        return R(t4, e3, r3, n2, 0);
      }
      function D(t4, e3) {
        return e3.filter(function(e4) {
          return y(t4, e4);
        });
      }
      function R(t4, e3, r3, n2, s2, c2) {
        if (arguments.length === 5) {
          c2 = Object.keys(t4);
          var f2 = Object.keys(e3);
          if (c2.length !== f2.length)
            return false;
        }
        for (var p2 = 0;p2 < c2.length; p2++)
          if (!h(e3, c2[p2]))
            return false;
        if (r3 && arguments.length === 5) {
          var d2 = l(t4);
          if (d2.length !== 0) {
            var b2 = 0;
            for (p2 = 0;p2 < d2.length; p2++) {
              var m2 = d2[p2];
              if (y(t4, m2)) {
                if (!y(e3, m2))
                  return false;
                c2.push(m2), b2++;
              } else if (y(e3, m2))
                return false;
            }
            var v2 = l(e3);
            if (d2.length !== v2.length && D(e3, v2).length !== b2)
              return false;
          } else {
            var g2 = l(e3);
            if (g2.length !== 0 && D(e3, g2).length !== 0)
              return false;
          }
        }
        if (c2.length === 0 && (s2 === 0 || s2 === 1 && t4.length === 0 || t4.size === 0))
          return true;
        if (n2 === undefined)
          n2 = { val1: new Map, val2: new Map, position: 0 };
        else {
          var _2 = n2.val1.get(t4);
          if (_2 !== undefined) {
            var w2 = n2.val2.get(e3);
            if (w2 !== undefined)
              return _2 === w2;
          }
          n2.position++;
        }
        n2.val1.set(t4, n2.position), n2.val2.set(e3, n2.position);
        var O2 = function(t5, e4, r4, n3, s3, c3) {
          var l2 = 0;
          if (c3 === 2) {
            if (!function(t6, e5, r5, n4) {
              for (var o2 = null, s4 = a(t6), u2 = 0;u2 < s4.length; u2++) {
                var c4 = s4[u2];
                if (i(c4) === "object" && c4 !== null)
                  o2 === null && (o2 = new Set), o2.add(c4);
                else if (!e5.has(c4)) {
                  if (r5)
                    return false;
                  if (!F(t6, e5, c4))
                    return false;
                  o2 === null && (o2 = new Set), o2.add(c4);
                }
              }
              if (o2 !== null) {
                for (var l3 = a(e5), f4 = 0;f4 < l3.length; f4++) {
                  var p4 = l3[f4];
                  if (i(p4) === "object" && p4 !== null) {
                    if (!U(o2, p4, r5, n4))
                      return false;
                  } else if (!r5 && !t6.has(p4) && !U(o2, p4, r5, n4))
                    return false;
                }
                return o2.size === 0;
              }
              return true;
            }(t5, e4, r4, s3))
              return false;
          } else if (c3 === 3) {
            if (!function(t6, e5, r5, n4) {
              for (var s4 = null, a2 = u(t6), c4 = 0;c4 < a2.length; c4++) {
                var l3 = o(a2[c4], 2), f4 = l3[0], p4 = l3[1];
                if (i(f4) === "object" && f4 !== null)
                  s4 === null && (s4 = new Set), s4.add(f4);
                else {
                  var h2 = e5.get(f4);
                  if (h2 === undefined && !e5.has(f4) || !M(p4, h2, r5, n4)) {
                    if (r5)
                      return false;
                    if (!L(t6, e5, f4, p4, n4))
                      return false;
                    s4 === null && (s4 = new Set), s4.add(f4);
                  }
                }
              }
              if (s4 !== null) {
                for (var y3 = u(e5), d3 = 0;d3 < y3.length; d3++) {
                  var b3 = o(y3[d3], 2), m3 = (f4 = b3[0], b3[1]);
                  if (i(f4) === "object" && f4 !== null) {
                    if (!V(s4, t6, f4, m3, r5, n4))
                      return false;
                  } else if (!(r5 || t6.has(f4) && M(t6.get(f4), m3, false, n4) || V(s4, t6, f4, m3, false, n4)))
                    return false;
                }
                return s4.size === 0;
              }
              return true;
            }(t5, e4, r4, s3))
              return false;
          } else if (c3 === 1)
            for (;l2 < t5.length; l2++) {
              if (!h(t5, l2)) {
                if (h(e4, l2))
                  return false;
                for (var f3 = Object.keys(t5);l2 < f3.length; l2++) {
                  var p3 = f3[l2];
                  if (!h(e4, p3) || !M(t5[p3], e4[p3], r4, s3))
                    return false;
                }
                return f3.length === Object.keys(e4).length;
              }
              if (!h(e4, l2) || !M(t5[l2], e4[l2], r4, s3))
                return false;
            }
          for (l2 = 0;l2 < n3.length; l2++) {
            var y2 = n3[l2];
            if (!M(t5[y2], e4[y2], r4, s3))
              return false;
          }
          return true;
        }(t4, e3, r3, c2, n2, s2);
        return n2.val1.delete(t4), n2.val2.delete(e3), O2;
      }
      function U(t4, e3, r3, n2) {
        for (var o2 = a(t4), i2 = 0;i2 < o2.length; i2++) {
          var s2 = o2[i2];
          if (M(e3, s2, r3, n2))
            return t4.delete(s2), true;
        }
        return false;
      }
      function C(t4) {
        switch (i(t4)) {
          case "undefined":
            return null;
          case "object":
            return;
          case "symbol":
            return false;
          case "string":
            t4 = +t4;
          case "number":
            if (f(t4))
              return false;
        }
        return true;
      }
      function F(t4, e3, r3) {
        var n2 = C(r3);
        return n2 != null ? n2 : e3.has(n2) && !t4.has(n2);
      }
      function L(t4, e3, r3, n2, o2) {
        var i2 = C(r3);
        if (i2 != null)
          return i2;
        var s2 = e3.get(i2);
        return !(s2 === undefined && !e3.has(i2) || !M(n2, s2, false, o2)) && !t4.has(i2) && M(n2, s2, false, o2);
      }
      function V(t4, e3, r3, n2, o2, i2) {
        for (var s2 = a(t4), u2 = 0;u2 < s2.length; u2++) {
          var c2 = s2[u2];
          if (M(r3, c2, o2, i2) && M(n2, e3.get(c2), o2, i2))
            return t4.delete(c2), true;
        }
        return false;
      }
      t3.exports = { isDeepEqual: function(t4, e3) {
        return M(t4, e3, false);
      }, isDeepStrictEqual: function(t4, e3) {
        return M(t4, e3, true);
      } };
    }, 6223: (t3) => {
      var e2 = /\./g;
      t3.exports = function(t4) {
        if (t4.indexOf(".") === -1)
          return [t4];
        for (var r2 = t4.split(e2), n = r2.length, o = new Array(n), i = "", s = 0;s < n; ++s)
          i += i.length !== 0 ? "." + r2[s] : r2[s], o[s] = i;
        return o;
      };
    }, 6312: (t3) => {
      function e2(t4) {
        return e2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      var r2 = Object.prototype.toString;
      t3.exports = function(t4) {
        var n = r2.call(t4), o = n === "[object Arguments]";
        return o || (o = n !== "[object Array]" && t4 !== null && e2(t4) === "object" && typeof t4.length == "number" && t4.length >= 0 && r2.call(t4.callee) === "[object Function]"), o;
      };
    }, 6353: (t3, e2, r2) => {
      r2.r(e2), r2.d(e2, { BSON: () => ze, BSONError: () => q, BSONOffsetError: () => K, BSONRegExp: () => Ht, BSONRuntimeError: () => z, BSONSymbol: () => Wt, BSONType: () => V, BSONValue: () => nt, BSONVersionError: () => J, Binary: () => ut, Code: () => ht, DBRef: () => dt, Decimal128: () => Rt, Double: () => Ut, EJSON: () => Ie, Int32: () => Ct, Long: () => $t, MaxKey: () => Ft, MinKey: () => Lt, ObjectId: () => Jt, Timestamp: () => Qt, UUID: () => pt, calculateObjectSize: () => qe, deserialize: () => Ve, deserializeStream: () => Je, onDemand: () => De, serialize: () => Fe, serializeWithBufferAndIndex: () => Le, setInternalBufferSize: () => Ce });
      var n = r2(5832).hp;
      const o = (() => {
        const t4 = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Uint8Array.prototype), Symbol.toStringTag).get;
        return (e3) => t4.call(e3);
      })();
      function i(t4) {
        return o(t4) === "Uint8Array";
      }
      function s(t4) {
        return typeof t4 == "object" && t4 != null && Symbol.toStringTag in t4 && (t4[Symbol.toStringTag] === "ArrayBuffer" || t4[Symbol.toStringTag] === "SharedArrayBuffer");
      }
      function a(t4) {
        return t4 instanceof RegExp || Object.prototype.toString.call(t4) === "[object RegExp]";
      }
      function u(t4) {
        return typeof t4 == "object" && t4 != null && Symbol.toStringTag in t4 && t4[Symbol.toStringTag] === "Map";
      }
      function c(t4) {
        return t4 instanceof Date || Object.prototype.toString.call(t4) === "[object Date]";
      }
      function l(t4, e3) {
        return JSON.stringify(t4, (t5, e4) => typeof e4 == "bigint" ? { $numberLong: `${e4}` } : u(e4) ? Object.fromEntries(e4) : e4);
      }
      const f = 6, p = Symbol.for("@@mdb.bson.version"), h = 2147483647, y = -2147483648, d = Math.pow(2, 63) - 1, b = -Math.pow(2, 63), m = Math.pow(2, 53), v = -Math.pow(2, 53), g = 1, _ = 2, w = 3, O = 4, S = 5, $ = 6, j = 7, P = 8, A = 9, E = 10, x = 11, T = 12, k = 13, N = 14, I = 15, B = 16, M = 17, D = 18, R = 19, U = 255, C = 127, F = 0, L = 4, V = Object.freeze({ double: 1, string: 2, object: 3, array: 4, binData: 5, undefined: 6, objectId: 7, bool: 8, date: 9, null: 10, regex: 11, dbPointer: 12, javascript: 13, symbol: 14, javascriptWithScope: 15, int: 16, timestamp: 17, long: 18, decimal: 19, minKey: -1, maxKey: 127 });

      class q extends Error {
        get bsonError() {
          return true;
        }
        get name() {
          return "BSONError";
        }
        constructor(t4, e3) {
          super(t4, e3);
        }
        static isBSONError(t4) {
          return t4 != null && typeof t4 == "object" && "bsonError" in t4 && t4.bsonError === true && "name" in t4 && "message" in t4 && "stack" in t4;
        }
      }

      class J extends q {
        get name() {
          return "BSONVersionError";
        }
        constructor() {
          super(`Unsupported BSON version, bson types must be from bson ${f}.x.x`);
        }
      }

      class z extends q {
        get name() {
          return "BSONRuntimeError";
        }
        constructor(t4) {
          super(t4);
        }
      }

      class K extends q {
        get name() {
          return "BSONOffsetError";
        }
        constructor(t4, e3, r3) {
          super(`${t4}. offset: ${e3}`, r3), this.offset = e3;
        }
      }
      let H, W;
      function G(t4, e3, r3, n2) {
        if (n2) {
          H ??= new TextDecoder("utf8", { fatal: true });
          try {
            return H.decode(t4.subarray(e3, r3));
          } catch (t5) {
            throw new q("Invalid UTF-8 string in BSON document", { cause: t5 });
          }
        }
        return W ??= new TextDecoder("utf8", { fatal: false }), W.decode(t4.subarray(e3, r3));
      }
      function Q(t4, e3, r3) {
        if (t4.length === 0)
          return "";
        const n2 = r3 - e3;
        if (n2 === 0)
          return "";
        if (n2 > 20)
          return null;
        if (n2 === 1 && t4[e3] < 128)
          return String.fromCharCode(t4[e3]);
        if (n2 === 2 && t4[e3] < 128 && t4[e3 + 1] < 128)
          return String.fromCharCode(t4[e3]) + String.fromCharCode(t4[e3 + 1]);
        if (n2 === 3 && t4[e3] < 128 && t4[e3 + 1] < 128 && t4[e3 + 2] < 128)
          return String.fromCharCode(t4[e3]) + String.fromCharCode(t4[e3 + 1]) + String.fromCharCode(t4[e3 + 2]);
        const o2 = [];
        for (let n3 = e3;n3 < r3; n3++) {
          const e4 = t4[n3];
          if (e4 > 127)
            return null;
          o2.push(e4);
        }
        return String.fromCharCode(...o2);
      }
      const Y = { toLocalBufferType(t4) {
        if (n.isBuffer(t4))
          return t4;
        if (ArrayBuffer.isView(t4))
          return n.from(t4.buffer, t4.byteOffset, t4.byteLength);
        const e3 = t4?.[Symbol.toStringTag] ?? Object.prototype.toString.call(t4);
        if (e3 === "ArrayBuffer" || e3 === "SharedArrayBuffer" || e3 === "[object ArrayBuffer]" || e3 === "[object SharedArrayBuffer]")
          return n.from(t4);
        throw new q("Cannot create Buffer from the passed potentialBuffer.");
      }, allocate: (t4) => n.alloc(t4), allocateUnsafe: (t4) => n.allocUnsafe(t4), equals: (t4, e3) => Y.toLocalBufferType(t4).equals(e3), fromNumberArray: (t4) => n.from(t4), fromBase64: (t4) => n.from(t4, "base64"), toBase64: (t4) => Y.toLocalBufferType(t4).toString("base64"), fromISO88591: (t4) => n.from(t4, "binary"), toISO88591: (t4) => Y.toLocalBufferType(t4).toString("binary"), fromHex: (t4) => n.from(t4, "hex"), toHex: (t4) => Y.toLocalBufferType(t4).toString("hex"), toUTF8(t4, e3, r3, n2) {
        const o2 = r3 - e3 <= 20 ? Q(t4, e3, r3) : null;
        if (o2 != null)
          return o2;
        const i2 = Y.toLocalBufferType(t4).toString("utf8", e3, r3);
        if (n2) {
          for (let n3 = 0;n3 < i2.length; n3++)
            if (i2.charCodeAt(n3) === 65533) {
              G(t4, e3, r3, true);
              break;
            }
        }
        return i2;
      }, utf8ByteLength: (t4) => n.byteLength(t4, "utf8"), encodeUTF8Into(t4, e3, r3) {
        const n2 = function(t5, e4, r4) {
          if (e4.length === 0)
            return 0;
          if (e4.length > 25)
            return null;
          if (t5.length - r4 < e4.length)
            return null;
          for (let n3 = 0, o2 = r4;n3 < e4.length; n3++, o2++) {
            const r5 = e4.charCodeAt(n3);
            if (r5 > 127)
              return null;
            t5[o2] = r5;
          }
          return e4.length;
        }(t4, e3, r3);
        return n2 != null ? n2 : Y.toLocalBufferType(t4).write(e3, r3, undefined, "utf8");
      }, randomBytes: function(t4) {
        return Y.fromNumberArray(Array.from({ length: t4 }, () => Math.floor(256 * Math.random())));
      }, swap32: (t4) => Y.toLocalBufferType(t4).swap32() };
      function Z(t4) {
        if (t4 < 0)
          throw new RangeError(`The argument 'byteLength' is invalid. Received ${t4}`);
        return et.fromNumberArray(Array.from({ length: t4 }, () => Math.floor(256 * Math.random())));
      }
      const X = (() => {
        const { crypto: t4 } = globalThis;
        if (t4 != null && typeof t4.getRandomValues == "function")
          return (e3) => t4.getRandomValues(et.allocate(e3));
        if (function() {
          const { navigator: t5 } = globalThis;
          return typeof t5 == "object" && t5.product === "ReactNative";
        }()) {
          const { console: t5 } = globalThis;
          t5?.warn?.("BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.");
        }
        return Z;
      })(), tt = /(\d|[a-f])/i, et = { toLocalBufferType(t4) {
        const e3 = t4?.[Symbol.toStringTag] ?? Object.prototype.toString.call(t4);
        if (e3 === "Uint8Array")
          return t4;
        if (ArrayBuffer.isView(t4))
          return new Uint8Array(t4.buffer.slice(t4.byteOffset, t4.byteOffset + t4.byteLength));
        if (e3 === "ArrayBuffer" || e3 === "SharedArrayBuffer" || e3 === "[object ArrayBuffer]" || e3 === "[object SharedArrayBuffer]")
          return new Uint8Array(t4);
        throw new q("Cannot make a Uint8Array from passed potentialBuffer.");
      }, allocate(t4) {
        if (typeof t4 != "number")
          throw new TypeError(`The "size" argument must be of type number. Received ${String(t4)}`);
        return new Uint8Array(t4);
      }, allocateUnsafe: (t4) => et.allocate(t4), equals(t4, e3) {
        if (t4.byteLength !== e3.byteLength)
          return false;
        for (let r3 = 0;r3 < t4.byteLength; r3++)
          if (t4[r3] !== e3[r3])
            return false;
        return true;
      }, fromNumberArray: (t4) => Uint8Array.from(t4), fromBase64: (t4) => Uint8Array.from(atob(t4), (t5) => t5.charCodeAt(0)), toBase64: (t4) => btoa(et.toISO88591(t4)), fromISO88591: (t4) => Uint8Array.from(t4, (t5) => 255 & t5.charCodeAt(0)), toISO88591: (t4) => Array.from(Uint16Array.from(t4), (t5) => String.fromCharCode(t5)).join(""), fromHex(t4) {
        const e3 = t4.length % 2 == 0 ? t4 : t4.slice(0, t4.length - 1), r3 = [];
        for (let t5 = 0;t5 < e3.length; t5 += 2) {
          const n2 = e3[t5], o2 = e3[t5 + 1];
          if (!tt.test(n2))
            break;
          if (!tt.test(o2))
            break;
          const i2 = Number.parseInt(`${n2}${o2}`, 16);
          r3.push(i2);
        }
        return Uint8Array.from(r3);
      }, toHex: (t4) => Array.from(t4, (t5) => t5.toString(16).padStart(2, "0")).join(""), toUTF8(t4, e3, r3, n2) {
        const o2 = r3 - e3 <= 20 ? Q(t4, e3, r3) : null;
        return o2 != null ? o2 : G(t4, e3, r3, n2);
      }, utf8ByteLength: (t4) => new TextEncoder().encode(t4).byteLength, encodeUTF8Into(t4, e3, r3) {
        const n2 = new TextEncoder().encode(e3);
        return t4.set(n2, r3), n2.byteLength;
      }, randomBytes: X, swap32(t4) {
        if (t4.length % 4 != 0)
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let e3 = 0;e3 < t4.length; e3 += 4) {
          const r3 = t4[e3], n2 = t4[e3 + 1], o2 = t4[e3 + 2], i2 = t4[e3 + 3];
          t4[e3] = i2, t4[e3 + 1] = o2, t4[e3 + 2] = n2, t4[e3 + 3] = r3;
        }
        return t4;
      } }, rt = typeof n == "function" && n.prototype?._isBuffer !== true ? Y : et;

      class nt {
        get [p]() {
          return f;
        }
        [Symbol.for("nodejs.util.inspect.custom")](t4, e3, r3) {
          return this.inspect(t4, e3, r3);
        }
      }
      const ot = new Float64Array(1), it = new Uint8Array(ot.buffer, 0, 8);
      ot[0] = -1;
      const st = it[7] === 0, at = { isBigEndian: st, getNonnegativeInt32LE(t4, e3) {
        if (t4[e3 + 3] > 127)
          throw new RangeError(`Size cannot be negative at offset: ${e3}`);
        return t4[e3] | t4[e3 + 1] << 8 | t4[e3 + 2] << 16 | t4[e3 + 3] << 24;
      }, getInt32LE: (t4, e3) => t4[e3] | t4[e3 + 1] << 8 | t4[e3 + 2] << 16 | t4[e3 + 3] << 24, getUint32LE: (t4, e3) => t4[e3] + 256 * t4[e3 + 1] + 65536 * t4[e3 + 2] + 16777216 * t4[e3 + 3], getUint32BE: (t4, e3) => t4[e3 + 3] + 256 * t4[e3 + 2] + 65536 * t4[e3 + 1] + 16777216 * t4[e3], getBigInt64LE(t4, e3) {
        const r3 = BigInt(t4[e3 + 4] + 256 * t4[e3 + 5] + 65536 * t4[e3 + 6] + (t4[e3 + 7] << 24)), n2 = BigInt(t4[e3] + 256 * t4[e3 + 1] + 65536 * t4[e3 + 2] + 16777216 * t4[e3 + 3]);
        return (r3 << BigInt(32)) + n2;
      }, getFloat64LE: st ? (t4, e3) => (it[7] = t4[e3], it[6] = t4[e3 + 1], it[5] = t4[e3 + 2], it[4] = t4[e3 + 3], it[3] = t4[e3 + 4], it[2] = t4[e3 + 5], it[1] = t4[e3 + 6], it[0] = t4[e3 + 7], ot[0]) : (t4, e3) => (it[0] = t4[e3], it[1] = t4[e3 + 1], it[2] = t4[e3 + 2], it[3] = t4[e3 + 3], it[4] = t4[e3 + 4], it[5] = t4[e3 + 5], it[6] = t4[e3 + 6], it[7] = t4[e3 + 7], ot[0]), setInt32BE: (t4, e3, r3) => (t4[e3 + 3] = r3, r3 >>>= 8, t4[e3 + 2] = r3, r3 >>>= 8, t4[e3 + 1] = r3, r3 >>>= 8, t4[e3] = r3, 4), setInt32LE: (t4, e3, r3) => (t4[e3] = r3, r3 >>>= 8, t4[e3 + 1] = r3, r3 >>>= 8, t4[e3 + 2] = r3, r3 >>>= 8, t4[e3 + 3] = r3, 4), setBigInt64LE(t4, e3, r3) {
        const n2 = BigInt(4294967295);
        let o2 = Number(r3 & n2);
        t4[e3] = o2, o2 >>= 8, t4[e3 + 1] = o2, o2 >>= 8, t4[e3 + 2] = o2, o2 >>= 8, t4[e3 + 3] = o2;
        let i2 = Number(r3 >> BigInt(32) & n2);
        return t4[e3 + 4] = i2, i2 >>= 8, t4[e3 + 5] = i2, i2 >>= 8, t4[e3 + 6] = i2, i2 >>= 8, t4[e3 + 7] = i2, 8;
      }, setFloat64LE: st ? (t4, e3, r3) => (ot[0] = r3, t4[e3] = it[7], t4[e3 + 1] = it[6], t4[e3 + 2] = it[5], t4[e3 + 3] = it[4], t4[e3 + 4] = it[3], t4[e3 + 5] = it[2], t4[e3 + 6] = it[1], t4[e3 + 7] = it[0], 8) : (t4, e3, r3) => (ot[0] = r3, t4[e3] = it[0], t4[e3 + 1] = it[1], t4[e3 + 2] = it[2], t4[e3 + 3] = it[3], t4[e3 + 4] = it[4], t4[e3 + 5] = it[5], t4[e3 + 6] = it[6], t4[e3 + 7] = it[7], 8) };

      class ut extends nt {
        get _bsontype() {
          return "Binary";
        }
        constructor(t4, e3) {
          if (super(), t4 != null && typeof t4 == "string" && !ArrayBuffer.isView(t4) && !s(t4) && !Array.isArray(t4))
            throw new q("Binary can only be constructed from Uint8Array or number[]");
          this.sub_type = e3 ?? ut.BSON_BINARY_SUBTYPE_DEFAULT, t4 == null ? (this.buffer = rt.allocate(ut.BUFFER_SIZE), this.position = 0) : (this.buffer = Array.isArray(t4) ? rt.fromNumberArray(t4) : rt.toLocalBufferType(t4), this.position = this.buffer.byteLength);
        }
        put(t4) {
          if (typeof t4 == "string" && t4.length !== 1)
            throw new q("only accepts single character String");
          if (typeof t4 != "number" && t4.length !== 1)
            throw new q("only accepts single character Uint8Array or Array");
          let e3;
          if (e3 = typeof t4 == "string" ? t4.charCodeAt(0) : typeof t4 == "number" ? t4 : t4[0], e3 < 0 || e3 > 255)
            throw new q("only accepts number in a valid unsigned byte range 0-255");
          if (this.buffer.byteLength > this.position)
            this.buffer[this.position++] = e3;
          else {
            const t5 = rt.allocate(ut.BUFFER_SIZE + this.buffer.length);
            t5.set(this.buffer, 0), this.buffer = t5, this.buffer[this.position++] = e3;
          }
        }
        write(t4, e3) {
          if (e3 = typeof e3 == "number" ? e3 : this.position, this.buffer.byteLength < e3 + t4.length) {
            const e4 = rt.allocate(this.buffer.byteLength + t4.length);
            e4.set(this.buffer, 0), this.buffer = e4;
          }
          if (ArrayBuffer.isView(t4))
            this.buffer.set(rt.toLocalBufferType(t4), e3), this.position = e3 + t4.byteLength > this.position ? e3 + t4.length : this.position;
          else if (typeof t4 == "string")
            throw new q("input cannot be string");
        }
        read(t4, e3) {
          const r3 = t4 + (e3 = e3 && e3 > 0 ? e3 : this.position);
          return this.buffer.subarray(t4, r3 > this.position ? this.position : r3);
        }
        value() {
          return this.buffer.length === this.position ? this.buffer : this.buffer.subarray(0, this.position);
        }
        length() {
          return this.position;
        }
        toJSON() {
          return rt.toBase64(this.buffer.subarray(0, this.position));
        }
        toString(t4) {
          return t4 === "hex" ? rt.toHex(this.buffer.subarray(0, this.position)) : t4 === "base64" ? rt.toBase64(this.buffer.subarray(0, this.position)) : rt.toUTF8(this.buffer, 0, this.position, false);
        }
        toExtendedJSON(t4) {
          t4 = t4 || {}, this.sub_type === ut.SUBTYPE_VECTOR && ct(this);
          const e3 = rt.toBase64(this.buffer), r3 = Number(this.sub_type).toString(16);
          return t4.legacy ? { $binary: e3, $type: r3.length === 1 ? "0" + r3 : r3 } : { $binary: { base64: e3, subType: r3.length === 1 ? "0" + r3 : r3 } };
        }
        toUUID() {
          if (this.sub_type === ut.SUBTYPE_UUID)
            return new pt(this.buffer.subarray(0, this.position));
          throw new q(`Binary sub_type "${this.sub_type}" is not supported for converting to UUID. Only "${ut.SUBTYPE_UUID}" is currently supported.`);
        }
        static createFromHexString(t4, e3) {
          return new ut(rt.fromHex(t4), e3);
        }
        static createFromBase64(t4, e3) {
          return new ut(rt.fromBase64(t4), e3);
        }
        static fromExtendedJSON(t4, e3) {
          let r3, n2;
          if (e3 = e3 || {}, "$binary" in t4 ? e3.legacy && typeof t4.$binary == "string" && "$type" in t4 ? (n2 = t4.$type ? parseInt(t4.$type, 16) : 0, r3 = rt.fromBase64(t4.$binary)) : typeof t4.$binary != "string" && (n2 = t4.$binary.subType ? parseInt(t4.$binary.subType, 16) : 0, r3 = rt.fromBase64(t4.$binary.base64)) : ("$uuid" in t4) && (n2 = 4, r3 = pt.bytesFromString(t4.$uuid)), !r3)
            throw new q(`Unexpected Binary Extended JSON format ${JSON.stringify(t4)}`);
          return n2 === L ? new pt(r3) : new ut(r3, n2);
        }
        inspect(t4, e3, r3) {
          return r3 ??= l, `Binary.createFromBase64(${r3(rt.toBase64(this.buffer.subarray(0, this.position)), e3)}, ${r3(this.sub_type, e3)})`;
        }
        toInt8Array() {
          if (this.sub_type !== ut.SUBTYPE_VECTOR)
            throw new q("Binary sub_type is not Vector");
          if (this.buffer[0] !== ut.VECTOR_TYPE.Int8)
            throw new q("Binary datatype field is not Int8");
          return ct(this), new Int8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));
        }
        toFloat32Array() {
          if (this.sub_type !== ut.SUBTYPE_VECTOR)
            throw new q("Binary sub_type is not Vector");
          if (this.buffer[0] !== ut.VECTOR_TYPE.Float32)
            throw new q("Binary datatype field is not Float32");
          ct(this);
          const t4 = new Uint8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));
          return at.isBigEndian && rt.swap32(t4), new Float32Array(t4.buffer);
        }
        toPackedBits() {
          if (this.sub_type !== ut.SUBTYPE_VECTOR)
            throw new q("Binary sub_type is not Vector");
          if (this.buffer[0] !== ut.VECTOR_TYPE.PackedBit)
            throw new q("Binary datatype field is not packed bit");
          return ct(this), new Uint8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));
        }
        toBits() {
          if (this.sub_type !== ut.SUBTYPE_VECTOR)
            throw new q("Binary sub_type is not Vector");
          if (this.buffer[0] !== ut.VECTOR_TYPE.PackedBit)
            throw new q("Binary datatype field is not packed bit");
          ct(this);
          const t4 = 8 * (this.length() - 2) - this.buffer[1], e3 = new Int8Array(t4);
          for (let t5 = 0;t5 < e3.length; t5++) {
            const r3 = t5 / 8 | 0, n2 = this.buffer[r3 + 2] >> 7 - t5 % 8 & 1;
            e3[t5] = n2;
          }
          return e3;
        }
        static fromInt8Array(t4) {
          const e3 = rt.allocate(t4.byteLength + 2);
          e3[0] = ut.VECTOR_TYPE.Int8, e3[1] = 0;
          const r3 = new Uint8Array(t4.buffer, t4.byteOffset, t4.byteLength);
          e3.set(r3, 2);
          const n2 = new this(e3, this.SUBTYPE_VECTOR);
          return ct(n2), n2;
        }
        static fromFloat32Array(t4) {
          const e3 = rt.allocate(t4.byteLength + 2);
          e3[0] = ut.VECTOR_TYPE.Float32, e3[1] = 0;
          const r3 = new Uint8Array(t4.buffer, t4.byteOffset, t4.byteLength);
          e3.set(r3, 2), at.isBigEndian && rt.swap32(new Uint8Array(e3.buffer, 2));
          const n2 = new this(e3, this.SUBTYPE_VECTOR);
          return ct(n2), n2;
        }
        static fromPackedBits(t4, e3 = 0) {
          const r3 = rt.allocate(t4.byteLength + 2);
          r3[0] = ut.VECTOR_TYPE.PackedBit, r3[1] = e3, r3.set(t4, 2);
          const n2 = new this(r3, this.SUBTYPE_VECTOR);
          return ct(n2), n2;
        }
        static fromBits(t4) {
          const e3 = t4.length + 7 >>> 3, r3 = new Uint8Array(e3 + 2);
          r3[0] = ut.VECTOR_TYPE.PackedBit;
          const n2 = t4.length % 8;
          r3[1] = n2 === 0 ? 0 : 8 - n2;
          for (let e4 = 0;e4 < t4.length; e4++) {
            const n3 = e4 >>> 3, o2 = t4[e4];
            if (o2 !== 0 && o2 !== 1)
              throw new q(`Invalid bit value at ${e4}: must be 0 or 1, found ${t4[e4]}`);
            if (o2 === 0)
              continue;
            const i2 = 7 - e4 % 8;
            r3[n3 + 2] |= o2 << i2;
          }
          return new this(r3, ut.SUBTYPE_VECTOR);
        }
      }
      function ct(t4) {
        if (t4.sub_type !== ut.SUBTYPE_VECTOR)
          return;
        const e3 = t4.position, r3 = t4.buffer[0], n2 = t4.buffer[1];
        if ((r3 === ut.VECTOR_TYPE.Float32 || r3 === ut.VECTOR_TYPE.Int8) && n2 !== 0)
          throw new q("Invalid Vector: padding must be zero for int8 and float32 vectors");
        if (r3 === ut.VECTOR_TYPE.Float32 && e3 !== 0 && e3 - 2 != 0 && (e3 - 2) % 4 != 0)
          throw new q("Invalid Vector: Float32 vector must contain a multiple of 4 bytes");
        if (r3 === ut.VECTOR_TYPE.PackedBit && n2 !== 0 && e3 === 2)
          throw new q("Invalid Vector: padding must be zero for packed bit vectors that are empty");
        if (r3 === ut.VECTOR_TYPE.PackedBit && n2 > 7)
          throw new q(`Invalid Vector: padding must be a value between 0 and 7. found: ${n2}`);
      }
      ut.BSON_BINARY_SUBTYPE_DEFAULT = 0, ut.BUFFER_SIZE = 256, ut.SUBTYPE_DEFAULT = 0, ut.SUBTYPE_FUNCTION = 1, ut.SUBTYPE_BYTE_ARRAY = 2, ut.SUBTYPE_UUID_OLD = 3, ut.SUBTYPE_UUID = 4, ut.SUBTYPE_MD5 = 5, ut.SUBTYPE_ENCRYPTED = 6, ut.SUBTYPE_COLUMN = 7, ut.SUBTYPE_SENSITIVE = 8, ut.SUBTYPE_VECTOR = 9, ut.SUBTYPE_USER_DEFINED = 128, ut.VECTOR_TYPE = Object.freeze({ Int8: 3, Float32: 39, PackedBit: 16 });
      const lt = /^[0-9A-F]{32}$/i, ft = /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;

      class pt extends ut {
        constructor(t4) {
          let e3;
          if (t4 == null)
            e3 = pt.generate();
          else if (t4 instanceof pt)
            e3 = rt.toLocalBufferType(new Uint8Array(t4.buffer));
          else if (ArrayBuffer.isView(t4) && t4.byteLength === 16)
            e3 = rt.toLocalBufferType(t4);
          else {
            if (typeof t4 != "string")
              throw new q("Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).");
            e3 = pt.bytesFromString(t4);
          }
          super(e3, L);
        }
        get id() {
          return this.buffer;
        }
        set id(t4) {
          this.buffer = t4;
        }
        toHexString(t4 = true) {
          return t4 ? [rt.toHex(this.buffer.subarray(0, 4)), rt.toHex(this.buffer.subarray(4, 6)), rt.toHex(this.buffer.subarray(6, 8)), rt.toHex(this.buffer.subarray(8, 10)), rt.toHex(this.buffer.subarray(10, 16))].join("-") : rt.toHex(this.buffer);
        }
        toString(t4) {
          return t4 === "hex" ? rt.toHex(this.id) : t4 === "base64" ? rt.toBase64(this.id) : this.toHexString();
        }
        toJSON() {
          return this.toHexString();
        }
        equals(t4) {
          if (!t4)
            return false;
          if (t4 instanceof pt)
            return rt.equals(t4.id, this.id);
          try {
            return rt.equals(new pt(t4).id, this.id);
          } catch {
            return false;
          }
        }
        toBinary() {
          return new ut(this.id, ut.SUBTYPE_UUID);
        }
        static generate() {
          const t4 = rt.randomBytes(16);
          return t4[6] = 15 & t4[6] | 64, t4[8] = 63 & t4[8] | 128, t4;
        }
        static isValid(t4) {
          return !!t4 && (typeof t4 == "string" ? pt.isValidUUIDString(t4) : i(t4) ? t4.byteLength === 16 : t4._bsontype === "Binary" && t4.sub_type === this.SUBTYPE_UUID && t4.buffer.byteLength === 16);
        }
        static createFromHexString(t4) {
          const e3 = pt.bytesFromString(t4);
          return new pt(e3);
        }
        static createFromBase64(t4) {
          return new pt(rt.fromBase64(t4));
        }
        static bytesFromString(t4) {
          if (!pt.isValidUUIDString(t4))
            throw new q("UUID string representation must be 32 hex digits or canonical hyphenated representation");
          return rt.fromHex(t4.replace(/-/g, ""));
        }
        static isValidUUIDString(t4) {
          return lt.test(t4) || ft.test(t4);
        }
        inspect(t4, e3, r3) {
          return r3 ??= l, `new UUID(${r3(this.toHexString(), e3)})`;
        }
      }

      class ht extends nt {
        get _bsontype() {
          return "Code";
        }
        constructor(t4, e3) {
          super(), this.code = t4.toString(), this.scope = e3 ?? null;
        }
        toJSON() {
          return this.scope != null ? { code: this.code, scope: this.scope } : { code: this.code };
        }
        toExtendedJSON() {
          return this.scope ? { $code: this.code, $scope: this.scope } : { $code: this.code };
        }
        static fromExtendedJSON(t4) {
          return new ht(t4.$code, t4.$scope);
        }
        inspect(t4, e3, r3) {
          r3 ??= l;
          let n2 = r3(this.code, e3);
          const o2 = n2.includes(`
`);
          return this.scope != null && (n2 += `,${o2 ? `
` : " "}${r3(this.scope, e3)}`), `new Code(${o2 ? `
` : ""}${n2}${o2 && this.scope === null ? `
` : ""})`;
        }
      }
      function yt(t4) {
        return t4 != null && typeof t4 == "object" && "$id" in t4 && t4.$id != null && "$ref" in t4 && typeof t4.$ref == "string" && (!("$db" in t4) || ("$db" in t4) && typeof t4.$db == "string");
      }

      class dt extends nt {
        get _bsontype() {
          return "DBRef";
        }
        constructor(t4, e3, r3, n2) {
          super();
          const o2 = t4.split(".");
          o2.length === 2 && (r3 = o2.shift(), t4 = o2.shift()), this.collection = t4, this.oid = e3, this.db = r3, this.fields = n2 || {};
        }
        get namespace() {
          return this.collection;
        }
        set namespace(t4) {
          this.collection = t4;
        }
        toJSON() {
          const t4 = Object.assign({ $ref: this.collection, $id: this.oid }, this.fields);
          return this.db != null && (t4.$db = this.db), t4;
        }
        toExtendedJSON(t4) {
          t4 = t4 || {};
          let e3 = { $ref: this.collection, $id: this.oid };
          return t4.legacy || (this.db && (e3.$db = this.db), e3 = Object.assign(e3, this.fields)), e3;
        }
        static fromExtendedJSON(t4) {
          const e3 = Object.assign({}, t4);
          return delete e3.$ref, delete e3.$id, delete e3.$db, new dt(t4.$ref, t4.$id, t4.$db, e3);
        }
        inspect(t4, e3, r3) {
          r3 ??= l;
          const n2 = [r3(this.namespace, e3), r3(this.oid, e3), ...this.db ? [r3(this.db, e3)] : [], ...Object.keys(this.fields).length > 0 ? [r3(this.fields, e3)] : []];
          return n2[1] = r3 === l ? `new ObjectId(${n2[1]})` : n2[1], `new DBRef(${n2.join(", ")})`;
        }
      }
      function bt(t4) {
        if (t4 === "")
          return t4;
        let e3 = 0;
        const r3 = t4[e3] === "-", n2 = t4[e3] === "+";
        (n2 || r3) && (e3 += 1);
        let o2 = false;
        for (;e3 < t4.length && t4[e3] === "0"; ++e3)
          o2 = true;
        return o2 ? `${r3 ? "-" : ""}${t4.length === e3 ? "0" : t4.slice(e3)}` : n2 ? t4.slice(1) : t4;
      }
      let mt;
      try {
        mt = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
      } catch {}
      const vt = 4294967296, gt = 18446744073709552000, _t = gt / 2, wt = {}, Ot = {}, St = /^(\+?0|(\+|-)?[1-9][0-9]*)$/;

      class $t extends nt {
        get _bsontype() {
          return "Long";
        }
        get __isLong__() {
          return true;
        }
        constructor(t4 = 0, e3, r3) {
          super();
          const n2 = typeof e3 == "boolean" ? e3 : Boolean(r3), o2 = typeof e3 == "number" ? e3 : 0, i2 = typeof t4 == "string" ? $t.fromString(t4, n2) : typeof t4 == "bigint" ? $t.fromBigInt(t4, n2) : { low: 0 | t4, high: 0 | o2, unsigned: n2 };
          this.low = i2.low, this.high = i2.high, this.unsigned = i2.unsigned;
        }
        static fromBits(t4, e3, r3) {
          return new $t(t4, e3, r3);
        }
        static fromInt(t4, e3) {
          let r3, n2, o2;
          return e3 ? (o2 = 0 <= (t4 >>>= 0) && t4 < 256) && (n2 = Ot[t4], n2) ? n2 : (r3 = $t.fromBits(t4, (0 | t4) < 0 ? -1 : 0, true), o2 && (Ot[t4] = r3), r3) : (o2 = -128 <= (t4 |= 0) && t4 < 128) && (n2 = wt[t4], n2) ? n2 : (r3 = $t.fromBits(t4, t4 < 0 ? -1 : 0, false), o2 && (wt[t4] = r3), r3);
        }
        static fromNumber(t4, e3) {
          if (isNaN(t4))
            return e3 ? $t.UZERO : $t.ZERO;
          if (e3) {
            if (t4 < 0)
              return $t.UZERO;
            if (t4 >= gt)
              return $t.MAX_UNSIGNED_VALUE;
          } else {
            if (t4 <= -9223372036854776000)
              return $t.MIN_VALUE;
            if (t4 + 1 >= _t)
              return $t.MAX_VALUE;
          }
          return t4 < 0 ? $t.fromNumber(-t4, e3).neg() : $t.fromBits(t4 % vt | 0, t4 / vt | 0, e3);
        }
        static fromBigInt(t4, e3) {
          const r3 = BigInt(4294967295), n2 = BigInt(32);
          return new $t(Number(t4 & r3), Number(t4 >> n2 & r3), e3);
        }
        static _fromString(t4, e3, r3) {
          if (t4.length === 0)
            throw new q("empty string");
          if (r3 < 2 || 36 < r3)
            throw new q("radix");
          let n2;
          if ((n2 = t4.indexOf("-")) > 0)
            throw new q("interior hyphen");
          if (n2 === 0)
            return $t._fromString(t4.substring(1), e3, r3).neg();
          const o2 = $t.fromNumber(Math.pow(r3, 8));
          let i2 = $t.ZERO;
          for (let e4 = 0;e4 < t4.length; e4 += 8) {
            const n3 = Math.min(8, t4.length - e4), s2 = parseInt(t4.substring(e4, e4 + n3), r3);
            if (n3 < 8) {
              const t5 = $t.fromNumber(Math.pow(r3, n3));
              i2 = i2.mul(t5).add($t.fromNumber(s2));
            } else
              i2 = i2.mul(o2), i2 = i2.add($t.fromNumber(s2));
          }
          return i2.unsigned = e3, i2;
        }
        static fromStringStrict(t4, e3, r3) {
          let n2 = false;
          if (typeof e3 == "number" ? (r3 = e3, e3 = false) : n2 = !!e3, r3 ??= 10, t4.trim() !== t4)
            throw new q(`Input: '${t4}' contains leading and/or trailing whitespace`);
          if (!function(t5, e4) {
            const r4 = "0123456789abcdefghijklmnopqrstuvwxyz".slice(0, e4 = e4 ?? 10);
            return !new RegExp(`[^-+${r4}]`, "i").test(t5) && t5;
          }(t4, r3))
            throw new q(`Input: '${t4}' contains invalid characters for radix: ${r3}`);
          const o2 = bt(t4), i2 = $t._fromString(o2, n2, r3);
          if (i2.toString(r3).toLowerCase() !== o2.toLowerCase())
            throw new q(`Input: ${t4} is not representable as ${i2.unsigned ? "an unsigned" : "a signed"} 64-bit Long ${r3 != null ? `with radix: ${r3}` : ""}`);
          return i2;
        }
        static fromString(t4, e3, r3) {
          let n2 = false;
          return typeof e3 == "number" ? (r3 = e3, e3 = false) : n2 = !!e3, r3 ??= 10, t4 === "NaN" && r3 < 24 || (t4 === "Infinity" || t4 === "+Infinity" || t4 === "-Infinity") && r3 < 35 ? $t.ZERO : $t._fromString(t4, n2, r3);
        }
        static fromBytes(t4, e3, r3) {
          return r3 ? $t.fromBytesLE(t4, e3) : $t.fromBytesBE(t4, e3);
        }
        static fromBytesLE(t4, e3) {
          return new $t(t4[0] | t4[1] << 8 | t4[2] << 16 | t4[3] << 24, t4[4] | t4[5] << 8 | t4[6] << 16 | t4[7] << 24, e3);
        }
        static fromBytesBE(t4, e3) {
          return new $t(t4[4] << 24 | t4[5] << 16 | t4[6] << 8 | t4[7], t4[0] << 24 | t4[1] << 16 | t4[2] << 8 | t4[3], e3);
        }
        static isLong(t4) {
          return t4 != null && typeof t4 == "object" && "__isLong__" in t4 && t4.__isLong__ === true;
        }
        static fromValue(t4, e3) {
          return typeof t4 == "number" ? $t.fromNumber(t4, e3) : typeof t4 == "string" ? $t.fromString(t4, e3) : $t.fromBits(t4.low, t4.high, typeof e3 == "boolean" ? e3 : t4.unsigned);
        }
        add(t4) {
          $t.isLong(t4) || (t4 = $t.fromValue(t4));
          const e3 = this.high >>> 16, r3 = 65535 & this.high, n2 = this.low >>> 16, o2 = 65535 & this.low, i2 = t4.high >>> 16, s2 = 65535 & t4.high, a2 = t4.low >>> 16;
          let u2 = 0, c2 = 0, l2 = 0, f2 = 0;
          return f2 += o2 + (65535 & t4.low), l2 += f2 >>> 16, f2 &= 65535, l2 += n2 + a2, c2 += l2 >>> 16, l2 &= 65535, c2 += r3 + s2, u2 += c2 >>> 16, c2 &= 65535, u2 += e3 + i2, u2 &= 65535, $t.fromBits(l2 << 16 | f2, u2 << 16 | c2, this.unsigned);
        }
        and(t4) {
          return $t.isLong(t4) || (t4 = $t.fromValue(t4)), $t.fromBits(this.low & t4.low, this.high & t4.high, this.unsigned);
        }
        compare(t4) {
          if ($t.isLong(t4) || (t4 = $t.fromValue(t4)), this.eq(t4))
            return 0;
          const e3 = this.isNegative(), r3 = t4.isNegative();
          return e3 && !r3 ? -1 : !e3 && r3 ? 1 : this.unsigned ? t4.high >>> 0 > this.high >>> 0 || t4.high === this.high && t4.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(t4).isNegative() ? -1 : 1;
        }
        comp(t4) {
          return this.compare(t4);
        }
        divide(t4) {
          if ($t.isLong(t4) || (t4 = $t.fromValue(t4)), t4.isZero())
            throw new q("division by zero");
          if (mt) {
            if (!this.unsigned && this.high === -2147483648 && t4.low === -1 && t4.high === -1)
              return this;
            const e4 = (this.unsigned ? mt.div_u : mt.div_s)(this.low, this.high, t4.low, t4.high);
            return $t.fromBits(e4, mt.get_high(), this.unsigned);
          }
          if (this.isZero())
            return this.unsigned ? $t.UZERO : $t.ZERO;
          let e3, r3, n2;
          if (this.unsigned) {
            if (t4.unsigned || (t4 = t4.toUnsigned()), t4.gt(this))
              return $t.UZERO;
            if (t4.gt(this.shru(1)))
              return $t.UONE;
            n2 = $t.UZERO;
          } else {
            if (this.eq($t.MIN_VALUE))
              return t4.eq($t.ONE) || t4.eq($t.NEG_ONE) ? $t.MIN_VALUE : t4.eq($t.MIN_VALUE) ? $t.ONE : (e3 = this.shr(1).div(t4).shl(1), e3.eq($t.ZERO) ? t4.isNegative() ? $t.ONE : $t.NEG_ONE : (r3 = this.sub(t4.mul(e3)), n2 = e3.add(r3.div(t4)), n2));
            if (t4.eq($t.MIN_VALUE))
              return this.unsigned ? $t.UZERO : $t.ZERO;
            if (this.isNegative())
              return t4.isNegative() ? this.neg().div(t4.neg()) : this.neg().div(t4).neg();
            if (t4.isNegative())
              return this.div(t4.neg()).neg();
            n2 = $t.ZERO;
          }
          for (r3 = this;r3.gte(t4); ) {
            e3 = Math.max(1, Math.floor(r3.toNumber() / t4.toNumber()));
            const o2 = Math.ceil(Math.log(e3) / Math.LN2), i2 = o2 <= 48 ? 1 : Math.pow(2, o2 - 48);
            let s2 = $t.fromNumber(e3), a2 = s2.mul(t4);
            for (;a2.isNegative() || a2.gt(r3); )
              e3 -= i2, s2 = $t.fromNumber(e3, this.unsigned), a2 = s2.mul(t4);
            s2.isZero() && (s2 = $t.ONE), n2 = n2.add(s2), r3 = r3.sub(a2);
          }
          return n2;
        }
        div(t4) {
          return this.divide(t4);
        }
        equals(t4) {
          return $t.isLong(t4) || (t4 = $t.fromValue(t4)), (this.unsigned === t4.unsigned || this.high >>> 31 != 1 || t4.high >>> 31 != 1) && this.high === t4.high && this.low === t4.low;
        }
        eq(t4) {
          return this.equals(t4);
        }
        getHighBits() {
          return this.high;
        }
        getHighBitsUnsigned() {
          return this.high >>> 0;
        }
        getLowBits() {
          return this.low;
        }
        getLowBitsUnsigned() {
          return this.low >>> 0;
        }
        getNumBitsAbs() {
          if (this.isNegative())
            return this.eq($t.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
          const t4 = this.high !== 0 ? this.high : this.low;
          let e3;
          for (e3 = 31;e3 > 0 && !(t4 & 1 << e3); e3--)
            ;
          return this.high !== 0 ? e3 + 33 : e3 + 1;
        }
        greaterThan(t4) {
          return this.comp(t4) > 0;
        }
        gt(t4) {
          return this.greaterThan(t4);
        }
        greaterThanOrEqual(t4) {
          return this.comp(t4) >= 0;
        }
        gte(t4) {
          return this.greaterThanOrEqual(t4);
        }
        ge(t4) {
          return this.greaterThanOrEqual(t4);
        }
        isEven() {
          return !(1 & this.low);
        }
        isNegative() {
          return !this.unsigned && this.high < 0;
        }
        isOdd() {
          return !(1 & ~this.low);
        }
        isPositive() {
          return this.unsigned || this.high >= 0;
        }
        isZero() {
          return this.high === 0 && this.low === 0;
        }
        lessThan(t4) {
          return this.comp(t4) < 0;
        }
        lt(t4) {
          return this.lessThan(t4);
        }
        lessThanOrEqual(t4) {
          return this.comp(t4) <= 0;
        }
        lte(t4) {
          return this.lessThanOrEqual(t4);
        }
        modulo(t4) {
          if ($t.isLong(t4) || (t4 = $t.fromValue(t4)), mt) {
            const e3 = (this.unsigned ? mt.rem_u : mt.rem_s)(this.low, this.high, t4.low, t4.high);
            return $t.fromBits(e3, mt.get_high(), this.unsigned);
          }
          return this.sub(this.div(t4).mul(t4));
        }
        mod(t4) {
          return this.modulo(t4);
        }
        rem(t4) {
          return this.modulo(t4);
        }
        multiply(t4) {
          if (this.isZero())
            return $t.ZERO;
          if ($t.isLong(t4) || (t4 = $t.fromValue(t4)), mt) {
            const e4 = mt.mul(this.low, this.high, t4.low, t4.high);
            return $t.fromBits(e4, mt.get_high(), this.unsigned);
          }
          if (t4.isZero())
            return $t.ZERO;
          if (this.eq($t.MIN_VALUE))
            return t4.isOdd() ? $t.MIN_VALUE : $t.ZERO;
          if (t4.eq($t.MIN_VALUE))
            return this.isOdd() ? $t.MIN_VALUE : $t.ZERO;
          if (this.isNegative())
            return t4.isNegative() ? this.neg().mul(t4.neg()) : this.neg().mul(t4).neg();
          if (t4.isNegative())
            return this.mul(t4.neg()).neg();
          if (this.lt($t.TWO_PWR_24) && t4.lt($t.TWO_PWR_24))
            return $t.fromNumber(this.toNumber() * t4.toNumber(), this.unsigned);
          const e3 = this.high >>> 16, r3 = 65535 & this.high, n2 = this.low >>> 16, o2 = 65535 & this.low, i2 = t4.high >>> 16, s2 = 65535 & t4.high, a2 = t4.low >>> 16, u2 = 65535 & t4.low;
          let c2 = 0, l2 = 0, f2 = 0, p2 = 0;
          return p2 += o2 * u2, f2 += p2 >>> 16, p2 &= 65535, f2 += n2 * u2, l2 += f2 >>> 16, f2 &= 65535, f2 += o2 * a2, l2 += f2 >>> 16, f2 &= 65535, l2 += r3 * u2, c2 += l2 >>> 16, l2 &= 65535, l2 += n2 * a2, c2 += l2 >>> 16, l2 &= 65535, l2 += o2 * s2, c2 += l2 >>> 16, l2 &= 65535, c2 += e3 * u2 + r3 * a2 + n2 * s2 + o2 * i2, c2 &= 65535, $t.fromBits(f2 << 16 | p2, c2 << 16 | l2, this.unsigned);
        }
        mul(t4) {
          return this.multiply(t4);
        }
        negate() {
          return !this.unsigned && this.eq($t.MIN_VALUE) ? $t.MIN_VALUE : this.not().add($t.ONE);
        }
        neg() {
          return this.negate();
        }
        not() {
          return $t.fromBits(~this.low, ~this.high, this.unsigned);
        }
        notEquals(t4) {
          return !this.equals(t4);
        }
        neq(t4) {
          return this.notEquals(t4);
        }
        ne(t4) {
          return this.notEquals(t4);
        }
        or(t4) {
          return $t.isLong(t4) || (t4 = $t.fromValue(t4)), $t.fromBits(this.low | t4.low, this.high | t4.high, this.unsigned);
        }
        shiftLeft(t4) {
          return $t.isLong(t4) && (t4 = t4.toInt()), (t4 &= 63) == 0 ? this : t4 < 32 ? $t.fromBits(this.low << t4, this.high << t4 | this.low >>> 32 - t4, this.unsigned) : $t.fromBits(0, this.low << t4 - 32, this.unsigned);
        }
        shl(t4) {
          return this.shiftLeft(t4);
        }
        shiftRight(t4) {
          return $t.isLong(t4) && (t4 = t4.toInt()), (t4 &= 63) == 0 ? this : t4 < 32 ? $t.fromBits(this.low >>> t4 | this.high << 32 - t4, this.high >> t4, this.unsigned) : $t.fromBits(this.high >> t4 - 32, this.high >= 0 ? 0 : -1, this.unsigned);
        }
        shr(t4) {
          return this.shiftRight(t4);
        }
        shiftRightUnsigned(t4) {
          if ($t.isLong(t4) && (t4 = t4.toInt()), (t4 &= 63) == 0)
            return this;
          {
            const e3 = this.high;
            if (t4 < 32) {
              const r3 = this.low;
              return $t.fromBits(r3 >>> t4 | e3 << 32 - t4, e3 >>> t4, this.unsigned);
            }
            return t4 === 32 ? $t.fromBits(e3, 0, this.unsigned) : $t.fromBits(e3 >>> t4 - 32, 0, this.unsigned);
          }
        }
        shr_u(t4) {
          return this.shiftRightUnsigned(t4);
        }
        shru(t4) {
          return this.shiftRightUnsigned(t4);
        }
        subtract(t4) {
          return $t.isLong(t4) || (t4 = $t.fromValue(t4)), this.add(t4.neg());
        }
        sub(t4) {
          return this.subtract(t4);
        }
        toInt() {
          return this.unsigned ? this.low >>> 0 : this.low;
        }
        toNumber() {
          return this.unsigned ? (this.high >>> 0) * vt + (this.low >>> 0) : this.high * vt + (this.low >>> 0);
        }
        toBigInt() {
          return BigInt(this.toString());
        }
        toBytes(t4) {
          return t4 ? this.toBytesLE() : this.toBytesBE();
        }
        toBytesLE() {
          const t4 = this.high, e3 = this.low;
          return [255 & e3, e3 >>> 8 & 255, e3 >>> 16 & 255, e3 >>> 24, 255 & t4, t4 >>> 8 & 255, t4 >>> 16 & 255, t4 >>> 24];
        }
        toBytesBE() {
          const t4 = this.high, e3 = this.low;
          return [t4 >>> 24, t4 >>> 16 & 255, t4 >>> 8 & 255, 255 & t4, e3 >>> 24, e3 >>> 16 & 255, e3 >>> 8 & 255, 255 & e3];
        }
        toSigned() {
          return this.unsigned ? $t.fromBits(this.low, this.high, false) : this;
        }
        toString(t4) {
          if ((t4 = t4 || 10) < 2 || 36 < t4)
            throw new q("radix");
          if (this.isZero())
            return "0";
          if (this.isNegative()) {
            if (this.eq($t.MIN_VALUE)) {
              const e4 = $t.fromNumber(t4), r4 = this.div(e4), n3 = r4.mul(e4).sub(this);
              return r4.toString(t4) + n3.toInt().toString(t4);
            }
            return "-" + this.neg().toString(t4);
          }
          const e3 = $t.fromNumber(Math.pow(t4, 6), this.unsigned);
          let r3 = this, n2 = "";
          for (;; ) {
            const o2 = r3.div(e3);
            let i2 = (r3.sub(o2.mul(e3)).toInt() >>> 0).toString(t4);
            if (r3 = o2, r3.isZero())
              return i2 + n2;
            for (;i2.length < 6; )
              i2 = "0" + i2;
            n2 = "" + i2 + n2;
          }
        }
        toUnsigned() {
          return this.unsigned ? this : $t.fromBits(this.low, this.high, true);
        }
        xor(t4) {
          return $t.isLong(t4) || (t4 = $t.fromValue(t4)), $t.fromBits(this.low ^ t4.low, this.high ^ t4.high, this.unsigned);
        }
        eqz() {
          return this.isZero();
        }
        le(t4) {
          return this.lessThanOrEqual(t4);
        }
        toExtendedJSON(t4) {
          return t4 && t4.relaxed ? this.toNumber() : { $numberLong: this.toString() };
        }
        static fromExtendedJSON(t4, e3) {
          const { useBigInt64: r3 = false, relaxed: n2 = true } = { ...e3 };
          if (t4.$numberLong.length > 20)
            throw new q("$numberLong string is too long");
          if (!St.test(t4.$numberLong))
            throw new q(`$numberLong string "${t4.$numberLong}" is in an invalid format`);
          if (r3) {
            const e4 = BigInt(t4.$numberLong);
            return BigInt.asIntN(64, e4);
          }
          const o2 = $t.fromString(t4.$numberLong);
          return n2 ? o2.toNumber() : o2;
        }
        inspect(t4, e3, r3) {
          return r3 ??= l, `new Long(${r3(this.toString(), e3)}${this.unsigned ? `, ${r3(this.unsigned, e3)}` : ""})`;
        }
      }
      $t.TWO_PWR_24 = $t.fromInt(1 << 24), $t.MAX_UNSIGNED_VALUE = $t.fromBits(-1, -1, true), $t.ZERO = $t.fromInt(0), $t.UZERO = $t.fromInt(0, true), $t.ONE = $t.fromInt(1), $t.UONE = $t.fromInt(1, true), $t.NEG_ONE = $t.fromInt(-1), $t.MAX_VALUE = $t.fromBits(-1, 2147483647, false), $t.MIN_VALUE = $t.fromBits(0, -2147483648, false);
      const jt = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/, Pt = /^(\+|-)?(Infinity|inf)$/i, At = /^(\+|-)?NaN$/i, Et = 6111, xt = -6176, Tt = rt.fromNumberArray([124, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0].reverse()), kt = rt.fromNumberArray([248, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0].reverse()), Nt = rt.fromNumberArray([120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0].reverse()), It = /^([-+])?(\d+)?$/;
      function Bt(t4) {
        return !isNaN(parseInt(t4, 10));
      }
      function Mt(t4) {
        const e3 = $t.fromNumber(1e9);
        let r3 = $t.fromNumber(0);
        if (!(t4.parts[0] || t4.parts[1] || t4.parts[2] || t4.parts[3]))
          return { quotient: t4, rem: r3 };
        for (let n2 = 0;n2 <= 3; n2++)
          r3 = r3.shiftLeft(32), r3 = r3.add(new $t(t4.parts[n2], 0)), t4.parts[n2] = r3.div(e3).low, r3 = r3.modulo(e3);
        return { quotient: t4, rem: r3 };
      }
      function Dt(t4, e3) {
        throw new q(`"${t4}" is not a valid Decimal128 string - ${e3}`);
      }

      class Rt extends nt {
        get _bsontype() {
          return "Decimal128";
        }
        constructor(t4) {
          if (super(), typeof t4 == "string")
            this.bytes = Rt.fromString(t4).bytes;
          else {
            if (!(t4 instanceof Uint8Array || i(t4)))
              throw new q("Decimal128 must take a Buffer or string");
            if (t4.byteLength !== 16)
              throw new q("Decimal128 must take a Buffer of 16 bytes");
            this.bytes = t4;
          }
        }
        static fromString(t4) {
          return Rt._fromString(t4, { allowRounding: false });
        }
        static fromStringWithRounding(t4) {
          return Rt._fromString(t4, { allowRounding: true });
        }
        static _fromString(t4, e3) {
          let r3 = false, n2 = false, o2 = false, i2 = false, s2 = 0, a2 = 0, u2 = 0, c2 = 0, l2 = 0;
          const f2 = [0];
          let p2 = 0, h2 = 0, y2 = 0, d2 = 0, b2 = new $t(0, 0), m2 = new $t(0, 0), v2 = 0, g2 = 0;
          if (t4.length >= 7000)
            throw new q(t4 + " not a valid Decimal128 string");
          const _2 = t4.match(jt), w2 = t4.match(Pt), O2 = t4.match(At);
          if (!_2 && !w2 && !O2 || t4.length === 0)
            throw new q(t4 + " not a valid Decimal128 string");
          if (_2) {
            const e4 = _2[2], r4 = _2[4], n3 = _2[5], o3 = _2[6];
            r4 && o3 === undefined && Dt(t4, "missing exponent power"), r4 && e4 === undefined && Dt(t4, "missing exponent base"), r4 === undefined && (n3 || o3) && Dt(t4, "missing e before exponent");
          }
          if (t4[g2] !== "+" && t4[g2] !== "-" || (n2 = true, r3 = t4[g2++] === "-"), !Bt(t4[g2]) && t4[g2] !== ".") {
            if (t4[g2] === "i" || t4[g2] === "I")
              return new Rt(r3 ? kt : Nt);
            if (t4[g2] === "N")
              return new Rt(Tt);
          }
          for (;Bt(t4[g2]) || t4[g2] === "."; )
            t4[g2] !== "." ? (p2 < 34 && (t4[g2] !== "0" || i2) && (i2 || (l2 = a2), i2 = true, f2[h2++] = parseInt(t4[g2], 10), p2 += 1), i2 && (u2 += 1), o2 && (c2 += 1), a2 += 1, g2 += 1) : (o2 && Dt(t4, "contains multiple periods"), o2 = true, g2 += 1);
          if (o2 && !a2)
            throw new q(t4 + " not a valid Decimal128 string");
          if (t4[g2] === "e" || t4[g2] === "E") {
            const e4 = t4.substr(++g2).match(It);
            if (!e4 || !e4[2])
              return new Rt(Tt);
            d2 = parseInt(e4[0], 10), g2 += e4[0].length;
          }
          if (t4[g2])
            return new Rt(Tt);
          if (p2) {
            if (y2 = p2 - 1, s2 = u2, s2 !== 1)
              for (;t4[l2 + s2 - 1 + Number(n2) + Number(o2)] === "0"; )
                s2 -= 1;
          } else
            f2[0] = 0, u2 = 1, p2 = 1, s2 = 0;
          for (d2 <= c2 && c2 > d2 + 16384 ? d2 = xt : d2 -= c2;d2 > Et; ) {
            if (y2 += 1, y2 >= 34) {
              if (s2 === 0) {
                d2 = Et;
                break;
              }
              Dt(t4, "overflow");
            }
            d2 -= 1;
          }
          if (e3.allowRounding) {
            for (;d2 < xt || p2 < u2; ) {
              if (y2 === 0 && s2 < p2) {
                d2 = xt, s2 = 0;
                break;
              }
              if (p2 < u2 ? u2 -= 1 : y2 -= 1, d2 < Et)
                d2 += 1;
              else {
                if (f2.join("").match(/^0+$/)) {
                  d2 = Et;
                  break;
                }
                Dt(t4, "overflow");
              }
            }
            if (y2 + 1 < s2) {
              let e4 = a2;
              o2 && (l2 += 1, e4 += 1), n2 && (l2 += 1, e4 += 1);
              const i3 = parseInt(t4[l2 + y2 + 1], 10);
              let s3 = 0;
              if (i3 >= 5 && (s3 = 1, i3 === 5)) {
                s3 = f2[y2] % 2 == 1 ? 1 : 0;
                for (let r4 = l2 + y2 + 2;r4 < e4; r4++)
                  if (parseInt(t4[r4], 10)) {
                    s3 = 1;
                    break;
                  }
              }
              if (s3) {
                let t5 = y2;
                for (;t5 >= 0 && ++f2[t5] > 9; t5--)
                  if (f2[t5] = 0, t5 === 0) {
                    if (!(d2 < Et))
                      return new Rt(r3 ? kt : Nt);
                    d2 += 1, f2[t5] = 1;
                  }
              }
            }
          } else {
            for (;d2 < xt || p2 < u2; ) {
              if (y2 === 0) {
                if (s2 === 0) {
                  d2 = xt;
                  break;
                }
                Dt(t4, "exponent underflow");
              }
              p2 < u2 ? (t4[u2 - 1 + Number(n2) + Number(o2)] !== "0" && s2 !== 0 && Dt(t4, "inexact rounding"), u2 -= 1) : (f2[y2] !== 0 && Dt(t4, "inexact rounding"), y2 -= 1), d2 < Et ? d2 += 1 : Dt(t4, "overflow");
            }
            y2 + 1 < s2 && (o2 && (l2 += 1), n2 && (l2 += 1), parseInt(t4[l2 + y2 + 1], 10) !== 0 && Dt(t4, "inexact rounding"));
          }
          if (b2 = $t.fromNumber(0), m2 = $t.fromNumber(0), s2 === 0)
            b2 = $t.fromNumber(0), m2 = $t.fromNumber(0);
          else if (y2 < 17) {
            let t5 = 0;
            for (m2 = $t.fromNumber(f2[t5++]), b2 = new $t(0, 0);t5 <= y2; t5++)
              m2 = m2.multiply($t.fromNumber(10)), m2 = m2.add($t.fromNumber(f2[t5]));
          } else {
            let t5 = 0;
            for (b2 = $t.fromNumber(f2[t5++]);t5 <= y2 - 17; t5++)
              b2 = b2.multiply($t.fromNumber(10)), b2 = b2.add($t.fromNumber(f2[t5]));
            for (m2 = $t.fromNumber(f2[t5++]);t5 <= y2; t5++)
              m2 = m2.multiply($t.fromNumber(10)), m2 = m2.add($t.fromNumber(f2[t5]));
          }
          const S2 = function(t5, e4) {
            if (!t5 && !e4)
              return { high: $t.fromNumber(0), low: $t.fromNumber(0) };
            const r4 = t5.shiftRightUnsigned(32), n3 = new $t(t5.getLowBits(), 0), o3 = e4.shiftRightUnsigned(32), i3 = new $t(e4.getLowBits(), 0);
            let s3 = r4.multiply(o3), a3 = r4.multiply(i3);
            const u3 = n3.multiply(o3);
            let c3 = n3.multiply(i3);
            return s3 = s3.add(a3.shiftRightUnsigned(32)), a3 = new $t(a3.getLowBits(), 0).add(u3).add(c3.shiftRightUnsigned(32)), s3 = s3.add(a3.shiftRightUnsigned(32)), c3 = a3.shiftLeft(32).add(new $t(c3.getLowBits(), 0)), { high: s3, low: c3 };
          }(b2, $t.fromString("100000000000000000"));
          S2.low = S2.low.add(m2), function(t5, e4) {
            const r4 = t5.high >>> 0, n3 = e4.high >>> 0;
            return r4 < n3 || r4 === n3 && t5.low >>> 0 < e4.low >>> 0;
          }(S2.low, m2) && (S2.high = S2.high.add($t.fromNumber(1))), v2 = d2 + 6176;
          const $2 = { low: $t.fromNumber(0), high: $t.fromNumber(0) };
          S2.high.shiftRightUnsigned(49).and($t.fromNumber(1)).equals($t.fromNumber(1)) ? ($2.high = $2.high.or($t.fromNumber(3).shiftLeft(61)), $2.high = $2.high.or($t.fromNumber(v2).and($t.fromNumber(16383).shiftLeft(47))), $2.high = $2.high.or(S2.high.and($t.fromNumber(140737488355327)))) : ($2.high = $2.high.or($t.fromNumber(16383 & v2).shiftLeft(49)), $2.high = $2.high.or(S2.high.and($t.fromNumber(562949953421311)))), $2.low = S2.low, r3 && ($2.high = $2.high.or($t.fromString("9223372036854775808")));
          const j2 = rt.allocateUnsafe(16);
          return g2 = 0, j2[g2++] = 255 & $2.low.low, j2[g2++] = $2.low.low >> 8 & 255, j2[g2++] = $2.low.low >> 16 & 255, j2[g2++] = $2.low.low >> 24 & 255, j2[g2++] = 255 & $2.low.high, j2[g2++] = $2.low.high >> 8 & 255, j2[g2++] = $2.low.high >> 16 & 255, j2[g2++] = $2.low.high >> 24 & 255, j2[g2++] = 255 & $2.high.low, j2[g2++] = $2.high.low >> 8 & 255, j2[g2++] = $2.high.low >> 16 & 255, j2[g2++] = $2.high.low >> 24 & 255, j2[g2++] = 255 & $2.high.high, j2[g2++] = $2.high.high >> 8 & 255, j2[g2++] = $2.high.high >> 16 & 255, j2[g2++] = $2.high.high >> 24 & 255, new Rt(j2);
        }
        toString() {
          let t4, e3 = 0;
          const r3 = new Array(36);
          for (let t5 = 0;t5 < r3.length; t5++)
            r3[t5] = 0;
          let n2, o2, i2, s2 = 0, a2 = false, u2 = { parts: [0, 0, 0, 0] };
          const c2 = [];
          s2 = 0;
          const l2 = this.bytes, f2 = l2[s2++] | l2[s2++] << 8 | l2[s2++] << 16 | l2[s2++] << 24, p2 = l2[s2++] | l2[s2++] << 8 | l2[s2++] << 16 | l2[s2++] << 24, h2 = l2[s2++] | l2[s2++] << 8 | l2[s2++] << 16 | l2[s2++] << 24, y2 = l2[s2++] | l2[s2++] << 8 | l2[s2++] << 16 | l2[s2++] << 24;
          s2 = 0, (new $t(f2, p2), new $t(h2, y2)).lessThan($t.ZERO) && c2.push("-");
          const d2 = y2 >> 26 & 31;
          if (d2 >> 3 == 3) {
            if (d2 === 30)
              return c2.join("") + "Infinity";
            if (d2 === 31)
              return "NaN";
            t4 = y2 >> 15 & 16383, n2 = 8 + (y2 >> 14 & 1);
          } else
            n2 = y2 >> 14 & 7, t4 = y2 >> 17 & 16383;
          const b2 = t4 - 6176;
          if (u2.parts[0] = (16383 & y2) + ((15 & n2) << 14), u2.parts[1] = h2, u2.parts[2] = p2, u2.parts[3] = f2, u2.parts[0] === 0 && u2.parts[1] === 0 && u2.parts[2] === 0 && u2.parts[3] === 0)
            a2 = true;
          else
            for (i2 = 3;i2 >= 0; i2--) {
              let t5 = 0;
              const e4 = Mt(u2);
              if (u2 = e4.quotient, t5 = e4.rem.low, t5)
                for (o2 = 8;o2 >= 0; o2--)
                  r3[9 * i2 + o2] = t5 % 10, t5 = Math.floor(t5 / 10);
            }
          if (a2)
            e3 = 1, r3[s2] = 0;
          else
            for (e3 = 36;!r3[s2]; )
              e3 -= 1, s2 += 1;
          const m2 = e3 - 1 + b2;
          if (m2 >= 34 || m2 <= -7 || b2 > 0) {
            if (e3 > 34)
              return c2.push("0"), b2 > 0 ? c2.push(`E+${b2}`) : b2 < 0 && c2.push(`E${b2}`), c2.join("");
            c2.push(`${r3[s2++]}`), e3 -= 1, e3 && c2.push(".");
            for (let t5 = 0;t5 < e3; t5++)
              c2.push(`${r3[s2++]}`);
            c2.push("E"), m2 > 0 ? c2.push(`+${m2}`) : c2.push(`${m2}`);
          } else if (b2 >= 0)
            for (let t5 = 0;t5 < e3; t5++)
              c2.push(`${r3[s2++]}`);
          else {
            let t5 = e3 + b2;
            if (t5 > 0)
              for (let e4 = 0;e4 < t5; e4++)
                c2.push(`${r3[s2++]}`);
            else
              c2.push("0");
            for (c2.push(".");t5++ < 0; )
              c2.push("0");
            for (let n3 = 0;n3 < e3 - Math.max(t5 - 1, 0); n3++)
              c2.push(`${r3[s2++]}`);
          }
          return c2.join("");
        }
        toJSON() {
          return { $numberDecimal: this.toString() };
        }
        toExtendedJSON() {
          return { $numberDecimal: this.toString() };
        }
        static fromExtendedJSON(t4) {
          return Rt.fromString(t4.$numberDecimal);
        }
        inspect(t4, e3, r3) {
          return r3 ??= l, `new Decimal128(${r3(this.toString(), e3)})`;
        }
      }

      class Ut extends nt {
        get _bsontype() {
          return "Double";
        }
        constructor(t4) {
          super(), t4 instanceof Number && (t4 = t4.valueOf()), this.value = +t4;
        }
        static fromString(t4) {
          const e3 = Number(t4);
          if (t4 === "NaN")
            return new Ut(NaN);
          if (t4 === "Infinity")
            return new Ut(1 / 0);
          if (t4 === "-Infinity")
            return new Ut(-1 / 0);
          if (!Number.isFinite(e3))
            throw new q(`Input: ${t4} is not representable as a Double`);
          if (t4.trim() !== t4)
            throw new q(`Input: '${t4}' contains whitespace`);
          if (t4 === "")
            throw new q("Input is an empty string");
          if (/[^-0-9.+eE]/.test(t4))
            throw new q(`Input: '${t4}' is not in decimal or exponential notation`);
          return new Ut(e3);
        }
        valueOf() {
          return this.value;
        }
        toJSON() {
          return this.value;
        }
        toString(t4) {
          return this.value.toString(t4);
        }
        toExtendedJSON(t4) {
          return t4 && (t4.legacy || t4.relaxed && isFinite(this.value)) ? this.value : Object.is(Math.sign(this.value), -0) ? { $numberDouble: "-0.0" } : { $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString() };
        }
        static fromExtendedJSON(t4, e3) {
          const r3 = parseFloat(t4.$numberDouble);
          return e3 && e3.relaxed ? r3 : new Ut(r3);
        }
        inspect(t4, e3, r3) {
          return r3 ??= l, `new Double(${r3(this.value, e3)})`;
        }
      }

      class Ct extends nt {
        get _bsontype() {
          return "Int32";
        }
        constructor(t4) {
          super(), t4 instanceof Number && (t4 = t4.valueOf()), this.value = 0 | +t4;
        }
        static fromString(t4) {
          const e3 = bt(t4), r3 = Number(t4);
          if (h < r3)
            throw new q(`Input: '${t4}' is larger than the maximum value for Int32`);
          if (y > r3)
            throw new q(`Input: '${t4}' is smaller than the minimum value for Int32`);
          if (!Number.isSafeInteger(r3))
            throw new q(`Input: '${t4}' is not a safe integer`);
          if (r3.toString() !== e3)
            throw new q(`Input: '${t4}' is not a valid Int32 string`);
          return new Ct(r3);
        }
        valueOf() {
          return this.value;
        }
        toString(t4) {
          return this.value.toString(t4);
        }
        toJSON() {
          return this.value;
        }
        toExtendedJSON(t4) {
          return t4 && (t4.relaxed || t4.legacy) ? this.value : { $numberInt: this.value.toString() };
        }
        static fromExtendedJSON(t4, e3) {
          return e3 && e3.relaxed ? parseInt(t4.$numberInt, 10) : new Ct(t4.$numberInt);
        }
        inspect(t4, e3, r3) {
          return r3 ??= l, `new Int32(${r3(this.value, e3)})`;
        }
      }

      class Ft extends nt {
        get _bsontype() {
          return "MaxKey";
        }
        toExtendedJSON() {
          return { $maxKey: 1 };
        }
        static fromExtendedJSON() {
          return new Ft;
        }
        inspect() {
          return "new MaxKey()";
        }
      }

      class Lt extends nt {
        get _bsontype() {
          return "MinKey";
        }
        toExtendedJSON() {
          return { $minKey: 1 };
        }
        static fromExtendedJSON() {
          return new Lt;
        }
        inspect() {
          return "new MinKey()";
        }
      }
      let Vt = null;
      const qt = new WeakMap;

      class Jt extends nt {
        get _bsontype() {
          return "ObjectId";
        }
        constructor(t4) {
          let e3;
          if (super(), typeof t4 == "object" && t4 && "id" in t4) {
            if (typeof t4.id != "string" && !ArrayBuffer.isView(t4.id))
              throw new q("Argument passed in must have an id that is of type string or Buffer");
            e3 = "toHexString" in t4 && typeof t4.toHexString == "function" ? rt.fromHex(t4.toHexString()) : t4.id;
          } else
            e3 = t4;
          if (e3 == null || typeof e3 == "number")
            this.buffer = Jt.generate(typeof e3 == "number" ? e3 : undefined);
          else if (ArrayBuffer.isView(e3) && e3.byteLength === 12)
            this.buffer = rt.toLocalBufferType(e3);
          else {
            if (typeof e3 != "string")
              throw new q("Argument passed in does not match the accepted types");
            if (!Jt.validateHexString(e3))
              throw new q("input must be a 24 character hex string, 12 byte Uint8Array, or an integer");
            this.buffer = rt.fromHex(e3), Jt.cacheHexString && qt.set(this, e3);
          }
        }
        get id() {
          return this.buffer;
        }
        set id(t4) {
          this.buffer = t4, Jt.cacheHexString && qt.set(this, rt.toHex(t4));
        }
        static validateHexString(t4) {
          if (t4?.length !== 24)
            return false;
          for (let e3 = 0;e3 < 24; e3++) {
            const r3 = t4.charCodeAt(e3);
            if (!(r3 >= 48 && r3 <= 57 || r3 >= 97 && r3 <= 102 || r3 >= 65 && r3 <= 70))
              return false;
          }
          return true;
        }
        toHexString() {
          if (Jt.cacheHexString) {
            const t5 = qt.get(this);
            if (t5)
              return t5;
          }
          const t4 = rt.toHex(this.id);
          return Jt.cacheHexString && qt.set(this, t4), t4;
        }
        static getInc() {
          return Jt.index = (Jt.index + 1) % 16777215;
        }
        static generate(t4) {
          typeof t4 != "number" && (t4 = Math.floor(Date.now() / 1000));
          const e3 = Jt.getInc(), r3 = rt.allocateUnsafe(12);
          return at.setInt32BE(r3, 0, t4), Vt === null && (Vt = rt.randomBytes(5)), r3[4] = Vt[0], r3[5] = Vt[1], r3[6] = Vt[2], r3[7] = Vt[3], r3[8] = Vt[4], r3[11] = 255 & e3, r3[10] = e3 >> 8 & 255, r3[9] = e3 >> 16 & 255, r3;
        }
        toString(t4) {
          return t4 === "base64" ? rt.toBase64(this.id) : this.toHexString();
        }
        toJSON() {
          return this.toHexString();
        }
        static is(t4) {
          return t4 != null && typeof t4 == "object" && "_bsontype" in t4 && t4._bsontype === "ObjectId";
        }
        equals(t4) {
          if (t4 == null)
            return false;
          if (Jt.is(t4))
            return this.buffer[11] === t4.buffer[11] && rt.equals(this.buffer, t4.buffer);
          if (typeof t4 == "string")
            return t4.toLowerCase() === this.toHexString();
          if (typeof t4 == "object" && typeof t4.toHexString == "function") {
            const e3 = t4.toHexString(), r3 = this.toHexString();
            return typeof e3 == "string" && e3.toLowerCase() === r3;
          }
          return false;
        }
        getTimestamp() {
          const t4 = new Date, e3 = at.getUint32BE(this.buffer, 0);
          return t4.setTime(1000 * Math.floor(e3)), t4;
        }
        static createPk() {
          return new Jt;
        }
        serializeInto(t4, e3) {
          return t4[e3] = this.buffer[0], t4[e3 + 1] = this.buffer[1], t4[e3 + 2] = this.buffer[2], t4[e3 + 3] = this.buffer[3], t4[e3 + 4] = this.buffer[4], t4[e3 + 5] = this.buffer[5], t4[e3 + 6] = this.buffer[6], t4[e3 + 7] = this.buffer[7], t4[e3 + 8] = this.buffer[8], t4[e3 + 9] = this.buffer[9], t4[e3 + 10] = this.buffer[10], t4[e3 + 11] = this.buffer[11], 12;
        }
        static createFromTime(t4) {
          const e3 = rt.allocate(12);
          for (let t5 = 11;t5 >= 4; t5--)
            e3[t5] = 0;
          return at.setInt32BE(e3, 0, t4), new Jt(e3);
        }
        static createFromHexString(t4) {
          if (t4?.length !== 24)
            throw new q("hex string must be 24 characters");
          return new Jt(rt.fromHex(t4));
        }
        static createFromBase64(t4) {
          if (t4?.length !== 16)
            throw new q("base64 string must be 16 characters");
          return new Jt(rt.fromBase64(t4));
        }
        static isValid(t4) {
          if (t4 == null)
            return false;
          if (typeof t4 == "string")
            return Jt.validateHexString(t4);
          try {
            return new Jt(t4), true;
          } catch {
            return false;
          }
        }
        toExtendedJSON() {
          return this.toHexString ? { $oid: this.toHexString() } : { $oid: this.toString("hex") };
        }
        static fromExtendedJSON(t4) {
          return new Jt(t4.$oid);
        }
        isCached() {
          return Jt.cacheHexString && qt.has(this);
        }
        inspect(t4, e3, r3) {
          return r3 ??= l, `new ObjectId(${r3(this.toHexString(), e3)})`;
        }
      }
      function zt(t4, e3, r3) {
        let n2 = 5;
        if (Array.isArray(t4))
          for (let o2 = 0;o2 < t4.length; o2++)
            n2 += Kt(o2.toString(), t4[o2], e3, true, r3);
        else {
          typeof t4?.toBSON == "function" && (t4 = t4.toBSON());
          for (const o2 of Object.keys(t4))
            n2 += Kt(o2, t4[o2], e3, false, r3);
        }
        return n2;
      }
      function Kt(t4, e3, r3 = false, n2 = false, o2 = false) {
        switch (typeof e3?.toBSON == "function" && (e3 = e3.toBSON()), typeof e3) {
          case "string":
            return 1 + rt.utf8ByteLength(t4) + 1 + 4 + rt.utf8ByteLength(e3) + 1;
          case "number":
            return Math.floor(e3) === e3 && e3 >= v && e3 <= m && e3 >= y && e3 <= h ? (t4 != null ? rt.utf8ByteLength(t4) + 1 : 0) + 5 : (t4 != null ? rt.utf8ByteLength(t4) + 1 : 0) + 9;
          case "undefined":
            return n2 || !o2 ? (t4 != null ? rt.utf8ByteLength(t4) + 1 : 0) + 1 : 0;
          case "boolean":
            return (t4 != null ? rt.utf8ByteLength(t4) + 1 : 0) + 2;
          case "object":
            if (e3 != null && typeof e3._bsontype == "string" && e3[p] !== f)
              throw new J;
            if (e3 == null || e3._bsontype === "MinKey" || e3._bsontype === "MaxKey")
              return (t4 != null ? rt.utf8ByteLength(t4) + 1 : 0) + 1;
            if (e3._bsontype === "ObjectId")
              return (t4 != null ? rt.utf8ByteLength(t4) + 1 : 0) + 13;
            if (e3 instanceof Date || c(e3))
              return (t4 != null ? rt.utf8ByteLength(t4) + 1 : 0) + 9;
            if (ArrayBuffer.isView(e3) || e3 instanceof ArrayBuffer || s(e3))
              return (t4 != null ? rt.utf8ByteLength(t4) + 1 : 0) + 6 + e3.byteLength;
            if (e3._bsontype === "Long" || e3._bsontype === "Double" || e3._bsontype === "Timestamp")
              return (t4 != null ? rt.utf8ByteLength(t4) + 1 : 0) + 9;
            if (e3._bsontype === "Decimal128")
              return (t4 != null ? rt.utf8ByteLength(t4) + 1 : 0) + 17;
            if (e3._bsontype === "Code")
              return e3.scope != null && Object.keys(e3.scope).length > 0 ? (t4 != null ? rt.utf8ByteLength(t4) + 1 : 0) + 1 + 4 + 4 + rt.utf8ByteLength(e3.code.toString()) + 1 + zt(e3.scope, r3, o2) : (t4 != null ? rt.utf8ByteLength(t4) + 1 : 0) + 1 + 4 + rt.utf8ByteLength(e3.code.toString()) + 1;
            if (e3._bsontype === "Binary") {
              const r4 = e3;
              return r4.sub_type === ut.SUBTYPE_BYTE_ARRAY ? (t4 != null ? rt.utf8ByteLength(t4) + 1 : 0) + (r4.position + 1 + 4 + 1 + 4) : (t4 != null ? rt.utf8ByteLength(t4) + 1 : 0) + (r4.position + 1 + 4 + 1);
            }
            if (e3._bsontype === "Symbol")
              return (t4 != null ? rt.utf8ByteLength(t4) + 1 : 0) + rt.utf8ByteLength(e3.value) + 4 + 1 + 1;
            if (e3._bsontype === "DBRef") {
              const n3 = Object.assign({ $ref: e3.collection, $id: e3.oid }, e3.fields);
              return e3.db != null && (n3.$db = e3.db), (t4 != null ? rt.utf8ByteLength(t4) + 1 : 0) + 1 + zt(n3, r3, o2);
            }
            return e3 instanceof RegExp || a(e3) ? (t4 != null ? rt.utf8ByteLength(t4) + 1 : 0) + 1 + rt.utf8ByteLength(e3.source) + 1 + (e3.global ? 1 : 0) + (e3.ignoreCase ? 1 : 0) + (e3.multiline ? 1 : 0) + 1 : e3._bsontype === "BSONRegExp" ? (t4 != null ? rt.utf8ByteLength(t4) + 1 : 0) + 1 + rt.utf8ByteLength(e3.pattern) + 1 + rt.utf8ByteLength(e3.options) + 1 : (t4 != null ? rt.utf8ByteLength(t4) + 1 : 0) + zt(e3, r3, o2) + 1;
          case "function":
            return r3 ? (t4 != null ? rt.utf8ByteLength(t4) + 1 : 0) + 1 + 4 + rt.utf8ByteLength(e3.toString()) + 1 : 0;
          case "bigint":
            return (t4 != null ? rt.utf8ByteLength(t4) + 1 : 0) + 9;
          case "symbol":
            return 0;
          default:
            throw new q("Unrecognized JS type: " + typeof e3);
        }
      }
      Jt.index = Math.floor(16777215 * Math.random());

      class Ht extends nt {
        get _bsontype() {
          return "BSONRegExp";
        }
        constructor(t4, e3) {
          if (super(), this.pattern = t4, this.options = (e3 ?? "").split("").sort().join(""), this.pattern.indexOf("\x00") !== -1)
            throw new q(`BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`);
          if (this.options.indexOf("\x00") !== -1)
            throw new q(`BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`);
          for (let t5 = 0;t5 < this.options.length; t5++)
            if (this.options[t5] !== "i" && this.options[t5] !== "m" && this.options[t5] !== "x" && this.options[t5] !== "l" && this.options[t5] !== "s" && this.options[t5] !== "u")
              throw new q(`The regular expression option [${this.options[t5]}] is not supported`);
        }
        static parseOptions(t4) {
          return t4 ? t4.split("").sort().join("") : "";
        }
        toExtendedJSON(t4) {
          return (t4 = t4 || {}).legacy ? { $regex: this.pattern, $options: this.options } : { $regularExpression: { pattern: this.pattern, options: this.options } };
        }
        static fromExtendedJSON(t4) {
          if ("$regex" in t4) {
            if (typeof t4.$regex == "string")
              return new Ht(t4.$regex, Ht.parseOptions(t4.$options));
            if (t4.$regex._bsontype === "BSONRegExp")
              return t4;
          }
          if ("$regularExpression" in t4)
            return new Ht(t4.$regularExpression.pattern, Ht.parseOptions(t4.$regularExpression.options));
          throw new q(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(t4)}`);
        }
        inspect(t4, e3, r3) {
          const n2 = function(t5) {
            if (t5 != null && typeof t5 == "object" && "stylize" in t5 && typeof t5.stylize == "function")
              return t5.stylize;
          }(e3) ?? ((t5) => t5);
          return r3 ??= l, `new BSONRegExp(${n2(r3(this.pattern), "regexp")}, ${n2(r3(this.options), "regexp")})`;
        }
      }

      class Wt extends nt {
        get _bsontype() {
          return "BSONSymbol";
        }
        constructor(t4) {
          super(), this.value = t4;
        }
        valueOf() {
          return this.value;
        }
        toString() {
          return this.value;
        }
        toJSON() {
          return this.value;
        }
        toExtendedJSON() {
          return { $symbol: this.value };
        }
        static fromExtendedJSON(t4) {
          return new Wt(t4.$symbol);
        }
        inspect(t4, e3, r3) {
          return r3 ??= l, `new BSONSymbol(${r3(this.value, e3)})`;
        }
      }
      const Gt = $t;

      class Qt extends Gt {
        get _bsontype() {
          return "Timestamp";
        }
        get i() {
          return this.low >>> 0;
        }
        get t() {
          return this.high >>> 0;
        }
        constructor(t4) {
          if (t4 == null)
            super(0, 0, true);
          else if (typeof t4 == "bigint")
            super(t4, true);
          else if ($t.isLong(t4))
            super(t4.low, t4.high, true);
          else {
            if (typeof t4 != "object" || !("t" in t4) || !("i" in t4))
              throw new q("A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }");
            {
              if (typeof t4.t != "number" && (typeof t4.t != "object" || t4.t._bsontype !== "Int32"))
                throw new q("Timestamp constructed from { t, i } must provide t as a number");
              if (typeof t4.i != "number" && (typeof t4.i != "object" || t4.i._bsontype !== "Int32"))
                throw new q("Timestamp constructed from { t, i } must provide i as a number");
              const e3 = Number(t4.t), r3 = Number(t4.i);
              if (e3 < 0 || Number.isNaN(e3))
                throw new q("Timestamp constructed from { t, i } must provide a positive t");
              if (r3 < 0 || Number.isNaN(r3))
                throw new q("Timestamp constructed from { t, i } must provide a positive i");
              if (e3 > 4294967295)
                throw new q("Timestamp constructed from { t, i } must provide t equal or less than uint32 max");
              if (r3 > 4294967295)
                throw new q("Timestamp constructed from { t, i } must provide i equal or less than uint32 max");
              super(r3, e3, true);
            }
          }
        }
        toJSON() {
          return { $timestamp: this.toString() };
        }
        static fromInt(t4) {
          return new Qt($t.fromInt(t4, true));
        }
        static fromNumber(t4) {
          return new Qt($t.fromNumber(t4, true));
        }
        static fromBits(t4, e3) {
          return new Qt({ i: t4, t: e3 });
        }
        static fromString(t4, e3) {
          return new Qt($t.fromString(t4, true, e3));
        }
        toExtendedJSON() {
          return { $timestamp: { t: this.t, i: this.i } };
        }
        static fromExtendedJSON(t4) {
          const e3 = $t.isLong(t4.$timestamp.i) ? t4.$timestamp.i.getLowBitsUnsigned() : t4.$timestamp.i, r3 = $t.isLong(t4.$timestamp.t) ? t4.$timestamp.t.getLowBitsUnsigned() : t4.$timestamp.t;
          return new Qt({ t: r3, i: e3 });
        }
        inspect(t4, e3, r3) {
          return r3 ??= l, `new Timestamp({ t: ${r3(this.t, e3)}, i: ${r3(this.i, e3)} })`;
        }
      }
      Qt.MAX_VALUE = $t.MAX_UNSIGNED_VALUE;
      const Yt = $t.fromNumber(m), Zt = $t.fromNumber(v);
      function Xt(t4, e3, r3) {
        const n2 = (e3 = e3 == null ? {} : e3) && e3.index ? e3.index : 0, o2 = at.getInt32LE(t4, n2);
        if (o2 < 5)
          throw new q(`bson size must be >= 5, is ${o2}`);
        if (e3.allowObjectSmallerThanBufferSize && t4.length < o2)
          throw new q(`buffer length ${t4.length} must be >= bson size ${o2}`);
        if (!e3.allowObjectSmallerThanBufferSize && t4.length !== o2)
          throw new q(`buffer length ${t4.length} must === bson size ${o2}`);
        if (o2 + n2 > t4.byteLength)
          throw new q(`(bson size ${o2} + options.index ${n2} must be <= buffer length ${t4.byteLength})`);
        if (t4[n2 + o2 - 1] !== 0)
          throw new q("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
        return ee(t4, n2, e3, r3);
      }
      const te = /^\$ref$|^\$id$|^\$db$/;
      function ee(t4, e3, r3, n2 = false) {
        const o2 = r3.fieldsAsRaw == null ? null : r3.fieldsAsRaw, i2 = r3.raw != null && r3.raw, s2 = typeof r3.bsonRegExp == "boolean" && r3.bsonRegExp, a2 = r3.promoteBuffers ?? false, u2 = r3.promoteLongs ?? true, c2 = r3.promoteValues ?? true, l2 = r3.useBigInt64 ?? false;
        if (l2 && !c2)
          throw new q("Must either request bigint or Long for int64 deserialization");
        if (l2 && !u2)
          throw new q("Must either request bigint or Long for int64 deserialization");
        let f2, p2, h2 = true;
        const y2 = (r3.validation == null ? { utf8: true } : r3.validation).utf8;
        if (typeof y2 == "boolean")
          f2 = y2;
        else {
          h2 = false;
          const t5 = Object.keys(y2).map(function(t6) {
            return y2[t6];
          });
          if (t5.length === 0)
            throw new q("UTF-8 validation setting cannot be empty");
          if (typeof t5[0] != "boolean")
            throw new q("Invalid UTF-8 validation option, must specify boolean values");
          if (f2 = t5[0], !t5.every((t6) => t6 === f2))
            throw new q("Invalid UTF-8 validation option - keys must be all true or all false");
        }
        if (!h2) {
          p2 = new Set;
          for (const t5 of Object.keys(y2))
            p2.add(t5);
        }
        const d2 = e3;
        if (t4.length < 5)
          throw new q("corrupt bson message < 5 bytes long");
        const b2 = at.getInt32LE(t4, e3);
        if (e3 += 4, b2 < 5 || b2 > t4.length)
          throw new q("corrupt bson message");
        const m2 = n2 ? [] : {};
        let v2 = 0, F2 = !n2 && null;
        for (;; ) {
          const y3 = t4[e3++];
          if (y3 === 0)
            break;
          let d3 = e3;
          for (;t4[d3] !== 0 && d3 < t4.length; )
            d3++;
          if (d3 >= t4.byteLength)
            throw new q("Bad BSON Document: illegal CString");
          const b3 = n2 ? v2++ : rt.toUTF8(t4, e3, d3, false);
          let V2, J2 = true;
          if (J2 = h2 || p2?.has(b3) ? f2 : !f2, F2 !== false && b3[0] === "$" && (F2 = te.test(b3)), e3 = d3 + 1, y3 === _) {
            const r4 = at.getInt32LE(t4, e3);
            if (e3 += 4, r4 <= 0 || r4 > t4.length - e3 || t4[e3 + r4 - 1] !== 0)
              throw new q("bad string length in bson");
            V2 = rt.toUTF8(t4, e3, e3 + r4 - 1, J2), e3 += r4;
          } else if (y3 === j) {
            const r4 = rt.allocateUnsafe(12);
            for (let n3 = 0;n3 < 12; n3++)
              r4[n3] = t4[e3 + n3];
            V2 = new Jt(r4), e3 += 12;
          } else if (y3 === B && c2 === false)
            V2 = new Ct(at.getInt32LE(t4, e3)), e3 += 4;
          else if (y3 === B)
            V2 = at.getInt32LE(t4, e3), e3 += 4;
          else if (y3 === g)
            V2 = at.getFloat64LE(t4, e3), e3 += 8, c2 === false && (V2 = new Ut(V2));
          else if (y3 === A) {
            const r4 = at.getInt32LE(t4, e3), n3 = at.getInt32LE(t4, e3 + 4);
            e3 += 8, V2 = new Date(new $t(r4, n3).toNumber());
          } else if (y3 === P) {
            if (t4[e3] !== 0 && t4[e3] !== 1)
              throw new q("illegal boolean type value");
            V2 = t4[e3++] === 1;
          } else if (y3 === w) {
            const n3 = e3, o3 = at.getInt32LE(t4, e3);
            if (o3 <= 0 || o3 > t4.length - e3)
              throw new q("bad embedded document length in bson");
            if (i2)
              V2 = t4.subarray(e3, e3 + o3);
            else {
              let e4 = r3;
              h2 || (e4 = { ...r3, validation: { utf8: J2 } }), V2 = ee(t4, n3, e4, false);
            }
            e3 += o3;
          } else if (y3 === O) {
            const n3 = e3, i3 = at.getInt32LE(t4, e3);
            let s3 = r3;
            const a3 = e3 + i3;
            if (o2 && o2[b3] && (s3 = { ...r3, raw: true }), h2 || (s3 = { ...s3, validation: { utf8: J2 } }), V2 = ee(t4, n3, s3, true), t4[(e3 += i3) - 1] !== 0)
              throw new q("invalid array terminator byte");
            if (e3 !== a3)
              throw new q("corrupted array bson");
          } else if (y3 === $)
            V2 = undefined;
          else if (y3 === E)
            V2 = null;
          else if (y3 === D)
            if (l2)
              V2 = at.getBigInt64LE(t4, e3), e3 += 8;
            else {
              const r4 = at.getInt32LE(t4, e3), n3 = at.getInt32LE(t4, e3 + 4);
              e3 += 8;
              const o3 = new $t(r4, n3);
              V2 = u2 && c2 === true && o3.lessThanOrEqual(Yt) && o3.greaterThanOrEqual(Zt) ? o3.toNumber() : o3;
            }
          else if (y3 === R) {
            const r4 = rt.allocateUnsafe(16);
            for (let n3 = 0;n3 < 16; n3++)
              r4[n3] = t4[e3 + n3];
            e3 += 16, V2 = new Rt(r4);
          } else if (y3 === S) {
            let r4 = at.getInt32LE(t4, e3);
            e3 += 4;
            const n3 = r4, o3 = t4[e3++];
            if (r4 < 0)
              throw new q("Negative binary type element size found");
            if (r4 > t4.byteLength)
              throw new q("Binary type size larger than document size");
            if (o3 === ut.SUBTYPE_BYTE_ARRAY) {
              if (r4 = at.getInt32LE(t4, e3), e3 += 4, r4 < 0)
                throw new q("Negative binary type element size found for subtype 0x02");
              if (r4 > n3 - 4)
                throw new q("Binary type with subtype 0x02 contains too long binary size");
              if (r4 < n3 - 4)
                throw new q("Binary type with subtype 0x02 contains too short binary size");
            }
            a2 && c2 ? V2 = rt.toLocalBufferType(t4.subarray(e3, e3 + r4)) : (V2 = new ut(t4.subarray(e3, e3 + r4), o3), o3 === L && pt.isValid(V2) && (V2 = V2.toUUID())), e3 += r4;
          } else if (y3 === x && s2 === false) {
            for (d3 = e3;t4[d3] !== 0 && d3 < t4.length; )
              d3++;
            if (d3 >= t4.length)
              throw new q("Bad BSON Document: illegal CString");
            const r4 = rt.toUTF8(t4, e3, d3, false);
            for (d3 = e3 = d3 + 1;t4[d3] !== 0 && d3 < t4.length; )
              d3++;
            if (d3 >= t4.length)
              throw new q("Bad BSON Document: illegal CString");
            const n3 = rt.toUTF8(t4, e3, d3, false);
            e3 = d3 + 1;
            const o3 = new Array(n3.length);
            for (d3 = 0;d3 < n3.length; d3++)
              switch (n3[d3]) {
                case "m":
                  o3[d3] = "m";
                  break;
                case "s":
                  o3[d3] = "g";
                  break;
                case "i":
                  o3[d3] = "i";
              }
            V2 = new RegExp(r4, o3.join(""));
          } else if (y3 === x && s2 === true) {
            for (d3 = e3;t4[d3] !== 0 && d3 < t4.length; )
              d3++;
            if (d3 >= t4.length)
              throw new q("Bad BSON Document: illegal CString");
            const r4 = rt.toUTF8(t4, e3, d3, false);
            for (d3 = e3 = d3 + 1;t4[d3] !== 0 && d3 < t4.length; )
              d3++;
            if (d3 >= t4.length)
              throw new q("Bad BSON Document: illegal CString");
            const n3 = rt.toUTF8(t4, e3, d3, false);
            e3 = d3 + 1, V2 = new Ht(r4, n3);
          } else if (y3 === N) {
            const r4 = at.getInt32LE(t4, e3);
            if (e3 += 4, r4 <= 0 || r4 > t4.length - e3 || t4[e3 + r4 - 1] !== 0)
              throw new q("bad string length in bson");
            const n3 = rt.toUTF8(t4, e3, e3 + r4 - 1, J2);
            V2 = c2 ? n3 : new Wt(n3), e3 += r4;
          } else if (y3 === M)
            V2 = new Qt({ i: at.getUint32LE(t4, e3), t: at.getUint32LE(t4, e3 + 4) }), e3 += 8;
          else if (y3 === U)
            V2 = new Lt;
          else if (y3 === C)
            V2 = new Ft;
          else if (y3 === k) {
            const r4 = at.getInt32LE(t4, e3);
            if (e3 += 4, r4 <= 0 || r4 > t4.length - e3 || t4[e3 + r4 - 1] !== 0)
              throw new q("bad string length in bson");
            const n3 = rt.toUTF8(t4, e3, e3 + r4 - 1, J2);
            V2 = new ht(n3), e3 += r4;
          } else if (y3 === I) {
            const n3 = at.getInt32LE(t4, e3);
            if (e3 += 4, n3 < 13)
              throw new q("code_w_scope total size shorter minimum expected length");
            const o3 = at.getInt32LE(t4, e3);
            if (e3 += 4, o3 <= 0 || o3 > t4.length - e3 || t4[e3 + o3 - 1] !== 0)
              throw new q("bad string length in bson");
            const i3 = rt.toUTF8(t4, e3, e3 + o3 - 1, J2), s3 = e3 += o3, a3 = at.getInt32LE(t4, e3), u3 = ee(t4, s3, r3, false);
            if (e3 += a3, n3 < 8 + a3 + o3)
              throw new q("code_w_scope total size is too short, truncating scope");
            if (n3 > 8 + a3 + o3)
              throw new q("code_w_scope total size is too long, clips outer document");
            V2 = new ht(i3, u3);
          } else {
            if (y3 !== T)
              throw new q(`Detected unknown BSON type ${y3.toString(16)} for fieldname "${b3}"`);
            {
              const r4 = at.getInt32LE(t4, e3);
              if (e3 += 4, r4 <= 0 || r4 > t4.length - e3 || t4[e3 + r4 - 1] !== 0)
                throw new q("bad string length in bson");
              const n3 = rt.toUTF8(t4, e3, e3 + r4 - 1, J2);
              e3 += r4;
              const o3 = rt.allocateUnsafe(12);
              for (let r5 = 0;r5 < 12; r5++)
                o3[r5] = t4[e3 + r5];
              const i3 = new Jt(o3);
              e3 += 12, V2 = new dt(n3, i3);
            }
          }
          b3 === "__proto__" ? Object.defineProperty(m2, b3, { value: V2, writable: true, enumerable: true, configurable: true }) : m2[b3] = V2;
        }
        if (b2 !== e3 - d2) {
          if (n2)
            throw new q("corrupt array bson");
          throw new q("corrupt object bson");
        }
        if (!F2)
          return m2;
        if (yt(m2)) {
          const t5 = Object.assign({}, m2);
          return delete t5.$ref, delete t5.$id, delete t5.$db, new dt(m2.$ref, m2.$id, m2.$db, t5);
        }
        return m2;
      }
      const re = /\x00/, ne = new Set(["$db", "$ref", "$id", "$clusterTime"]);
      function oe(t4, e3, r3, n2) {
        t4[n2++] = _, t4[(n2 = n2 + rt.encodeUTF8Into(t4, e3, n2) + 1) - 1] = 0;
        const o2 = rt.encodeUTF8Into(t4, r3, n2 + 4);
        return at.setInt32LE(t4, n2, o2 + 1), n2 = n2 + 4 + o2, t4[n2++] = 0, n2;
      }
      function ie(t4, e3, r3, n2) {
        const o2 = !Object.is(r3, -0) && Number.isSafeInteger(r3) && r3 <= h && r3 >= y ? B : g;
        return t4[n2++] = o2, n2 += rt.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0, n2 + (o2 === B ? at.setInt32LE(t4, n2, r3) : at.setFloat64LE(t4, n2, r3));
      }
      function se(t4, e3, r3, n2) {
        return t4[n2++] = D, n2 += rt.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0, n2 + at.setBigInt64LE(t4, n2, r3);
      }
      function ae(t4, e3, r3, n2) {
        return t4[n2++] = E, n2 += rt.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0, n2;
      }
      function ue(t4, e3, r3, n2) {
        return t4[n2++] = P, n2 += rt.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0, t4[n2++] = r3 ? 1 : 0, n2;
      }
      function ce(t4, e3, r3, n2) {
        t4[n2++] = A, n2 += rt.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0;
        const o2 = $t.fromNumber(r3.getTime()), i2 = o2.getLowBits(), s2 = o2.getHighBits();
        return (n2 += at.setInt32LE(t4, n2, i2)) + at.setInt32LE(t4, n2, s2);
      }
      function le(t4, e3, r3, n2) {
        if (t4[n2++] = x, n2 += rt.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0, r3.source && r3.source.match(re) != null)
          throw new q("value " + r3.source + " must not contain null bytes");
        return n2 += rt.encodeUTF8Into(t4, r3.source, n2), t4[n2++] = 0, r3.ignoreCase && (t4[n2++] = 105), r3.global && (t4[n2++] = 115), r3.multiline && (t4[n2++] = 109), t4[n2++] = 0, n2;
      }
      function fe(t4, e3, r3, n2) {
        if (t4[n2++] = x, n2 += rt.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0, r3.pattern.match(re) != null)
          throw new q("pattern " + r3.pattern + " must not contain null bytes");
        n2 += rt.encodeUTF8Into(t4, r3.pattern, n2), t4[n2++] = 0;
        const o2 = r3.options.split("").sort().join("");
        return n2 += rt.encodeUTF8Into(t4, o2, n2), t4[n2++] = 0, n2;
      }
      function pe(t4, e3, r3, n2) {
        return r3 === null ? t4[n2++] = E : r3._bsontype === "MinKey" ? t4[n2++] = U : t4[n2++] = C, n2 += rt.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0, n2;
      }
      function he(t4, e3, r3, n2) {
        return t4[n2++] = j, n2 += rt.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0, n2 + r3.serializeInto(t4, n2);
      }
      function ye(t4, e3, r3, n2) {
        t4[n2++] = S, n2 += rt.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0;
        const o2 = r3.length;
        if (n2 += at.setInt32LE(t4, n2, o2), t4[n2++] = F, o2 <= 16)
          for (let e4 = 0;e4 < o2; e4++)
            t4[n2 + e4] = r3[e4];
        else
          t4.set(r3, n2);
        return n2 + o2;
      }
      function de(t4, e3, r3, n2, o2, i2, s2, a2, u2) {
        if (u2.has(r3))
          throw new q("Cannot convert circular structure to BSON");
        u2.add(r3), t4[n2++] = Array.isArray(r3) ? O : w, n2 += rt.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0;
        const c2 = je(t4, r3, o2, n2, i2 + 1, s2, a2, u2);
        return u2.delete(r3), c2;
      }
      function be(t4, e3, r3, n2) {
        t4[n2++] = R, n2 += rt.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0;
        for (let e4 = 0;e4 < 16; e4++)
          t4[n2 + e4] = r3.bytes[e4];
        return n2 + 16;
      }
      function me(t4, e3, r3, n2) {
        t4[n2++] = r3._bsontype === "Long" ? D : M, n2 += rt.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0;
        const o2 = r3.getLowBits(), i2 = r3.getHighBits();
        return (n2 += at.setInt32LE(t4, n2, o2)) + at.setInt32LE(t4, n2, i2);
      }
      function ve(t4, e3, r3, n2) {
        return r3 = r3.valueOf(), t4[n2++] = B, n2 += rt.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0, n2 + at.setInt32LE(t4, n2, r3);
      }
      function ge(t4, e3, r3, n2) {
        return t4[n2++] = g, n2 += rt.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0, n2 + at.setFloat64LE(t4, n2, r3.value);
      }
      function _e(t4, e3, r3, n2) {
        t4[n2++] = k, n2 += rt.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0;
        const o2 = r3.toString(), i2 = rt.encodeUTF8Into(t4, o2, n2 + 4) + 1;
        return at.setInt32LE(t4, n2, i2), n2 = n2 + 4 + i2 - 1, t4[n2++] = 0, n2;
      }
      function we(t4, e3, r3, n2, o2 = false, i2 = 0, s2 = false, a2 = true, u2) {
        if (r3.scope && typeof r3.scope == "object") {
          t4[n2++] = I, n2 += rt.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0;
          let c2 = n2;
          const l2 = r3.code;
          n2 += 4;
          const f2 = rt.encodeUTF8Into(t4, l2, n2 + 4) + 1;
          at.setInt32LE(t4, n2, f2), t4[n2 + 4 + f2 - 1] = 0, n2 = n2 + f2 + 4;
          const p2 = je(t4, r3.scope, o2, n2, i2 + 1, s2, a2, u2);
          n2 = p2 - 1;
          const h2 = p2 - c2;
          c2 += at.setInt32LE(t4, c2, h2), t4[n2++] = 0;
        } else {
          t4[n2++] = k, n2 += rt.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0;
          const o3 = r3.code.toString(), i3 = rt.encodeUTF8Into(t4, o3, n2 + 4) + 1;
          at.setInt32LE(t4, n2, i3), n2 = n2 + 4 + i3 - 1, t4[n2++] = 0;
        }
        return n2;
      }
      function Oe(t4, e3, r3, n2) {
        t4[n2++] = S, n2 += rt.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0;
        const o2 = r3.buffer;
        let i2 = r3.position;
        if (r3.sub_type === ut.SUBTYPE_BYTE_ARRAY && (i2 += 4), n2 += at.setInt32LE(t4, n2, i2), t4[n2++] = r3.sub_type, r3.sub_type === ut.SUBTYPE_BYTE_ARRAY && (i2 -= 4, n2 += at.setInt32LE(t4, n2, i2)), r3.sub_type === ut.SUBTYPE_VECTOR && ct(r3), i2 <= 16)
          for (let e4 = 0;e4 < i2; e4++)
            t4[n2 + e4] = o2[e4];
        else
          t4.set(o2, n2);
        return n2 + r3.position;
      }
      function Se(t4, e3, r3, n2) {
        t4[n2++] = N, n2 += rt.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0;
        const o2 = rt.encodeUTF8Into(t4, r3.value, n2 + 4) + 1;
        return at.setInt32LE(t4, n2, o2), n2 = n2 + 4 + o2 - 1, t4[n2++] = 0, n2;
      }
      function $e(t4, e3, r3, n2, o2, i2, s2) {
        t4[n2++] = w, n2 += rt.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0;
        let a2 = n2, u2 = { $ref: r3.collection || r3.namespace, $id: r3.oid };
        r3.db != null && (u2.$db = r3.db), u2 = Object.assign(u2, r3.fields);
        const c2 = je(t4, u2, false, n2, o2 + 1, i2, true, s2), l2 = c2 - a2;
        return a2 += at.setInt32LE(t4, n2, l2), c2;
      }
      function je(t4, e3, r3, n2, o2, l2, h2, y2) {
        if (y2 == null) {
          if (e3 == null)
            return t4[0] = 5, t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 0, 5;
          if (Array.isArray(e3))
            throw new q("serialize does not support an array as the root input");
          if (typeof e3 != "object")
            throw new q("serialize does not support non-object as the root input");
          if ("_bsontype" in e3 && typeof e3._bsontype == "string")
            throw new q("BSON types cannot be serialized as a document");
          if (c(e3) || a(e3) || i(e3) || s(e3))
            throw new q("date, regexp, typedarray, and arraybuffer cannot be BSON documents");
          y2 = new Set;
        }
        y2.add(e3);
        let d2 = n2 + 4;
        if (Array.isArray(e3))
          for (let n3 = 0;n3 < e3.length; n3++) {
            const s2 = `${n3}`;
            let u2 = e3[n3];
            typeof u2?.toBSON == "function" && (u2 = u2.toBSON());
            const b3 = typeof u2;
            if (u2 === undefined)
              d2 = ae(t4, s2, 0, d2);
            else if (u2 === null)
              d2 = ae(t4, s2, 0, d2);
            else if (b3 === "string")
              d2 = oe(t4, s2, u2, d2);
            else if (b3 === "number")
              d2 = ie(t4, s2, u2, d2);
            else if (b3 === "bigint")
              d2 = se(t4, s2, u2, d2);
            else if (b3 === "boolean")
              d2 = ue(t4, s2, u2, d2);
            else if (b3 === "object" && u2._bsontype == null)
              d2 = u2 instanceof Date || c(u2) ? ce(t4, s2, u2, d2) : u2 instanceof Uint8Array || i(u2) ? ye(t4, s2, u2, d2) : u2 instanceof RegExp || a(u2) ? le(t4, s2, u2, d2) : de(t4, s2, u2, d2, r3, o2, l2, h2, y2);
            else if (b3 === "object") {
              if (u2[p] !== f)
                throw new J;
              if (u2._bsontype === "ObjectId")
                d2 = he(t4, s2, u2, d2);
              else if (u2._bsontype === "Decimal128")
                d2 = be(t4, s2, u2, d2);
              else if (u2._bsontype === "Long" || u2._bsontype === "Timestamp")
                d2 = me(t4, s2, u2, d2);
              else if (u2._bsontype === "Double")
                d2 = ge(t4, s2, u2, d2);
              else if (u2._bsontype === "Code")
                d2 = we(t4, s2, u2, d2, r3, o2, l2, h2, y2);
              else if (u2._bsontype === "Binary")
                d2 = Oe(t4, s2, u2, d2);
              else if (u2._bsontype === "BSONSymbol")
                d2 = Se(t4, s2, u2, d2);
              else if (u2._bsontype === "DBRef")
                d2 = $e(t4, s2, u2, d2, o2, l2, y2);
              else if (u2._bsontype === "BSONRegExp")
                d2 = fe(t4, s2, u2, d2);
              else if (u2._bsontype === "Int32")
                d2 = ve(t4, s2, u2, d2);
              else if (u2._bsontype === "MinKey" || u2._bsontype === "MaxKey")
                d2 = pe(t4, s2, u2, d2);
              else if (u2._bsontype !== undefined)
                throw new q(`Unrecognized or invalid _bsontype: ${String(u2._bsontype)}`);
            } else
              b3 === "function" && l2 && (d2 = _e(t4, s2, u2, d2));
          }
        else if (e3 instanceof Map || u(e3)) {
          const n3 = e3.entries();
          let s2 = false;
          for (;!s2; ) {
            const e4 = n3.next();
            if (s2 = !!e4.done, s2)
              continue;
            const u2 = e4.value ? e4.value[0] : undefined;
            let b3 = e4.value ? e4.value[1] : undefined;
            typeof b3?.toBSON == "function" && (b3 = b3.toBSON());
            const m2 = typeof b3;
            if (typeof u2 == "string" && !ne.has(u2)) {
              if (u2.match(re) != null)
                throw new q("key " + u2 + " must not contain null bytes");
              if (r3) {
                if (u2[0] === "$")
                  throw new q("key " + u2 + " must not start with '$'");
                if (u2.includes("."))
                  throw new q("key " + u2 + " must not contain '.'");
              }
            }
            if (b3 === undefined)
              h2 === false && (d2 = ae(t4, u2, 0, d2));
            else if (b3 === null)
              d2 = ae(t4, u2, 0, d2);
            else if (m2 === "string")
              d2 = oe(t4, u2, b3, d2);
            else if (m2 === "number")
              d2 = ie(t4, u2, b3, d2);
            else if (m2 === "bigint")
              d2 = se(t4, u2, b3, d2);
            else if (m2 === "boolean")
              d2 = ue(t4, u2, b3, d2);
            else if (m2 === "object" && b3._bsontype == null)
              d2 = b3 instanceof Date || c(b3) ? ce(t4, u2, b3, d2) : b3 instanceof Uint8Array || i(b3) ? ye(t4, u2, b3, d2) : b3 instanceof RegExp || a(b3) ? le(t4, u2, b3, d2) : de(t4, u2, b3, d2, r3, o2, l2, h2, y2);
            else if (m2 === "object") {
              if (b3[p] !== f)
                throw new J;
              if (b3._bsontype === "ObjectId")
                d2 = he(t4, u2, b3, d2);
              else if (b3._bsontype === "Decimal128")
                d2 = be(t4, u2, b3, d2);
              else if (b3._bsontype === "Long" || b3._bsontype === "Timestamp")
                d2 = me(t4, u2, b3, d2);
              else if (b3._bsontype === "Double")
                d2 = ge(t4, u2, b3, d2);
              else if (b3._bsontype === "Code")
                d2 = we(t4, u2, b3, d2, r3, o2, l2, h2, y2);
              else if (b3._bsontype === "Binary")
                d2 = Oe(t4, u2, b3, d2);
              else if (b3._bsontype === "BSONSymbol")
                d2 = Se(t4, u2, b3, d2);
              else if (b3._bsontype === "DBRef")
                d2 = $e(t4, u2, b3, d2, o2, l2, y2);
              else if (b3._bsontype === "BSONRegExp")
                d2 = fe(t4, u2, b3, d2);
              else if (b3._bsontype === "Int32")
                d2 = ve(t4, u2, b3, d2);
              else if (b3._bsontype === "MinKey" || b3._bsontype === "MaxKey")
                d2 = pe(t4, u2, b3, d2);
              else if (b3._bsontype !== undefined)
                throw new q(`Unrecognized or invalid _bsontype: ${String(b3._bsontype)}`);
            } else
              m2 === "function" && l2 && (d2 = _e(t4, u2, b3, d2));
          }
        } else {
          if (typeof e3?.toBSON == "function" && (e3 = e3.toBSON()) != null && typeof e3 != "object")
            throw new q("toBSON function did not return an object");
          for (const n3 of Object.keys(e3)) {
            let s2 = e3[n3];
            typeof s2?.toBSON == "function" && (s2 = s2.toBSON());
            const u2 = typeof s2;
            if (typeof n3 == "string" && !ne.has(n3)) {
              if (n3.match(re) != null)
                throw new q("key " + n3 + " must not contain null bytes");
              if (r3) {
                if (n3[0] === "$")
                  throw new q("key " + n3 + " must not start with '$'");
                if (n3.includes("."))
                  throw new q("key " + n3 + " must not contain '.'");
              }
            }
            if (s2 === undefined)
              h2 === false && (d2 = ae(t4, n3, 0, d2));
            else if (s2 === null)
              d2 = ae(t4, n3, 0, d2);
            else if (u2 === "string")
              d2 = oe(t4, n3, s2, d2);
            else if (u2 === "number")
              d2 = ie(t4, n3, s2, d2);
            else if (u2 === "bigint")
              d2 = se(t4, n3, s2, d2);
            else if (u2 === "boolean")
              d2 = ue(t4, n3, s2, d2);
            else if (u2 === "object" && s2._bsontype == null)
              d2 = s2 instanceof Date || c(s2) ? ce(t4, n3, s2, d2) : s2 instanceof Uint8Array || i(s2) ? ye(t4, n3, s2, d2) : s2 instanceof RegExp || a(s2) ? le(t4, n3, s2, d2) : de(t4, n3, s2, d2, r3, o2, l2, h2, y2);
            else if (u2 === "object") {
              if (s2[p] !== f)
                throw new J;
              if (s2._bsontype === "ObjectId")
                d2 = he(t4, n3, s2, d2);
              else if (s2._bsontype === "Decimal128")
                d2 = be(t4, n3, s2, d2);
              else if (s2._bsontype === "Long" || s2._bsontype === "Timestamp")
                d2 = me(t4, n3, s2, d2);
              else if (s2._bsontype === "Double")
                d2 = ge(t4, n3, s2, d2);
              else if (s2._bsontype === "Code")
                d2 = we(t4, n3, s2, d2, r3, o2, l2, h2, y2);
              else if (s2._bsontype === "Binary")
                d2 = Oe(t4, n3, s2, d2);
              else if (s2._bsontype === "BSONSymbol")
                d2 = Se(t4, n3, s2, d2);
              else if (s2._bsontype === "DBRef")
                d2 = $e(t4, n3, s2, d2, o2, l2, y2);
              else if (s2._bsontype === "BSONRegExp")
                d2 = fe(t4, n3, s2, d2);
              else if (s2._bsontype === "Int32")
                d2 = ve(t4, n3, s2, d2);
              else if (s2._bsontype === "MinKey" || s2._bsontype === "MaxKey")
                d2 = pe(t4, n3, s2, d2);
              else if (s2._bsontype !== undefined)
                throw new q(`Unrecognized or invalid _bsontype: ${String(s2._bsontype)}`);
            } else
              u2 === "function" && l2 && (d2 = _e(t4, n3, s2, d2));
          }
        }
        y2.delete(e3), t4[d2++] = 0;
        const b2 = d2 - n2;
        return n2 += at.setInt32LE(t4, n2, b2), d2;
      }
      const Pe = { $oid: Jt, $binary: ut, $uuid: ut, $symbol: Wt, $numberInt: Ct, $numberDecimal: Rt, $numberDouble: Ut, $numberLong: $t, $minKey: Lt, $maxKey: Ft, $regex: Ht, $regularExpression: Ht, $timestamp: Qt };
      function Ae(t4, e3 = {}) {
        if (typeof t4 == "number") {
          const r4 = t4 <= h && t4 >= y, n2 = t4 <= d && t4 >= b;
          if (e3.relaxed || e3.legacy)
            return t4;
          if (Number.isInteger(t4) && !Object.is(t4, -0)) {
            if (r4)
              return new Ct(t4);
            if (n2)
              return e3.useBigInt64 ? BigInt(t4) : $t.fromNumber(t4);
          }
          return new Ut(t4);
        }
        if (t4 == null || typeof t4 != "object")
          return t4;
        if (t4.$undefined)
          return null;
        const r3 = Object.keys(t4).filter((e4) => e4.startsWith("$") && t4[e4] != null);
        for (let n2 = 0;n2 < r3.length; n2++) {
          const o2 = Pe[r3[n2]];
          if (o2)
            return o2.fromExtendedJSON(t4, e3);
        }
        if (t4.$date != null) {
          const r4 = t4.$date, n2 = new Date;
          if (e3.legacy)
            if (typeof r4 == "number")
              n2.setTime(r4);
            else if (typeof r4 == "string")
              n2.setTime(Date.parse(r4));
            else {
              if (typeof r4 != "bigint")
                throw new z("Unrecognized type for EJSON date: " + typeof r4);
              n2.setTime(Number(r4));
            }
          else if (typeof r4 == "string")
            n2.setTime(Date.parse(r4));
          else if ($t.isLong(r4))
            n2.setTime(r4.toNumber());
          else if (typeof r4 == "number" && e3.relaxed)
            n2.setTime(r4);
          else {
            if (typeof r4 != "bigint")
              throw new z("Unrecognized type for EJSON date: " + typeof r4);
            n2.setTime(Number(r4));
          }
          return n2;
        }
        if (t4.$code != null) {
          const e4 = Object.assign({}, t4);
          return t4.$scope && (e4.$scope = Ae(t4.$scope)), ht.fromExtendedJSON(t4);
        }
        if (yt(t4) || t4.$dbPointer) {
          const e4 = t4.$ref ? t4 : t4.$dbPointer;
          if (e4 instanceof dt)
            return e4;
          const r4 = Object.keys(e4).filter((t5) => t5.startsWith("$"));
          let n2 = true;
          if (r4.forEach((t5) => {
            ["$ref", "$id", "$db"].indexOf(t5) === -1 && (n2 = false);
          }), n2)
            return dt.fromExtendedJSON(e4);
        }
        return t4;
      }
      function Ee(t4) {
        const e3 = t4.toISOString();
        return t4.getUTCMilliseconds() !== 0 ? e3 : e3.slice(0, -5) + "Z";
      }
      function xe(t4, e3) {
        if (t4 instanceof Map || u(t4)) {
          const r3 = Object.create(null);
          for (const [e4, n2] of t4) {
            if (typeof e4 != "string")
              throw new q("Can only serialize maps with string keys");
            r3[e4] = n2;
          }
          return xe(r3, e3);
        }
        if ((typeof t4 == "object" || typeof t4 == "function") && t4 !== null) {
          const r3 = e3.seenObjects.findIndex((e4) => e4.obj === t4);
          if (r3 !== -1) {
            const t5 = e3.seenObjects.map((t6) => t6.propertyName), n2 = t5.slice(0, r3).map((t6) => `${t6} -> `).join(""), o2 = t5[r3], i2 = " -> " + t5.slice(r3 + 1, t5.length - 1).map((t6) => `${t6} -> `).join(""), s2 = t5[t5.length - 1], a2 = " ".repeat(n2.length + o2.length / 2), u2 = "-".repeat(i2.length + (o2.length + s2.length) / 2 - 1);
            throw new q(`Converting circular structure to EJSON:
    ${n2}${o2}${i2}${s2}
    ${a2}\\${u2}/`);
          }
          e3.seenObjects[e3.seenObjects.length - 1].obj = t4;
        }
        if (Array.isArray(t4))
          return function(t5, e4) {
            return t5.map((t6, r3) => {
              e4.seenObjects.push({ propertyName: `index ${r3}`, obj: null });
              try {
                return xe(t6, e4);
              } finally {
                e4.seenObjects.pop();
              }
            });
          }(t4, e3);
        if (t4 === undefined)
          return null;
        if (t4 instanceof Date || c(t4)) {
          const r3 = t4.getTime(), n2 = r3 > -1 && r3 < 253402318800000;
          return e3.legacy ? e3.relaxed && n2 ? { $date: t4.getTime() } : { $date: Ee(t4) } : e3.relaxed && n2 ? { $date: Ee(t4) } : { $date: { $numberLong: t4.getTime().toString() } };
        }
        if (!(typeof t4 != "number" || e3.relaxed && isFinite(t4))) {
          if (Number.isInteger(t4) && !Object.is(t4, -0)) {
            if (t4 >= y && t4 <= h)
              return { $numberInt: t4.toString() };
            if (t4 >= b && t4 <= d)
              return { $numberLong: t4.toString() };
          }
          return { $numberDouble: Object.is(t4, -0) ? "-0.0" : t4.toString() };
        }
        if (typeof t4 == "bigint")
          return e3.relaxed ? Number(BigInt.asIntN(64, t4)) : { $numberLong: BigInt.asIntN(64, t4).toString() };
        if (t4 instanceof RegExp || a(t4)) {
          let r3 = t4.flags;
          if (r3 === undefined) {
            const e4 = t4.toString().match(/[gimuy]*$/);
            e4 && (r3 = e4[0]);
          }
          return new Ht(t4.source, r3).toExtendedJSON(e3);
        }
        return t4 != null && typeof t4 == "object" ? function(t5, e4) {
          if (t5 == null || typeof t5 != "object")
            throw new q("not an object instance");
          const r3 = t5._bsontype;
          if (r3 === undefined) {
            const r4 = {};
            for (const n2 of Object.keys(t5)) {
              e4.seenObjects.push({ propertyName: n2, obj: null });
              try {
                const o2 = xe(t5[n2], e4);
                n2 === "__proto__" ? Object.defineProperty(r4, n2, { value: o2, writable: true, enumerable: true, configurable: true }) : r4[n2] = o2;
              } finally {
                e4.seenObjects.pop();
              }
            }
            return r4;
          }
          if (t5 != null && typeof t5 == "object" && typeof t5._bsontype == "string" && t5[p] !== f)
            throw new J;
          if (function(t6) {
            return t6 != null && typeof t6 == "object" && "_bsontype" in t6 && typeof t6._bsontype == "string";
          }(t5)) {
            let n2 = t5;
            if (typeof n2.toExtendedJSON != "function") {
              const e5 = Te[t5._bsontype];
              if (!e5)
                throw new q("Unrecognized or invalid _bsontype: " + t5._bsontype);
              n2 = e5(n2);
            }
            return r3 === "Code" && n2.scope ? n2 = new ht(n2.code, xe(n2.scope, e4)) : r3 === "DBRef" && n2.oid && (n2 = new dt(xe(n2.collection, e4), xe(n2.oid, e4), xe(n2.db, e4), xe(n2.fields, e4))), n2.toExtendedJSON(e4);
          }
          throw new q("_bsontype must be a string, but was: " + typeof r3);
        }(t4, e3) : t4;
      }
      const Te = { Binary: (t4) => new ut(t4.value(), t4.sub_type), Code: (t4) => new ht(t4.code, t4.scope), DBRef: (t4) => new dt(t4.collection || t4.namespace, t4.oid, t4.db, t4.fields), Decimal128: (t4) => new Rt(t4.bytes), Double: (t4) => new Ut(t4.value), Int32: (t4) => new Ct(t4.value), Long: (t4) => $t.fromBits(t4.low != null ? t4.low : t4.low_, t4.low != null ? t4.high : t4.high_, t4.low != null ? t4.unsigned : t4.unsigned_), MaxKey: () => new Ft, MinKey: () => new Lt, ObjectId: (t4) => new Jt(t4), BSONRegExp: (t4) => new Ht(t4.pattern, t4.options), BSONSymbol: (t4) => new Wt(t4.value), Timestamp: (t4) => Qt.fromBits(t4.low, t4.high) };
      function ke(t4, e3) {
        const r3 = { useBigInt64: e3?.useBigInt64 ?? false, relaxed: e3?.relaxed ?? true, legacy: e3?.legacy ?? false };
        return JSON.parse(t4, (t5, e4) => {
          if (t5.indexOf("\x00") !== -1)
            throw new q(`BSON Document field names cannot contain null bytes, found: ${JSON.stringify(t5)}`);
          return Ae(e4, r3);
        });
      }
      function Ne(t4, e3, r3, n2) {
        r3 != null && typeof r3 == "object" && (n2 = r3, r3 = 0), e3 == null || typeof e3 != "object" || Array.isArray(e3) || (n2 = e3, e3 = undefined, r3 = 0);
        const o2 = xe(t4, Object.assign({ relaxed: true, legacy: false }, n2, { seenObjects: [{ propertyName: "(root)", obj: null }] }));
        return JSON.stringify(o2, e3, r3);
      }
      const Ie = Object.create(null);
      Ie.parse = ke, Ie.stringify = Ne, Ie.serialize = function(t4, e3) {
        return e3 = e3 || {}, JSON.parse(Ne(t4, e3));
      }, Ie.deserialize = function(t4, e3) {
        return e3 = e3 || {}, ke(JSON.stringify(t4), e3);
      }, Object.freeze(Ie);
      function Be(t4, e3) {
        try {
          return at.getNonnegativeInt32LE(t4, e3);
        } catch (t5) {
          throw new K("BSON size cannot be negative", e3, { cause: t5 });
        }
      }
      function Me(t4, e3) {
        let r3 = e3;
        for (;t4[r3] !== 0; r3++)
          ;
        if (r3 === t4.length - 1)
          throw new K("Null terminator not found", e3);
        return r3;
      }
      const De = Object.create(null);
      De.parseToElements = function(t4, e3 = 0) {
        if (e3 ??= 0, t4.length < 5)
          throw new K(`Input must be at least 5 bytes, got ${t4.length} bytes`, e3);
        const r3 = Be(t4, e3);
        if (r3 > t4.length - e3)
          throw new K(`Parsed documentSize (${r3} bytes) does not match input length (${t4.length} bytes)`, e3);
        if (t4[e3 + r3 - 1] !== 0)
          throw new K("BSON documents must end in 0x00", e3 + r3);
        const n2 = [];
        let o2 = e3 + 4;
        for (;o2 <= r3 + e3; ) {
          const i2 = t4[o2];
          if (o2 += 1, i2 === 0) {
            if (o2 - e3 !== r3)
              throw new K("Invalid 0x00 type byte", o2);
            break;
          }
          const s2 = o2, a2 = Me(t4, o2) - s2;
          let u2;
          if (o2 += a2 + 1, i2 === 1 || i2 === 18 || i2 === 9 || i2 === 17)
            u2 = 8;
          else if (i2 === 16)
            u2 = 4;
          else if (i2 === 7)
            u2 = 12;
          else if (i2 === 19)
            u2 = 16;
          else if (i2 === 8)
            u2 = 1;
          else if (i2 === 10 || i2 === 6 || i2 === 127 || i2 === 255)
            u2 = 0;
          else if (i2 === 11)
            u2 = Me(t4, Me(t4, o2) + 1) + 1 - o2;
          else if (i2 === 3 || i2 === 4 || i2 === 15)
            u2 = Be(t4, o2);
          else {
            if (i2 !== 2 && i2 !== 5 && i2 !== 12 && i2 !== 13 && i2 !== 14)
              throw new K(`Invalid 0x${i2.toString(16).padStart(2, "0")} type byte`, o2);
            u2 = Be(t4, o2) + 4, i2 === 5 && (u2 += 1), i2 === 12 && (u2 += 12);
          }
          if (u2 > r3)
            throw new K("value reports length larger than document", o2);
          n2.push([i2, s2, a2, o2, u2]), o2 += u2;
        }
        return n2;
      }, De.ByteUtils = rt, De.NumberUtils = at, Object.freeze(De);
      const Re = 17825792;
      let Ue = rt.allocate(Re);
      function Ce(t4) {
        Ue.length < t4 && (Ue = rt.allocate(t4));
      }
      function Fe(t4, e3 = {}) {
        const r3 = typeof e3.checkKeys == "boolean" && e3.checkKeys, n2 = typeof e3.serializeFunctions == "boolean" && e3.serializeFunctions, o2 = typeof e3.ignoreUndefined != "boolean" || e3.ignoreUndefined, i2 = typeof e3.minInternalBufferSize == "number" ? e3.minInternalBufferSize : Re;
        Ue.length < i2 && (Ue = rt.allocate(i2));
        const s2 = je(Ue, t4, r3, 0, 0, n2, o2, null), a2 = rt.allocateUnsafe(s2);
        return a2.set(Ue.subarray(0, s2), 0), a2;
      }
      function Le(t4, e3, r3 = {}) {
        const n2 = typeof r3.checkKeys == "boolean" && r3.checkKeys, o2 = typeof r3.serializeFunctions == "boolean" && r3.serializeFunctions, i2 = typeof r3.ignoreUndefined != "boolean" || r3.ignoreUndefined, s2 = typeof r3.index == "number" ? r3.index : 0, a2 = je(Ue, t4, n2, 0, 0, o2, i2, null);
        return e3.set(Ue.subarray(0, a2), s2), s2 + a2 - 1;
      }
      function Ve(t4, e3 = {}) {
        return Xt(rt.toLocalBufferType(t4), e3);
      }
      function qe(t4, e3 = {}) {
        return zt(t4, typeof (e3 = e3 || {}).serializeFunctions == "boolean" && e3.serializeFunctions, typeof e3.ignoreUndefined != "boolean" || e3.ignoreUndefined);
      }
      function Je(t4, e3, r3, n2, o2, i2) {
        const s2 = Object.assign({ allowObjectSmallerThanBufferSize: true, index: 0 }, i2), a2 = rt.toLocalBufferType(t4);
        let u2 = e3;
        for (let t5 = 0;t5 < r3; t5++) {
          const e4 = at.getInt32LE(a2, u2);
          s2.index = u2, n2[o2 + t5] = Xt(a2, s2), u2 += e4;
        }
        return u2;
      }
      var ze = Object.freeze({ __proto__: null, BSONError: q, BSONOffsetError: K, BSONRegExp: Ht, BSONRuntimeError: z, BSONSymbol: Wt, BSONType: V, BSONValue: nt, BSONVersionError: J, Binary: ut, Code: ht, DBRef: dt, Decimal128: Rt, Double: Ut, EJSON: Ie, Int32: Ct, Long: $t, MaxKey: Ft, MinKey: Lt, ObjectId: Jt, Timestamp: Qt, UUID: pt, calculateObjectSize: qe, deserialize: Ve, deserializeStream: Je, onDemand: De, serialize: Fe, serializeWithBufferAndIndex: Le, setInternalBufferSize: Ce });
    }, 6365: (t3, e2, r2) => {
      var n = r2(5832).hp, o = r2(6353).Binary, i = r2(6353).UUID, s = r2(8768);
      function a(t4, e3, r3) {
        var o2, i2, u2, l, f = t4;
        return t4 == null && (f = 0), Array.isArray(e3) ? (i2 = e3[0], u2 = e3[1]) : o2 = e3, l = typeof f == "number" || f instanceof Number ? n.alloc(f) : n.from(f, o2, r3), s.decorate(l, a.mixin), l.isMongooseBuffer = true, l[a.pathSymbol] = i2, l[c] = u2, l._subtype = 0, l;
      }
      var u = Symbol.for("mongoose#Buffer#_path"), c = Symbol.for("mongoose#Buffer#_parent");
      a.pathSymbol = u, a.mixin = { _subtype: undefined, _markModified: function() {
        var t4 = this[c];
        return t4 && t4.markModified(this[a.pathSymbol]), this;
      }, write: function() {
        var t4 = n.prototype.write.apply(this, arguments);
        return t4 > 0 && this._markModified(), t4;
      }, copy: function(t4) {
        var e3 = n.prototype.copy.apply(this, arguments);
        return t4 && t4.isMongooseBuffer && t4._markModified(), e3;
      } }, s.each(["writeUInt8", "writeUInt16", "writeUInt32", "writeInt8", "writeInt16", "writeInt32", "writeFloat", "writeDouble", "fill", "utf8Write", "binaryWrite", "asciiWrite", "set", "writeUInt16LE", "writeUInt16BE", "writeUInt32LE", "writeUInt32BE", "writeInt16LE", "writeInt16BE", "writeInt32LE", "writeInt32BE", "writeFloatLE", "writeFloatBE", "writeDoubleLE", "writeDoubleBE"], function(t4) {
        n.prototype[t4] && (a.mixin[t4] = function() {
          var e3 = n.prototype[t4].apply(this, arguments);
          return this._markModified(), e3;
        });
      }), a.mixin.toObject = function(t4) {
        var e3 = typeof t4 == "number" ? t4 : this._subtype || 0;
        return new o(n.from(this), e3);
      }, a.mixin.$toObject = a.mixin.toObject, a.mixin.toBSON = function() {
        return new o(this, this._subtype || 0);
      }, a.mixin.toUUID = function() {
        if (this._subtype !== 4)
          throw new Error("Cannot convert a Buffer with subtype " + this._subtype + " to a UUID");
        return new i(this);
      }, a.mixin.equals = function(t4) {
        if (!n.isBuffer(t4))
          return false;
        if (this.length !== t4.length)
          return false;
        for (var e3 = 0;e3 < this.length; ++e3)
          if (this[e3] !== t4[e3])
            return false;
        return true;
      }, a.mixin.subtype = function(t4) {
        if (typeof t4 != "number")
          throw new TypeError("Invalid subtype. Expected a number");
        this._subtype !== t4 && this._markModified(), this._subtype = t4;
      }, a.Binary = o, t3.exports = a;
    }, 6400: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var o, i = r2(8093), s = r2(9870), a = r2(9206), u = r2(9939), c = r2(783), l = r2(9907), f = r2(2268), p = r2(8188), h = r2(9471), y = r2(2401), d = r2(1697), b = r2(8435), m = r2(8633), v = r2(2151), g = r2(674), _ = Function, w = function(t4) {
        try {
          return _('"use strict"; return (' + t4 + ").constructor;")();
        } catch (t5) {}
      }, O = r2(1464), S = r2(988), $ = function() {
        throw new f;
      }, j = O ? function() {
        try {
          return $;
        } catch (t4) {
          try {
            return O(arguments, "callee").get;
          } catch (t5) {
            return $;
          }
        }
      }() : $, P = r2(5510)(), A = r2(209), E = r2(5825), x = r2(2403), T = r2(3279), k = r2(3123), N = {}, I = typeof Uint8Array != "undefined" && A ? A(Uint8Array) : o, B = { __proto__: null, "%AggregateError%": typeof AggregateError == "undefined" ? o : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer == "undefined" ? o : ArrayBuffer, "%ArrayIteratorPrototype%": P && A ? A([][Symbol.iterator]()) : o, "%AsyncFromSyncIteratorPrototype%": o, "%AsyncFunction%": N, "%AsyncGenerator%": N, "%AsyncGeneratorFunction%": N, "%AsyncIteratorPrototype%": N, "%Atomics%": typeof Atomics == "undefined" ? o : Atomics, "%BigInt%": typeof BigInt == "undefined" ? o : BigInt, "%BigInt64Array%": typeof BigInt64Array == "undefined" ? o : BigInt64Array, "%BigUint64Array%": typeof BigUint64Array == "undefined" ? o : BigUint64Array, "%Boolean%": Boolean, "%DataView%": typeof DataView == "undefined" ? o : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": s, "%eval%": eval, "%EvalError%": a, "%Float16Array%": typeof Float16Array == "undefined" ? o : Float16Array, "%Float32Array%": typeof Float32Array == "undefined" ? o : Float32Array, "%Float64Array%": typeof Float64Array == "undefined" ? o : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry == "undefined" ? o : FinalizationRegistry, "%Function%": _, "%GeneratorFunction%": N, "%Int8Array%": typeof Int8Array == "undefined" ? o : Int8Array, "%Int16Array%": typeof Int16Array == "undefined" ? o : Int16Array, "%Int32Array%": typeof Int32Array == "undefined" ? o : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": P && A ? A(A([][Symbol.iterator]())) : o, "%JSON%": (typeof JSON == "undefined" ? "undefined" : n(JSON)) === "object" ? JSON : o, "%Map%": typeof Map == "undefined" ? o : Map, "%MapIteratorPrototype%": typeof Map != "undefined" && P && A ? A(new Map()[Symbol.iterator]()) : o, "%Math%": Math, "%Number%": Number, "%Object%": i, "%Object.getOwnPropertyDescriptor%": O, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise == "undefined" ? o : Promise, "%Proxy%": typeof Proxy == "undefined" ? o : Proxy, "%RangeError%": u, "%ReferenceError%": c, "%Reflect%": typeof Reflect == "undefined" ? o : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set == "undefined" ? o : Set, "%SetIteratorPrototype%": typeof Set != "undefined" && P && A ? A(new Set()[Symbol.iterator]()) : o, "%SharedArrayBuffer%": typeof SharedArrayBuffer == "undefined" ? o : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": P && A ? A(""[Symbol.iterator]()) : o, "%Symbol%": P ? Symbol : o, "%SyntaxError%": l, "%ThrowTypeError%": j, "%TypedArray%": I, "%TypeError%": f, "%Uint8Array%": typeof Uint8Array == "undefined" ? o : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray == "undefined" ? o : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array == "undefined" ? o : Uint16Array, "%Uint32Array%": typeof Uint32Array == "undefined" ? o : Uint32Array, "%URIError%": p, "%WeakMap%": typeof WeakMap == "undefined" ? o : WeakMap, "%WeakRef%": typeof WeakRef == "undefined" ? o : WeakRef, "%WeakSet%": typeof WeakSet == "undefined" ? o : WeakSet, "%Function.prototype.call%": k, "%Function.prototype.apply%": T, "%Object.defineProperty%": S, "%Object.getPrototypeOf%": E, "%Math.abs%": h, "%Math.floor%": y, "%Math.max%": d, "%Math.min%": b, "%Math.pow%": m, "%Math.round%": v, "%Math.sign%": g, "%Reflect.getPrototypeOf%": x };
      if (A)
        try {
          null.error;
        } catch (t4) {
          var M = A(A(t4));
          B["%Error.prototype%"] = M;
        }
      var D = function t(e3) {
        var r3;
        if (e3 === "%AsyncFunction%")
          r3 = w("async function () {}");
        else if (e3 === "%GeneratorFunction%")
          r3 = w("function* () {}");
        else if (e3 === "%AsyncGeneratorFunction%")
          r3 = w("async function* () {}");
        else if (e3 === "%AsyncGenerator%") {
          var n2 = t("%AsyncGeneratorFunction%");
          n2 && (r3 = n2.prototype);
        } else if (e3 === "%AsyncIteratorPrototype%") {
          var o2 = t("%AsyncGenerator%");
          o2 && A && (r3 = A(o2.prototype));
        }
        return B[e3] = r3, r3;
      }, R = { __proto__: null, "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, U = r2(2354), C = r2(5994), F = U.call(k, Array.prototype.concat), L = U.call(T, Array.prototype.splice), V = U.call(k, String.prototype.replace), q = U.call(k, String.prototype.slice), J = U.call(k, RegExp.prototype.exec), z = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, K = /\\(\\)?/g, H = function(t4, e3) {
        var r3, n2 = t4;
        if (C(R, n2) && (n2 = "%" + (r3 = R[n2])[0] + "%"), C(B, n2)) {
          var o2 = B[n2];
          if (o2 === N && (o2 = D(n2)), o2 === undefined && !e3)
            throw new f("intrinsic " + t4 + " exists, but is not available. Please file an issue!");
          return { alias: r3, name: n2, value: o2 };
        }
        throw new l("intrinsic " + t4 + " does not exist!");
      };
      t3.exports = function(t4, e3) {
        if (typeof t4 != "string" || t4.length === 0)
          throw new f("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && typeof e3 != "boolean")
          throw new f('"allowMissing" argument must be a boolean');
        if (J(/^%?[^%]*%?$/, t4) === null)
          throw new l("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        var r3 = function(t5) {
          var e4 = q(t5, 0, 1), r4 = q(t5, -1);
          if (e4 === "%" && r4 !== "%")
            throw new l("invalid intrinsic syntax, expected closing `%`");
          if (r4 === "%" && e4 !== "%")
            throw new l("invalid intrinsic syntax, expected opening `%`");
          var n3 = [];
          return V(t5, z, function(t6, e5, r5, o3) {
            n3[n3.length] = r5 ? V(o3, K, "$1") : e5 || t6;
          }), n3;
        }(t4), n2 = r3.length > 0 ? r3[0] : "", o2 = H("%" + n2 + "%", e3), i2 = o2.name, s2 = o2.value, a2 = false, u2 = o2.alias;
        u2 && (n2 = u2[0], L(r3, F([0, 1], u2)));
        for (var c2 = 1, p2 = true;c2 < r3.length; c2 += 1) {
          var h2 = r3[c2], y2 = q(h2, 0, 1), d2 = q(h2, -1);
          if ((y2 === '"' || y2 === "'" || y2 === "`" || d2 === '"' || d2 === "'" || d2 === "`") && y2 !== d2)
            throw new l("property names with quotes must have matching quotes");
          if (h2 !== "constructor" && p2 || (a2 = true), C(B, i2 = "%" + (n2 += "." + h2) + "%"))
            s2 = B[i2];
          else if (s2 != null) {
            if (!(h2 in s2)) {
              if (!e3)
                throw new f("base intrinsic for " + t4 + " exists, but the property is not available.");
              return;
            }
            if (O && c2 + 1 >= r3.length) {
              var b2 = O(s2, h2);
              s2 = (p2 = !!b2) && "get" in b2 && !("originalValue" in b2.get) ? b2.get : s2[h2];
            } else
              p2 = C(s2, h2), s2 = s2[h2];
            p2 && !a2 && (B[i2] = s2);
          }
        }
        return s2;
      };
    }, 6413: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function i(t4, e3, r3) {
        return (e3 = function(t5) {
          var e4 = function(t6) {
            if (n(t6) != "object" || !t6)
              return t6;
            var e5 = t6[Symbol.toPrimitive];
            if (e5 !== undefined) {
              var r4 = e5.call(t6, "string");
              if (n(r4) != "object")
                return r4;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t6);
          }(t5);
          return n(e4) == "symbol" ? e4 : e4 + "";
        }(e3)) in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      var s = r2(3609), a = r2(6426), u = r2(8953), c = r2(4327);
      function l(t4, e3) {
        a.call(this, t4, e3, "Boolean");
      }
      l.schemaName = "Boolean", l.defaultOptions = {}, l.prototype = Object.create(a.prototype), l.prototype.constructor = l, l._cast = u, l.set = a.set, l.setters = [], l.get = a.get, l.cast = function(t4) {
        return arguments.length === 0 || (t4 === false && (t4 = this._defaultCaster), this._cast = t4), this._cast;
      }, l._defaultCaster = function(t4) {
        if (t4 != null && typeof t4 != "boolean")
          throw new Error;
        return t4;
      }, l._checkRequired = function(t4) {
        return t4 === true || t4 === false;
      }, l.checkRequired = a.checkRequired, l.prototype.checkRequired = function(t4) {
        return this.constructor._checkRequired(t4);
      }, Object.defineProperty(l, "convertToTrue", { get: function() {
        return u.convertToTrue;
      }, set: function(t4) {
        u.convertToTrue = t4;
      } }), Object.defineProperty(l, "convertToFalse", { get: function() {
        return u.convertToFalse;
      }, set: function(t4) {
        u.convertToFalse = t4;
      } }), l.prototype.cast = function(t4) {
        var e3;
        e3 = typeof this._castFunction == "function" ? this._castFunction : typeof this.constructor.cast == "function" ? this.constructor.cast() : l.cast();
        try {
          return e3(t4);
        } catch (e4) {
          throw new s("Boolean", t4, this.path, e4, this);
        }
      };
      var f = function(t4) {
        for (var e3 = 1;e3 < arguments.length; e3++) {
          var r3 = arguments[e3] != null ? arguments[e3] : {};
          e3 % 2 ? o(Object(r3), true).forEach(function(e4) {
            i(t4, e4, r3[e4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : o(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }({}, a.prototype.$conditionalHandlers);
      Object.defineProperty(l.prototype, "$conditionalHandlers", { enumerable: false, value: f }), l.prototype.castForQuery = function(t4, e3, r3) {
        var n2;
        if (t4 != null)
          return (n2 = this.$conditionalHandlers[t4]) ? n2.call(this, e3) : this.applySetters(e3, r3);
        try {
          return this.applySetters(e3, r3);
        } catch (t5) {
          throw t5 instanceof s && t5.path === this.path && this.$fullPath != null && (t5.path = this.$fullPath), t5;
        }
      }, l.prototype._castNullish = function(t4) {
        if (t4 === undefined)
          return t4;
        var e3 = typeof this.constructor.cast == "function" ? this.constructor.cast() : l.cast();
        return e3 == null ? t4 : !(e3.convertToFalse instanceof Set && e3.convertToFalse.has(t4)) && (!!(e3.convertToTrue instanceof Set && e3.convertToTrue.has(t4)) || t4);
      }, l.prototype.toJSONSchema = function(t4) {
        var e3 = this.options.required && typeof this.options.required != "function";
        return c("boolean", "bool", t4 == null ? undefined : t4.useBsonType, e3);
      }, l.prototype.autoEncryptionType = function() {
        return "bool";
      }, t3.exports = l;
    }, 6426: (t3, e2, r2) => {
      var n = r2(5832).hp;
      function o(t4) {
        return o = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, o(t4);
      }
      var i = r2(3672), s = r2(8879), a = r2(8499), u = r2(2555), c = r2(4450), l = r2(8133), f = r2(9183), p = r2(6155), h = r2(2746), y = r2(7930).schemaTypeSymbol, d = r2(8768), b = r2(7930).validatorErrorSymbol, m = r2(7930).documentIsModified, v = r2(7930).populateModelSymbol, g = i.CastError, _ = i.ValidatorError, w = { _skipMarkModified: true };
      function O(t4, e3, r3) {
        this[y] = true, this.path = t4, this.instance = r3, this.validators = [], this.getters = this.constructor.hasOwnProperty("getters") ? this.constructor.getters.slice() : [], this.setters = this.constructor.hasOwnProperty("setters") ? this.constructor.setters.slice() : [], this.splitPath(), e3 = e3 || {};
        for (var n2 = this.constructor.defaultOptions || {}, i2 = 0, a2 = Object.keys(n2);i2 < a2.length; i2++) {
          var u2 = a2[i2];
          u2 === "validate" ? this.validate(n2.validate) : n2.hasOwnProperty(u2) && !Object.prototype.hasOwnProperty.call(e3, u2) && (e3[u2] = n2[u2]);
        }
        e3.select == null && delete e3.select;
        var c2 = this.OptionsConstructor || s;
        this.options = new c2(e3), this._index = null, d.hasUserDefinedProperty(this.options, "immutable") && (this.$immutable = this.options.immutable, l(this));
        for (var f2 = 0, p2 = Object.keys(this.options);f2 < p2.length; f2++) {
          var h2 = p2[f2];
          if (h2 !== "cast") {
            if (d.hasUserDefinedProperty(this.options, h2) && typeof this[h2] == "function") {
              if (h2 === "index" && this._index) {
                if (e3.index === false) {
                  var b2 = this._index;
                  if (o(b2) === "object" && b2 != null) {
                    if (b2.unique)
                      throw new Error('Path "' + this.path + '" may not have `index` set to false and `unique` set to true');
                    if (b2.sparse)
                      throw new Error('Path "' + this.path + '" may not have `index` set to false and `sparse` set to true');
                  }
                  this._index = false;
                }
                continue;
              }
              var m2 = e3[h2];
              if (h2 === "default") {
                this.default(m2);
                continue;
              }
              var v2 = Array.isArray(m2) ? m2 : [m2];
              this[h2].apply(this, v2);
            }
          } else
            Array.isArray(this.options[h2]) ? this.castFunction.apply(this, this.options[h2]) : this.castFunction(this.options[h2]);
        }
        Object.defineProperty(this, "$$context", { enumerable: false, configurable: false, writable: true, value: null });
      }
      function S(t4, e3) {
        if (t4 !== undefined && !t4) {
          var r3 = new (e3.ErrorConstructor || _)(e3);
          return r3[b] = true, r3;
        }
      }
      function $(t4, e3) {
        return this.castForQuery(null, t4, e3);
      }
      function j(t4, e3) {
        var r3 = this;
        return Array.isArray(t4) ? t4.map(function(t5) {
          return Array.isArray(t5) && t5.length === 0 ? t5 : r3.castForQuery(null, t5, e3);
        }) : [this.castForQuery(null, t4, e3)];
      }
      O.prototype.OptionsConstructor = s, O.prototype.path, O.prototype.validators, O.prototype.isRequired, O.prototype.splitPath = function() {
        return this._presplitPath != null ? this._presplitPath : this.path != null ? (this._presplitPath = this.path.indexOf(".") === -1 ? [this.path] : this.path.split("."), this._presplitPath) : undefined;
      }, O.cast = function(t4) {
        return arguments.length === 0 || (t4 === false && (t4 = function(t5) {
          return t5;
        }), this._cast = t4), this._cast;
      }, O.prototype.castFunction = function(t4, e3) {
        return arguments.length === 0 ? this._castFunction : (t4 === false && (t4 = this.constructor._defaultCaster || function(t5) {
          return t5;
        }), typeof t4 == "string" ? (this._castErrorMessage = t4, this._castFunction) : (t4 != null && (this._castFunction = t4), e3 != null && (this._castErrorMessage = e3), this._castFunction));
      }, O.prototype.cast = function() {
        throw new Error("Base SchemaType class does not implement a `cast()` function");
      }, O.set = function(t4, e3) {
        this.hasOwnProperty("defaultOptions") || (this.defaultOptions = Object.assign({}, this.defaultOptions)), this.defaultOptions[t4] = e3;
      }, O.get = function(t4) {
        this.getters = this.hasOwnProperty("getters") ? this.getters : [], this.getters.push(t4);
      }, O.prototype.default = function(t4) {
        if (arguments.length === 1) {
          if (t4 === undefined)
            return void (this.defaultValue = undefined);
          if (t4 != null && t4.instanceOfSchema)
            throw new i("Cannot set default value of path `" + this.path + "` to a mongoose Schema instance.");
          return this.defaultValue = t4, this.defaultValue;
        }
        return arguments.length > 1 && (this.defaultValue = Array.prototype.slice.call(arguments)), this.defaultValue;
      }, O.prototype.index = function(t4) {
        return this._index = t4, d.expires(this._index), this;
      }, O.prototype.unique = function(t4, e3) {
        if (this._index === false) {
          if (!t4)
            return;
          throw new Error('Path "' + this.path + '" may not have `index` set to false and `unique` set to true');
        }
        return this.options.hasOwnProperty("index") || t4 !== false ? (this._index == null || this._index === true ? this._index = {} : typeof this._index == "string" && (this._index = { type: this._index }), this._index.unique = !!t4, typeof e3 == "string" && (this._duplicateKeyErrorMessage = e3), this) : this;
      }, O.prototype.text = function(t4) {
        if (this._index === false) {
          if (!t4)
            return this;
          throw new Error('Path "' + this.path + '" may not have `index` set to false and `text` set to true');
        }
        return this.options.hasOwnProperty("index") || t4 !== false ? (this._index === null || this._index === undefined || typeof this._index == "boolean" ? this._index = {} : typeof this._index == "string" && (this._index = { type: this._index }), this._index.text = t4, this) : this;
      }, O.prototype.sparse = function(t4) {
        if (this._index === false) {
          if (!t4)
            return this;
          throw new Error('Path "' + this.path + '" may not have `index` set to false and `sparse` set to true');
        }
        return this.options.hasOwnProperty("index") || t4 !== false ? (this._index == null || typeof this._index == "boolean" ? this._index = {} : typeof this._index == "string" && (this._index = { type: this._index }), this._index.sparse = t4, this) : this;
      }, O.prototype.immutable = function(t4) {
        return this.$immutable = t4, l(this), this;
      }, O.prototype.transform = function(t4) {
        return this.options.transform = t4, this;
      }, O.prototype.set = function(t4) {
        if (typeof t4 != "function")
          throw new TypeError("A setter must be a function.");
        return this.setters.push(t4), this;
      }, O.prototype.get = function(t4) {
        if (typeof t4 != "function")
          throw new TypeError("A getter must be a function.");
        return this.getters.push(t4), this;
      }, O.prototype.validateAll = function(t4) {
        for (var e3 = 0;e3 < t4.length; e3++)
          this.validate(t4[e3]);
        return this;
      }, O.prototype.validate = function(t4, e3, r3) {
        var n2, s2, a2, u2;
        if (typeof t4 == "function" || t4 && d.getFunctionName(t4.constructor) === "RegExp")
          return typeof e3 == "function" ? (n2 = { validator: t4, message: e3 }).type = r3 || "user defined" : e3 instanceof Object && !r3 ? ((n2 = p(e3) ? Object.assign({}, e3) : c(e3)).message || (n2.message = n2.msg), n2.validator = t4, n2.type = n2.type || "user defined") : (e3 == null && (e3 = i.messages.general.default), r3 || (r3 = "user defined"), n2 = { message: e3, type: r3, validator: t4 }), this.validators.push(n2), this;
        for (s2 = 0, a2 = arguments.length;s2 < a2; s2++) {
          if (u2 = arguments[s2], !d.isPOJO(u2)) {
            var l2 = "Invalid validator. Received (" + o(u2) + ") " + u2 + ". See https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.validate()";
            throw new Error(l2);
          }
          this.validate(u2.validator, u2);
        }
        return this;
      }, O.prototype.required = function(t4, e3) {
        var r3 = {};
        if (arguments.length > 0 && t4 == null)
          return this.validators = this.validators.filter(function(t5) {
            return t5.validator !== this.requiredValidator;
          }, this), this.isRequired = false, delete this.originalRequiredValue, this;
        if (o(t4) === "object" && (e3 = (r3 = t4).message || e3, t4 = t4.isRequired), t4 === false)
          return this.validators = this.validators.filter(function(t5) {
            return t5.validator !== this.requiredValidator;
          }, this), this.isRequired = false, delete this.originalRequiredValue, this;
        var n2 = this;
        this.isRequired = true, this.requiredValidator = function(e4) {
          var r4 = this && this.$__ && this.$__.cachedRequired;
          if (r4 != null && !this.$__isSelected(n2.path) && !this[m](n2.path))
            return true;
          if (r4 != null && n2.path in r4) {
            var o2 = !r4[n2.path] || n2.checkRequired(e4, this);
            return delete r4[n2.path], o2;
          }
          return typeof t4 == "function" && !t4.apply(this) || n2.checkRequired(e4, this);
        }, this.originalRequiredValue = t4, typeof t4 == "string" && (e3 = t4, t4 = undefined);
        var s2 = e3 || i.messages.general.required;
        return this.validators.unshift(Object.assign({}, r3, { validator: this.requiredValidator, message: s2, type: "required" })), this;
      }, O.prototype.ref = function(t4) {
        return this.options.ref = t4, this;
      }, O.prototype.getDefault = function(t4, e3, r3) {
        var n2;
        if ((n2 = typeof this.defaultValue == "function" ? this.defaultValue === Date.now || this.defaultValue === Array || this.defaultValue.name.toLowerCase() === "objectid" ? this.defaultValue.call(t4) : this.defaultValue.call(t4, t4) : this.defaultValue) != null) {
          if (o(n2) !== "object" || this.options && this.options.shared || (n2 = c(n2)), r3 && r3.skipCast)
            return this._applySetters(n2, t4);
          var i2 = this.applySetters(n2, t4, e3, undefined, w);
          return i2 && !Array.isArray(i2) && i2.$isSingleNested && (i2.$__parent = t4), i2;
        }
        return n2;
      }, O.prototype._applySetters = function(t4, e3, r3, n2, o2) {
        var i2 = t4;
        if (r3)
          return i2;
        for (var s2 = this.setters, a2 = s2.length - 1;a2 >= 0; a2--)
          i2 = s2[a2].call(e3, i2, n2, this, o2);
        return i2;
      }, O.prototype._castNullish = function(t4) {
        return t4;
      }, O.prototype.applySetters = function(t4, e3, r3, n2, o2) {
        var i2 = this._applySetters(t4, e3, r3, n2, o2);
        return i2 == null ? this._castNullish(i2) : i2 = this.cast(i2, e3, r3, n2, o2);
      }, O.prototype.applyGetters = function(t4, e3) {
        var r3 = t4, n2 = this.getters, o2 = n2.length;
        if (o2 === 0)
          return r3;
        for (var i2 = 0;i2 < o2; ++i2)
          r3 = n2[i2].call(e3, r3, this);
        return r3;
      }, O.prototype.select = function(t4) {
        return this.selected = !!t4, this;
      }, O.prototype.doValidate = function(t4, e3, r3, n2) {
        var i2 = this, s2 = false, a2 = this.path;
        if (typeof e3 != "function")
          throw new TypeError("Must pass callback function to doValidate(), got ".concat(o(e3)));
        var u2 = this.validators.filter(function(t5) {
          return o(t5) === "object" && t5 !== null;
        }), l2 = u2.length;
        if (!l2)
          return e3(null);
        for (var f2 = function() {
          if (s2)
            return 0;
          var e4, o2 = u2[y2], l3 = o2.validator, f3 = p(o2) ? Object.assign({}, o2) : c(o2);
          if (f3.path = n2 && n2.path ? n2.path : a2, f3.fullPath = i2.$fullPath, f3.value = t4, typeof t4 == "string" && (f3.length = t4.length, f3.value.length > 30 && (f3.value = f3.value.slice(0, 30) + "...")), l3 instanceof RegExp)
            return m2(l3.test(t4), f3, r3), 1;
          if (typeof l3 != "function")
            return 1;
          if (t4 === undefined && l3 !== i2.requiredValidator)
            return m2(true, f3, r3), 1;
          try {
            e4 = f3.propsParameter ? l3.call(r3, t4, f3) : l3.call(r3, t4);
          } catch (t5) {
            e4 = false, f3.reason = t5, t5.message && (f3.message = t5.message);
          }
          e4 != null && typeof e4.then == "function" ? e4.then(function(t5) {
            m2(t5, f3, r3);
          }, function(t5) {
            f3.reason = t5, f3.message = t5.message, m2(e4 = false, f3, r3);
          }) : m2(e4, f3, r3);
        }, y2 = 0, d2 = u2.length;y2 < d2 && f2() !== 0; ++y2)
          ;
        function m2(t5, r4, n3) {
          if (!s2)
            if (t5 === undefined || t5)
              --l2 <= 0 && h(function() {
                e3(null);
              });
            else {
              var o2 = r4.ErrorConstructor || _;
              (s2 = new o2(r4, n3))[b] = true, h(function() {
                e3(s2);
              });
            }
        }
      }, O.prototype.doValidateSync = function(t4, e3, r3) {
        var n2 = this.path;
        if (!this.validators.length)
          return null;
        var i2 = this.validators;
        if (t4 === undefined) {
          if (this.validators.length === 0 || this.validators[0].type !== "required")
            return null;
          i2 = [this.validators[0]];
        }
        var s2 = null, a2 = 0, u2 = i2.length;
        for (a2 = 0;a2 < u2; ++a2) {
          var l2 = i2[a2];
          if (l2 !== null && o(l2) === "object") {
            var h2 = l2.validator, y2 = p(l2) ? Object.assign({}, l2) : c(l2);
            y2.path = r3 && r3.path ? r3.path : n2, y2.fullPath = this.$fullPath, y2.value = t4, typeof t4 == "string" && (y2.length = t4.length, y2.value.length > 30 && (y2.value = y2.value.slice(0, 30) + "..."));
            var d2 = false;
            if (!f(h2)) {
              if (h2 instanceof RegExp)
                s2 = S(h2.test(t4), y2);
              else if (typeof h2 == "function") {
                try {
                  d2 = y2.propsParameter ? h2.call(e3, t4, y2) : h2.call(e3, t4);
                } catch (t5) {
                  d2 = false, y2.reason = t5;
                }
                if ((d2 == null || typeof d2.then != "function") && (s2 = S(d2, y2)))
                  break;
              }
            }
          }
        }
        return s2;
      }, O._isRef = function(t4, e3, r3, o2) {
        var i2 = o2 && t4.options && (t4.options.ref || t4.options.refPath);
        if (!i2 && r3 && r3.$__ != null) {
          var s2 = r3.$__fullPath(t4.path, true), a2 = r3.ownerDocument();
          i2 = s2 != null && a2.$populated(s2) || r3.$populated(t4.path);
        }
        return !!i2 && (e3 == null || !(n.isBuffer(e3) || e3._bsontype === "Binary" || !d.isObject(e3)) || o2);
      }, O.prototype._castRef = function(t4, e3, r3, i2) {
        if (t4 == null)
          return t4;
        if (t4.$__ != null)
          return t4.$__.wasPopulated = t4.$__.wasPopulated || { value: t4._doc._id }, t4;
        if (n.isBuffer(t4) || !d.isObject(t4)) {
          if (r3)
            return t4;
          throw new g(this.instance, t4, this.path, null, this);
        }
        var s2, a2, u2, c2 = e3.$__fullPath(this.path, true), l2 = e3.ownerDocument().$populated(c2, true), f2 = t4;
        if (!(e3.$__.populated && e3.$__.populated[c2] && e3.$__.populated[c2].options && e3.$__.populated[c2].options.options && e3.$__.populated[c2].options.options.lean)) {
          var p2 = l2 ? l2.options[v] : e3.constructor.db.model(this.options.ref);
          (f2 = p2.hydrate(t4, null, i2)).$__.wasPopulated = { value: f2._doc._id, options: (s2 = {}, a2 = v, u2 = p2, ((a2 = function(t5) {
            var e4 = function(t6) {
              if (o(t6) != "object" || !t6)
                return t6;
              var e5 = t6[Symbol.toPrimitive];
              if (e5 !== undefined) {
                var r4 = e5.call(t6, "string");
                if (o(r4) != "object")
                  return r4;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(t6);
            }(t5);
            return o(e4) == "symbol" ? e4 : e4 + "";
          }(a2)) in s2) ? Object.defineProperty(s2, a2, { value: u2, enumerable: true, configurable: true, writable: true }) : s2[a2] = u2, s2) };
        }
        return f2;
      }, O.prototype.$conditionalHandlers = { $all: function(t4, e3) {
        var r3 = this;
        return Array.isArray(t4) ? t4.map(function(t5) {
          return r3.castForQuery(null, t5, e3);
        }) : [this.castForQuery(null, t4, e3)];
      }, $eq: $, $in: j, $ne: $, $nin: j, $exists: a, $type: u }, O.prototype.castForQuery = function(t4, e3, r3) {
        var n2;
        if (t4 != null) {
          if (!(n2 = this.$conditionalHandlers[t4]))
            throw new Error("Can't use " + t4);
          return n2.call(this, e3, r3);
        }
        try {
          return this.applySetters(e3, r3);
        } catch (t5) {
          throw t5 instanceof g && t5.path === this.path && this.$fullPath != null && (t5.path = this.$fullPath), t5;
        }
      }, O.checkRequired = function(t4) {
        return arguments.length !== 0 && (this._checkRequired = t4), this._checkRequired;
      }, O.prototype.checkRequired = function(t4) {
        return t4 != null;
      }, O.prototype.clone = function() {
        var t4 = Object.assign({}, this.options), e3 = new this.constructor(this.path, t4, this.instance);
        return e3.validators = this.validators.slice(), this.requiredValidator !== undefined && (e3.requiredValidator = this.requiredValidator), this.defaultValue !== undefined && (e3.defaultValue = this.defaultValue), this.$immutable !== undefined && this.options.immutable === undefined && (e3.$immutable = this.$immutable, l(e3)), this._index !== undefined && (e3._index = this._index), this.selected !== undefined && (e3.selected = this.selected), this.isRequired !== undefined && (e3.isRequired = this.isRequired), this.originalRequiredValue !== undefined && (e3.originalRequiredValue = this.originalRequiredValue), e3.getters = this.getters.slice(), e3.setters = this.setters.slice(), e3;
      }, O.prototype.getEmbeddedSchemaType = function() {
        return this.$embeddedSchemaType;
      }, O.prototype._duplicateKeyErrorMessage = null, O.prototype.toJSONSchema = function(t4) {
        throw new Error("Converting unsupported SchemaType to JSON Schema: ".concat(this.instance, ' at path "').concat(this.path, '"'));
      }, O.prototype.autoEncryptionType = function() {
        return null;
      }, t3.exports = e2 = O, e2.CastError = g, e2.ValidatorError = _;
    }, 6451: (t3, e2, r2) => {
      var n = r2(8768).isPOJO;
      t3.exports = function t(e3) {
        for (var r3, o, i, s = Object.keys(e3), a = s.length;a--; )
          i = e3[o = s[a]], n(i) && (e3[o] = t(i)), e3[o] !== undefined ? r3 = true : delete e3[o];
        return r3 ? e3 : undefined;
      };
    }, 6511: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o(t4, e3) {
        (e3 == null || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = Array(e3);r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      function i(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function s(t4) {
        for (var e3 = 1;e3 < arguments.length; e3++) {
          var r3 = arguments[e3] != null ? arguments[e3] : {};
          e3 % 2 ? i(Object(r3), true).forEach(function(e4) {
            a(t4, e4, r3[e4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : i(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      function a(t4, e3, r3) {
        return (e3 = function(t5) {
          var e4 = function(t6) {
            if (n(t6) != "object" || !t6)
              return t6;
            var e5 = t6[Symbol.toPrimitive];
            if (e5 !== undefined) {
              var r4 = e5.call(t6, "string");
              if (n(r4) != "object")
                return r4;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t6);
          }(t5);
          return n(e4) == "symbol" ? e4 : e4 + "";
        }(e3)) in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      r2(8768);
      var u = t3.exports = function() {};
      u.ctor = function() {
        var t4 = Array.prototype.slice.call(arguments), e3 = function() {
          u.apply(this, arguments), this.paths = {}, this.states = {};
        };
        return (e3.prototype = new u).constructor = e3, e3.prototype.stateNames = t4, t4.forEach(function(t5) {
          e3.prototype[t5] = function(e4) {
            this._changeState(e4, t5);
          };
        }), e3;
      }, u.prototype._changeState = function(t4, e3) {
        var r3 = this.paths[t4];
        if (r3 !== e3) {
          var n2 = this.states[r3];
          n2 && delete n2[t4], this.paths[t4] = e3, this.states[e3] = this.states[e3] || {}, this.states[e3][t4] = true;
        }
      }, u.prototype.clear = function(t4) {
        if (this.states[t4] != null)
          for (var e3, r3 = Object.keys(this.states[t4]), n2 = r3.length;n2--; )
            e3 = r3[n2], delete this.states[t4][e3], delete this.paths[e3];
      }, u.prototype.clearPath = function(t4) {
        var e3 = this.paths[t4];
        e3 && (delete this.paths[t4], delete this.states[e3][t4]);
      }, u.prototype.getStatePaths = function(t4) {
        return this.states[t4] != null ? this.states[t4] : {};
      }, u.prototype.some = function() {
        var t4 = this, e3 = arguments.length ? arguments : this.stateNames;
        return Array.prototype.some.call(e3, function(e4) {
          return t4.states[e4] != null && Object.keys(t4.states[e4]).length;
        });
      }, u.prototype._iter = function(t4) {
        return function() {
          var e3 = Array.prototype.slice.call(arguments), r3 = e3.pop();
          e3.length || (e3 = this.stateNames);
          var n2 = this;
          return e3.reduce(function(t5, e4) {
            return n2.states[e4] == null ? t5 : t5.concat(Object.keys(n2.states[e4]));
          }, [])[t4](function(t5, e4, n3) {
            return r3(t5, e4, n3);
          });
        };
      }, u.prototype.forEach = function() {
        return this.forEach = this._iter("forEach"), this.forEach.apply(this, arguments);
      }, u.prototype.map = function() {
        return this.map = this._iter("map"), this.map.apply(this, arguments);
      }, u.prototype.clone = function() {
        var t4 = new this.constructor;
        t4.paths = s({}, this.paths);
        var e3, r3 = function(t5, e4) {
          var r4 = typeof Symbol != "undefined" && t5[Symbol.iterator] || t5["@@iterator"];
          if (!r4) {
            if (Array.isArray(t5) || (r4 = function(t6, e5) {
              if (t6) {
                if (typeof t6 == "string")
                  return o(t6, e5);
                var r5 = {}.toString.call(t6).slice(8, -1);
                return r5 === "Object" && t6.constructor && (r5 = t6.constructor.name), r5 === "Map" || r5 === "Set" ? Array.from(t6) : r5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? o(t6, e5) : undefined;
              }
            }(t5)) || e4 && t5 && typeof t5.length == "number") {
              r4 && (t5 = r4);
              var n3 = 0, i2 = function() {};
              return { s: i2, n: function() {
                return n3 >= t5.length ? { done: true } : { done: false, value: t5[n3++] };
              }, e: function(t6) {
                throw t6;
              }, f: i2 };
            }
            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }
          var s2, a2 = true, u2 = false;
          return { s: function() {
            r4 = r4.call(t5);
          }, n: function() {
            var t6 = r4.next();
            return a2 = t6.done, t6;
          }, e: function(t6) {
            u2 = true, s2 = t6;
          }, f: function() {
            try {
              a2 || r4.return == null || r4.return();
            } finally {
              if (u2)
                throw s2;
            }
          } };
        }(this.stateNames);
        try {
          for (r3.s();!(e3 = r3.n()).done; ) {
            var n2 = e3.value;
            n2 in this.states && (t4.states[n2] = this.states[n2] == null ? this.states[n2] : s({}, this.states[n2]));
          }
        } catch (t5) {
          r3.e(t5);
        } finally {
          r3.f();
        }
        return t4;
      };
    }, 6544: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var o;
      if (!Object.keys) {
        var i = Object.prototype.hasOwnProperty, s = Object.prototype.toString, a = r2(6312), u = Object.prototype.propertyIsEnumerable, c = !u.call({ toString: null }, "toString"), l = u.call(function() {}, "prototype"), f = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], p = function(t4) {
          var e3 = t4.constructor;
          return e3 && e3.prototype === t4;
        }, h = { $applicationCache: true, $console: true, $external: true, $frame: true, $frameElement: true, $frames: true, $innerHeight: true, $innerWidth: true, $onmozfullscreenchange: true, $onmozfullscreenerror: true, $outerHeight: true, $outerWidth: true, $pageXOffset: true, $pageYOffset: true, $parent: true, $scrollLeft: true, $scrollTop: true, $scrollX: true, $scrollY: true, $self: true, $webkitIndexedDB: true, $webkitStorageInfo: true, $window: true }, y = function() {
          if (typeof window == "undefined")
            return false;
          for (var t4 in window)
            try {
              if (!h["$" + t4] && i.call(window, t4) && window[t4] !== null && n(window[t4]) === "object")
                try {
                  p(window[t4]);
                } catch (t5) {
                  return true;
                }
            } catch (t5) {
              return true;
            }
          return false;
        }();
        o = function(t4) {
          var e3 = t4 !== null && n(t4) === "object", r3 = s.call(t4) === "[object Function]", o2 = a(t4), u2 = e3 && s.call(t4) === "[object String]", h2 = [];
          if (!e3 && !r3 && !o2)
            throw new TypeError("Object.keys called on a non-object");
          var d = l && r3;
          if (u2 && t4.length > 0 && !i.call(t4, 0))
            for (var b = 0;b < t4.length; ++b)
              h2.push(String(b));
          if (o2 && t4.length > 0)
            for (var m = 0;m < t4.length; ++m)
              h2.push(String(m));
          else
            for (var v in t4)
              d && v === "prototype" || !i.call(t4, v) || h2.push(String(v));
          if (c)
            for (var g = function(t5) {
              if (typeof window == "undefined" || !y)
                return p(t5);
              try {
                return p(t5);
              } catch (t6) {
                return false;
              }
            }(t4), _ = 0;_ < f.length; ++_)
              g && f[_] === "constructor" || !i.call(t4, f[_]) || h2.push(f[_]);
          return h2;
        };
      }
      t3.exports = o;
    }, 6547: (t3, e2, r2) => {
      function n(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function o(t4, e3, r3) {
        return (e3 = function(t5) {
          var e4 = function(t6) {
            if (i(t6) != "object" || !t6)
              return t6;
            var e5 = t6[Symbol.toPrimitive];
            if (e5 !== undefined) {
              var r4 = e5.call(t6, "string");
              if (i(r4) != "object")
                return r4;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t6);
          }(t5);
          return i(e4) == "symbol" ? e4 : e4 + "";
        }(e3)) in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      function i(t4) {
        return i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, i(t4);
      }
      var s = r2(3550).EventEmitter, a = r2(9380), u = r2(8768), c = r2(7930).documentArrayParent;
      function l(t4, e3, r3, s2, l2) {
        var f2;
        u.isMongooseDocumentArray(e3) ? (this.__parentArray = e3, this[c] = e3.$parent()) : (this.__parentArray = undefined, this[c] = undefined), this.$setIndex(l2), this.$__parent = this[c], i(r3) === "object" && r3 != null ? (f2 = function(t5) {
          for (var e4 = 1;e4 < arguments.length; e4++) {
            var r4 = arguments[e4] != null ? arguments[e4] : {};
            e4 % 2 ? n(Object(r4), true).forEach(function(e5) {
              o(t5, e5, r4[e5]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t5, Object.getOwnPropertyDescriptors(r4)) : n(Object(r4)).forEach(function(e5) {
              Object.defineProperty(t5, e5, Object.getOwnPropertyDescriptor(r4, e5));
            });
          }
          return t5;
        }({ isNew: true }, r3), r3 = undefined) : f2 = { isNew: true }, a.call(this, t4, s2, this[c], r3, f2);
      }
      for (var f in l.prototype = Object.create(a.prototype), l.prototype.constructor = l, Object.defineProperty(l.prototype, "$isSingleNested", { configurable: false, writable: false, value: false }), Object.defineProperty(l.prototype, "$isDocumentArrayElement", { configurable: false, writable: false, value: true }), s.prototype)
        l[f] = s.prototype[f];
      l.prototype.$setIndex = function(t4) {
        if (this.__index = t4, this.$__ != null && this.$__.validationError != null)
          for (var e3 = 0, r3 = Object.keys(this.$__.validationError.errors);e3 < r3.length; e3++) {
            var n2 = r3[e3];
            this.invalidate(n2, this.$__.validationError.errors[n2]);
          }
      }, l.prototype.populate = function() {
        throw new Error('Mongoose does not support calling populate() on nested docs. Instead of `doc.arr[0].populate("path")`, use `doc.populate("arr.0.path")`');
      }, l.prototype.$__removeFromParent = function() {
        var t4 = this._doc._id;
        if (!t4)
          throw new Error("For your own good, Mongoose does not know how to remove an ArraySubdocument that has no _id");
        this.__parentArray.pull({ _id: t4 });
      }, l.prototype.$__fullPath = function(t4, e3) {
        return this.__index == null ? null : (this.$__.fullPath || this.ownerDocument(), e3 ? t4 ? this.$__.fullPath + "." + t4 : this.$__.fullPath : t4 ? this.$__.fullPath + "." + this.__index + "." + t4 : this.$__.fullPath + "." + this.__index);
      }, l.prototype.$__pathRelativeToParent = function(t4, e3) {
        return this.__index != null && this.__parentArray && this.__parentArray.$path ? e3 ? t4 == null ? this.__parentArray.$path() : this.__parentArray.$path() + "." + t4 : t4 == null ? this.__parentArray.$path() + "." + this.__index : this.__parentArray.$path() + "." + this.__index + "." + t4 : null;
      }, l.prototype.$parent = function() {
        return this[c];
      }, l.prototype.parentArray = function() {
        return this.__parentArray;
      }, t3.exports = l;
    }, 6583: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var o, i = r2(8863), s = r2(1464);
      try {
        o = [].__proto__ === Array.prototype;
      } catch (t4) {
        if (!t4 || n(t4) !== "object" || !("code" in t4) || t4.code !== "ERR_PROTO_ACCESS")
          throw t4;
      }
      var a = !!o && s && s(Object.prototype, "__proto__"), u = Object, c = u.getPrototypeOf;
      t3.exports = a && typeof a.get == "function" ? i([a.get]) : typeof c == "function" && function(t4) {
        return c(t4 == null ? t4 : u(t4));
      };
    }, 6665: (t3) => {
      t3.exports = function(t4, e2) {
        for (var r2, n, o, i = e2.split("."), s = "", a = 0;a < i.length; ++a)
          if (t4[s += s.length ? "." : "" + i[a]]) {
            for (o = (n = Object.keys(t4)).length, r2 = 0;r2 < o; ++r2)
              n[a].indexOf(s + ".") !== 0 || n[a].indexOf(e2);
            return true;
          }
        return false;
      };
    }, 6730: (t3) => {
      var e2 = Object.prototype.toString, r2 = Math.max, n = function(t4, e3) {
        for (var r3 = [], n2 = 0;n2 < t4.length; n2 += 1)
          r3[n2] = t4[n2];
        for (var o = 0;o < e3.length; o += 1)
          r3[o + t4.length] = e3[o];
        return r3;
      };
      t3.exports = function(t4) {
        var o = this;
        if (typeof o != "function" || e2.apply(o) !== "[object Function]")
          throw new TypeError("Function.prototype.bind called on incompatible " + o);
        for (var i, s = function(t5) {
          for (var e3 = [], r3 = 1, n2 = 0;r3 < t5.length; r3 += 1, n2 += 1)
            e3[n2] = t5[r3];
          return e3;
        }(arguments), a = r2(0, o.length - s.length), u = [], c = 0;c < a; c++)
          u[c] = "$" + c;
        if (i = Function("binder", "return function (" + function(t5) {
          for (var e3 = "", r3 = 0;r3 < t5.length; r3 += 1)
            e3 += t5[r3], r3 + 1 < t5.length && (e3 += ",");
          return e3;
        }(u) + "){ return binder.apply(this,arguments); }")(function() {
          if (this instanceof i) {
            var e3 = o.apply(this, n(s, arguments));
            return Object(e3) === e3 ? e3 : this;
          }
          return o.apply(t4, n(s, arguments));
        }), o.prototype) {
          var l = function() {};
          l.prototype = o.prototype, i.prototype = new l, l.prototype = null;
        }
        return i;
      };
    }, 6750: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var o = r2(988), i = r2(9907), s = r2(2268), a = r2(1464);
      t3.exports = function(t4, e3, r3) {
        if (!t4 || n(t4) !== "object" && typeof t4 != "function")
          throw new s("`obj` must be an object or a function`");
        if (typeof e3 != "string" && n(e3) !== "symbol")
          throw new s("`property` must be a string or a symbol`");
        if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
          throw new s("`nonEnumerable`, if provided, must be a boolean or null");
        if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
          throw new s("`nonWritable`, if provided, must be a boolean or null");
        if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
          throw new s("`nonConfigurable`, if provided, must be a boolean or null");
        if (arguments.length > 6 && typeof arguments[6] != "boolean")
          throw new s("`loose`, if provided, must be a boolean");
        var u = arguments.length > 3 ? arguments[3] : null, c = arguments.length > 4 ? arguments[4] : null, l = arguments.length > 5 ? arguments[5] : null, f = arguments.length > 6 && arguments[6], p = !!a && a(t4, e3);
        if (o)
          o(t4, e3, { configurable: l === null && p ? p.configurable : !l, enumerable: u === null && p ? p.enumerable : !u, value: r3, writable: c === null && p ? p.writable : !c });
        else {
          if (!f && (u || c || l))
            throw new i("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
          t4[e3] = r3;
        }
      };
    }, 6775: (t3, e2) => {
      e2.byteLength = function(t4) {
        var e3 = a(t4), r3 = e3[0], n2 = e3[1];
        return 3 * (r3 + n2) / 4 - n2;
      }, e2.toByteArray = function(t4) {
        var e3, r3, i2 = a(t4), s2 = i2[0], u2 = i2[1], c2 = new o(function(t5, e4, r4) {
          return 3 * (e4 + r4) / 4 - r4;
        }(0, s2, u2)), l = 0, f = u2 > 0 ? s2 - 4 : s2;
        for (r3 = 0;r3 < f; r3 += 4)
          e3 = n[t4.charCodeAt(r3)] << 18 | n[t4.charCodeAt(r3 + 1)] << 12 | n[t4.charCodeAt(r3 + 2)] << 6 | n[t4.charCodeAt(r3 + 3)], c2[l++] = e3 >> 16 & 255, c2[l++] = e3 >> 8 & 255, c2[l++] = 255 & e3;
        return u2 === 2 && (e3 = n[t4.charCodeAt(r3)] << 2 | n[t4.charCodeAt(r3 + 1)] >> 4, c2[l++] = 255 & e3), u2 === 1 && (e3 = n[t4.charCodeAt(r3)] << 10 | n[t4.charCodeAt(r3 + 1)] << 4 | n[t4.charCodeAt(r3 + 2)] >> 2, c2[l++] = e3 >> 8 & 255, c2[l++] = 255 & e3), c2;
      }, e2.fromByteArray = function(t4) {
        for (var e3, n2 = t4.length, o2 = n2 % 3, i2 = [], s2 = 16383, a2 = 0, u2 = n2 - o2;a2 < u2; a2 += s2)
          i2.push(c(t4, a2, a2 + s2 > u2 ? u2 : a2 + s2));
        return o2 === 1 ? (e3 = t4[n2 - 1], i2.push(r2[e3 >> 2] + r2[e3 << 4 & 63] + "==")) : o2 === 2 && (e3 = (t4[n2 - 2] << 8) + t4[n2 - 1], i2.push(r2[e3 >> 10] + r2[e3 >> 4 & 63] + r2[e3 << 2 & 63] + "=")), i2.join("");
      };
      for (var r2 = [], n = [], o = typeof Uint8Array != "undefined" ? Uint8Array : Array, i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0;s < 64; ++s)
        r2[s] = i[s], n[i.charCodeAt(s)] = s;
      function a(t4) {
        var e3 = t4.length;
        if (e3 % 4 > 0)
          throw new Error("Invalid string. Length must be a multiple of 4");
        var r3 = t4.indexOf("=");
        return r3 === -1 && (r3 = e3), [r3, r3 === e3 ? 0 : 4 - r3 % 4];
      }
      function u(t4) {
        return r2[t4 >> 18 & 63] + r2[t4 >> 12 & 63] + r2[t4 >> 6 & 63] + r2[63 & t4];
      }
      function c(t4, e3, r3) {
        for (var n2, o2 = [], i2 = e3;i2 < r3; i2 += 3)
          n2 = (t4[i2] << 16 & 16711680) + (t4[i2 + 1] << 8 & 65280) + (255 & t4[i2 + 2]), o2.push(u(n2));
        return o2.join("");
      }
      n[45] = 62, n[95] = 63;
    }, 6801: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (o = function() {
          return !!t4;
        })();
      }
      function i(t4) {
        return i = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, i(t4);
      }
      function s(t4, e3) {
        return s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s(t4, e3);
      }
      var a = function(t4) {
        function e3(t5, r4) {
          var s2;
          return function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), (s2 = function(t6, e4, r5) {
            return e4 = i(e4), function(t7, e5) {
              if (e5 && (n(e5) == "object" || typeof e5 == "function"))
                return e5;
              if (e5 !== undefined)
                throw new TypeError("Derived constructors may only return object or undefined");
              return function(t8) {
                if (t8 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t8;
              }(t7);
            }(t6, o() ? Reflect.construct(e4, r5 || [], i(t6).constructor) : e4.apply(t6, r5));
          }(this, e3, [r4 = r4 || "Cannot populate path `" + t5 + "` because it is not in your schema. Set the `strictPopulate` option to false to override."])).path = t5, s2;
        }
        return function(t5, e4) {
          if (typeof e4 != "function" && e4 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(8213));
      Object.defineProperty(a.prototype, "name", { value: "StrictPopulateError" }), t3.exports = a;
    }, 6814: (t3) => {
      t3.exports = function(t4) {
        for (var e2 = {}, r2 = 0, n = Object.keys(t4);r2 < n.length; r2++) {
          var o = n[r2];
          if (o.indexOf(".") !== -1)
            for (var i = o.split("."), s = i[0], a = 0;a < i.length; ++a)
              e2[s] = 1, a + 1 < i.length && (s = s + "." + i[a + 1]);
          else
            e2[o] = 1;
        }
        return e2;
      };
    }, 6867: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o(t4, e3) {
        (e3 == null || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = Array(e3);r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      function i(t4, e3) {
        for (var r3 = 0;r3 < e3.length; r3++) {
          var n2 = e3[r3];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t4, s(n2.key), n2);
        }
      }
      function s(t4) {
        var e3 = function(t5) {
          if (n(t5) != "object" || !t5)
            return t5;
          var e4 = t5[Symbol.toPrimitive];
          if (e4 !== undefined) {
            var r3 = e4.call(t5, "string");
            if (n(r3) != "object")
              return r3;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t5);
        }(t4);
        return n(e3) == "symbol" ? e3 : e3 + "";
      }
      function a() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (a = function() {
          return !!t4;
        })();
      }
      function u() {
        return u = typeof Reflect != "undefined" && Reflect.get ? Reflect.get.bind() : function(t4, e3, r3) {
          var n2 = function(t5, e4) {
            for (;!{}.hasOwnProperty.call(t5, e4) && (t5 = c(t5)) !== null; )
              ;
            return t5;
          }(t4, e3);
          if (n2) {
            var o2 = Object.getOwnPropertyDescriptor(n2, e3);
            return o2.get ? o2.get.call(arguments.length < 3 ? t4 : r3) : o2.value;
          }
        }, u.apply(null, arguments);
      }
      function c(t4) {
        return c = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, c(t4);
      }
      function l(t4, e3) {
        return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, l(t4, e3);
      }
      var f = r2(2081), p = r2(241), h = r2(6426), y = r2(4327), d = function(t4) {
        function e3(t5, r3) {
          var o2;
          return function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), (o2 = function(t6, e4, r4) {
            return e4 = c(e4), function(t7, e5) {
              if (e5 && (n(e5) == "object" || typeof e5 == "function"))
                return e5;
              if (e5 !== undefined)
                throw new TypeError("Derived constructors may only return object or undefined");
              return function(t8) {
                if (t8 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t8;
              }(t7);
            }(t6, a() ? Reflect.construct(e4, r4 || [], c(t6).constructor) : e4.apply(t6, r4));
          }(this, e3, [t5, r3, "Map"])).$isSchemaMap = true, o2;
        }
        return function(t5, e4) {
          if (typeof e4 != "function" && e4 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && l(t5, e4);
        }(e3, t4), s2 = e3, p2 = [{ key: "set", value: function(t5, e4) {
          return h.set(t5, e4);
        } }, { key: "cast", value: function(t5, e4, n2, i2, s3) {
          var a2;
          if (t5 instanceof f)
            return t5;
          var u2 = (a2 = s3 == null ? undefined : s3.path) !== null && a2 !== undefined ? a2 : this.path;
          if (n2) {
            var c2 = new f({}, u2, e4, this.$__schemaType);
            if (t5 instanceof r2.g.Map) {
              var l2, p3 = function(t6, e5) {
                var r3 = typeof Symbol != "undefined" && t6[Symbol.iterator] || t6["@@iterator"];
                if (!r3) {
                  if (Array.isArray(t6) || (r3 = function(t7, e6) {
                    if (t7) {
                      if (typeof t7 == "string")
                        return o(t7, e6);
                      var r4 = {}.toString.call(t7).slice(8, -1);
                      return r4 === "Object" && t7.constructor && (r4 = t7.constructor.name), r4 === "Map" || r4 === "Set" ? Array.from(t7) : r4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r4) ? o(t7, e6) : undefined;
                    }
                  }(t6)) || e5 && t6 && typeof t6.length == "number") {
                    r3 && (t6 = r3);
                    var n3 = 0, i3 = function() {};
                    return { s: i3, n: function() {
                      return n3 >= t6.length ? { done: true } : { done: false, value: t6[n3++] };
                    }, e: function(t7) {
                      throw t7;
                    }, f: i3 };
                  }
                  throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
                }
                var s4, a3 = true, u3 = false;
                return { s: function() {
                  r3 = r3.call(t6);
                }, n: function() {
                  var t7 = r3.next();
                  return a3 = t7.done, t7;
                }, e: function(t7) {
                  u3 = true, s4 = t7;
                }, f: function() {
                  try {
                    a3 || r3.return == null || r3.return();
                  } finally {
                    if (u3)
                      throw s4;
                  }
                } };
              }(t5.keys());
              try {
                for (p3.s();!(l2 = p3.n()).done; ) {
                  var h2 = l2.value, y2 = t5.get(h2);
                  y2 = y2 == null ? c2.$__schemaType._castNullish(y2) : c2.$__schemaType.cast(y2, e4, true, null, { path: u2 + "." + h2 }), c2.$init(h2, y2);
                }
              } catch (t6) {
                p3.e(t6);
              } finally {
                p3.f();
              }
            } else
              for (var d2 = 0, b = Object.keys(t5);d2 < b.length; d2++) {
                var m = b[d2], v = t5[m];
                v = v == null ? c2.$__schemaType._castNullish(v) : c2.$__schemaType.cast(v, e4, true, null, { path: u2 + "." + m }), c2.$init(m, v);
              }
            return c2;
          }
          return new f(t5, u2, e4, this.$__schemaType);
        } }, { key: "clone", value: function() {
          var t5, r3, n2, o2 = (t5 = e3, r3 = this, typeof (n2 = u(c(1 & 3 ? t5.prototype : t5), "clone", r3)) == "function" ? function(t6) {
            return n2.apply(r3, t6);
          } : n2)([]);
          return this.$__schemaType != null && (o2.$__schemaType = this.$__schemaType.clone()), o2;
        } }, { key: "getEmbeddedSchemaType", value: function() {
          return this.$__schemaType;
        } }, { key: "toJSONSchema", value: function(t5) {
          var e4 = t5 == null ? undefined : t5.useBsonType, r3 = this.getEmbeddedSchemaType(), n2 = this.options.required && typeof this.options.required != "function", o2 = y("object", "object", e4, n2);
          return o2.additionalProperties = r3.toJSONSchema(t5), o2;
        } }, { key: "autoEncryptionType", value: function() {
          return "object";
        } }], p2 && i(s2.prototype, p2), Object.defineProperty(s2, "prototype", { writable: false }), s2;
        var s2, p2;
      }(h);
      d.schemaName = "Map", d.prototype.OptionsConstructor = p, d.defaultOptions = {}, t3.exports = d;
    }, 6948: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o(t4, e3) {
        for (var r3 = 0;r3 < e3.length; r3++) {
          var n2 = e3[r3];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t4, s(n2.key), n2);
        }
      }
      function i(t4, e3, r3) {
        return e3 && o(t4.prototype, e3), r3 && o(t4, r3), Object.defineProperty(t4, "prototype", { writable: false }), t4;
      }
      function s(t4) {
        var e3 = function(t5) {
          if (n(t5) != "object" || !t5)
            return t5;
          var e4 = t5[Symbol.toPrimitive];
          if (e4 !== undefined) {
            var r3 = e4.call(t5, "string");
            if (n(r3) != "object")
              return r3;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t5);
        }(t4);
        return n(e3) == "symbol" ? e3 : e3 + "";
      }
      var a = r2(4450), u = i(function t(e3) {
        if (function(t4, e4) {
          if (!(t4 instanceof e4))
            throw new TypeError("Cannot call a class as a function");
        }(this, t), this._docs = {}, this._childDocs = [], e3 != null && (e3 = a(e3), Object.assign(this, e3), n(e3.subPopulate) === "object" && (this.populate = e3.subPopulate), e3.perDocumentLimit != null && e3.limit != null))
          throw new Error("Can not use `limit` and `perDocumentLimit` at the same time. Path: `" + e3.path + "`.");
      });
      t3.exports = u;
    }, 6949: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o(t4, e3) {
        for (var r3 = 0;r3 < e3.length; r3++) {
          var n2 = e3[r3];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t4, i(n2.key), n2);
        }
      }
      function i(t4) {
        var e3 = function(t5) {
          if (n(t5) != "object" || !t5)
            return t5;
          var e4 = t5[Symbol.toPrimitive];
          if (e4 !== undefined) {
            var r3 = e4.call(t5, "string");
            if (n(r3) != "object")
              return r3;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t5);
        }(t4);
        return n(e3) == "symbol" ? e3 : e3 + "";
      }
      function s() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (s = function() {
          return !!t4;
        })();
      }
      function a(t4) {
        return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, a(t4);
      }
      function u(t4, e3) {
        return u = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, u(t4, e3);
      }
      var c = r2(8213), l = r2(8260), f = r2(7352), p = r2(1875), h = function(t4) {
        function e3(t5) {
          var r4, o2;
          return function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), (r4 = function(t6, e4, r5) {
            return e4 = a(e4), function(t7, e5) {
              if (e5 && (n(e5) == "object" || typeof e5 == "function"))
                return e5;
              if (e5 !== undefined)
                throw new TypeError("Derived constructors may only return object or undefined");
              return function(t8) {
                if (t8 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t8;
              }(t7);
            }(t6, s() ? Reflect.construct(e4, r5 || [], a(t6).constructor) : e4.apply(t6, r5));
          }(this, e3, [o2 = l(t5) === "model" ? t5.constructor.modelName + " validation failed" : "Validation failed"])).errors = {}, r4._message = o2, t5 && (t5.$errors = r4.errors), r4;
        }
        return function(t5, e4) {
          if (typeof e4 != "function" && e4 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && u(t5, e4);
        }(e3, t4), r3 = e3, (i2 = [{ key: "toString", value: function() {
          return this.name + ": " + p(this);
        } }, { key: "inspect", value: function() {
          return Object.assign(new Error(this.message), this);
        } }, { key: "addError", value: function(t5, r4) {
          if (r4 instanceof e3)
            for (var n2 = r4.errors, o2 = 0, i3 = Object.keys(n2);o2 < i3.length; o2++) {
              var s2 = i3[o2];
              this.addError("".concat(t5, ".").concat(s2), n2[s2]);
            }
          else
            this.errors[t5] = r4, this.message = this._message + ": " + p(this);
        } }]) && o(r3.prototype, i2), Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3, i2;
      }(c);
      f.inspect.custom && (h.prototype[f.inspect.custom] = h.prototype.inspect), Object.defineProperty(h.prototype, "toJSON", { enumerable: false, writable: false, configurable: true, value: function() {
        return Object.assign({}, this, { name: this.name, message: this.message });
      } }), Object.defineProperty(h.prototype, "name", { value: "ValidationError" }), t3.exports = h;
    }, 6974: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (o = function() {
          return !!t4;
        })();
      }
      function i(t4) {
        return i = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, i(t4);
      }
      function s(t4, e3) {
        return s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s(t4, e3);
      }
      var a = function(t4) {
        function e3() {
          return function(t5, e4) {
            if (!(t5 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), function(t5, e4, r4) {
            return e4 = i(e4), function(t6, e5) {
              if (e5 && (n(e5) == "object" || typeof e5 == "function"))
                return e5;
              if (e5 !== undefined)
                throw new TypeError("Derived constructors may only return object or undefined");
              return function(t7) {
                if (t7 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t7;
              }(t6);
            }(t5, o() ? Reflect.construct(e4, r4 || [], i(t5).constructor) : e4.apply(t5, r4));
          }(this, e3, arguments);
        }
        return function(t5, e4) {
          if (typeof e4 != "function" && e4 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(8879)), u = r2(5761);
      Object.defineProperty(a.prototype, "of", u), t3.exports = a;
    }, 6996: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (o = function() {
          return !!t4;
        })();
      }
      function i(t4) {
        return i = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, i(t4);
      }
      function s(t4, e3) {
        return s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s(t4, e3);
      }
      var a = function(t4) {
        function e3(t5, r4, s2) {
          var a2;
          (function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          })(this, e3);
          var u = s2.join(", ");
          return (a2 = function(t6, e4, r5) {
            return e4 = i(e4), function(t7, e5) {
              if (e5 && (n(e5) == "object" || typeof e5 == "function"))
                return e5;
              if (e5 !== undefined)
                throw new TypeError("Derived constructors may only return object or undefined");
              return function(t8) {
                if (t8 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t8;
              }(t7);
            }(t6, o() ? Reflect.construct(e4, r5 || [], i(t6).constructor) : e4.apply(t6, r5));
          }(this, e3, ['No matching document found for id "' + t5._doc._id + '" version ' + r4 + ' modifiedPaths "' + u + '"'])).version = r4, a2.modifiedPaths = s2, a2;
        }
        return function(t5, e4) {
          if (typeof e4 != "function" && e4 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(8213));
      Object.defineProperty(a.prototype, "name", { value: "VersionError" }), t3.exports = a;
    }, 7045: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function i(t4) {
        for (var e3 = 1;e3 < arguments.length; e3++) {
          var r3 = arguments[e3] != null ? arguments[e3] : {};
          e3 % 2 ? o(Object(r3), true).forEach(function(e4) {
            s(t4, e4, r3[e4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : o(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      function s(t4, e3, r3) {
        return (e3 = function(t5) {
          var e4 = function(t6) {
            if (n(t6) != "object" || !t6)
              return t6;
            var e5 = t6[Symbol.toPrimitive];
            if (e5 !== undefined) {
              var r4 = e5.call(t6, "string");
              if (n(r4) != "object")
                return r4;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t6);
          }(t5);
          return n(e4) == "symbol" ? e4 : e4 + "";
        }(e3)) in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      var a = r2(6426), u = a.CastError, c = r2(9553), l = r2(4327), f = r2(3305);
      function p(t4, e3) {
        a.call(this, t4, e3, "Decimal128");
      }
      function h(t4) {
        return this.cast(t4);
      }
      p.schemaName = "Decimal128", p.defaultOptions = {}, p.prototype = Object.create(a.prototype), p.prototype.constructor = p, p._cast = c, p.set = a.set, p.setters = [], p.get = a.get, p.cast = function(t4) {
        return arguments.length === 0 || (t4 === false && (t4 = this._defaultCaster), this._cast = t4), this._cast;
      }, p._defaultCaster = function(t4) {
        if (t4 != null && !f(t4, "Decimal128"))
          throw new Error;
        return t4;
      }, p._checkRequired = function(t4) {
        return f(t4, "Decimal128");
      }, p.checkRequired = a.checkRequired, p.prototype.checkRequired = function(t4, e3) {
        return a._isRef(this, t4, e3, true) ? !!t4 : (typeof this.constructor.checkRequired == "function" ? this.constructor.checkRequired() : p.checkRequired())(t4);
      }, p.prototype.cast = function(t4, e3, r3, n2, o2) {
        if (a._isRef(this, t4, e3, r3))
          return f(t4, "Decimal128") ? t4 : this._castRef(t4, e3, r3, o2);
        var i2;
        i2 = typeof this._castFunction == "function" ? this._castFunction : typeof this.constructor.cast == "function" ? this.constructor.cast() : p.cast();
        try {
          return i2(t4);
        } catch (e4) {
          throw new u("Decimal128", t4, this.path, e4, this);
        }
      };
      var y = i(i({}, a.prototype.$conditionalHandlers), {}, { $gt: h, $gte: h, $lt: h, $lte: h });
      Object.defineProperty(p.prototype, "$conditionalHandlers", { enumerable: false, value: y }), p.prototype.toJSONSchema = function(t4) {
        var e3 = this.options.required && typeof this.options.required != "function";
        return l("string", "decimal", t4 == null ? undefined : t4.useBsonType, e3);
      }, p.prototype.autoEncryptionType = function() {
        return "decimal";
      }, t3.exports = p;
    }, 7058: (t3, e2, r2) => {
      var n = r2(5832).hp;
      function o(t4) {
        return function(t5) {
          if (Array.isArray(t5))
            return p(t5);
        }(t4) || function(t5) {
          if (typeof Symbol != "undefined" && t5[Symbol.iterator] != null || t5["@@iterator"] != null)
            return Array.from(t5);
        }(t4) || f(t4) || function() {
          throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }();
      }
      function i(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function s(t4) {
        for (var e3 = 1;e3 < arguments.length; e3++) {
          var r3 = arguments[e3] != null ? arguments[e3] : {};
          e3 % 2 ? i(Object(r3), true).forEach(function(e4) {
            a(t4, e4, r3[e4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : i(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      function a(t4, e3, r3) {
        return (e3 = function(t5) {
          var e4 = function(t6) {
            if (u(t6) != "object" || !t6)
              return t6;
            var e5 = t6[Symbol.toPrimitive];
            if (e5 !== undefined) {
              var r4 = e5.call(t6, "string");
              if (u(r4) != "object")
                return r4;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t6);
          }(t5);
          return u(e4) == "symbol" ? e4 : e4 + "";
        }(e3)) in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      function u(t4) {
        return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, u(t4);
      }
      function c(t4, e3) {
        return function(t5) {
          if (Array.isArray(t5))
            return t5;
        }(t4) || function(t5, e4) {
          var r3 = t5 == null ? null : typeof Symbol != "undefined" && t5[Symbol.iterator] || t5["@@iterator"];
          if (r3 != null) {
            var n2, o2, i2, s2, a2 = [], u2 = true, c2 = false;
            try {
              if (i2 = (r3 = r3.call(t5)).next, e4 === 0) {
                if (Object(r3) !== r3)
                  return;
                u2 = false;
              } else
                for (;!(u2 = (n2 = i2.call(r3)).done) && (a2.push(n2.value), a2.length !== e4); u2 = true)
                  ;
            } catch (t6) {
              c2 = true, o2 = t6;
            } finally {
              try {
                if (!u2 && r3.return != null && (s2 = r3.return(), Object(s2) !== s2))
                  return;
              } finally {
                if (c2)
                  throw o2;
              }
            }
            return a2;
          }
        }(t4, e3) || f(t4, e3) || function() {
          throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }();
      }
      function l(t4, e3) {
        var r3 = typeof Symbol != "undefined" && t4[Symbol.iterator] || t4["@@iterator"];
        if (!r3) {
          if (Array.isArray(t4) || (r3 = f(t4)) || e3 && t4 && typeof t4.length == "number") {
            r3 && (t4 = r3);
            var n2 = 0, o2 = function() {};
            return { s: o2, n: function() {
              return n2 >= t4.length ? { done: true } : { done: false, value: t4[n2++] };
            }, e: function(t5) {
              throw t5;
            }, f: o2 };
          }
          throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        var i2, s2 = true, a2 = false;
        return { s: function() {
          r3 = r3.call(t4);
        }, n: function() {
          var t5 = r3.next();
          return s2 = t5.done, t5;
        }, e: function(t5) {
          a2 = true, i2 = t5;
        }, f: function() {
          try {
            s2 || r3.return == null || r3.return();
          } finally {
            if (a2)
              throw i2;
          }
        } };
      }
      function f(t4, e3) {
        if (t4) {
          if (typeof t4 == "string")
            return p(t4, e3);
          var r3 = {}.toString.call(t4).slice(8, -1);
          return r3 === "Object" && t4.constructor && (r3 = t4.constructor.name), r3 === "Map" || r3 === "Set" ? Array.from(t4) : r3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? p(t4, e3) : undefined;
        }
      }
      function p(t4, e3) {
        (e3 == null || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = Array(e3);r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      var h, y = r2(3550).EventEmitter, d = r2(8297), b = r2(8213), m = r2(6426), v = r2(8879), g = r2(2069), _ = r2(622), w = r2(486), O = r2(4450), S = r2(3703), $ = r2(8260), j = r2(2003), P = r2(5289), A = r2(3381), E = r2(1199), x = r2(9539), T = r2(5678), k = r2(7834), N = r2(2097), I = r2(8768), B = r2(533), M = /\.\d+(\.|$)/, D = r2(1260).Ut, R = r2(4957).middlewareFunctions, U = D.concat(R).reduce(function(t4, e3) {
        return t4.add(e3);
      }, new Set), C = I.isPOJO, F = 0, L = /^\d+$/;
      function V(t4, e3) {
        if (!(this instanceof V))
          return new V(t4, e3);
        if (this.obj = t4, this.paths = {}, this.aliases = {}, this.subpaths = {}, this.virtuals = {}, this.singleNestedPaths = {}, this.nested = {}, this.inherits = {}, this.callQueue = [], this._indexes = [], this._searchIndexes = [], this.methods = e3 && e3.methods || {}, this.methodOptions = {}, this.statics = e3 && e3.statics || {}, this.tree = {}, this.query = e3 && e3.query || {}, this.childSchemas = [], this.plugins = [], this.$id = ++F, this.mapPaths = [], this.encryptedFields = {}, this.s = { hooks: new d }, this.options = this.defaultOptions(e3), Array.isArray(t4)) {
          var r3, n2 = l(t4);
          try {
            for (n2.s();!(r3 = n2.n()).done; ) {
              var o2 = r3.value;
              this.add(o2);
            }
          } catch (t5) {
            n2.e(t5);
          } finally {
            n2.f();
          }
        } else
          t4 && this.add(t4);
        if (e3 && e3.virtuals)
          for (var i2 = e3.virtuals, s2 = 0, a2 = Object.keys(i2);s2 < a2.length; s2++) {
            var u2 = a2[s2], c2 = i2[u2].options ? i2[u2].options : undefined, f2 = this.virtual(u2, c2);
            i2[u2].get && f2.get(i2[u2].get), i2[u2].set && f2.set(i2[u2].set);
          }
        var p2 = t4 && t4._id && I.isObject(t4._id);
        !this.paths._id && this.options._id && !p2 && w(this), this.setupTimestamp(this.options.timestamps);
      }
      function q(t4, e3) {
        for (var r3 = 0, n2 = Object.keys(e3);r3 < n2.length; r3++) {
          var o2 = n2[r3], i2 = null;
          if (e3[o2] != null)
            i2 = e3[o2];
          else {
            var s2 = S(t4.paths[o2], "options");
            if (s2 == null)
              continue;
            i2 = s2.alias;
          }
          if (i2) {
            var a2 = t4.paths[o2].path;
            if (Array.isArray(i2)) {
              var u2, c2 = l(i2);
              try {
                for (c2.s();!(u2 = c2.n()).done; ) {
                  var f2 = u2.value;
                  if (typeof f2 != "string")
                    throw new Error("Invalid value for alias option on " + a2 + ", got " + f2);
                  t4.aliases[f2] = a2, t4.virtual(f2).get(function(t5) {
                    return function() {
                      return typeof this.get == "function" ? this.get(t5) : this[t5];
                    };
                  }(a2)).set(function(t5) {
                    return function(e4) {
                      return this.$set(t5, e4);
                    };
                  }(a2));
                }
              } catch (t5) {
                c2.e(t5);
              } finally {
                c2.f();
              }
            } else {
              if (typeof i2 != "string")
                throw new Error("Invalid value for alias option on " + a2 + ", got " + i2);
              t4.aliases[i2] = a2, t4.virtual(i2).get(function(t5) {
                return function() {
                  return typeof this.get == "function" ? this.get(t5) : this[t5];
                };
              }(a2)).set(function(t5) {
                return function(e4) {
                  return this.$set(t5, e4);
                };
              }(a2));
            }
          }
        }
      }
      V.prototype = Object.create(y.prototype), V.prototype.constructor = V, V.prototype.instanceOfSchema = true, Object.defineProperty(V.prototype, "$schemaType", { configurable: false, enumerable: false, writable: true }), Object.defineProperty(V.prototype, "childSchemas", { configurable: false, enumerable: true, writable: true }), Object.defineProperty(V.prototype, "virtuals", { configurable: false, enumerable: true, writable: true }), V.prototype.obj, V.prototype.paths, V.prototype.tree, V.prototype.clone = function() {
        var t4 = this, e3 = this._clone();
        return e3.on("init", function(e4) {
          return t4.emit("init", e4);
        }), e3;
      }, V.prototype._clone = function(t4) {
        var e3 = new (t4 = t4 || (this.base == null ? V : this.base.Schema))({}, this._userProvidedOptions);
        e3.base = this.base, e3.obj = this.obj, e3.options = O(this.options), e3.callQueue = this.callQueue.map(function(t5) {
          return t5;
        }), e3.methods = O(this.methods), e3.methodOptions = O(this.methodOptions), e3.statics = O(this.statics), e3.query = O(this.query), e3.plugins = Array.prototype.slice.call(this.plugins), e3._indexes = O(this._indexes), e3._searchIndexes = O(this._searchIndexes), e3.s.hooks = this.s.hooks.clone(), e3.tree = O(this.tree), e3.paths = Object.fromEntries(Object.entries(this.paths).map(function(t5) {
          var e4 = c(t5, 2);
          return [e4[0], e4[1].clone()];
        })), e3.nested = O(this.nested), e3.subpaths = O(this.subpaths);
        for (var r3 = 0, n2 = Object.values(e3.paths);r3 < n2.length; r3++) {
          var o2 = n2[r3];
          if (o2.$isSingleNested) {
            for (var i2 = o2.path, s2 = 0, a2 = Object.keys(o2.schema.paths);s2 < a2.length; s2++) {
              var u2 = a2[s2];
              e3.singleNestedPaths[i2 + "." + u2] = o2.schema.paths[u2];
            }
            for (var l2 = 0, f2 = Object.keys(o2.schema.singleNestedPaths);l2 < f2.length; l2++) {
              var p2 = f2[l2];
              e3.singleNestedPaths[i2 + "." + p2] = o2.schema.singleNestedPaths[p2];
            }
            for (var h2 = 0, y2 = Object.keys(o2.schema.subpaths);h2 < y2.length; h2++) {
              var d2 = y2[h2];
              e3.singleNestedPaths[i2 + "." + d2] = o2.schema.subpaths[d2];
            }
            for (var b2 = 0, m2 = Object.keys(o2.schema.nested);b2 < m2.length; b2++) {
              var v2 = m2[b2];
              e3.singleNestedPaths[i2 + "." + v2] = "nested";
            }
          }
        }
        return e3._gatherChildSchemas(), e3.virtuals = O(this.virtuals), e3.$globalPluginsApplied = this.$globalPluginsApplied, e3.$isRootDiscriminator = this.$isRootDiscriminator, e3.$implicitlyCreated = this.$implicitlyCreated, e3.$id = ++F, e3.$originalSchemaId = this.$id, e3.mapPaths = [].concat(this.mapPaths), this.discriminatorMapping != null && (e3.discriminatorMapping = Object.assign({}, this.discriminatorMapping)), this.discriminators != null && (e3.discriminators = Object.assign({}, this.discriminators)), this._applyDiscriminators != null && (e3._applyDiscriminators = new Map(this._applyDiscriminators)), e3.aliases = Object.assign({}, this.aliases), e3.encryptedFields = O(this.encryptedFields), e3;
      }, V.prototype.pick = function(t4, e3) {
        var r3 = new V({}, e3 || this.options);
        if (!Array.isArray(t4))
          throw new b('Schema#pick() only accepts an array argument, got "' + u(t4) + '"');
        var n2, o2 = l(t4);
        try {
          for (o2.s();!(n2 = o2.n()).done; ) {
            var i2 = n2.value;
            if (this._hasEncryptedField(i2)) {
              var s2 = this.encryptedFields[i2], c2 = this.path(i2);
              r3.add(a({}, i2, a({ encrypt: s2 }, this.options.typeKey, c2)));
            } else if (this.nested[i2])
              r3.add(a({}, i2, S(this.tree, i2)));
            else {
              var f2 = this.path(i2);
              if (f2 == null)
                throw new b("Path `" + i2 + "` is not in the schema");
              r3.add(a({}, i2, f2));
            }
          }
        } catch (t5) {
          o2.e(t5);
        } finally {
          o2.f();
        }
        return this._hasEncryptedFields() || (r3.options.encryptionType = null), r3;
      }, V.prototype.omit = function(t4, e3) {
        var r3 = new V(this, e3 || this.options);
        if (!Array.isArray(t4))
          throw new b('Schema#omit() only accepts an array argument, got "' + u(t4) + '"');
        for (var n2 in r3.remove(t4), r3.singleNestedPaths)
          t4.includes(n2) && delete r3.singleNestedPaths[n2];
        return r3;
      }, V.prototype.defaultOptions = function(t4) {
        this._userProvidedOptions = t4 == null ? {} : O(t4);
        var e3 = this.base && this.base.options || {};
        if ((t4 = s({ strict: !("strict" in e3) || e3.strict, strictQuery: "strictQuery" in e3 && e3.strictQuery, bufferCommands: true, capped: false, versionKey: "__v", optimisticConcurrency: false, minimize: true, autoIndex: null, discriminatorKey: "__t", shardKey: null, read: null, validateBeforeSave: true, validateModifiedOnly: false, _id: true, id: !("id" in e3) || e3.id, typeKey: "type" }, t4)).versionKey && typeof t4.versionKey != "string")
          throw new b("`versionKey` must be falsy or string, got `" + u(t4.versionKey) + "`");
        if (typeof t4.read == "string" ? t4.read = P(t4.read) : Array.isArray(t4.read) && typeof t4.read[0] == "string" && (t4.read = { mode: P(t4.read[0]), tags: t4.read[1] }), t4.optimisticConcurrency && !t4.versionKey)
          throw new b("Must set `versionKey` if using `optimisticConcurrency`");
        return t4;
      }, V.prototype.discriminator = function(t4, e3, r3) {
        return this._applyDiscriminators = this._applyDiscriminators || new Map, this._applyDiscriminators.set(t4, { schema: e3, options: r3 }), this;
      }, V.prototype._defaultToObjectOptions = function(t4) {
        var e3 = t4 ? "toJSON" : "toObject";
        if (this._defaultToObjectOptionsMap && this._defaultToObjectOptionsMap[e3])
          return this._defaultToObjectOptionsMap[e3];
        var r3 = this.base && this.base.options && this.base.options[e3] || {}, n2 = this.options[e3] || {}, o2 = Object.assign({}, r3, n2);
        return this._defaultToObjectOptionsMap = this._defaultToObjectOptionsMap || {}, this._defaultToObjectOptionsMap[e3] = o2, o2;
      }, V.prototype.encryptionType = function(t4) {
        if (arguments.length === 0)
          return this.options.encryptionType;
        if (typeof t4 != "string" && t4 !== null)
          throw new Error("invalid `encryptionType`: ${encryptionType}");
        this.options.encryptionType = t4;
      }, V.prototype.add = function(t4, e3) {
        if (t4 instanceof V || t4 != null && t4.instanceOfSchema)
          return x(this, t4), this;
        if (t4._id === false && e3 == null && (this.options._id = false), (e3 = e3 || "") === "__proto__." || e3 === "constructor." || e3 === "prototype.")
          return this;
        for (var r3 = Object.keys(t4), n2 = this.options.typeKey, o2 = 0, i2 = r3;o2 < i2.length; o2++) {
          var s2 = i2[o2];
          if (!I.specialProperties.has(s2)) {
            var l2 = e3 + s2, f2 = t4[s2];
            if (f2 == null)
              throw new TypeError("Invalid value for schema path `" + l2 + '`, got value "' + f2 + '"');
            if (s2 !== "_id" || f2 !== false) {
              var p2 = false;
              if (typeof f2 == "string" && (p2 = (this.base != null ? this.base.Schema.Types : V.Types)[f2.charAt(0).toUpperCase() + f2.substring(1)] != null), s2 !== "_id" && (u(f2) !== "object" && typeof f2 != "function" && !p2 || f2 == null))
                throw new TypeError("Invalid schema configuration: `".concat(f2, "` is not ") + "a valid type at path `".concat(s2, "`. See ") + "https://bit.ly/mongoose-schematypes for a list of valid schema types.");
              if (f2 instanceof _ || (f2.constructor && f2.constructor.name || null) === "VirtualType")
                this.virtual(f2);
              else {
                if (Array.isArray(f2) && f2.length === 1 && f2[0] == null)
                  throw new TypeError("Invalid value for schema Array path `" + l2 + '`, got value "' + f2[0] + '"');
                if (C(f2) || f2 instanceof v)
                  if (Object.keys(f2).length < 1)
                    e3 && (this.nested[e3.substring(0, e3.length - 1)] = true), this.path(l2, f2);
                  else if (!f2[n2] || n2 === "type" && C(f2.type) && f2.type.type)
                    this.nested[l2] = true, this.add(f2, l2 + ".");
                  else {
                    var h2 = f2[n2];
                    if (C(h2) && Object.keys(h2).length > 0) {
                      e3 && (this.nested[e3.substring(0, e3.length - 1)] = true);
                      var y2 = {};
                      this._userProvidedOptions.typeKey && (y2.typeKey = this._userProvidedOptions.typeKey), this._userProvidedOptions.strict != null && (y2.strict = this._userProvidedOptions.strict), this._userProvidedOptions.toObject != null && (y2.toObject = I.omit(this._userProvidedOptions.toObject, ["transform"])), this._userProvidedOptions.toJSON != null && (y2.toJSON = I.omit(this._userProvidedOptions.toJSON, ["transform"]));
                      var d2 = new V(h2, y2);
                      d2.$implicitlyCreated = true;
                      var b2 = Object.assign({}, f2, a({}, n2, d2));
                      this.path(e3 + s2, b2);
                    } else if (e3 && (this.nested[e3.substring(0, e3.length - 1)] = true), this.path(e3 + s2, f2), f2 != null && !f2.instanceOfSchema && I.isPOJO(f2.discriminators)) {
                      var m2 = this.path(e3 + s2);
                      for (var g2 in f2.discriminators)
                        m2.discriminator(g2, f2.discriminators[g2]);
                    }
                  }
                else if (e3 && (this.nested[e3.substring(0, e3.length - 1)] = true), this.path(e3 + s2, f2), f2[0] != null && !f2[0].instanceOfSchema && I.isPOJO(f2[0].discriminators)) {
                  var w2 = this.path(e3 + s2);
                  for (var O2 in f2[0].discriminators)
                    w2.discriminator(O2, f2[0].discriminators[O2]);
                }
                if (f2.instanceOfSchema && f2.encryptionType() != null) {
                  if (this.encryptionType() != f2.encryptionType())
                    throw new Error("encryptionType of a nested schema must match the encryption type of the parent schema.");
                  for (var S2 = 0, $2 = Object.entries(f2.encryptedFields);S2 < $2.length; S2++) {
                    var j2 = c($2[S2], 2), P2 = j2[0], A2 = j2[1], E2 = l2 + "." + P2;
                    this._addEncryptedField(E2, A2);
                  }
                } else if (u(f2) === "object" && "encrypt" in f2) {
                  var T2 = f2.encrypt;
                  if (this.encryptionType() == null)
                    throw new Error("encryptionType must be provided");
                  this._addEncryptedField(l2, T2);
                } else
                  this._removeEncryptedField(l2);
              }
            }
          }
        }
        var k2 = Object.fromEntries(Object.entries(t4).map(function(t5) {
          var r4 = c(t5, 1)[0];
          return [e3 + r4, null];
        }));
        return q(this, k2), this;
      }, V.prototype._addEncryptedField = function(t4, e3) {
        if (this.path(t4).autoEncryptionType() == null)
          throw new Error("Invalid BSON type for FLE field: '".concat(t4, "'"));
        this.encryptedFields[t4] = O(e3);
      }, V.prototype._removeEncryptedField = function(t4) {
        delete this.encryptedFields[t4];
      }, V.prototype._hasEncryptedFields = function() {
        return Object.keys(this.encryptedFields).length > 0;
      }, V.prototype._hasEncryptedField = function(t4) {
        return t4 in this.encryptedFields;
      }, V.prototype._buildEncryptedFields = function() {
        var t4 = this;
        return { fields: Object.entries(this.encryptedFields).map(function(e3) {
          var r3 = c(e3, 2), n2 = r3[0], o2 = r3[1];
          return s({ path: n2, bsonType: t4.path(n2).autoEncryptionType() }, o2);
        }) };
      }, V.prototype._buildSchemaMap = function() {
        var t4 = this;
        return { bsonType: "object", properties: Object.entries(this.encryptedFields).reduce(function(e3, r3) {
          var n2 = c(r3, 2), o2 = n2[0], i2 = n2[1], a2 = t4.path(o2).autoEncryptionType();
          return function(t5, e4, r4) {
            for (var n3 = 0, o3 = t5[n3];n3 < t5.length - 1; o3 = t5[++n3])
              e4[o3] = e4[o3] == null ? { bsonType: "object", properties: {} } : e4[o3], e4 = e4[o3].properties;
            e4[o3] = r4;
          }(o2.split("."), e3, { encrypt: s(s({}, i2), {}, { bsonType: a2 }) }), e3;
        }, {}) };
      }, V.prototype.alias = function(t4, e3) {
        return q(this, a({}, t4, e3)), this;
      }, V.prototype.removeIndex = function(t4) {
        if (arguments.length > 1)
          throw new Error("removeIndex() takes only 1 argument");
        if (u(t4) !== "object" && typeof t4 != "string")
          throw new Error("removeIndex() may only take either an object or a string as an argument");
        if (u(t4) === "object")
          for (var e3 = this._indexes.length - 1;e3 >= 0; --e3)
            E(this._indexes[e3][0], t4) && this._indexes.splice(e3, 1);
        else
          for (var r3 = this._indexes.length - 1;r3 >= 0; --r3)
            this._indexes[r3][1] != null && this._indexes[r3][1].name === t4 && this._indexes.splice(r3, 1);
        return this;
      }, V.prototype.clearIndexes = function() {
        return this._indexes.length = 0, this;
      }, V.prototype.searchIndex = function(t4) {
        return this._searchIndexes.push(t4), this;
      }, V.reserved = Object.create(null), V.prototype.reserved = V.reserved;
      var J = V.reserved;
      function z(t4) {
        return /\.\d+/.test(t4) ? t4.replace(/\.\d+\./g, ".$.").replace(/\.\d+$/, ".$") : t4;
      }
      function K(t4, e3) {
        if (t4.mapPaths.length === 0)
          return null;
        var r3, n2 = l(t4.mapPaths);
        try {
          for (n2.s();!(r3 = n2.n()).done; ) {
            var o2 = r3.value, i2 = o2.path.replace(/\.\$\*/g, "");
            if (e3 === i2 || e3.startsWith(i2 + ".") && e3.slice(i2.length + 1).indexOf(".") === -1)
              return o2;
            if (o2.schema && e3.startsWith(i2 + ".")) {
              var s2 = e3.slice(i2.length + 1);
              return s2 = s2.slice(s2.indexOf(".") + 1), o2.schema.paths[s2];
            }
            if (o2.$isSchemaMap && e3.startsWith(i2 + ".")) {
              var a2 = e3.slice(i2.length + 1);
              a2 = a2.slice(a2.indexOf(".") + 1);
              var u2 = o2.$__schemaType._presplitPath;
              if (a2.indexOf(".") === -1 && u2[u2.length - 1] === "$*")
                return o2.$__schemaType;
              if (a2.indexOf(".") !== -1 && o2.$__schemaType.schema && u2[u2.length - 1] === "$*")
                return o2.$__schemaType.schema.path(a2.slice(a2.indexOf(".") + 1));
            }
          }
        } catch (t5) {
          n2.e(t5);
        } finally {
          n2.f();
        }
        return null;
      }
      function H(t4, e3, r3) {
        var n2 = e3.split(/\.(\d+)\.|\.(\d+)$/).filter(Boolean);
        if (n2.length < 2)
          return t4.paths.hasOwnProperty(n2[0]) ? t4.paths[n2[0]] : "adhocOrUndefined";
        var o2 = t4.path(n2[0]), i2 = false;
        if (!o2)
          return "adhocOrUndefined";
        for (var s2 = n2.length - 1, a2 = 1;a2 < n2.length; ++a2) {
          i2 = false;
          var u2 = n2[a2];
          if (a2 === s2 && o2 && !/\D/.test(u2)) {
            o2 = o2.$isMongooseDocumentArray ? o2.$embeddedSchemaType : o2 instanceof h.Array ? o2.caster : undefined;
            break;
          }
          if (/\D/.test(u2)) {
            if (!o2 || !o2.schema) {
              o2 = undefined;
              break;
            }
            i2 = o2.schema.pathType(u2) === "nested", o2 = o2.schema.path(u2);
          } else
            o2 instanceof h.Array && a2 !== s2 && (o2 = o2.caster);
        }
        return t4.subpaths[r3] = o2, o2 ? "real" : i2 ? "nested" : "adhocOrUndefined";
      }
      function W(t4, e3) {
        var r3, n2 = l(t4.childSchemas);
        try {
          for (n2.s();!(r3 = n2.n()).done; ) {
            var o2 = r3.value.schema;
            o2.$implicitlyCreated && (Object.assign(o2.options, e3), W(o2, e3));
          }
        } catch (t5) {
          n2.e(t5);
        } finally {
          n2.f();
        }
      }
      J.prototype = J.emit = J.listeners = J.removeListener = J.collection = J.errors = J.get = J.init = J.isModified = J.isNew = J.populated = J.remove = J.save = J.toObject = J.validate = 1, J.collection = 1, V.prototype.path = function(t4, e3) {
        if (e3 === undefined) {
          if (this.paths[t4] != null)
            return this.paths[t4];
          var r3 = z(t4), n2 = function(t5, e4, r4) {
            if (t5.paths.hasOwnProperty(e4))
              return t5.paths[e4];
            if (t5.subpaths.hasOwnProperty(r4)) {
              var n3 = t5.subpaths[r4];
              if (n3 === "nested")
                return;
              return n3;
            }
            if (t5.singleNestedPaths.hasOwnProperty(r4) && u(t5.singleNestedPaths[r4]) === "object") {
              var o3 = t5.singleNestedPaths[r4];
              if (o3 === "nested")
                return;
              return o3;
            }
            return null;
          }(this, t4, r3);
          if (n2 != null)
            return n2;
          var o2 = K(this, t4);
          return o2 != null ? o2 : (n2 = this.hasMixedParent(r3)) != null ? n2 : M.test(t4) ? function(t5, e4, r4) {
            return H(t5, e4, r4), t5.subpaths[r4];
          }(this, t4, r3) : undefined;
        }
        var i2 = t4.split(".")[0];
        if (J[i2] && !this.options.suppressReservedKeysWarning) {
          var s2 = "`".concat(i2, "` is a reserved schema pathname and may break some functionality. ") + "You are allowed to use it, but use at your own risk. To disable this warning pass `suppressReservedKeysWarning` as a schema option.";
          I.warn(s2);
        }
        u(e3) === "object" && I.hasUserDefinedProperty(e3, "ref") && B(e3.ref, t4);
        var a2, c2 = t4.split(/\./), f2 = c2.pop(), p2 = this.tree, h2 = "", y2 = l(c2);
        try {
          for (y2.s();!(a2 = y2.n()).done; ) {
            var d2 = a2.value;
            if (I.specialProperties.has(d2))
              throw new Error("Cannot set special property `" + d2 + "` on a schema");
            if (h2 = h2 += (h2.length > 0 ? "." : "") + d2, p2[d2] || (this.nested[h2] = true, p2[d2] = {}), u(p2[d2]) !== "object") {
              var b2 = "Cannot set nested path `" + t4 + "`. Parent path `" + h2 + "` already set to type " + p2[d2].name + ".";
              throw new Error(b2);
            }
            p2 = p2[d2];
          }
        } catch (t5) {
          y2.e(t5);
        } finally {
          y2.f();
        }
        p2[f2] = O(e3), this.paths[t4] = this.interpretAsType(t4, e3, this.options);
        var v2 = this.paths[t4];
        if (this.childSchemas = this.childSchemas.filter(function(e4) {
          return e4.path !== t4;
        }), v2.$isSchemaMap) {
          var g2 = t4 + ".$*";
          this.paths[g2] = v2.$__schemaType, this.mapPaths.push(this.paths[g2]), v2.$__schemaType.$isSingleNested && this.childSchemas.push({ schema: v2.$__schemaType.schema, model: v2.$__schemaType.caster, path: t4 });
        }
        if (v2.$isSingleNested) {
          for (var _2 = 0, w2 = Object.keys(v2.schema.paths);_2 < w2.length; _2++) {
            var S2 = w2[_2];
            this.singleNestedPaths[t4 + "." + S2] = v2.schema.paths[S2];
          }
          for (var $2 = 0, j2 = Object.keys(v2.schema.singleNestedPaths);$2 < j2.length; $2++) {
            var P2 = j2[$2];
            this.singleNestedPaths[t4 + "." + P2] = v2.schema.singleNestedPaths[P2];
          }
          for (var A2 = 0, E2 = Object.keys(v2.schema.subpaths);A2 < E2.length; A2++) {
            var x2 = E2[A2];
            this.singleNestedPaths[t4 + "." + x2] = v2.schema.subpaths[x2];
          }
          for (var T2 = 0, k2 = Object.keys(v2.schema.nested);T2 < k2.length; T2++) {
            var N2 = k2[T2];
            this.singleNestedPaths[t4 + "." + N2] = "nested";
          }
          Object.defineProperty(v2.schema, "base", { configurable: true, enumerable: false, writable: false, value: this.base }), v2.caster.base = this.base, this.childSchemas.push({ schema: v2.schema, model: v2.caster, path: t4 });
        } else
          v2.$isMongooseDocumentArray && (Object.defineProperty(v2.schema, "base", { configurable: true, enumerable: false, writable: false, value: this.base }), v2.casterConstructor.base = this.base, this.childSchemas.push({ schema: v2.schema, model: v2.casterConstructor, path: t4 }));
        if (v2.$isMongooseArray && v2.caster instanceof m) {
          for (var D2 = t4, R2 = v2;R2.$isMongooseArray; )
            D2 += ".$", R2.$isMongooseDocumentArray ? (R2.$embeddedSchemaType._arrayPath = D2, R2.$embeddedSchemaType._arrayParentPath = t4, R2 = R2.$embeddedSchemaType) : (R2.caster._arrayPath = D2, R2.caster._arrayParentPath = t4, R2 = R2.caster), this.subpaths[D2] = R2;
          for (var U2 = 0, C2 = [];U2 < C2.length; U2++) {
            var F2 = C2[U2];
            this.subpaths[F2.path] = F2;
          }
        }
        if (v2.$isMongooseDocumentArray) {
          for (var L2 = 0, V2 = Object.keys(v2.schema.paths);L2 < V2.length; L2++) {
            var q2 = V2[L2], W2 = v2.schema.paths[q2];
            this.subpaths[t4 + "." + q2] = W2, u(W2) === "object" && W2 != null && W2.$parentSchemaDocArray == null && (W2.$parentSchemaDocArray = v2);
          }
          for (var G2 = 0, Q2 = Object.keys(v2.schema.subpaths);G2 < Q2.length; G2++) {
            var Y2 = Q2[G2], Z = v2.schema.subpaths[Y2];
            this.subpaths[t4 + "." + Y2] = Z, u(Z) === "object" && Z != null && Z.$parentSchemaDocArray == null && (Z.$parentSchemaDocArray = v2);
          }
          for (var X = 0, tt = Object.keys(v2.schema.singleNestedPaths);X < tt.length; X++) {
            var et = tt[X], rt = v2.schema.singleNestedPaths[et];
            this.subpaths[t4 + "." + et] = rt, u(rt) === "object" && rt != null && rt.$parentSchemaDocArray == null && (rt.$parentSchemaDocArray = v2);
          }
        }
        return this;
      }, V.prototype._gatherChildSchemas = function() {
        for (var t4 = [], e3 = 0, r3 = Object.keys(this.paths);e3 < r3.length; e3++) {
          var n2 = r3[e3];
          if (typeof n2 == "string") {
            var o2 = this.paths[n2];
            o2.$isMongooseDocumentArray || o2.$isSingleNested ? t4.push({ schema: o2.schema, model: o2.caster, path: n2 }) : o2.$isSchemaMap && o2.$__schemaType.$isSingleNested && t4.push({ schema: o2.$__schemaType.schema, model: o2.$__schemaType.caster, path: n2 });
          }
        }
        return this.childSchemas = t4, t4;
      }, Object.defineProperty(V.prototype, "base", { configurable: true, enumerable: false, writable: true, value: null }), V.prototype.interpretAsType = function(t4, e3, o2) {
        if (e3 instanceof m) {
          if (e3.path === t4)
            return e3;
          var i2 = e3.clone();
          return i2.path = t4, i2;
        }
        var s2 = this.base != null ? this.base.Schema.Types : V.Types, c2 = this.base != null ? this.base.Types : r2(9600);
        if (!(I.isPOJO(e3) || e3 instanceof v) && I.getFunctionName(e3.constructor) !== "Object") {
          var l2 = e3;
          (e3 = {})[o2.typeKey] = l2;
        }
        var f2, p2 = e3[o2.typeKey] && (e3[o2.typeKey] instanceof Function || o2.typeKey !== "type" || !e3.type.type) ? e3[o2.typeKey] : {};
        if (p2 instanceof m) {
          if (p2.path === t4)
            return p2;
          var h2 = p2.clone();
          return h2.path = t4, h2;
        }
        if (I.isPOJO(p2) || p2 === "mixed")
          return new s2.Mixed(t4, e3);
        if (Array.isArray(p2) || p2 === Array || p2 === "array" || p2 === s2.Array) {
          var y2 = p2 === Array || p2 === "array" ? e3.cast || e3.of : p2[0];
          if (y2 && y2.instanceOfSchema) {
            if (!(y2 instanceof V)) {
              if (!this.options._isMerging)
                throw new TypeError("Schema for array path `" + t4 + "` is from a different copy of the Mongoose module. Please make sure you're using the same version of Mongoose everywhere with `npm list mongoose`. If you are still getting this error, please add `new Schema()` around the path: " + "".concat(t4, ": new Schema(...)"));
              y2 = new V(y2);
            }
            return new s2.DocumentArray(t4, y2, e3);
          }
          if (y2 && y2[o2.typeKey] && y2[o2.typeKey].instanceOfSchema) {
            if (!(y2[o2.typeKey] instanceof V)) {
              if (!this.options._isMerging)
                throw new TypeError("Schema for array path `" + t4 + "` is from a different copy of the Mongoose module. Please make sure you're using the same version of Mongoose everywhere with `npm list mongoose`. If you are still getting this error, please add `new Schema()` around the path: " + "".concat(t4, ": new Schema(...)"));
              y2[o2.typeKey] = new V(y2[o2.typeKey]);
            }
            return new s2.DocumentArray(t4, y2[o2.typeKey], e3, y2);
          }
          if (y2 !== undefined && (Array.isArray(y2) || y2.type === Array || y2.type == "Array"))
            return y2 && y2.type == "Array" && (y2.type = Array), new s2.Array(t4, this.interpretAsType(t4, y2, o2), e3);
          var d2 = y2 == null || !y2[o2.typeKey] || o2.typeKey === "type" && y2.type.type ? y2 : y2[o2.typeKey];
          if (typeof y2 == "string")
            y2 = s2[y2.charAt(0).toUpperCase() + y2.substring(1)];
          else if (I.isPOJO(d2)) {
            if (Object.keys(d2).length) {
              var g2 = { minimize: o2.minimize };
              o2.typeKey && (g2.typeKey = o2.typeKey), o2.hasOwnProperty("strict") && (g2.strict = o2.strict), o2.hasOwnProperty("strictQuery") && (g2.strictQuery = o2.strictQuery), o2.hasOwnProperty("toObject") && (g2.toObject = I.omit(o2.toObject, ["transform"])), o2.hasOwnProperty("toJSON") && (g2.toJSON = I.omit(o2.toJSON, ["transform"])), this._userProvidedOptions.hasOwnProperty("_id") ? g2._id = this._userProvidedOptions._id : V.Types.DocumentArray.defaultOptions._id != null && (g2._id = V.Types.DocumentArray.defaultOptions._id);
              var _2 = new V(d2, g2);
              return _2.$implicitlyCreated = true, new s2.DocumentArray(t4, _2, e3);
            }
            return new s2.Array(t4, s2.Mixed, e3);
          }
          if (y2) {
            if (p2 = !y2[o2.typeKey] || o2.typeKey === "type" && y2.type.type ? y2 : y2[o2.typeKey], Array.isArray(p2))
              return new s2.Array(t4, this.interpretAsType(t4, p2, o2), e3);
            if ((f2 = typeof p2 == "string" ? p2 : p2.schemaName || I.getFunctionName(p2)) === "ClockDate" && (f2 = "Date"), f2 === undefined)
              throw new TypeError("Invalid schema configuration: " + "Could not determine the embedded type for array `".concat(t4, "`. ") + "See https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.");
            if (!s2.hasOwnProperty(f2))
              throw new TypeError("Invalid schema configuration: " + "`".concat(f2, "` is not a valid type within the array `").concat(t4, "`.") + "See https://bit.ly/mongoose-schematypes for a list of valid schema types.");
          }
          return new s2.Array(t4, y2 || s2.Mixed, e3, o2);
        }
        if (p2 && p2.instanceOfSchema)
          return new s2.Subdocument(p2, t4, e3);
        if ((f2 = n.isBuffer(p2) ? "Buffer" : typeof p2 == "function" || u(p2) === "object" ? p2.schemaName || I.getFunctionName(p2) : p2 === c2.ObjectId ? "ObjectId" : p2 === c2.Decimal128 ? "Decimal128" : p2 == null ? "" + p2 : p2.toString()) && (f2 = f2.charAt(0).toUpperCase() + f2.substring(1)), f2 === "ObjectID" && (f2 = "ObjectId"), f2 === "ClockDate" && (f2 = "Date"), f2 === undefined)
          throw new TypeError("Invalid schema configuration: `".concat(t4, "` schematype definition is ") + "invalid. See https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.");
        if (s2[f2] == null)
          throw new TypeError("Invalid schema configuration: `".concat(f2, "` is not ") + "a valid type at path `".concat(t4, "`. See ") + "https://bit.ly/mongoose-schematypes for a list of valid schema types.");
        f2 === "Union" && (e3.parentSchema = this);
        var w2 = new s2[f2](t4, e3, o2);
        return w2.$isSchemaMap && function(t5, e4, r3, n2, o3) {
          var i3 = r3 + ".$*", s3 = { type: {} };
          I.hasUserDefinedProperty(n2, "of") && ((s3 = I.isPOJO(n2.of) && Object.keys(n2.of).length > 0 && !I.hasUserDefinedProperty(n2.of, t5.options.typeKey) ? a({}, t5.options.typeKey, new V(n2.of)) : I.isPOJO(n2.of) ? Object.assign({}, n2.of) : a({}, t5.options.typeKey, n2.of))[t5.options.typeKey] && s3[t5.options.typeKey].instanceOfSchema && s3[t5.options.typeKey].eachPath(function(t6, e5) {
            if (e5.options.select === true || e5.options.select === false)
              throw new b('Cannot use schema-level projections (`select: true` or `select: false`) within maps at path "' + r3 + "." + t6 + '"');
          }), I.hasUserDefinedProperty(n2, "ref") && (s3.ref = n2.ref)), e4.$__schemaType = t5.interpretAsType(i3, s3, o3);
        }(this, w2, t4, e3, o2), w2;
      }, V.prototype.eachPath = function(t4) {
        for (var e3 = Object.keys(this.paths), r3 = e3.length, n2 = 0;n2 < r3; ++n2)
          t4(e3[n2], this.paths[e3[n2]]);
        return this;
      }, V.prototype.requiredPaths = function(t4) {
        if (this._requiredpaths && !t4)
          return this._requiredpaths;
        for (var e3 = Object.keys(this.paths), r3 = e3.length, n2 = [];r3--; ) {
          var o2 = e3[r3];
          this.paths[o2].isRequired && n2.push(o2);
        }
        return this._requiredpaths = n2, this._requiredpaths;
      }, V.prototype.indexedPaths = function() {
        return this._indexedpaths || (this._indexedpaths = this.indexes()), this._indexedpaths;
      }, V.prototype.pathType = function(t4) {
        if (this.paths.hasOwnProperty(t4))
          return "real";
        if (this.virtuals.hasOwnProperty(t4))
          return "virtual";
        if (this.nested.hasOwnProperty(t4))
          return "nested";
        var e3 = z(t4);
        if (this.subpaths.hasOwnProperty(e3) || this.subpaths.hasOwnProperty(t4))
          return "real";
        var r3 = this.singleNestedPaths.hasOwnProperty(e3) || this.singleNestedPaths.hasOwnProperty(t4);
        return r3 ? r3 === "nested" ? "nested" : "real" : K(this, t4) != null ? "real" : /\.\d+\.|\.\d+$/.test(t4) ? H(this, t4, e3) : "adhocOrUndefined";
      }, V.prototype.hasMixedParent = function(t4) {
        var e3 = t4.split(/\./g);
        t4 = "";
        for (var r3 = 0;r3 < e3.length; ++r3)
          if (t4 = r3 > 0 ? t4 + "." + e3[r3] : e3[r3], this.paths.hasOwnProperty(t4) && this.paths[t4] instanceof h.Mixed)
            return this.paths[t4];
        return null;
      }, V.prototype.setupTimestamp = function(t4) {
        return N(this, t4);
      }, V.prototype.queue = function(t4, e3) {
        return this.callQueue.push([t4, e3]), this;
      }, V.prototype.pre = function(t4) {
        if (t4 instanceof RegExp) {
          var e3, r3 = Array.prototype.slice.call(arguments, 1), n2 = l(U);
          try {
            for (n2.s();!(e3 = n2.n()).done; ) {
              var o2 = e3.value;
              t4.test(o2) && this.pre.apply(this, [o2].concat(r3));
            }
          } catch (t5) {
            n2.e(t5);
          } finally {
            n2.f();
          }
          return this;
        }
        if (Array.isArray(t4)) {
          var i2, s2 = Array.prototype.slice.call(arguments, 1), a2 = l(t4);
          try {
            for (a2.s();!(i2 = a2.n()).done; ) {
              var u2 = i2.value;
              this.pre.apply(this, [u2].concat(s2));
            }
          } catch (t5) {
            a2.e(t5);
          } finally {
            a2.f();
          }
          return this;
        }
        return this.s.hooks.pre.apply(this.s.hooks, arguments), this;
      }, V.prototype.post = function(t4) {
        if (t4 instanceof RegExp) {
          var e3, r3 = Array.prototype.slice.call(arguments, 1), n2 = l(U);
          try {
            for (n2.s();!(e3 = n2.n()).done; ) {
              var o2 = e3.value;
              t4.test(o2) && this.post.apply(this, [o2].concat(r3));
            }
          } catch (t5) {
            n2.e(t5);
          } finally {
            n2.f();
          }
          return this;
        }
        if (Array.isArray(t4)) {
          var i2, s2 = Array.prototype.slice.call(arguments, 1), a2 = l(t4);
          try {
            for (a2.s();!(i2 = a2.n()).done; ) {
              var u2 = i2.value;
              this.post.apply(this, [u2].concat(s2));
            }
          } catch (t5) {
            a2.e(t5);
          } finally {
            a2.f();
          }
          return this;
        }
        return this.s.hooks.post.apply(this.s.hooks, arguments), this;
      }, V.prototype.plugin = function(t4, e3) {
        if (typeof t4 != "function")
          throw new Error('First param to `schema.plugin()` must be a function, got "' + u(t4) + '"');
        if (e3 && e3.deduplicate) {
          var r3, n2 = l(this.plugins);
          try {
            for (n2.s();!(r3 = n2.n()).done; )
              if (r3.value.fn === t4)
                return this;
          } catch (t5) {
            n2.e(t5);
          } finally {
            n2.f();
          }
        }
        return this.plugins.push({ fn: t4, opts: e3 }), t4(this, e3), this;
      }, V.prototype.method = function(t4, e3, r3) {
        if (typeof t4 != "string")
          for (var n2 in t4)
            this.methods[n2] = t4[n2], this.methodOptions[n2] = O(r3);
        else
          this.methods[t4] = e3, this.methodOptions[t4] = O(r3);
        return this;
      }, V.prototype.static = function(t4, e3) {
        if (typeof t4 != "string")
          for (var r3 in t4)
            this.statics[r3] = t4[r3];
        else
          this.statics[t4] = e3;
        return this;
      }, V.prototype.index = function(t4, e3) {
        for (var r3 in t4 || (t4 = {}), e3 || (e3 = {}), e3.expires && I.expires(e3), t4)
          this.aliases[r3] && (t4 = I.renameObjKey(t4, r3, this.aliases[r3]));
        for (var n2 = 0, o2 = Object.keys(t4);n2 < o2.length; n2++) {
          var i2 = o2[n2];
          t4[i2] === "ascending" || t4[i2] === "asc" ? t4[i2] = 1 : t4[i2] !== "descending" && t4[i2] !== "desc" || (t4[i2] = -1);
        }
        var s2, a2 = l(this.indexes());
        try {
          for (a2.s();!(s2 = a2.n()).done; ) {
            var u2 = s2.value;
            e3.name == null && u2[1].name == null && E(u2[0], t4) && I.warn("Duplicate schema index on ".concat(JSON.stringify(t4), ' found. This is often due to declaring an index using both "index: true" and "schema.index()". Please remove the duplicate index definition.'));
          }
        } catch (t5) {
          a2.e(t5);
        } finally {
          a2.f();
        }
        return this._indexes.push([t4, e3]), this;
      }, V.prototype.set = function(t4, e3, r3) {
        if (arguments.length === 1)
          return this.options[t4];
        switch (t4) {
          case "read":
            typeof e3 == "string" ? this.options[t4] = { mode: P(e3), tags: r3 } : Array.isArray(e3) && typeof e3[0] == "string" ? this.options[t4] = { mode: P(e3[0]), tags: e3[1] } : this.options[t4] = e3, this._userProvidedOptions[t4] = this.options[t4];
            break;
          case "timestamps":
            this.setupTimestamp(e3), this.options[t4] = e3, this._userProvidedOptions[t4] = this.options[t4];
            break;
          case "_id":
            this.options[t4] = e3, this._userProvidedOptions[t4] = this.options[t4], e3 && !this.paths._id ? w(this) : !e3 && this.paths._id != null && this.paths._id.auto && this.remove("_id");
            break;
          default:
            this.options[t4] = e3, this._userProvidedOptions[t4] = this.options[t4];
        }
        return t4 === "strict" && W(this, { strict: e3 }), t4 === "strictQuery" && W(this, { strictQuery: e3 }), t4 === "toObject" && (delete (e3 = s({}, e3)).transform, W(this, { toObject: e3 })), t4 === "toJSON" && (delete (e3 = s({}, e3)).transform, W(this, { toJSON: e3 })), this;
      }, V.prototype.get = function(t4) {
        return this.options[t4];
      };
      var G = "2d 2dsphere hashed text".split(" ");
      function Q(t4, e3) {
        var r3, n2 = e3.split("."), o2 = n2.pop(), i2 = t4.tree, s2 = l(n2);
        try {
          for (s2.s();!(r3 = s2.n()).done; )
            i2 = i2[r3.value];
        } catch (t5) {
          s2.e(t5);
        } finally {
          s2.f();
        }
        delete i2[o2];
      }
      function Y(t4) {
        return t4.startsWith("$[") && t4.endsWith("]");
      }
      Object.defineProperty(V, "indexTypes", { get: function() {
        return G;
      }, set: function() {
        throw new Error("Cannot overwrite Schema.indexTypes");
      } }), V.prototype.indexes = function() {
        return j(this);
      }, V.prototype.virtual = function(t4, e3) {
        if (t4 instanceof _ || $(t4) === "VirtualType")
          return this.virtual(t4.path, t4.options);
        if (e3 = new g(e3), I.hasUserDefinedProperty(e3, ["ref", "refPath"])) {
          if (e3.localField == null)
            throw new Error("Reference virtuals require `localField` option");
          if (e3.foreignField == null)
            throw new Error("Reference virtuals require `foreignField` option");
          var r3 = this.virtual(t4);
          r3.options = e3, this.pre("init", function(n3, o3) {
            if (T.has(t4, n3)) {
              var i3 = T.get(t4, n3);
              if (this.$$populatedVirtuals || (this.$$populatedVirtuals = {}), e3.justOne || e3.count ? this.$$populatedVirtuals[t4] = Array.isArray(i3) ? i3[0] : i3 : this.$$populatedVirtuals[t4] = Array.isArray(i3) ? i3 : i3 == null ? [] : [i3], o3 != null && o3.hydratedPopulatedDocs && !e3.count) {
                var s3 = r3._getModelNamesForPopulate(this), a3 = this.$$populatedVirtuals[t4];
                if (Array.isArray(a3) || a3.$__ || (s3 == null ? undefined : s3.length) !== 1) {
                  if (Array.isArray(a3) && (s3 == null ? undefined : s3.length) === 1) {
                    for (var u3 = this.db.model(s3[0]), c3 = 0;c3 < a3.length; ++c3)
                      a3[c3].$__ || (a3[c3] = u3.hydrate(a3[c3], null, { hydratedPopulatedDocs: true }));
                    var l3 = e3.foreignField;
                    this.$populated(t4, a3.map(function(t5) {
                      return t5 == null ? t5 : t5.get(typeof l3 == "function" ? l3.call(t5, t5) : l3);
                    }), { populateModelSymbol: u3 });
                  }
                } else {
                  var f2 = this.db.model(s3[0]);
                  this.$$populatedVirtuals[t4] = f2.hydrate(a3);
                }
              }
              T.unset(t4, n3);
            }
          }), r3.set(function(r4) {
            return this.$$populatedVirtuals || (this.$$populatedVirtuals = {}), k(this.$$populatedVirtuals, t4, r4, e3);
          }), typeof e3.get == "function" && r3.get(e3.get);
          for (var n2 = t4.split("."), o2 = n2[0], i2 = 0;i2 < n2.length - 1; ++i2)
            if (this.paths[o2] != null) {
              if (this.paths[o2].$isMongooseDocumentArray || this.paths[o2].$isSingleNested) {
                var s2 = n2.slice(i2 + 1).join(".");
                this.paths[o2].schema.virtual(s2, e3);
                break;
              }
              if (this.paths[o2].$isSchemaMap) {
                var a2 = n2.slice(i2 + 2).join(".");
                this.paths[o2].$__schemaType.schema.virtual(a2, e3);
                break;
              }
              o2 += "." + n2[i2 + 1];
            }
          return r3;
        }
        var u2 = this.virtuals, c2 = t4.split(".");
        if (this.pathType(t4) === "real")
          throw new Error('Virtual path "' + t4 + '" conflicts with a real path in the schema');
        if (u2[t4] = c2.reduce(function(r4, n3, o3) {
          return r4[n3] || (r4[n3] = o3 === c2.length - 1 ? new _(e3, t4) : {}), r4[n3];
        }, this.tree), e3 && e3.applyToArray && c2.length > 1) {
          var l2 = this.path(c2.slice(0, -1).join("."));
          if (l2 && l2.$isMongooseArray)
            return l2.virtual(c2[c2.length - 1], e3);
          throw new b('Path "'.concat(l2, '" is not an array'));
        }
        return u2[t4];
      }, V.prototype.virtualpath = function(t4) {
        return this.virtuals.hasOwnProperty(t4) ? this.virtuals[t4] : null;
      }, V.prototype.remove = function(t4) {
        return typeof t4 == "string" && (t4 = [t4]), Array.isArray(t4) && t4.forEach(function(t5) {
          if (this.path(t5) != null || this.nested[t5]) {
            if (this.nested[t5]) {
              var e3, r3 = l(Object.keys(this.paths).concat(Object.keys(this.nested)));
              try {
                for (r3.s();!(e3 = r3.n()).done; ) {
                  var n2 = e3.value;
                  n2.startsWith(t5 + ".") && (delete this.paths[n2], delete this.nested[n2], Q(this, n2));
                }
              } catch (t6) {
                r3.e(t6);
              } finally {
                r3.f();
              }
              return delete this.nested[t5], void Q(this, t5);
            }
            delete this.paths[t5], Q(this, t5), this._removeEncryptedField(t5);
          }
        }, this), this;
      }, V.prototype.removeVirtual = function(t4) {
        if (typeof t4 == "string" && (t4 = [t4]), Array.isArray(t4)) {
          var e3, r3 = l(t4);
          try {
            for (r3.s();!(e3 = r3.n()).done; ) {
              var n2 = e3.value;
              if (this.virtuals[n2] == null)
                throw new b('Attempting to remove virtual "'.concat(n2, '" that does not exist.'));
            }
          } catch (t5) {
            r3.e(t5);
          } finally {
            r3.f();
          }
          var o2, i2 = l(t4);
          try {
            for (i2.s();!(o2 = i2.n()).done; ) {
              var s2 = o2.value;
              delete this.paths[s2], delete this.virtuals[s2], s2.indexOf(".") !== -1 ? T.unset(s2, this.tree) : delete this.tree[s2];
            }
          } catch (t5) {
            i2.e(t5);
          } finally {
            i2.f();
          }
        }
        return this;
      }, V.prototype.loadClass = function(t4, e3) {
        return t4 === Object.prototype || t4 === Function.prototype || t4.prototype.hasOwnProperty("$isMongooseModelPrototype") || t4.prototype.hasOwnProperty("$isMongooseDocumentPrototype") || (this.loadClass(Object.getPrototypeOf(t4), e3), e3 || Object.getOwnPropertyNames(t4).forEach(function(e4) {
          if (!e4.match(/^(length|name|prototype|constructor|__proto__)$/)) {
            var r3 = Object.getOwnPropertyDescriptor(t4, e4);
            r3.hasOwnProperty("value") && this.static(e4, r3.value);
          }
        }, this), Object.getOwnPropertyNames(t4.prototype).forEach(function(r3) {
          if (!r3.match(/^(constructor)$/)) {
            var n2 = Object.getOwnPropertyDescriptor(t4.prototype, r3);
            e3 || typeof n2.value == "function" && this.method(r3, n2.value), typeof n2.get == "function" && (this.virtuals[r3] && (this.virtuals[r3].getters = []), this.virtual(r3).get(n2.get)), typeof n2.set == "function" && (this.virtuals[r3] && (this.virtuals[r3].setters = []), this.virtual(r3).set(n2.set));
          }
        }, this)), this;
      }, V.prototype._getSchema = function(t4) {
        var e3 = this.path(t4), r3 = [];
        if (e3)
          return e3.$fullPath = t4, e3;
        for (var n2 = t4.split("."), o2 = 0;o2 < n2.length; ++o2)
          (n2[o2] === "$" || Y(n2[o2])) && (n2[o2] = "0"), L.test(n2[o2]) && (n2[o2] = "$");
        return function t(e4, n3) {
          for (var o3, i2, s2 = e4.length + 1;s2--; )
            if (i2 = e4.slice(0, s2).join("."), o3 = n3.path(i2)) {
              if (r3.push(i2), o3.caster) {
                if (o3.caster instanceof h.Mixed)
                  return o3.caster.$fullPath = r3.join("."), o3.caster;
                if (s2 !== e4.length) {
                  if (s2 + 1 === e4.length && o3.$embeddedSchemaType && (e4[s2] === "$" || Y(e4[s2])))
                    return o3.$embeddedSchemaType;
                  if (o3.schema) {
                    var a2 = undefined;
                    return e4[s2] === "$" || Y(e4[s2]) ? s2 + 1 === e4.length ? o3.$embeddedSchemaType : ((a2 = t(e4.slice(s2 + 1), o3.schema)) && (a2.$parentSchemaDocArray = a2.$parentSchemaDocArray || (o3.schema.$isSingleNested ? null : o3)), a2) : ((a2 = t(e4.slice(s2), o3.schema)) && (a2.$parentSchemaDocArray = a2.$parentSchemaDocArray || (o3.schema.$isSingleNested ? null : o3)), a2);
                  }
                }
              } else if (o3.$isSchemaMap) {
                if (s2 >= e4.length)
                  return o3;
                if (s2 + 1 >= e4.length)
                  return o3.$__schemaType;
                if (o3.$__schemaType instanceof h.Mixed)
                  return o3.$__schemaType;
                if (o3.$__schemaType.schema != null)
                  return t(e4.slice(s2 + 1), o3.$__schemaType.schema);
              }
              return o3.$fullPath = r3.join("."), o3;
            }
        }(n2, this);
      }, V.prototype._getPathType = function(t4) {
        return this.path(t4) ? "real" : function t(e3, r3) {
          for (var n2, o2, i2 = e3.length + 1;i2--; ) {
            if (o2 = e3.slice(0, i2).join("."), n2 = r3.path(o2))
              return n2.caster ? n2.caster instanceof h.Mixed ? { schema: n2, pathType: "mixed" } : i2 !== e3.length && n2.schema ? e3[i2] === "$" || Y(e3[i2]) ? i2 === e3.length - 1 ? { schema: n2, pathType: "nested" } : t(e3.slice(i2 + 1), n2.schema) : t(e3.slice(i2), n2.schema) : { schema: n2, pathType: n2.$isSingleNested ? "nested" : "array" } : { schema: n2, pathType: "real" };
            if (i2 === e3.length && r3.nested[o2])
              return { schema: r3, pathType: "nested" };
          }
          return { schema: n2 || r3, pathType: "undefined" };
        }(t4.split("."), this);
      }, V.prototype._transformDuplicateKeyError = function(t4) {
        if (!this._duplicateKeyErrorMessagesByPath)
          return t4;
        if (t4.code !== 11000 && t4.code !== 11001)
          return t4;
        if (t4.keyPattern != null) {
          var e3 = t4.keyPattern, r3 = Object.keys(e3);
          if (r3.length !== 1)
            return t4;
          var n2 = r3[0];
          return this._duplicateKeyErrorMessagesByPath.hasOwnProperty(n2) ? new b(this._duplicateKeyErrorMessagesByPath[n2], { cause: t4 }) : t4;
        }
        return t4;
      }, V.prototype._preCompile = function() {
        this.plugin(A, { deduplicate: true });
      }, V.prototype.toJSONSchema = function(t4) {
        for (var e3, r3 = (e3 = t4 == null ? undefined : t4.useBsonType) !== null && e3 !== undefined && e3, n2 = r3 ? { required: [], properties: {} } : { type: "object", required: [], properties: {} }, i2 = 0, s2 = Object.keys(this.paths);i2 < s2.length; i2++) {
          var a2 = s2[i2], u2 = this.paths[a2];
          if (u2._presplitPath.indexOf("$*") === -1) {
            var c2 = n2;
            if (u2._presplitPath.length > 1)
              for (var l2 = 0;l2 < u2._presplitPath.length - 1; ++l2) {
                var f2 = u2._presplitPath[l2];
                c2.properties[f2] == null && (c2.properties[f2] = r3 ? { bsonType: ["object", "null"], properties: {} } : { type: ["object", "null"], properties: {} }), c2 = c2.properties[f2];
              }
            var p2 = u2._presplitPath[u2._presplitPath.length - 1], h2 = false;
            a2 === "_id" ? (c2.required || (c2.required = []), c2.required.push("_id"), h2 = true) : u2.options.required && typeof u2.options.required != "function" && (c2.required || (c2.required = []), c2.required.push(p2), h2 = true), c2.properties[p2] = u2.toJSONSchema(t4), u2.options.enum && (c2.properties[p2].enum = h2 ? u2.options.enum : [].concat(o(u2.options.enum), [null]));
          }
        }
        return n2.required.length === 0 && delete n2.required, n2;
      }, t3.exports = e2 = V, V.Types = h = r2(7953), e2.ObjectId = h.ObjectId;
    }, 7160: (t3, e2) => {
      e2.schemaMixedSymbol = Symbol.for("mongoose:schema_mixed"), e2.builtInMiddleware = Symbol.for("mongoose:built-in-middleware");
    }, 7219: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o(t4, e3) {
        for (var r3 = 0;r3 < e3.length; r3++) {
          var n2 = e3[r3];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t4, i(n2.key), n2);
        }
      }
      function i(t4) {
        var e3 = function(t5) {
          if (n(t5) != "object" || !t5)
            return t5;
          var e4 = t5[Symbol.toPrimitive];
          if (e4 !== undefined) {
            var r3 = e4.call(t5, "string");
            if (n(r3) != "object")
              return r3;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t5);
        }(t4);
        return n(e3) == "symbol" ? e3 : e3 + "";
      }
      function s() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (s = function() {
          return !!t4;
        })();
      }
      function a(t4) {
        return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, a(t4);
      }
      function u(t4, e3) {
        return u = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, u(t4, e3);
      }
      var c = r2(8213), l = r2(2900), f = r2(4070), p = r2(5497), h = function(t4) {
        function e3() {
          return function(t5, e4) {
            if (!(t5 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), function(t5, e4, r4) {
            return e4 = a(e4), function(t6, e5) {
              if (e5 && (n(e5) == "object" || typeof e5 == "function"))
                return e5;
              if (e5 !== undefined)
                throw new TypeError("Derived constructors may only return object or undefined");
              return function(t7) {
                if (t7 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t7;
              }(t6);
            }(t5, s() ? Reflect.construct(e4, r4 || [], a(t5).constructor) : e4.apply(t5, r4));
          }(this, e3, arguments);
        }
        return function(t5, e4) {
          if (typeof e4 != "function" && e4 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && u(t5, e4);
        }(e3, t4), r3 = e3, (i2 = [{ key: "assimilateError", value: function(t5) {
          var e4 = t5.reason, r4 = f(e4) && l(e4) && t5.message.indexOf("bad auth") === -1 && t5.message.indexOf("Authentication failed") === -1;
          for (var n2 in r4 ? this.message = "Could not connect to any servers in your MongoDB Atlas cluster. One common reason is that you're trying to access the database from an IP that isn't whitelisted. Make sure your current IP address is on your Atlas cluster's IP whitelist: https://www.mongodb.com/docs/atlas/security-whitelist/" : p(e4) ? this.message = "Mongoose is connecting with SSL enabled, but the server is not accepting SSL connections. Please ensure that the MongoDB server you are connecting to is configured to accept SSL connections. Learn more: https://mongoosejs.com/docs/tutorials/ssl.html" : this.message = t5.message, t5)
            n2 !== "name" && (this[n2] = t5[n2]);
          return this.cause = e4, this;
        } }]) && o(r3.prototype, i2), Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3, i2;
      }(c);
      Object.defineProperty(h.prototype, "name", { value: "MongooseServerSelectionError" }), t3.exports = h;
    }, 7236: (t3) => {
      function e2(t4) {
        return e2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      t3.exports = function(t4) {
        if (t4 == null || e2(t4) !== "object")
          return t4;
        if (Array.isArray(t4))
          for (var r2 = t4.length - 1;r2 >= 0; --r2)
            t4[r2] === undefined && t4.splice(r2, 1);
        for (var n = 0, o = Object.keys(t4);n < o.length; n++) {
          var i = o[n];
          t4[i] === undefined && delete t4[i];
        }
        return t4;
      };
    }, 7291: (t3, e2) => {
      function r2(t4) {
        return r2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, r2(t4);
      }
      var n = Symbol("mongoose#trustedSymbol");
      e2.trustedSymbol = n, e2.trusted = function(t4) {
        return t4 == null || r2(t4) !== "object" || (t4[n] = true), t4;
      };
    }, 7300: (t3) => {
      function e2(t4) {
        return e2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      t3.exports = function(t4) {
        return t4 == null || e2(t4) !== "object" || !("$meta" in t4) && !("$slice" in t4);
      };
    }, 7352: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var o = Object.getOwnPropertyDescriptors || function(t4) {
        for (var e3 = Object.keys(t4), r3 = {}, n2 = 0;n2 < e3.length; n2++)
          r3[e3[n2]] = Object.getOwnPropertyDescriptor(t4, e3[n2]);
        return r3;
      }, i = /%[sdj%]/g;
      e2.format = function(t4) {
        if (!g(t4)) {
          for (var e3 = [], r3 = 0;r3 < arguments.length; r3++)
            e3.push(c(arguments[r3]));
          return e3.join(" ");
        }
        r3 = 1;
        for (var n2 = arguments, o2 = n2.length, s2 = String(t4).replace(i, function(t5) {
          if (t5 === "%%")
            return "%";
          if (r3 >= o2)
            return t5;
          switch (t5) {
            case "%s":
              return String(n2[r3++]);
            case "%d":
              return Number(n2[r3++]);
            case "%j":
              try {
                return JSON.stringify(n2[r3++]);
              } catch (t6) {
                return "[Circular]";
              }
            default:
              return t5;
          }
        }), a2 = n2[r3];r3 < o2; a2 = n2[++r3])
          m(a2) || !O(a2) ? s2 += " " + a2 : s2 += " " + c(a2);
        return s2;
      }, e2.deprecate = function(t4, e3) {
        if ({ env: {} }.noDeprecation === true)
          return t4;
        var r3 = false;
        return function() {
          if (!r3) {
            if ({ env: {} }.throwDeprecation)
              throw new Error(e3);
            !{ env: {} }.traceDeprecation ? console.error(e3) : console.trace(e3), r3 = true;
          }
          return t4.apply(this, arguments);
        };
      };
      var s = {}, a = /^$/;
      if ({}.NODE_DEBUG) {
        var u = {}.NODE_DEBUG;
        u = u.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), a = new RegExp("^" + u + "$", "i");
      }
      function c(t4, r3) {
        var n2 = { seen: [], stylize: f };
        return arguments.length >= 3 && (n2.depth = arguments[2]), arguments.length >= 4 && (n2.colors = arguments[3]), b(r3) ? n2.showHidden = r3 : r3 && e2._extend(n2, r3), _(n2.showHidden) && (n2.showHidden = false), _(n2.depth) && (n2.depth = 2), _(n2.colors) && (n2.colors = false), _(n2.customInspect) && (n2.customInspect = true), n2.colors && (n2.stylize = l), p(n2, t4, n2.depth);
      }
      function l(t4, e3) {
        var r3 = c.styles[e3];
        return r3 ? "\x1B[" + c.colors[r3][0] + "m" + t4 + "\x1B[" + c.colors[r3][1] + "m" : t4;
      }
      function f(t4, e3) {
        return t4;
      }
      function p(t4, r3, n2) {
        if (t4.customInspect && r3 && j(r3.inspect) && r3.inspect !== e2.inspect && (!r3.constructor || r3.constructor.prototype !== r3)) {
          var o2 = r3.inspect(n2, t4);
          return g(o2) || (o2 = p(t4, o2, n2)), o2;
        }
        var i2 = function(t5, e3) {
          if (_(e3))
            return t5.stylize("undefined", "undefined");
          if (g(e3)) {
            var r4 = "'" + JSON.stringify(e3).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            return t5.stylize(r4, "string");
          }
          return v(e3) ? t5.stylize("" + e3, "number") : b(e3) ? t5.stylize("" + e3, "boolean") : m(e3) ? t5.stylize("null", "null") : undefined;
        }(t4, r3);
        if (i2)
          return i2;
        var s2 = Object.keys(r3), a2 = function(t5) {
          var e3 = {};
          return t5.forEach(function(t6, r4) {
            e3[t6] = true;
          }), e3;
        }(s2);
        if (t4.showHidden && (s2 = Object.getOwnPropertyNames(r3)), $(r3) && (s2.indexOf("message") >= 0 || s2.indexOf("description") >= 0))
          return h(r3);
        if (s2.length === 0) {
          if (j(r3)) {
            var u2 = r3.name ? ": " + r3.name : "";
            return t4.stylize("[Function" + u2 + "]", "special");
          }
          if (w(r3))
            return t4.stylize(RegExp.prototype.toString.call(r3), "regexp");
          if (S(r3))
            return t4.stylize(Date.prototype.toString.call(r3), "date");
          if ($(r3))
            return h(r3);
        }
        var c2, l2 = "", f2 = false, O2 = ["{", "}"];
        return d(r3) && (f2 = true, O2 = ["[", "]"]), j(r3) && (l2 = " [Function" + (r3.name ? ": " + r3.name : "") + "]"), w(r3) && (l2 = " " + RegExp.prototype.toString.call(r3)), S(r3) && (l2 = " " + Date.prototype.toUTCString.call(r3)), $(r3) && (l2 = " " + h(r3)), s2.length !== 0 || f2 && r3.length != 0 ? n2 < 0 ? w(r3) ? t4.stylize(RegExp.prototype.toString.call(r3), "regexp") : t4.stylize("[Object]", "special") : (t4.seen.push(r3), c2 = f2 ? function(t5, e3, r4, n3, o3) {
          for (var i3 = [], s3 = 0, a3 = e3.length;s3 < a3; ++s3)
            x(e3, String(s3)) ? i3.push(y(t5, e3, r4, n3, String(s3), true)) : i3.push("");
          return o3.forEach(function(o4) {
            o4.match(/^\d+$/) || i3.push(y(t5, e3, r4, n3, o4, true));
          }), i3;
        }(t4, r3, n2, a2, s2) : s2.map(function(e3) {
          return y(t4, r3, n2, a2, e3, f2);
        }), t4.seen.pop(), function(t5, e3, r4) {
          return t5.reduce(function(t6, e4) {
            return e4.indexOf(`
`), t6 + e4.replace(/\u001b\[\d\d?m/g, "").length + 1;
          }, 0) > 60 ? r4[0] + (e3 === "" ? "" : e3 + `
 `) + " " + t5.join(`,
  `) + " " + r4[1] : r4[0] + e3 + " " + t5.join(", ") + " " + r4[1];
        }(c2, l2, O2)) : O2[0] + l2 + O2[1];
      }
      function h(t4) {
        return "[" + Error.prototype.toString.call(t4) + "]";
      }
      function y(t4, e3, r3, n2, o2, i2) {
        var s2, a2, u2;
        if ((u2 = Object.getOwnPropertyDescriptor(e3, o2) || { value: e3[o2] }).get ? a2 = u2.set ? t4.stylize("[Getter/Setter]", "special") : t4.stylize("[Getter]", "special") : u2.set && (a2 = t4.stylize("[Setter]", "special")), x(n2, o2) || (s2 = "[" + o2 + "]"), a2 || (t4.seen.indexOf(u2.value) < 0 ? (a2 = m(r3) ? p(t4, u2.value, null) : p(t4, u2.value, r3 - 1)).indexOf(`
`) > -1 && (a2 = i2 ? a2.split(`
`).map(function(t5) {
          return "  " + t5;
        }).join(`
`).slice(2) : `
` + a2.split(`
`).map(function(t5) {
          return "   " + t5;
        }).join(`
`)) : a2 = t4.stylize("[Circular]", "special")), _(s2)) {
          if (i2 && o2.match(/^\d+$/))
            return a2;
          (s2 = JSON.stringify("" + o2)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (s2 = s2.slice(1, -1), s2 = t4.stylize(s2, "name")) : (s2 = s2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), s2 = t4.stylize(s2, "string"));
        }
        return s2 + ": " + a2;
      }
      function d(t4) {
        return Array.isArray(t4);
      }
      function b(t4) {
        return typeof t4 == "boolean";
      }
      function m(t4) {
        return t4 === null;
      }
      function v(t4) {
        return typeof t4 == "number";
      }
      function g(t4) {
        return typeof t4 == "string";
      }
      function _(t4) {
        return t4 === undefined;
      }
      function w(t4) {
        return O(t4) && P(t4) === "[object RegExp]";
      }
      function O(t4) {
        return n(t4) === "object" && t4 !== null;
      }
      function S(t4) {
        return O(t4) && P(t4) === "[object Date]";
      }
      function $(t4) {
        return O(t4) && (P(t4) === "[object Error]" || t4 instanceof Error);
      }
      function j(t4) {
        return typeof t4 == "function";
      }
      function P(t4) {
        return Object.prototype.toString.call(t4);
      }
      function A(t4) {
        return t4 < 10 ? "0" + t4.toString(10) : t4.toString(10);
      }
      e2.debuglog = function(t4) {
        if (t4 = t4.toUpperCase(), !s[t4])
          if (a.test(t4)) {
            var r3 = { env: {} }.pid;
            s[t4] = function() {
              var n2 = e2.format.apply(e2, arguments);
              console.error("%s %d: %s", t4, r3, n2);
            };
          } else
            s[t4] = function() {};
        return s[t4];
      }, e2.inspect = c, c.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, c.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, e2.types = r2(7595), e2.isArray = d, e2.isBoolean = b, e2.isNull = m, e2.isNullOrUndefined = function(t4) {
        return t4 == null;
      }, e2.isNumber = v, e2.isString = g, e2.isSymbol = function(t4) {
        return n(t4) === "symbol";
      }, e2.isUndefined = _, e2.isRegExp = w, e2.types.isRegExp = w, e2.isObject = O, e2.isDate = S, e2.types.isDate = S, e2.isError = $, e2.types.isNativeError = $, e2.isFunction = j, e2.isPrimitive = function(t4) {
        return t4 === null || typeof t4 == "boolean" || typeof t4 == "number" || typeof t4 == "string" || n(t4) === "symbol" || t4 === undefined;
      }, e2.isBuffer = r2(7944);
      var E = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      function x(t4, e3) {
        return Object.prototype.hasOwnProperty.call(t4, e3);
      }
      e2.log = function() {
        var t4, r3;
        console.log("%s - %s", (r3 = [A((t4 = new Date).getHours()), A(t4.getMinutes()), A(t4.getSeconds())].join(":"), [t4.getDate(), E[t4.getMonth()], r3].join(" ")), e2.format.apply(e2, arguments));
      }, e2.inherits = r2(1679), e2._extend = function(t4, e3) {
        if (!e3 || !O(e3))
          return t4;
        for (var r3 = Object.keys(e3), n2 = r3.length;n2--; )
          t4[r3[n2]] = e3[r3[n2]];
        return t4;
      };
      var T = typeof Symbol != "undefined" ? Symbol("util.promisify.custom") : undefined;
      function k(t4, e3) {
        if (!t4) {
          var r3 = new Error("Promise was rejected with a falsy value");
          r3.reason = t4, t4 = r3;
        }
        return e3(t4);
      }
      e2.promisify = function(t4) {
        if (typeof t4 != "function")
          throw new TypeError('The "original" argument must be of type Function');
        if (T && t4[T]) {
          var e3;
          if (typeof (e3 = t4[T]) != "function")
            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
          return Object.defineProperty(e3, T, { value: e3, enumerable: false, writable: false, configurable: true }), e3;
        }
        function e3() {
          for (var e4, r3, n2 = new Promise(function(t5, n3) {
            e4 = t5, r3 = n3;
          }), o2 = [], i2 = 0;i2 < arguments.length; i2++)
            o2.push(arguments[i2]);
          o2.push(function(t5, n3) {
            t5 ? r3(t5) : e4(n3);
          });
          try {
            t4.apply(this, o2);
          } catch (t5) {
            r3(t5);
          }
          return n2;
        }
        return Object.setPrototypeOf(e3, Object.getPrototypeOf(t4)), T && Object.defineProperty(e3, T, { value: e3, enumerable: false, writable: false, configurable: true }), Object.defineProperties(e3, o(t4));
      }, e2.promisify.custom = T, e2.callbackify = function(t4) {
        if (typeof t4 != "function")
          throw new TypeError('The "original" argument must be of type Function');
        function e3() {
          for (var e4 = [], r3 = 0;r3 < arguments.length; r3++)
            e4.push(arguments[r3]);
          var n2 = e4.pop();
          if (typeof n2 != "function")
            throw new TypeError("The last argument must be of type Function");
          var o2 = this, i2 = function() {
            return n2.apply(o2, arguments);
          };
          t4.apply(this, e4).then(function(t5) {
            ({ env: {} }).nextTick(i2.bind(null, null, t5));
          }, function(t5) {
            ({ env: {} }).nextTick(k.bind(null, t5, i2));
          });
        }
        return Object.setPrototypeOf(e3, Object.getPrototypeOf(t4)), Object.defineProperties(e3, o(t4)), e3;
      };
    }, 7425: (t3, e2, r2) => {
      var n = r2(2696);
      t3.exports = function(t4, e3) {
        if (t4 == null || t4.discriminators == null)
          return null;
        for (var r3 = 0, o = Object.keys(t4.discriminators);r3 < o.length; r3++) {
          var i = o[r3], s = t4.discriminators[i];
          if (s.discriminatorMapping != null && n(s.discriminatorMapping.value, e3))
            return s;
        }
        return null;
      };
    }, 7430: (t3, e2, r2) => {
      var n = r2(5832).hp;
      function o(t4) {
        return o = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, o(t4);
      }
      var i = r2(6353).Binary, s = r2(3305), a = r2(2497);
      r2(3672), r2(7352);
      function u(t4) {
        return t4 && o(t4) === "object" && !(t4 instanceof Date) && !s(t4, "ObjectId") && (!Array.isArray(t4) || t4.length !== 0) && !(t4 instanceof n) && !s(t4, "Decimal128") && !(t4 instanceof i);
      }
      e2.B = function t(e3, r3, o2, i2) {
        var s2, c = (s2 = e3 && a(e3) && !n.isBuffer(e3) ? Object.keys(e3.toObject({ transform: false, virtuals: false }) || {}) : Object.keys(e3 || {})).length, l = {};
        r3 = r3 ? r3 + "." : "";
        for (var f = 0;f < c; ++f) {
          var p = s2[f], h = e3[p];
          l[r3 + p] = h;
          var y = i2 && i2.path && i2.path(r3 + p), d = i2 && i2.nested && i2.nested[r3 + p];
          if (!y || y.instance !== "Mixed") {
            if (u(h)) {
              if (o2 && o2.skipArrays && Array.isArray(h))
                continue;
              var b = t(h, r3 + p, o2, i2);
              for (var m in b)
                l[m] = b[m];
              Array.isArray(h) && (l[r3 + p] = h);
            }
            if (d)
              for (var v = 0, g = Object.keys(i2.paths);v < g.length; v++) {
                var _ = g[v];
                _.startsWith(r3 + p + ".") && !l.hasOwnProperty(_) && (l[_] = undefined);
              }
          }
        }
        return l;
      };
    }, 7494: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (o = function() {
          return !!t4;
        })();
      }
      function i(t4) {
        return i = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, i(t4);
      }
      function s(t4, e3) {
        return s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s(t4, e3);
      }
      var a = function(t4) {
        function e3() {
          return function(t5, e4) {
            if (!(t5 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), function(t5, e4, r4) {
            return e4 = i(e4), function(t6, e5) {
              if (e5 && (n(e5) == "object" || typeof e5 == "function"))
                return e5;
              if (e5 !== undefined)
                throw new TypeError("Derived constructors may only return object or undefined");
              return function(t7) {
                if (t7 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t7;
              }(t6);
            }(t5, o() ? Reflect.construct(e4, r4 || [], i(t5).constructor) : e4.apply(t5, r4));
          }(this, e3, arguments);
        }
        return function(t5, e4) {
          if (typeof e4 != "function" && e4 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(8879)), u = r2(5761);
      Object.defineProperty(a.prototype, "_id", u), Object.defineProperty(a.prototype, "minimize", u), t3.exports = a;
    }, 7557: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o(t4, e3, r3) {
        return (e3 = function(t5) {
          var e4 = function(t6) {
            if (n(t6) != "object" || !t6)
              return t6;
            var e5 = t6[Symbol.toPrimitive];
            if (e5 !== undefined) {
              var r4 = e5.call(t6, "string");
              if (n(r4) != "object")
                return r4;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t6);
          }(t5);
          return n(e4) == "symbol" ? e4 : e4 + "";
        }(e3)) in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      var i = r2(8920), s = r2(7930).arrayAtomicsSymbol, a = r2(7930).arrayAtomicsBackupSymbol, u = r2(7930).arrayParentSymbol, c = r2(7930).arrayPathSymbol, l = r2(7930).arraySchemaSymbol, f = Array.prototype.push, p = /^\d+$/;
      t3.exports = function(t4, e3, r3, n2) {
        var h;
        if (Array.isArray(t4)) {
          var y = t4.length;
          if (y === 0)
            h = new Array;
          else if (y === 1)
            (h = new Array(1))[0] = t4[0];
          else if (y < 1e4)
            h = new Array, f.apply(h, t4);
          else {
            h = new Array;
            for (var d = 0;d < y; ++d)
              f.call(h, t4[d]);
          }
        } else
          h = [];
        var b = o(o(o(o(o(o(o(o({}, s, {}), a, undefined), c, e3), l, n2), u, undefined), "isMongooseArray", true), "isMongooseArrayProxy", true), "__array", h);
        t4 && t4[s] != null && (b[s] = t4[s]), r3 != null && r3.$__ && (b[u] = r3, b[l] = n2 || r3.schema.path(e3));
        var m = new Proxy(h, { get: function(t5, e4) {
          return b.hasOwnProperty(e4) ? b[e4] : i.hasOwnProperty(e4) ? i[e4] : n2 && n2.virtuals && n2.virtuals.hasOwnProperty(e4) ? n2.virtuals[e4].applyGetters(undefined, t5) : typeof e4 == "string" && p.test(e4) && (n2 == null ? undefined : n2.$embeddedSchemaType) != null ? n2.$embeddedSchemaType.applyGetters(h[e4], r3) : h[e4];
        }, set: function(t5, e4, r4) {
          return typeof e4 == "string" && p.test(e4) ? i.set.call(m, e4, r4, false) : b.hasOwnProperty(e4) ? b[e4] = r4 : n2 && n2.virtuals && n2.virtuals.hasOwnProperty(e4) ? n2.virtuals[e4].applySetters(r4, t5) : h[e4] = r4, true;
        } });
        return m;
      };
    }, 7591: (t3) => {
      var e2 = null;
      t3.exports.get = function() {
        return e2;
      }, t3.exports.set = function(t4) {
        e2 = t4;
      };
    }, 7595: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var o = r2(5899), i = r2(1905), s = r2(9834), a = r2(7911);
      function u(t4) {
        return t4.call.bind(t4);
      }
      var c = typeof BigInt != "undefined", l = typeof Symbol != "undefined", f = u(Object.prototype.toString), p = u(Number.prototype.valueOf), h = u(String.prototype.valueOf), y = u(Boolean.prototype.valueOf);
      if (c)
        var d = u(BigInt.prototype.valueOf);
      if (l)
        var b = u(Symbol.prototype.valueOf);
      function m(t4, e3) {
        if (n(t4) !== "object")
          return false;
        try {
          return e3(t4), true;
        } catch (t5) {
          return false;
        }
      }
      function v(t4) {
        return f(t4) === "[object Map]";
      }
      function g(t4) {
        return f(t4) === "[object Set]";
      }
      function _(t4) {
        return f(t4) === "[object WeakMap]";
      }
      function w(t4) {
        return f(t4) === "[object WeakSet]";
      }
      function O(t4) {
        return f(t4) === "[object ArrayBuffer]";
      }
      function S(t4) {
        return typeof ArrayBuffer != "undefined" && (O.working ? O(t4) : t4 instanceof ArrayBuffer);
      }
      function $(t4) {
        return f(t4) === "[object DataView]";
      }
      function j(t4) {
        return typeof DataView != "undefined" && ($.working ? $(t4) : t4 instanceof DataView);
      }
      e2.isArgumentsObject = o, e2.isGeneratorFunction = i, e2.isTypedArray = a, e2.isPromise = function(t4) {
        return typeof Promise != "undefined" && t4 instanceof Promise || t4 !== null && n(t4) === "object" && typeof t4.then == "function" && typeof t4.catch == "function";
      }, e2.isArrayBufferView = function(t4) {
        return typeof ArrayBuffer != "undefined" && ArrayBuffer.isView ? ArrayBuffer.isView(t4) : a(t4) || j(t4);
      }, e2.isUint8Array = function(t4) {
        return s(t4) === "Uint8Array";
      }, e2.isUint8ClampedArray = function(t4) {
        return s(t4) === "Uint8ClampedArray";
      }, e2.isUint16Array = function(t4) {
        return s(t4) === "Uint16Array";
      }, e2.isUint32Array = function(t4) {
        return s(t4) === "Uint32Array";
      }, e2.isInt8Array = function(t4) {
        return s(t4) === "Int8Array";
      }, e2.isInt16Array = function(t4) {
        return s(t4) === "Int16Array";
      }, e2.isInt32Array = function(t4) {
        return s(t4) === "Int32Array";
      }, e2.isFloat32Array = function(t4) {
        return s(t4) === "Float32Array";
      }, e2.isFloat64Array = function(t4) {
        return s(t4) === "Float64Array";
      }, e2.isBigInt64Array = function(t4) {
        return s(t4) === "BigInt64Array";
      }, e2.isBigUint64Array = function(t4) {
        return s(t4) === "BigUint64Array";
      }, v.working = typeof Map != "undefined" && v(new Map), e2.isMap = function(t4) {
        return typeof Map != "undefined" && (v.working ? v(t4) : t4 instanceof Map);
      }, g.working = typeof Set != "undefined" && g(new Set), e2.isSet = function(t4) {
        return typeof Set != "undefined" && (g.working ? g(t4) : t4 instanceof Set);
      }, _.working = typeof WeakMap != "undefined" && _(new WeakMap), e2.isWeakMap = function(t4) {
        return typeof WeakMap != "undefined" && (_.working ? _(t4) : t4 instanceof WeakMap);
      }, w.working = typeof WeakSet != "undefined" && w(new WeakSet), e2.isWeakSet = function(t4) {
        return w(t4);
      }, O.working = typeof ArrayBuffer != "undefined" && O(new ArrayBuffer), e2.isArrayBuffer = S, $.working = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined" && $(new DataView(new ArrayBuffer(1), 0, 1)), e2.isDataView = j;
      var P = typeof SharedArrayBuffer != "undefined" ? SharedArrayBuffer : undefined;
      function A(t4) {
        return f(t4) === "[object SharedArrayBuffer]";
      }
      function E(t4) {
        return P !== undefined && (A.working === undefined && (A.working = A(new P)), A.working ? A(t4) : t4 instanceof P);
      }
      function x(t4) {
        return m(t4, p);
      }
      function T(t4) {
        return m(t4, h);
      }
      function k(t4) {
        return m(t4, y);
      }
      function N(t4) {
        return c && m(t4, d);
      }
      function I(t4) {
        return l && m(t4, b);
      }
      e2.isSharedArrayBuffer = E, e2.isAsyncFunction = function(t4) {
        return f(t4) === "[object AsyncFunction]";
      }, e2.isMapIterator = function(t4) {
        return f(t4) === "[object Map Iterator]";
      }, e2.isSetIterator = function(t4) {
        return f(t4) === "[object Set Iterator]";
      }, e2.isGeneratorObject = function(t4) {
        return f(t4) === "[object Generator]";
      }, e2.isWebAssemblyCompiledModule = function(t4) {
        return f(t4) === "[object WebAssembly.Module]";
      }, e2.isNumberObject = x, e2.isStringObject = T, e2.isBooleanObject = k, e2.isBigIntObject = N, e2.isSymbolObject = I, e2.isBoxedPrimitive = function(t4) {
        return x(t4) || T(t4) || k(t4) || N(t4) || I(t4);
      }, e2.isAnyArrayBuffer = function(t4) {
        return typeof Uint8Array != "undefined" && (S(t4) || E(t4));
      }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(t4) {
        Object.defineProperty(e2, t4, { enumerable: false, value: function() {
          throw new Error(t4 + " is not supported in userland");
        } });
      });
    }, 7760: (t3, e2, r2) => {
      function n(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function o(t4) {
        for (var e3 = 1;e3 < arguments.length; e3++) {
          var r3 = arguments[e3] != null ? arguments[e3] : {};
          e3 % 2 ? n(Object(r3), true).forEach(function(e4) {
            i(t4, e4, r3[e4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : n(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      function i(t4, e3, r3) {
        return (e3 = function(t5) {
          var e4 = function(t6) {
            if (a(t6) != "object" || !t6)
              return t6;
            var e5 = t6[Symbol.toPrimitive];
            if (e5 !== undefined) {
              var r4 = e5.call(t6, "string");
              if (a(r4) != "object")
                return r4;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t6);
          }(t5);
          return a(e4) == "symbol" ? e4 : e4 + "";
        }(e3)) in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      function s(t4, e3) {
        (e3 == null || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = Array(e3);r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      function a(t4) {
        return a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, a(t4);
      }
      var u, c, l = r2(8499), f = r2(2555), p = r2(8213), h = r2(4592), y = r2(6426), d = y.CastError, b = r2(5022), m = r2(2069), v = r2(622), g = r2(2073), _ = r2(7982), w = r2(4450), O = r2(8260), S = r2(5110), $ = r2(7352), j = r2(8768), P = r2(5558).G, A = r2(4327), E = r2(9604), x = r2(1058), T = Symbol("mongoose#isNestedArray"), k = Object.freeze({});
      function N(t4, e3, n2, o2) {
        c || (c = r2(9600).Embedded);
        var i2, s2, a2 = "type";
        if (o2 && o2.typeKey && (a2 = o2.typeKey), this.schemaOptions = o2, e3) {
          var u2 = {};
          j.isPOJO(e3) && (e3[a2] ? (delete (u2 = w(e3))[a2], e3 = e3[a2]) : e3 = b), n2 != null && n2.ref != null && u2.ref == null && (u2.ref = n2.ref), e3 === Object && (e3 = b);
          var l2 = typeof e3 == "string" ? e3 : j.getFunctionName(e3), f2 = r2(7953), p2 = f2.hasOwnProperty(l2) ? f2[l2] : e3;
          if (this.casterConstructor = p2, this.casterConstructor instanceof N && (this.casterConstructor[T] = true), typeof p2 != "function" || p2.$isArraySubdocument || p2.$isSchemaMap)
            this.caster = p2, this.caster instanceof c || (this.caster.path = t4);
          else {
            var h2 = this.caster instanceof c ? null : t4;
            this.caster = new p2(h2, u2);
          }
          this.$embeddedSchemaType = this.caster;
        }
        if (this.$isMongooseArray = true, y.call(this, t4, n2, "Array"), this.defaultValue != null && (i2 = this.defaultValue, s2 = typeof i2 == "function"), !("defaultValue" in this) || this.defaultValue != null) {
          var d2 = function() {
            return s2 ? i2.call(this) : i2 != null ? [].concat(i2) : [];
          };
          d2.$runBeforeSetters = !s2, this.default(d2);
        }
      }
      N.schemaName = "Array", N.options = { castNonArrays: true }, N.defaultOptions = {}, N.set = y.set, N.setters = [], N.get = y.get, N.prototype = Object.create(y.prototype), N.prototype.constructor = N, N.prototype.OptionsConstructor = h, N._checkRequired = y.prototype.checkRequired, N.checkRequired = y.checkRequired, N.prototype.virtuals = null, N.prototype.checkRequired = function(t4, e3) {
        return a(t4) === "object" && y._isRef(this, t4, e3, true) ? !!t4 : (typeof this.constructor.checkRequired == "function" ? this.constructor.checkRequired() : N.checkRequired())(t4);
      }, N.prototype.enum = function() {
        for (var t4 = this;; ) {
          var e3 = t4 && t4.caster && t4.caster.instance;
          if (e3 !== "Array") {
            if (e3 !== "String" && e3 !== "Number")
              throw new Error("`enum` can only be set on an array of strings or numbers , not " + e3);
            break;
          }
          t4 = t4.caster;
        }
        var r3 = arguments;
        return !Array.isArray(arguments) && j.isObject(arguments) && (r3 = j.object.vals(r3)), t4.caster.enum.apply(t4.caster, r3), this;
      }, N.prototype.applyGetters = function(t4, e3) {
        return e3 != null && e3.$__ != null && e3.$populated(this.path) ? t4 : y.prototype.applyGetters.call(this, t4, e3);
      }, N.prototype._applySetters = function(t4, e3, r3, n2) {
        if (this.casterConstructor.$isMongooseArray && N.options.castNonArrays && !this[T]) {
          for (var o2 = 0, i2 = this;i2 != null && i2.$isMongooseArray && !i2.$isMongooseDocumentArray; )
            ++o2, i2 = i2.casterConstructor;
          if (t4 != null && t4.length !== 0) {
            var s2 = g(t4);
            if (s2.min === s2.max && s2.max < o2 && s2.containsNonArrayItem)
              for (var a2 = s2.max;a2 < o2; ++a2)
                t4 = [t4];
          }
        }
        return y.prototype._applySetters.call(this, t4, e3, r3, n2);
      }, N.prototype.cast = function(t4, e3, n2, o2, i2) {
        var s2, a2;
        if (u || (u = r2(9600).Array), Array.isArray(t4)) {
          if (!t4.length && e3) {
            var c2 = e3.schema.indexedPaths(), l2 = this.path;
            for (s2 = 0, a2 = c2.length;s2 < a2; ++s2) {
              var f2 = c2[s2][0][l2];
              if (f2 === "2dsphere" || f2 === "2d")
                return;
            }
            var p2 = this.path.endsWith(".coordinates") ? this.path.substring(0, this.path.lastIndexOf(".")) : null;
            if (p2 != null) {
              for (s2 = 0, a2 = c2.length;s2 < a2; ++s2)
                if (c2[s2][0][p2] === "2dsphere")
                  return;
            }
          }
          i2 = i2 || k;
          var h2 = j.isMongooseArray(t4) ? t4.__array : t4, y2 = i2.path || this.path;
          if (i2.arrayPathIndex != null && (y2 += "." + i2.arrayPathIndex), h2 = (t4 = u(h2, y2, e3, this)).__array, n2 && e3 != null && e3.$__ != null && e3.$populated(this.path))
            return t4;
          var m2 = this.caster, v2 = m2.$isMongooseArray;
          if (m2 && this.casterConstructor !== b)
            try {
              var g2 = h2.length;
              for (s2 = 0;s2 < g2; s2++) {
                var _2 = {};
                v2 && (i2.arrayPath != null || m2._arrayParentPath != null) && (_2.arrayPathIndex = s2), i2.hydratedPopulatedDocs && (_2.hydratedPopulatedDocs = i2.hydratedPopulatedDocs), h2[s2] = m2.applySetters(h2[s2], e3, n2, undefined, _2);
              }
            } catch (e4) {
              throw new d("[" + e4.kind + "]", $.inspect(t4), this.path + "." + s2, e4, this);
            }
          return t4;
        }
        var w2 = this.options.castNonArrays != null ? this.options.castNonArrays : N.options.castNonArrays;
        if (n2 || w2)
          return e3 && n2 && e3.markModified(this.path), this.cast([t4], e3, n2);
        throw new d("Array", $.inspect(t4), this.path, null, this);
      }, N.prototype._castForPopulate = function(t4, e3) {
        if (u || (u = r2(9600).Array), Array.isArray(t4)) {
          var n2, o2 = t4.__array ? t4.__array : t4, i2 = o2.length, s2 = this.caster;
          if (s2 && this.casterConstructor !== b)
            try {
              for (n2 = 0;n2 < i2; n2++) {
                var a2 = {};
                s2.$isMongooseArray && s2._arrayParentPath != null && (a2.arrayPathIndex = n2), o2[n2] = s2.cast(o2[n2], e3, false, undefined, a2);
              }
            } catch (e4) {
              throw new d("[" + e4.kind + "]", $.inspect(t4), this.path + "." + n2, e4, this);
            }
          return t4;
        }
        throw new d("Array", $.inspect(t4), this.path, null, this);
      }, N.prototype.$toObject = N.prototype.toObject, N.prototype.discriminator = function() {
        for (var t4, e3 = this;e3.$isMongooseArray && !e3.$isMongooseDocumentArray; )
          if ((e3 = e3.casterConstructor) == null || typeof e3 == "function")
            throw new p("You can only add an embedded discriminator on a document array, " + this.path + " is a plain array");
        return (t4 = e3).discriminator.apply(t4, arguments);
      }, N.prototype.clone = function() {
        var t4 = Object.assign({}, this.options), e3 = new this.constructor(this.path, this.caster, t4, this.schemaOptions);
        return e3.validators = this.validators.slice(), this.requiredValidator !== undefined && (e3.requiredValidator = this.requiredValidator), e3;
      }, N.prototype._castForQuery = function(t4, e3) {
        var r3 = this, n2 = this.casterConstructor;
        if (t4 && n2.discriminators && n2.schema && n2.schema.options && n2.schema.options.discriminatorKey)
          if (typeof t4[n2.schema.options.discriminatorKey] == "string" && n2.discriminators[t4[n2.schema.options.discriminatorKey]])
            n2 = n2.discriminators[t4[n2.schema.options.discriminatorKey]];
          else {
            var o2 = x(n2.discriminators, t4[n2.schema.options.discriminatorKey]);
            o2 && (n2 = o2);
          }
        var i2 = this.casterConstructor.prototype, s2 = i2 && i2.castForQuery, a2 = i2 && i2.cast, u2 = n2.castForQuery, c2 = this.caster;
        return Array.isArray(t4) ? (this.setters.reverse().forEach(function(e4) {
          t4 = e4.call(r3, t4, r3);
        }), t4 = t4.map(function(t5) {
          return j.isObject(t5) && t5.$elemMatch ? t5 : s2 ? t5 = s2.call(c2, null, t5, e3) : a2 ? t5 = a2.call(c2, t5) : u2 ? t5 = u2.call(c2, null, t5, e3) : t5 != null ? t5 = new n2(t5) : t5;
        })) : s2 ? t4 = s2.call(c2, null, t4, e3) : a2 ? t4 = a2.call(c2, t4) : u2 ? t4 = u2.call(c2, null, t4, e3) : t4 != null && (t4 = new n2(t4)), t4;
      }, N.prototype.castForQuery = function(t4, e3, r3) {
        var n2;
        if (t4 != null) {
          if (!(n2 = this.$conditionalHandlers[t4]))
            throw new Error("Can't use " + t4 + " with Array.");
          return n2.call(this, e3, r3);
        }
        return this._castForQuery(e3, r3);
      }, N.prototype.virtual = function(t4, e3) {
        if (t4 instanceof v || O(t4) === "VirtualType")
          return this.virtual(t4.path, t4.options);
        if (e3 = new m(e3), j.hasUserDefinedProperty(e3, ["ref", "refPath"]))
          throw new p("Cannot set populate virtual as a property of an array");
        var r3 = new v(e3, t4);
        return this.virtuals === null && (this.virtuals = {}), this.virtuals[t4] = r3, r3;
      };
      var I = N.prototype.$conditionalHandlers = {};
      function B(t4) {
        return function(e3, r3) {
          if (!Array.isArray(e3))
            throw new TypeError("conditional " + t4 + " requires an array");
          var n2, o2 = [], i2 = function(t5, e4) {
            var r4 = typeof Symbol != "undefined" && t5[Symbol.iterator] || t5["@@iterator"];
            if (!r4) {
              if (Array.isArray(t5) || (r4 = function(t6, e5) {
                if (t6) {
                  if (typeof t6 == "string")
                    return s(t6, e5);
                  var r5 = {}.toString.call(t6).slice(8, -1);
                  return r5 === "Object" && t6.constructor && (r5 = t6.constructor.name), r5 === "Map" || r5 === "Set" ? Array.from(t6) : r5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? s(t6, e5) : undefined;
                }
              }(t5)) || e4 && t5 && typeof t5.length == "number") {
                r4 && (t5 = r4);
                var n3 = 0, o3 = function() {};
                return { s: o3, n: function() {
                  return n3 >= t5.length ? { done: true } : { done: false, value: t5[n3++] };
                }, e: function(t6) {
                  throw t6;
                }, f: o3 };
              }
              throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            var i3, a3 = true, u3 = false;
            return { s: function() {
              r4 = r4.call(t5);
            }, n: function() {
              var t6 = r4.next();
              return a3 = t6.done, t6;
            }, e: function(t6) {
              u3 = true, i3 = t6;
            }, f: function() {
              try {
                a3 || r4.return == null || r4.return();
              } finally {
                if (u3)
                  throw i3;
              }
            } };
          }(e3);
          try {
            for (i2.s();!(n2 = i2.n()).done; ) {
              var a2, u2 = n2.value;
              o2.push(_((a2 = this.casterConstructor.schema) !== null && a2 !== undefined ? a2 : r3.schema, u2, null, this && this.$$context));
            }
          } catch (t5) {
            i2.e(t5);
          } finally {
            i2.f();
          }
          return o2;
        };
      }
      I.$all = function(t4, e3) {
        var r3 = this;
        return Array.isArray(t4) || (t4 = [t4]), t4 = t4.map(function(t5) {
          if (!j.isObject(t5))
            return t5;
          if (t5.$elemMatch != null)
            return { $elemMatch: _(r3.casterConstructor.schema, t5.$elemMatch, null, r3 && r3.$$context) };
          var e4 = {};
          return e4[r3.path] = t5, _(r3.casterConstructor.schema, e4, null, r3 && r3.$$context)[r3.path];
        }, this), this.castForQuery(null, t4, e3);
      }, I.$options = String, I.$elemMatch = function(t4, e3) {
        for (var r3 = Object.keys(t4), n2 = r3.length, o2 = 0;o2 < n2; ++o2) {
          var i2 = r3[o2], s2 = t4[i2];
          S(i2) && s2 != null && (t4[i2] = this.castForQuery(i2, s2, e3));
        }
        return t4;
      }, I.$geoIntersects = E.cast$geoIntersects, I.$or = B("$or"), I.$and = B("$and"), I.$nor = B("$nor"), I.$near = I.$nearSphere = E.cast$near, I.$within = I.$geoWithin = E.cast$within, I.$size = I.$minDistance = I.$maxDistance = P, I.$exists = l, I.$type = f, I.$eq = I.$gt = I.$gte = I.$lt = I.$lte = I.$not = I.$regex = I.$ne = N.prototype._castForQuery, I.$nin = y.prototype.$conditionalHandlers.$nin, I.$in = y.prototype.$conditionalHandlers.$in, N.prototype.toJSONSchema = function(t4) {
        var e3 = this.getEmbeddedSchemaType(), r3 = this.options.required && typeof this.options.required != "function";
        return o(o({}, A("array", "array", t4 == null ? undefined : t4.useBsonType, r3)), {}, { items: e3.toJSONSchema(t4) });
      }, N.prototype.autoEncryptionType = function() {
        return "array";
      }, t3.exports = N;
    }, 7768: (t3, e2, r2) => {
      var n = r2(2402);
      t3.exports = function(t4) {
        return t4 == null ? t4 : t4 === "" ? null : (typeof t4 != "string" && typeof t4 != "boolean" || (t4 = Number(t4)), n.ok(!isNaN(t4)), t4 instanceof Number ? t4.valueOf() : typeof t4 == "number" ? t4 : Array.isArray(t4) || typeof t4.valueOf != "function" ? t4.toString && !Array.isArray(t4) && t4.toString() == Number(t4) ? Number(t4) : void n.ok(false) : Number(t4.valueOf()));
      };
    }, 7834: (t3) => {
      function e2(t4) {
        return e2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      t3.exports = function(t4, r2, n, o) {
        return o.justOne || o.count ? (t4[r2] = Array.isArray(n) ? n[0] : n, e2(t4[r2]) !== "object" && (t4[r2] = o.count ? n : null)) : (t4[r2] = Array.isArray(n) ? n : n == null ? [] : [n], t4[r2] = t4[r2].filter(function(t5) {
          return t5 && e2(t5) === "object";
        })), t4[r2];
      };
    }, 7860: (t3) => {
      t3.exports = function(t4) {
        for (var e2 = [], r2 = "", n = "DEFAULT", o = 0;o < t4.length; ++o)
          n !== "IN_SQUARE_BRACKETS" || /\d/.test(t4[o]) || t4[o] === "]" || (n = "DEFAULT", r2 = e2[e2.length - 1] + "[" + r2, e2.splice(e2.length - 1, 1)), t4[o] === "[" ? (n !== "IMMEDIATELY_AFTER_SQUARE_BRACKETS" && (e2.push(r2), r2 = ""), n = "IN_SQUARE_BRACKETS") : t4[o] === "]" ? n === "IN_SQUARE_BRACKETS" ? (n = "IMMEDIATELY_AFTER_SQUARE_BRACKETS", e2.push(r2), r2 = "") : (n = "DEFAULT", r2 += t4[o]) : t4[o] === "." ? (n !== "IMMEDIATELY_AFTER_SQUARE_BRACKETS" && (e2.push(r2), r2 = ""), n = "DEFAULT") : r2 += t4[o];
        return n !== "IMMEDIATELY_AFTER_SQUARE_BRACKETS" && e2.push(r2), e2;
      };
    }, 7878: (t3, e2, r2) => {
      var n = r2(2273), o = r2(4183);
      t3.exports = function() {
        var t4 = o();
        return n(Number, { isNaN: t4 }, { isNaN: function() {
          return Number.isNaN !== t4;
        } }), t4;
      };
    }, 7910: (t3, e2, r2) => {
      var n = r2(1058);
      t3.exports = function(t4, e3, r3) {
        var o = t4.schema.options.discriminatorKey, i = e3 != null && e3[o];
        if (i == null && (i = r3), t4.discriminators && i != null)
          if (t4.discriminators[i])
            t4 = t4.discriminators[i];
          else {
            var s = n(t4.discriminators, i);
            s && (t4 = s);
          }
        return t4;
      };
    }, 7911: (t3, e2, r2) => {
      var n = r2(9834);
      t3.exports = function(t4) {
        return !!n(t4);
      };
    }, 7930: (t3, e2) => {
      e2.arrayAtomicsBackupSymbol = Symbol("mongoose#Array#atomicsBackup"), e2.arrayAtomicsSymbol = Symbol("mongoose#Array#_atomics"), e2.arrayParentSymbol = Symbol("mongoose#Array#_parent"), e2.arrayPathSymbol = Symbol("mongoose#Array#_path"), e2.arraySchemaSymbol = Symbol("mongoose#Array#_schema"), e2.documentArrayParent = Symbol("mongoose#documentArrayParent"), e2.documentIsSelected = Symbol("mongoose#Document#isSelected"), e2.documentIsModified = Symbol("mongoose#Document#isModified"), e2.documentModifiedPaths = Symbol("mongoose#Document#modifiedPaths"), e2.documentSchemaSymbol = Symbol("mongoose#Document#schema"), e2.getSymbol = Symbol("mongoose#Document#get"), e2.modelSymbol = Symbol("mongoose#Model"), e2.objectIdSymbol = Symbol("mongoose#ObjectId"), e2.populateModelSymbol = Symbol("mongoose#PopulateOptions#Model"), e2.schemaTypeSymbol = Symbol("mongoose#schemaType"), e2.sessionNewDocuments = Symbol("mongoose#ClientSession#newDocuments"), e2.scopeSymbol = Symbol("mongoose#Document#scope"), e2.validatorErrorSymbol = Symbol("mongoose#validatorError");
    }, 7944: (t3) => {
      function e2(t4) {
        return e2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      t3.exports = function(t4) {
        return t4 && e2(t4) === "object" && typeof t4.copy == "function" && typeof t4.fill == "function" && typeof t4.readUInt8 == "function";
      };
    }, 7953: (t3, e2, r2) => {
      e2.Array = r2(7760), e2.BigInt = r2(3318), e2.Boolean = r2(6413), e2.Buffer = r2(2307), e2.Date = r2(2345), e2.Decimal128 = e2.Decimal = r2(7045), e2.DocumentArray = r2(9123), e2.Double = r2(1732), e2.Int32 = r2(433), e2.Map = r2(6867), e2.Mixed = r2(5022), e2.Number = r2(3660), e2.ObjectId = r2(3091), e2.String = r2(8728), e2.Subdocument = r2(5098), e2.UUID = r2(2134), e2.Union = r2(8866), e2.Oid = e2.ObjectId, e2.Object = e2.Mixed, e2.Bool = e2.Boolean, e2.ObjectID = e2.ObjectId;
    }, 7982: (t3, e2, r2) => {
      function n(t4, e3) {
        var r3 = typeof Symbol != "undefined" && t4[Symbol.iterator] || t4["@@iterator"];
        if (!r3) {
          if (Array.isArray(t4) || (r3 = function(t5, e4) {
            if (t5) {
              if (typeof t5 == "string")
                return o(t5, e4);
              var r4 = {}.toString.call(t5).slice(8, -1);
              return r4 === "Object" && t5.constructor && (r4 = t5.constructor.name), r4 === "Map" || r4 === "Set" ? Array.from(t5) : r4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r4) ? o(t5, e4) : undefined;
            }
          }(t4)) || e3 && t4 && typeof t4.length == "number") {
            r3 && (t4 = r3);
            var n2 = 0, i2 = function() {};
            return { s: i2, n: function() {
              return n2 >= t4.length ? { done: true } : { done: false, value: t4[n2++] };
            }, e: function(t5) {
              throw t5;
            }, f: i2 };
          }
          throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        var s2, a2 = true, u2 = false;
        return { s: function() {
          r3 = r3.call(t4);
        }, n: function() {
          var t5 = r3.next();
          return a2 = t5.done, t5;
        }, e: function(t5) {
          u2 = true, s2 = t5;
        }, f: function() {
          try {
            a2 || r3.return == null || r3.return();
          } finally {
            if (u2)
              throw s2;
          }
        } };
      }
      function o(t4, e3) {
        (e3 == null || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = Array(e3);r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      function i(t4) {
        return i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, i(t4);
      }
      var s = r2(3609), a = r2(8995), u = r2(7953), c = r2(170), l = r2(1244), f = r2(9064), p = r2(3703), h = r2(7425), y = r2(5110), d = r2(7352), b = r2(608), m = r2(2497), v = r2(8768), g = ["Polygon", "MultiPolygon"];
      function _(t4, e3, r3) {
        if (Array.isArray(t4))
          t4.forEach(function(n3, o3) {
            if (Array.isArray(n3) || b(n3))
              return _(n3, e3, r3);
            t4[o3] = e3.castForQuery(null, n3, r3);
          });
        else
          for (var n2 = Object.keys(t4), o2 = n2.length;o2--; ) {
            var i2 = n2[o2], s2 = t4[i2];
            Array.isArray(s2) || b(s2) ? (_(s2, e3, r3), t4[i2] = s2) : t4[i2] = e3.castForQuery({ val: s2, context: r3 });
          }
      }
      function w(t4, e3, r3, n2) {
        if ("strictQuery" in t4)
          return t4.strictQuery;
        if ("strictQuery" in e3)
          return e3.strictQuery;
        var o2 = n2 && n2.mongooseCollection && n2.mongooseCollection.conn && n2.mongooseCollection.conn.base && n2.mongooseCollection.conn.base.options;
        return o2 && "strictQuery" in o2 ? o2.strictQuery : r3.strictQuery;
      }
      t3.exports = function t(e3, r3, o2, O) {
        if (Array.isArray(r3))
          throw new Error("Query filter must be an object, got an array ", d.inspect(r3));
        if (r3 == null)
          return r3;
        e3 != null && e3.discriminators != null && r3[e3.options.discriminatorKey] != null && (e3 = h(e3, r3[e3.options.discriminatorKey]) || e3);
        var S, $, j, P, A, E, x = Object.keys(r3), T = x.length;
        for (o2 = o2 || {};T--; )
          if (E = r3[P = x[T]], P === "$or" || P === "$nor" || P === "$and") {
            if (!Array.isArray(E))
              throw new s("Array", E, P);
            for (var k = E.length - 1;k >= 0; k--) {
              if (E[k] == null || i(E[k]) !== "object")
                throw new s("Object", E[k], P + "." + k);
              var N = Object.keys(E[k]).length, I = E[k][e3.options.discriminatorKey];
              if (I == null)
                E[k] = t(e3, E[k], o2, O);
              else {
                var B = h(O.schema, I);
                E[k] = t(B || e3, E[k], o2, O);
              }
              Object.keys(E[k]).length === 0 && N !== 0 && E.splice(k, 1);
            }
            E.length === 0 && delete r3[P];
          } else {
            if (P === "$where") {
              if ((A = i(E)) !== "string" && A !== "function")
                throw new Error("Must have a string or function for $where");
              A === "function" && (r3[P] = E.toString());
              continue;
            }
            if (P === "$expr") {
              E = c(E, e3);
              continue;
            }
            if (P === "$elemMatch")
              E = t(e3, E, o2, O);
            else if (P === "$text")
              E = f(E, P);
            else if (P !== "$comment" || e3.paths.hasOwnProperty("$comment")) {
              if (!e3)
                continue;
              if (!($ = e3.path(P)))
                for (var M = P.split("."), D = M.length;D--; ) {
                  var R = M.slice(0, D).join("."), U = M.slice(D).join("."), C = e3.path(R), F = C && C.schema && C.schema.options && C.schema.options.discriminatorKey;
                  if (C != null && (C.schema && C.schema.discriminators) != null && F != null && U !== F) {
                    var L = p(r3, R + "." + F), V = C.schema.discriminators;
                    typeof L == "string" && V[L] != null ? $ = V[L].path(U) : L != null && Object.keys(L).length === 1 && Array.isArray(L.$in) && L.$in.length === 1 && typeof L.$in[0] == "string" && V[L.$in[0]] != null && ($ = V[L.$in[0]].path(U));
                  }
                }
              if ($) {
                if (E == null)
                  continue;
                if (v.isPOJO(E))
                  if (Object.keys(E).some(y))
                    for (var q = Object.keys(E), J = undefined, z = q.length;z--; )
                      if (j = E[J = q[z]], J === "$elemMatch")
                        j && $ != null && $.schema != null ? t($.schema, j, o2, O) : j && $ != null && $.$isMongooseArray && (v.isPOJO(j) && j.$not != null ? t(e3, j, o2, O) : E[J] = $.castForQuery(J, j, O));
                      else if (J === "$not") {
                        if (j && $) {
                          if ((S = Object.keys(j)).length && y(S[0]))
                            for (var K in j)
                              j[K] = $.castForQuery(K, j[K], O);
                          else
                            E[J] = $.castForQuery(J, j, O);
                          continue;
                        }
                      } else
                        E[J] = $.castForQuery(J, j, O);
                  else
                    r3[P] = $.castForQuery(null, E, O);
                else if (Array.isArray(E) && ["Buffer", "Array"].indexOf($.instance) === -1 && !o2.sanitizeFilter) {
                  var H, W = [], G = n(E);
                  try {
                    for (G.s();!(H = G.n()).done; ) {
                      var Q = H.value;
                      W.push($.castForQuery(null, Q, O));
                    }
                  } catch (t4) {
                    G.e(t4);
                  } finally {
                    G.f();
                  }
                  r3[P] = { $in: W };
                } else
                  r3[P] = $.castForQuery(null, E, O);
              } else {
                for (var Y = P.split("."), Z = Y.length, X = undefined, tt = undefined, et = undefined;Z-- && (X = Y.slice(0, Z).join("."), !($ = e3.path(X))); )
                  ;
                if ($) {
                  if ($.caster && $.caster.schema) {
                    (et = {})[tt = Y.slice(Z).join(".")] = E;
                    var rt = t($.caster.schema, et, o2, O)[tt];
                    rt === undefined ? delete r3[P] : r3[P] = rt;
                  } else
                    r3[P] = E;
                  continue;
                }
                if (b(E)) {
                  var nt = "";
                  if (E.$near ? nt = "$near" : E.$nearSphere ? nt = "$nearSphere" : E.$within ? nt = "$within" : E.$geoIntersects ? nt = "$geoIntersects" : E.$geoWithin && (nt = "$geoWithin"), nt) {
                    var ot = new u.Number("__QueryCasting__"), it = E[nt];
                    if (E.$maxDistance != null && (E.$maxDistance = ot.castForQuery(null, E.$maxDistance, O)), E.$minDistance != null && (E.$minDistance = ot.castForQuery(null, E.$minDistance, O)), nt === "$within") {
                      var st = it.$center || it.$centerSphere || it.$box || it.$polygon;
                      if (!st)
                        throw new Error("Bad $within parameter: " + JSON.stringify(E));
                      it = st;
                    } else if (nt === "$near" && typeof it.type == "string" && Array.isArray(it.coordinates))
                      it = it.coordinates;
                    else if ((nt === "$near" || nt === "$nearSphere" || nt === "$geoIntersects") && it.$geometry && typeof it.$geometry.type == "string" && Array.isArray(it.$geometry.coordinates))
                      it.$maxDistance != null && (it.$maxDistance = ot.castForQuery(null, it.$maxDistance, O)), it.$minDistance != null && (it.$minDistance = ot.castForQuery(null, it.$minDistance, O)), m(it.$geometry) && (it.$geometry = it.$geometry.toObject({ transform: false, virtuals: false })), it = it.$geometry.coordinates;
                    else if (nt === "$geoWithin")
                      if (it.$geometry) {
                        m(it.$geometry) && (it.$geometry = it.$geometry.toObject({ virtuals: false }));
                        var at = it.$geometry.type;
                        if (g.indexOf(at) === -1)
                          throw new Error('Invalid geoJSON type for $geoWithin "' + at + '", must be "Polygon" or "MultiPolygon"');
                        it = it.$geometry.coordinates;
                      } else
                        it = it.$box || it.$polygon || it.$center || it.$centerSphere, m(it) && (it = it.toObject({ virtuals: false }));
                    _(it, ot, O);
                    continue;
                  }
                }
                if (e3.nested[P])
                  continue;
                var ut = "strict" in o2 ? o2.strict : e3.options.strict, ct = w(o2, e3._userProvidedOptions, e3.options, O);
                if (o2.upsert && ut) {
                  if (ut === "throw")
                    throw new a(P);
                  throw new a(P, 'Path "' + P + '" is not in schema, strict mode is `true`, and upsert is `true`.');
                }
                if (ct === "throw")
                  throw new a(P, 'Path "' + P + `" is not in schema and strictQuery is 'throw'.`);
                ct && delete r3[P];
              }
            } else
              E = l(E, P), r3[P] = E;
          }
        return r3;
      };
    }, 8063: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (o = function() {
          return !!t4;
        })();
      }
      function i(t4) {
        return i = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, i(t4);
      }
      function s(t4, e3) {
        return s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s(t4, e3);
      }
      var a = function(t4) {
        function e3(t5) {
          return function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), function(t6, e4, r4) {
            return e4 = i(e4), function(t7, e5) {
              if (e5 && (n(e5) == "object" || typeof e5 == "function"))
                return e5;
              if (e5 !== undefined)
                throw new TypeError("Derived constructors may only return object or undefined");
              return function(t8) {
                if (t8 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t8;
              }(t7);
            }(t6, o() ? Reflect.construct(e4, r4 || [], i(t6).constructor) : e4.apply(t6, r4));
          }(this, e3, [`Schema hasn't been registered for model "` + t5 + `".
Use mongoose.model(name, schema)`]);
        }
        return function(t5, e4) {
          if (typeof e4 != "function" && e4 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(8213));
      Object.defineProperty(a.prototype, "name", { value: "MissingSchemaError" }), t3.exports = a;
    }, 8093: (t3) => {
      t3.exports = Object;
    }, 8133: (t3, e2, r2) => {
      var n = r2(8995);
      t3.exports = function(t4) {
        var e3, r3;
        t4.$immutable ? (t4.$immutableSetter = (e3 = t4.path, r3 = t4.options.immutable, function(t5, o, i, s) {
          if (this == null || this.$__ == null)
            return t5;
          if (this.isNew)
            return t5;
          if (s && s.overwriteImmutable)
            return t5;
          if (!(typeof r3 == "function" ? r3.call(this, this) : r3))
            return t5;
          var a = this.$__.priorDoc != null ? this.$__.priorDoc.$__getValue(e3) : this.$__getValue(e3);
          if (this.$__.strictMode === "throw" && t5 !== a)
            throw new n(e3, "Path `" + e3 + "` is immutable and strict mode is set to throw.", true);
          return a;
        }), t4.set(t4.$immutableSetter)) : t4.$immutableSetter && (t4.setters = t4.setters.filter(function(e4) {
          return e4 !== t4.$immutableSetter;
        }), delete t4.$immutableSetter);
      };
    }, 8188: (t3) => {
      t3.exports = URIError;
    }, 8213: (t3) => {
      function e2(t4) {
        return e2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      function r2(t4) {
        var e3 = typeof Map == "function" ? new Map : undefined;
        return r2 = function(t5) {
          if (t5 === null || !function(t6) {
            try {
              return Function.toString.call(t6).indexOf("[native code]") !== -1;
            } catch (e4) {
              return typeof t6 == "function";
            }
          }(t5))
            return t5;
          if (typeof t5 != "function")
            throw new TypeError("Super expression must either be null or a function");
          if (e3 !== undefined) {
            if (e3.has(t5))
              return e3.get(t5);
            e3.set(t5, r3);
          }
          function r3() {
            return function(t6, e4, r4) {
              if (n())
                return Reflect.construct.apply(null, arguments);
              var i2 = [null];
              i2.push.apply(i2, e4);
              var s2 = new (t6.bind.apply(t6, i2));
              return r4 && o(s2, r4.prototype), s2;
            }(t5, arguments, i(this).constructor);
          }
          return r3.prototype = Object.create(t5.prototype, { constructor: { value: r3, enumerable: false, writable: true, configurable: true } }), o(r3, t5);
        }, r2(t4);
      }
      function n() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (n = function() {
          return !!t4;
        })();
      }
      function o(t4, e3) {
        return o = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, o(t4, e3);
      }
      function i(t4) {
        return i = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, i(t4);
      }
      var s = function(t4) {
        function r3() {
          return function(t5, e3) {
            if (!(t5 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, r3), function(t5, r4, o2) {
            return r4 = i(r4), function(t6, r5) {
              if (r5 && (e2(r5) == "object" || typeof r5 == "function"))
                return r5;
              if (r5 !== undefined)
                throw new TypeError("Derived constructors may only return object or undefined");
              return function(t7) {
                if (t7 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t7;
              }(t6);
            }(t5, n() ? Reflect.construct(r4, o2 || [], i(t5).constructor) : r4.apply(t5, o2));
          }(this, r3, arguments);
        }
        return function(t5, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e3 && o(t5, e3);
        }(r3, t4), s2 = r3, Object.defineProperty(s2, "prototype", { writable: false }), s2;
        var s2;
      }(r2(Error));
      Object.defineProperty(s.prototype, "name", { value: "MongooseError" }), t3.exports = s;
    }, 8235: (t3, e2, r2) => {
      var n = r2(8213), o = r2(6426), i = r2(5098), s = r2(7910);
      function a(t4, e3) {
        if (this.$parentSchemaType = e3 && e3.$parentSchemaType, !this.$parentSchemaType)
          throw new n("Cannot create DocumentArrayElement schematype without a parent");
        delete e3.$parentSchemaType, o.call(this, t4, e3, "DocumentArrayElement"), this.$isMongooseDocumentArrayElement = true;
      }
      a.schemaName = "DocumentArrayElement", a.defaultOptions = {}, a.prototype = Object.create(o.prototype), a.prototype.constructor = a, a.prototype.cast = function() {
        var t4;
        return (t4 = this.$parentSchemaType).cast.apply(t4, arguments)[0];
      }, a.prototype.doValidate = function(t4, e3, r3, n2) {
        var o2 = s(this.caster, t4);
        return !t4 || t4 instanceof o2 || (t4 = new o2(t4, r3, null, null, n2 && n2.index != null ? n2.index : null)), i.prototype.doValidate.call(this, t4, e3, r3, n2);
      }, a.prototype.clone = function() {
        this.options.$parentSchemaType = this.$parentSchemaType;
        var t4 = o.prototype.clone.apply(this, arguments);
        return delete this.options.$parentSchemaType, t4.caster = this.caster, t4.schema = this.schema, t4;
      }, t3.exports = a;
    }, 8250: (t3, e2, r2) => {
      var n = r2(5832).hp, o = r2(6365), i = /[0-9a-f]{8}-[0-9a-f]{4}-[0-9][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}/i, s = o.Binary;
      function a(t4) {
        typeof t4 != "string" && (t4 = "");
        var e3, r3 = (e3 = t4.replace(/[{}-]/g, "")) != null && n.from(e3, "hex"), i2 = new o(r3);
        return i2._subtype = 4, i2;
      }
      t3.exports = function(t4) {
        if (t4 == null)
          return t4;
        function e3(t5) {
          var e4 = new o(t5);
          return e4._subtype = 4, e4;
        }
        if (typeof t4 == "string") {
          if (i.test(t4))
            return a(t4);
          throw new Error('"'.concat(t4, '" is not a valid UUID string'));
        }
        if (n.isBuffer(t4))
          return e3(t4);
        if (t4 instanceof s)
          return e3(t4.value(true));
        if (t4.toString && t4.toString !== Object.prototype.toString && i.test(t4.toString()))
          return a(t4.toString());
        throw new Error('"'.concat(t4, '" cannot be casted to a UUID'));
      }, t3.exports.UUID_FORMAT = i;
    }, 8260: (t3) => {
      t3.exports = function(t4) {
        if (t4 != null && typeof t4.constructor == "function")
          return t4.constructor.name;
      };
    }, 8285: (t3, e2, r2) => {
      var n = r2(2400), o = r2(2580), i = false;
      t3.exports = function() {
        return i ? o : n;
      }, t3.exports.setBrowser = function(t4) {
        i = t4;
      };
    }, 8297: (t3) => {
      function e2(t4, e3) {
        var r3 = typeof Symbol != "undefined" && t4[Symbol.iterator] || t4["@@iterator"];
        if (!r3) {
          if (Array.isArray(t4) || (r3 = n(t4)) || e3 && t4 && typeof t4.length == "number") {
            r3 && (t4 = r3);
            var o2 = 0, i2 = function() {};
            return { s: i2, n: function() {
              return o2 >= t4.length ? { done: true } : { done: false, value: t4[o2++] };
            }, e: function(t5) {
              throw t5;
            }, f: i2 };
          }
          throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        var s2, a2 = true, u2 = false;
        return { s: function() {
          r3 = r3.call(t4);
        }, n: function() {
          var t5 = r3.next();
          return a2 = t5.done, t5;
        }, e: function(t5) {
          u2 = true, s2 = t5;
        }, f: function() {
          try {
            a2 || r3.return == null || r3.return();
          } finally {
            if (u2)
              throw s2;
          }
        } };
      }
      function r2(t4) {
        return r2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, r2(t4);
      }
      function n(t4, e3) {
        if (t4) {
          if (typeof t4 == "string")
            return o(t4, e3);
          var r3 = {}.toString.call(t4).slice(8, -1);
          return r3 === "Object" && t4.constructor && (r3 = t4.constructor.name), r3 === "Map" || r3 === "Set" ? Array.from(t4) : r3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? o(t4, e3) : undefined;
        }
      }
      function o(t4, e3) {
        (e3 == null || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = Array(e3);r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      function i(t4, e3, r3) {
        if (a())
          return Reflect.construct.apply(null, arguments);
        var n2 = [null];
        n2.push.apply(n2, e3);
        var o2 = new (t4.bind.apply(t4, n2));
        return r3 && s(o2, r3.prototype), o2;
      }
      function s(t4, e3) {
        return s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s(t4, e3);
      }
      function a() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (a = function() {
          return !!t4;
        })();
      }
      function u() {
        this._pres = new Map, this._posts = new Map;
      }
      function c(t4, e3, r3, n2, o2, i2, s2) {
        return i2.useErrorHandlers ? t4.execPost(r3, n2, o2, { error: e3 }, function(t5) {
          return typeof s2 == "function" && s2(t5);
        }) : typeof s2 == "function" && s2(e3);
      }
      function l(t4, e3, r3, n2) {
        var o2;
        try {
          o2 = t4.apply(e3, r3);
        } catch (t5) {
          return n2(t5);
        }
        f(o2) && o2.then(function() {
          return n2();
        }, function(t5) {
          return n2(t5);
        });
      }
      function f(t4) {
        return r2(t4) === "object" && t4 !== null && typeof t4.then == "function";
      }
      function p(t4) {
        var e3 = false, r3 = this;
        return function() {
          var n2 = arguments;
          if (!e3)
            return e3 = true, h(function() {
              return t4.apply(r3, n2);
            });
        };
      }
      u.skipWrappedFunction = function() {
        if (!(this instanceof u.skipWrappedFunction))
          return i(u.skipWrappedFunction, Array.prototype.slice.call(arguments));
        this.args = Array.prototype.slice.call(arguments);
      }, u.overwriteResult = function() {
        if (!(this instanceof u.overwriteResult))
          return i(u.overwriteResult, Array.prototype.slice.call(arguments));
        this.args = Array.prototype.slice.call(arguments);
      }, u.prototype.execPre = function(t4, e3, r3, n2) {
        arguments.length === 3 && (n2 = r3, r3 = []);
        var o2 = this._pres.get(t4) || [], i2 = o2.length, s2 = o2.numAsync || 0, a2 = 0, c2 = s2, y2 = false, d = r3, b = null;
        if (!i2)
          return h(function() {
            n2(null);
          });
        function m() {
          if (!(a2 >= i2)) {
            var t5 = o2[a2];
            if (t5.isAsync) {
              var r4 = [p(v), p(function(t6) {
                if (t6) {
                  if (y2)
                    return;
                  if (!(t6 instanceof u.skipWrappedFunction))
                    return y2 = true, n2(t6);
                  b = t6;
                }
                if (--c2 === 0 && a2 >= i2)
                  return n2(b);
              })];
              l(t5.fn, e3, r4, r4[0]);
            } else if (t5.fn.length > 0) {
              for (var s3 = [p(v)], g = arguments.length >= 2 ? arguments : [null].concat(d), _ = 1;_ < g.length; ++_)
                _ === g.length - 1 && typeof g[_] == "function" || s3.push(g[_]);
              l(t5.fn, e3, s3, s3[0]);
            } else {
              var w = null;
              try {
                w = t5.fn.call(e3);
              } catch (t6) {
                if (t6 != null)
                  return n2(t6);
              }
              if (f(w))
                w.then(function() {
                  return v();
                }, function(t6) {
                  return v(t6);
                });
              else {
                if (++a2 >= i2)
                  return c2 > 0 ? undefined : h(function() {
                    n2(b);
                  });
                m();
              }
            }
          }
        }
        function v(t5) {
          if (t5) {
            if (y2)
              return;
            if (!(t5 instanceof u.skipWrappedFunction))
              return y2 = true, n2(t5);
            b = t5;
          }
          if (++a2 >= i2)
            return c2 > 0 ? undefined : n2(b);
          m.apply(e3, arguments);
        }
        m.apply(null, [null].concat(r3));
      }, u.prototype.execPreSync = function(t4, e3, r3) {
        for (var n2 = this._pres.get(t4) || [], o2 = n2.length, i2 = 0;i2 < o2; ++i2)
          n2[i2].fn.apply(e3, r3 || []);
      }, u.prototype.execPost = function(t4, e3, r3, n2, o2) {
        arguments.length < 5 && (o2 = n2, n2 = null);
        var i2 = this._posts.get(t4) || [], s2 = i2.length, a2 = 0, c2 = null;
        if (n2 && n2.error && (c2 = n2.error), !s2)
          return h(function() {
            o2.apply(null, [c2].concat(r3));
          });
        (function t() {
          for (var n3 = i2[a2].fn, h2 = 0, d = r3.length, b = [], m = 0;m < d; ++m)
            h2 += r3[m] && r3[m]._kareemIgnore ? 0 : 1, r3[m] && r3[m]._kareemIgnore || b.push(r3[m]);
          if (c2)
            if (y(i2[a2], h2)) {
              var v = p(function(e4) {
                if (e4) {
                  if (e4 instanceof u.overwriteResult)
                    return r3 = e4.args, ++a2 >= s2 ? o2.call(null, c2) : t();
                  c2 = e4;
                }
                if (++a2 >= s2)
                  return o2.call(null, c2);
                t();
              });
              l(n3, e3, [c2].concat(b).concat([v]), v);
            } else {
              if (++a2 >= s2)
                return o2.call(null, c2);
              t();
            }
          else {
            var g = p(function(e4) {
              return e4 ? e4 instanceof u.overwriteResult ? (r3 = e4.args, ++a2 >= s2 ? o2.apply(null, [null].concat(r3)) : t()) : (c2 = e4, t()) : ++a2 >= s2 ? o2.apply(null, [null].concat(r3)) : void t();
            });
            if (y(i2[a2], h2))
              return ++a2 >= s2 ? o2.apply(null, [null].concat(r3)) : t();
            if (n3.length === h2 + 1)
              l(n3, e3, b.concat([g]), g);
            else {
              var _, w;
              try {
                w = n3.apply(e3, b);
              } catch (t5) {
                _ = t5, c2 = t5;
              }
              if (f(w))
                return w.then(function(t5) {
                  g(t5 instanceof u.overwriteResult ? t5 : null);
                }, function(t5) {
                  return g(t5);
                });
              if (w instanceof u.overwriteResult && (r3 = w.args), ++a2 >= s2)
                return o2.apply(null, [_].concat(r3));
              t();
            }
          }
        })();
      }, u.prototype.execPostSync = function(t4, e3, r3) {
        for (var n2 = this._posts.get(t4) || [], o2 = n2.length, i2 = 0;i2 < o2; ++i2) {
          var s2 = n2[i2].fn.apply(e3, r3 || []);
          s2 instanceof u.overwriteResult && (r3 = s2.args);
        }
        return r3;
      }, u.prototype.createWrapperSync = function(t4, e3) {
        var r3 = this;
        return function() {
          r3.execPreSync(t4, this, arguments);
          var n2 = e3.apply(this, arguments);
          return r3.execPostSync(t4, this, [n2])[0];
        };
      }, u.prototype.wrap = function(t4, e3, r3, i2, s2) {
        var a2 = i2.length > 0 ? i2[i2.length - 1] : null, l2 = Array.from(i2);
        typeof a2 == "function" && l2.pop();
        var p2 = this, h2 = (s2 = s2 || {}).checkForPromise;
        this.execPre(t4, r3, i2, function(i3) {
          if (i3 && !(i3 instanceof u.skipWrappedFunction)) {
            for (var y2 = s2.numCallbackParams || 0, d = s2.contextParameter ? [r3] : [], b = d.length;b < y2; ++b)
              d.push(null);
            return c(p2, i3, t4, r3, d, s2, a2);
          }
          var m, v, g = e3.length;
          if (i3 instanceof u.skipWrappedFunction)
            return m = i3.args[0], _.apply(undefined, [null].concat(function(t5) {
              if (Array.isArray(t5))
                return o(t5);
            }(v = i3.args) || function(t5) {
              if (typeof Symbol != "undefined" && t5[Symbol.iterator] != null || t5["@@iterator"] != null)
                return Array.from(t5);
            }(v) || n(v) || function() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }()));
          try {
            m = e3.apply(r3, l2.concat(_));
          } catch (t5) {
            return _(t5);
          }
          if (h2) {
            if (f(m))
              return m.then(function(t5) {
                return _(null, t5);
              }, function(t5) {
                return _(t5);
              });
            if (g < l2.length + 1)
              return _(null, m);
          }
          function _() {
            var e4 = Array.from(arguments);
            if (e4.shift(), s2.nullResultByDefault && e4.length === 0 && e4.push(null), arguments[0])
              return c(p2, arguments[0], t4, r3, e4, s2, a2);
            p2.execPost(t4, r3, e4, function() {
              a2 !== null && (arguments[0] ? a2(arguments[0]) : a2.apply(r3, arguments));
            });
          }
        });
      }, u.prototype.filter = function(t4) {
        for (var e3 = this, r3 = this.clone(), n2 = Array.from(r3._pres.keys()), o2 = function() {
          var n3 = s2[i2], o3 = e3._pres.get(n3).map(function(t5) {
            return Object.assign({}, t5, { name: n3 });
          }).filter(t4);
          if (o3.length === 0)
            return r3._pres.delete(n3), 1;
          o3.numAsync = o3.filter(function(t5) {
            return t5.isAsync;
          }).length, r3._pres.set(n3, o3);
        }, i2 = 0, s2 = n2;i2 < s2.length; i2++)
          o2();
        for (var a2 = Array.from(r3._posts.keys()), u2 = function() {
          var n3 = l2[c2], o3 = e3._posts.get(n3).map(function(t5) {
            return Object.assign({}, t5, { name: n3 });
          }).filter(t4);
          if (o3.length === 0)
            return r3._posts.delete(n3), 1;
          r3._posts.set(n3, o3);
        }, c2 = 0, l2 = a2;c2 < l2.length; c2++)
          u2();
        return r3;
      }, u.prototype.hasHooks = function(t4) {
        return this._pres.has(t4) || this._posts.has(t4);
      }, u.prototype.createWrapper = function(t4, e3, r3, n2) {
        var o2 = this;
        return this.hasHooks(t4) ? function() {
          var i2 = r3 || this;
          o2.wrap(t4, e3, i2, Array.from(arguments), n2);
        } : function() {
          var t5 = arguments, r4 = this;
          h(function() {
            return e3.apply(r4, t5);
          });
        };
      }, u.prototype.pre = function(t4, e3, n2, o2, i2) {
        var s2 = {};
        r2(e3) === "object" && e3 !== null ? e3 = (s2 = e3).isAsync : typeof arguments[1] != "boolean" && (n2 = e3, e3 = false);
        var a2 = this._pres.get(t4) || [];
        if (this._pres.set(t4, a2), e3 && (a2.numAsync = a2.numAsync || 0, ++a2.numAsync), typeof n2 != "function")
          throw new Error('pre() requires a function, got "' + r2(n2) + '"');
        return i2 ? a2.unshift(Object.assign({}, s2, { fn: n2, isAsync: e3 })) : a2.push(Object.assign({}, s2, { fn: n2, isAsync: e3 })), this;
      }, u.prototype.post = function(t4, e3, n2, o2) {
        var i2 = this._posts.get(t4) || [];
        if (typeof e3 == "function" && (o2 = !!n2, n2 = e3, e3 = {}), typeof n2 != "function")
          throw new Error('post() requires a function, got "' + r2(n2) + '"');
        return o2 ? i2.unshift(Object.assign({}, e3, { fn: n2 })) : i2.push(Object.assign({}, e3, { fn: n2 })), this._posts.set(t4, i2), this;
      }, u.prototype.clone = function() {
        var t4, r3 = new u, n2 = e2(this._pres.keys());
        try {
          for (n2.s();!(t4 = n2.n()).done; ) {
            var o2 = t4.value, i2 = this._pres.get(o2).slice();
            i2.numAsync = this._pres.get(o2).numAsync, r3._pres.set(o2, i2);
          }
        } catch (t5) {
          n2.e(t5);
        } finally {
          n2.f();
        }
        var s2, a2 = e2(this._posts.keys());
        try {
          for (a2.s();!(s2 = a2.n()).done; ) {
            var c2 = s2.value;
            r3._posts.set(c2, this._posts.get(c2).slice());
          }
        } catch (t5) {
          a2.e(t5);
        } finally {
          a2.f();
        }
        return r3;
      }, u.prototype.merge = function(t4, r3) {
        var n2, o2 = (r3 = arguments.length === 1 || r3) ? this.clone() : this, i2 = e2(t4._pres.keys());
        try {
          var s2 = function() {
            var e3 = n2.value, r4 = o2._pres.get(e3) || [], i3 = t4._pres.get(e3).filter(function(t5) {
              return r4.map(function(t6) {
                return t6.fn;
              }).indexOf(t5.fn) === -1;
            }), s3 = r4.concat(i3);
            s3.numAsync = r4.numAsync || 0, s3.numAsync += i3.filter(function(t5) {
              return t5.isAsync;
            }).length, o2._pres.set(e3, s3);
          };
          for (i2.s();!(n2 = i2.n()).done; )
            s2();
        } catch (t5) {
          i2.e(t5);
        } finally {
          i2.f();
        }
        var a2, u2 = e2(t4._posts.keys());
        try {
          var c2 = function() {
            var e3 = a2.value, r4 = o2._posts.get(e3) || [], n3 = t4._posts.get(e3).filter(function(t5) {
              return r4.indexOf(t5) === -1;
            });
            o2._posts.set(e3, r4.concat(n3));
          };
          for (u2.s();!(a2 = u2.n()).done; )
            c2();
        } catch (t5) {
          u2.e(t5);
        } finally {
          u2.f();
        }
        return o2;
      };
      var h = r2({ env: {} }) === "object" && { env: {} } !== null && { env: {} }.nextTick || function(t4) {
        setTimeout(t4, 0);
      };
      function y(t4, e3) {
        return !!t4.errorHandler || t4.fn.length === e3 + 2;
      }
      t3.exports = u;
    }, 8435: (t3) => {
      t3.exports = Math.min;
    }, 8442: (t3, e2, r2) => {
      var n = r2(1898);
      t3.exports = function(t4) {
        for (var e3 = 0, r3 = Object.values(n);e3 < r3.length; e3++)
          (0, r3[e3])(t4, { deduplicate: true });
        t4.plugins = Object.values(n).map(function(t5) {
          return { fn: t5, opts: { deduplicate: true } };
        }).concat(t4.plugins);
      };
    }, 8499: (t3, e2, r2) => {
      var n = r2(8953);
      t3.exports = function(t4) {
        var e3 = this != null ? this.path : null;
        return n(t4, e3);
      };
    }, 8517: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (o = function() {
          return !!t4;
        })();
      }
      function i(t4) {
        return i = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, i(t4);
      }
      function s(t4, e3) {
        return s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s(t4, e3);
      }
      var a = function(t4) {
        function e3(t5, r4, s2) {
          var a2, u, c;
          (function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          })(this, e3);
          var l = (a2 = s2 == null ? undefined : s2.matchedCount) !== null && a2 !== undefined ? a2 : 0, f = (u = s2 == null ? undefined : s2.insertedCount) !== null && u !== undefined ? u : 0, p = r4.map(function(t6) {
            return t6._id;
          }).join(", ");
          p.length > 100 && (p = p.slice(0, 100) + "...");
          var h = r4.length - l - f;
          return (c = function(t6, e4, r5) {
            return e4 = i(e4), function(t7, e5) {
              if (e5 && (n(e5) == "object" || typeof e5 == "function"))
                return e5;
              if (e5 !== undefined)
                throw new TypeError("Derived constructors may only return object or undefined");
              return function(t8) {
                if (t8 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t8;
              }(t7);
            }(t6, o() ? Reflect.construct(e4, r5 || [], i(t6).constructor) : e4.apply(t6, r5));
          }(this, e3, ["".concat(t5, ".bulkSave() was not able to update ").concat(h, " of the given documents due to incorrect version or optimistic concurrency, document ids: ").concat(p)])).modelName = t5, c.documents = r4, c.bulkWriteResult = s2, c.numDocumentsNotUpdated = h, c;
        }
        return function(t5, e4) {
          if (typeof e4 != "function" && e4 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(8213));
      Object.defineProperty(a.prototype, "name", { value: "MongooseBulkSaveIncompleteError" }), t3.exports = a;
    }, 8533: (t3, e2, r2) => {
      var n = r2(5832).hp;
      function o(t4) {
        return o = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, o(t4);
      }
      function i() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (i = function() {
          return !!t4;
        })();
      }
      function s(t4) {
        return s = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, s(t4);
      }
      function a(t4, e3) {
        return a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, a(t4, e3);
      }
      r2(7591).set(r2(4026));
      var u = r2(8285);
      u.setBrowser(true), e2.Error = r2(3672), e2.Schema = r2(7058), e2.Types = r2(9600), e2.VirtualType = r2(622), e2.SchemaType = r2(6426), e2.SchemaTypeOptions = r2(8879), e2.utils = r2(8768), e2.Document = u(), e2.model = function(t4, r3) {
        var n2 = function(t5) {
          function e3(t6, n4) {
            return function(t7, e4) {
              if (!(t7 instanceof e4))
                throw new TypeError("Cannot call a class as a function");
            }(this, e3), function(t7, e4, r4) {
              return e4 = s(e4), function(t8, e5) {
                if (e5 && (o(e5) == "object" || typeof e5 == "function"))
                  return e5;
                if (e5 !== undefined)
                  throw new TypeError("Derived constructors may only return object or undefined");
                return function(t9) {
                  if (t9 === undefined)
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return t9;
                }(t8);
              }(t7, i() ? Reflect.construct(e4, r4 || [], s(t7).constructor) : e4.apply(t7, r4));
            }(this, e3, [t6, r3, n4]);
          }
          return function(t6, e4) {
            if (typeof e4 != "function" && e4 !== null)
              throw new TypeError("Super expression must either be null or a function");
            t6.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t6, writable: true, configurable: true } }), Object.defineProperty(t6, "prototype", { writable: false }), e4 && a(t6, e4);
          }(e3, t5), n3 = e3, Object.defineProperty(n3, "prototype", { writable: false }), n3;
          var n3;
        }(e2.Document);
        return n2.modelName = t4, n2;
      }, typeof window != "undefined" && (window.mongoose = t3.exports, window.Buffer = n);
    }, 8633: (t3) => {
      t3.exports = Math.pow;
    }, 8728: (t3, e2, r2) => {
      function n(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function o(t4) {
        for (var e3 = 1;e3 < arguments.length; e3++) {
          var r3 = arguments[e3] != null ? arguments[e3] : {};
          e3 % 2 ? n(Object(r3), true).forEach(function(e4) {
            i(t4, e4, r3[e4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : n(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      function i(t4, e3, r3) {
        return (e3 = function(t5) {
          var e4 = function(t6) {
            if (s(t6) != "object" || !t6)
              return t6;
            var e5 = t6[Symbol.toPrimitive];
            if (e5 !== undefined) {
              var r4 = e5.call(t6, "string");
              if (s(r4) != "object")
                return r4;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t6);
          }(t5);
          return s(e4) == "symbol" ? e4 : e4 + "";
        }(e3)) in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      function s(t4) {
        return s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, s(t4);
      }
      function a(t4, e3) {
        (e3 == null || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = Array(e3);r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      var u = r2(6426), c = r2(3672), l = r2(9528), f = r2(1244), p = r2(4327), h = r2(8768), y = r2(3305), d = u.CastError;
      function b(t4, e3) {
        this.enumValues = [], this.regExp = null, u.call(this, t4, e3, "String");
      }
      function m(t4, e3) {
        return this.castForQuery(null, t4, e3);
      }
      function v(t4) {
        return t4 == null ? this._castNullish(t4) : this.cast(t4, this);
      }
      b.schemaName = "String", b.defaultOptions = {}, b.prototype = Object.create(u.prototype), b.prototype.constructor = b, Object.defineProperty(b.prototype, "OptionsConstructor", { configurable: false, enumerable: false, writable: false, value: l }), b._cast = f, b.cast = function(t4) {
        return arguments.length === 0 || (t4 === false && (t4 = this._defaultCaster), this._cast = t4), this._cast;
      }, b._defaultCaster = function(t4) {
        if (t4 != null && typeof t4 != "string")
          throw new Error;
        return t4;
      }, b.get = u.get, b.set = u.set, b.setters = [], b._checkRequired = function(t4) {
        return (t4 instanceof String || typeof t4 == "string") && t4.length;
      }, b.checkRequired = u.checkRequired, b.prototype.enum = function() {
        if (this.enumValidator && (this.validators = this.validators.filter(function(t5) {
          return t5.validator !== this.enumValidator;
        }, this), this.enumValidator = false), arguments[0] === undefined || arguments[0] === false)
          return this;
        var t4, e3;
        h.isObject(arguments[0]) ? Array.isArray(arguments[0].values) ? (t4 = arguments[0].values, e3 = arguments[0].message) : (t4 = h.object.vals(arguments[0]), e3 = c.messages.String.enum) : (t4 = arguments, e3 = c.messages.String.enum);
        var r3, n2 = function(t5, e4) {
          var r4 = typeof Symbol != "undefined" && t5[Symbol.iterator] || t5["@@iterator"];
          if (!r4) {
            if (Array.isArray(t5) || (r4 = function(t6, e5) {
              if (t6) {
                if (typeof t6 == "string")
                  return a(t6, e5);
                var r5 = {}.toString.call(t6).slice(8, -1);
                return r5 === "Object" && t6.constructor && (r5 = t6.constructor.name), r5 === "Map" || r5 === "Set" ? Array.from(t6) : r5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? a(t6, e5) : undefined;
              }
            }(t5)) || e4 && t5 && typeof t5.length == "number") {
              r4 && (t5 = r4);
              var n3 = 0, o3 = function() {};
              return { s: o3, n: function() {
                return n3 >= t5.length ? { done: true } : { done: false, value: t5[n3++] };
              }, e: function(t6) {
                throw t6;
              }, f: o3 };
            }
            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }
          var i3, s2 = true, u2 = false;
          return { s: function() {
            r4 = r4.call(t5);
          }, n: function() {
            var t6 = r4.next();
            return s2 = t6.done, t6;
          }, e: function(t6) {
            u2 = true, i3 = t6;
          }, f: function() {
            try {
              s2 || r4.return == null || r4.return();
            } finally {
              if (u2)
                throw i3;
            }
          } };
        }(t4);
        try {
          for (n2.s();!(r3 = n2.n()).done; ) {
            var o2 = r3.value;
            o2 !== undefined && this.enumValues.push(this.cast(o2));
          }
        } catch (t5) {
          n2.e(t5);
        } finally {
          n2.f();
        }
        var i2 = this.enumValues;
        return this.enumValidator = function(t5) {
          return t5 == null || ~i2.indexOf(t5);
        }, this.validators.push({ validator: this.enumValidator, message: e3, type: "enum", enumValues: i2 }), this;
      }, b.prototype.lowercase = function(t4) {
        var e3 = this;
        return arguments.length > 0 && !t4 ? this : this.set(function(t5) {
          return typeof t5 != "string" && (t5 = e3.cast(t5)), t5 ? t5.toLowerCase() : t5;
        });
      }, b.prototype.uppercase = function(t4) {
        var e3 = this;
        return arguments.length > 0 && !t4 ? this : this.set(function(t5) {
          return typeof t5 != "string" && (t5 = e3.cast(t5)), t5 ? t5.toUpperCase() : t5;
        });
      }, b.prototype.trim = function(t4) {
        var e3 = this;
        return arguments.length > 0 && !t4 ? this : this.set(function(t5) {
          return typeof t5 != "string" && (t5 = e3.cast(t5)), t5 ? t5.trim() : t5;
        });
      }, b.prototype.minlength = function(t4, e3) {
        if (this.minlengthValidator && (this.validators = this.validators.filter(function(t5) {
          return t5.validator !== this.minlengthValidator;
        }, this)), t4 != null) {
          var r3 = e3 || c.messages.String.minlength;
          r3 = r3.replace(/{MINLENGTH}/, t4), this.validators.push({ validator: this.minlengthValidator = function(e4) {
            return e4 === null || e4.length >= t4;
          }, message: r3, type: "minlength", minlength: t4 });
        }
        return this;
      }, b.prototype.minLength = b.prototype.minlength, b.prototype.maxlength = function(t4, e3) {
        if (this.maxlengthValidator && (this.validators = this.validators.filter(function(t5) {
          return t5.validator !== this.maxlengthValidator;
        }, this)), t4 != null) {
          var r3 = e3 || c.messages.String.maxlength;
          r3 = r3.replace(/{MAXLENGTH}/, t4), this.validators.push({ validator: this.maxlengthValidator = function(e4) {
            return e4 === null || e4.length <= t4;
          }, message: r3, type: "maxlength", maxlength: t4 });
        }
        return this;
      }, b.prototype.maxLength = b.prototype.maxlength, b.prototype.match = function(t4, e3) {
        var r3 = e3 || c.messages.String.match;
        return this.validators.push({ validator: function(e4) {
          return !!t4 && (t4.lastIndex = 0, e4 == null || e4 === "" || t4.test(e4));
        }, message: r3, type: "regexp", regexp: t4 }), this;
      }, b.prototype.checkRequired = function(t4, e3) {
        return s(t4) === "object" && u._isRef(this, t4, e3, true) ? t4 != null : (typeof this.constructor.checkRequired == "function" ? this.constructor.checkRequired() : b.checkRequired())(t4);
      }, b.prototype.cast = function(t4, e3, r3, n2, o2) {
        if (typeof t4 != "string" && u._isRef(this, t4, e3, r3))
          return this._castRef(t4, e3, r3, o2);
        var i2;
        i2 = typeof this._castFunction == "function" ? this._castFunction : typeof this.constructor.cast == "function" ? this.constructor.cast() : b.cast();
        try {
          return i2(t4);
        } catch (e4) {
          throw new d("string", t4, this.path, null, this);
        }
      };
      var g = o(o({}, u.prototype.$conditionalHandlers), {}, { $all: function(t4, e3) {
        var r3 = this;
        return Array.isArray(t4) ? t4.map(function(t5) {
          return r3.castForQuery(null, t5, e3);
        }) : [this.castForQuery(null, t4, e3)];
      }, $gt: m, $gte: m, $lt: m, $lte: m, $options: v, $regex: function(t4) {
        return Object.prototype.toString.call(t4) === "[object RegExp]" ? t4 : v.call(this, t4);
      }, $not: m });
      Object.defineProperty(b.prototype, "$conditionalHandlers", { enumerable: false, value: g }), b.prototype.castForQuery = function(t4, e3, r3) {
        var n2;
        if (t4 != null) {
          if (!(n2 = this.$conditionalHandlers[t4]))
            throw new Error("Can't use " + t4 + " with String.");
          return n2.call(this, e3, r3);
        }
        if (Object.prototype.toString.call(e3) === "[object RegExp]" || y(e3, "BSONRegExp"))
          return e3;
        try {
          return this.applySetters(e3, r3);
        } catch (t5) {
          throw t5 instanceof d && t5.path === this.path && this.$fullPath != null && (t5.path = this.$fullPath), t5;
        }
      }, b.prototype.toJSONSchema = function(t4) {
        var e3 = this.options.required && typeof this.options.required != "function";
        return p("string", "string", t4 == null ? undefined : t4.useBsonType, e3);
      }, b.prototype.autoEncryptionType = function() {
        return "string";
      }, t3.exports = b;
    }, 8759: (t3) => {
      t3.exports = function(t4) {
        return t4.replace(/\.\$(\[[^\]]*\])?(?=\.)/g, ".0").replace(/\.\$(\[[^\]]*\])?$/g, ".0");
      };
    }, 8768: (t3, e2, r2) => {
      var n = r2(5832).hp;
      function o(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function i(t4, e3, r3) {
        return (e3 = function(t5) {
          var e4 = function(t6) {
            if (c(t6) != "object" || !t6)
              return t6;
            var e5 = t6[Symbol.toPrimitive];
            if (e5 !== undefined) {
              var r4 = e5.call(t6, "string");
              if (c(r4) != "object")
                return r4;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t6);
          }(t5);
          return c(e4) == "symbol" ? e4 : e4 + "";
        }(e3)) in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      function s(t4, e3) {
        var r3 = typeof Symbol != "undefined" && t4[Symbol.iterator] || t4["@@iterator"];
        if (!r3) {
          if (Array.isArray(t4) || (r3 = a(t4)) || e3 && t4 && typeof t4.length == "number") {
            r3 && (t4 = r3);
            var n2 = 0, o2 = function() {};
            return { s: o2, n: function() {
              return n2 >= t4.length ? { done: true } : { done: false, value: t4[n2++] };
            }, e: function(t5) {
              throw t5;
            }, f: o2 };
          }
          throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        var i2, s2 = true, u2 = false;
        return { s: function() {
          r3 = r3.call(t4);
        }, n: function() {
          var t5 = r3.next();
          return s2 = t5.done, t5;
        }, e: function(t5) {
          u2 = true, i2 = t5;
        }, f: function() {
          try {
            s2 || r3.return == null || r3.return();
          } finally {
            if (u2)
              throw i2;
          }
        } };
      }
      function a(t4, e3) {
        if (t4) {
          if (typeof t4 == "string")
            return u(t4, e3);
          var r3 = {}.toString.call(t4).slice(8, -1);
          return r3 === "Object" && t4.constructor && (r3 = t4.constructor.name), r3 === "Map" || r3 === "Set" ? Array.from(t4) : r3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? u(t4, e3) : undefined;
        }
      }
      function u(t4, e3) {
        (e3 == null || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = Array(e3);r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      function c(t4) {
        return c = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, c(t4);
      }
      var l, f = r2(6353).UUID, p = r2(354), h = r2(5678), y = r2(5549), d = r2(6948), b = r2(4450), m = r2(2746), v = r2(608), g = r2(1243), _ = r2(1347), w = r2(3305), O = r2(2789), S = r2(9696), $ = r2(2497), j = r2(5268), P = r2(9539), A = r2(2793), E = r2(7291).trustedSymbol;
      e2.specialProperties = A, e2.isMongooseArray = g.isMongooseArray, e2.isMongooseDocumentArray = _.isMongooseDocumentArray, e2.registerMongooseArray = g.registerMongooseArray, e2.registerMongooseDocumentArray = _.registerMongooseDocumentArray;
      var x = /\s/, T = /\s+/;
      e2.toCollectionName = function(t4, e3) {
        if (t4 === "system.profile")
          return t4;
        if (t4 === "system.indexes")
          return t4;
        if (typeof e3 == "function") {
          if (typeof t4 != "string")
            throw new TypeError("Collection name must be a string");
          if (t4.length === 0)
            throw new TypeError("Collection name cannot be empty");
          return e3(t4);
        }
        return t4;
      }, e2.deepEqual = function t(r3, o2) {
        if (r3 === o2)
          return true;
        if (c(r3) !== "object" || c(o2) !== "object")
          return r3 === o2;
        if (r3 instanceof Date && o2 instanceof Date)
          return r3.getTime() === o2.getTime();
        if (w(r3, "ObjectId") && w(o2, "ObjectId") || w(r3, "Decimal128") && w(o2, "Decimal128"))
          return r3.toString() === o2.toString();
        if (r3 instanceof RegExp && o2 instanceof RegExp)
          return r3.source === o2.source && r3.ignoreCase === o2.ignoreCase && r3.multiline === o2.multiline && r3.global === o2.global && r3.dotAll === o2.dotAll && r3.unicode === o2.unicode && r3.sticky === o2.sticky && r3.hasIndices === o2.hasIndices;
        if (r3 == null || o2 == null)
          return false;
        if (r3.prototype !== o2.prototype)
          return false;
        if (r3 instanceof Map || o2 instanceof Map)
          return r3 instanceof Map && o2 instanceof Map && t(Array.from(r3.keys()), Array.from(o2.keys())) && t(Array.from(r3.values()), Array.from(o2.values()));
        if (r3 instanceof Number && o2 instanceof Number)
          return r3.valueOf() === o2.valueOf();
        if (n.isBuffer(r3))
          return e2.buffer.areEqual(r3, o2);
        if (Array.isArray(r3) || Array.isArray(o2)) {
          if (!Array.isArray(r3) || !Array.isArray(o2))
            return false;
          var i2 = r3.length;
          if (i2 !== o2.length)
            return false;
          for (var s2 = 0;s2 < i2; ++s2)
            if (!t(r3[s2], o2[s2]))
              return false;
          return true;
        }
        r3.$__ != null ? r3 = r3._doc : $(r3) && (r3 = r3.toObject()), o2.$__ != null ? o2 = o2._doc : $(o2) && (o2 = o2.toObject());
        var a2 = Object.keys(r3), u2 = Object.keys(o2), l2 = a2.length;
        if (l2 !== u2.length)
          return false;
        for (var f2 = l2 - 1;f2 >= 0; f2--)
          if (a2[f2] !== u2[f2])
            return false;
        for (var p2 = 0, h2 = a2;p2 < h2.length; p2++) {
          var y2 = h2[p2];
          if (!t(r3[y2], o2[y2]))
            return false;
        }
        return true;
      }, e2.last = function(t4) {
        if (t4.length > 0)
          return t4[t4.length - 1];
      }, e2.promiseOrCallback = j, e2.cloneArrays = function(t4) {
        return Array.isArray(t4) ? t4.map(function(t5) {
          return e2.cloneArrays(t5);
        }) : t4;
      }, e2.omit = function(t4, e3) {
        if (e3 == null)
          return Object.assign({}, t4);
        Array.isArray(e3) || (e3 = [e3]);
        var r3, n2 = Object.assign({}, t4), o2 = s(e3);
        try {
          for (o2.s();!(r3 = o2.n()).done; )
            delete n2[r3.value];
        } catch (t5) {
          o2.e(t5);
        } finally {
          o2.f();
        }
        return n2;
      }, e2.clonePOJOsAndArrays = function(t4) {
        if (t4 == null)
          return t4;
        if (t4.$__ != null)
          return t4;
        if (O(t4)) {
          t4 = function(t5) {
            for (var e3 = 1;e3 < arguments.length; e3++) {
              var r4 = arguments[e3] != null ? arguments[e3] : {};
              e3 % 2 ? o(Object(r4), true).forEach(function(e4) {
                i(t5, e4, r4[e4]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t5, Object.getOwnPropertyDescriptors(r4)) : o(Object(r4)).forEach(function(e4) {
                Object.defineProperty(t5, e4, Object.getOwnPropertyDescriptor(r4, e4));
              });
            }
            return t5;
          }({}, t4);
          for (var r3 = 0, n2 = Object.keys(t4);r3 < n2.length; r3++) {
            var s2 = n2[r3];
            t4[s2] = e2.clonePOJOsAndArrays(t4[s2]);
          }
          return t4;
        }
        if (Array.isArray(t4)) {
          t4 = function(t5) {
            if (Array.isArray(t5))
              return u(t5);
          }(l2 = t4) || function(t5) {
            if (typeof Symbol != "undefined" && t5[Symbol.iterator] != null || t5["@@iterator"] != null)
              return Array.from(t5);
          }(l2) || a(l2) || function() {
            throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }();
          for (var c2 = 0;c2 < t4.length; ++c2)
            t4[c2] = e2.clonePOJOsAndArrays(t4[c2]);
          return t4;
        }
        var l2;
        return t4;
      }, e2.merge = function t(r3, n2, o2, i2) {
        o2 = o2 || {};
        var s2, a2 = Object.keys(n2), u2 = 0, c2 = a2.length;
        n2[E] && (r3[E] = n2[E]), i2 = i2 || "";
        for (var l2 = o2.omitNested || {};u2 < c2; )
          if (s2 = a2[u2++], !(o2.omit && o2.omit[s2] || l2[i2] || A.has(s2)))
            if (r3[s2] == null)
              r3[s2] = e2.clonePOJOsAndArrays(n2[s2]);
            else if (e2.isObject(n2[s2])) {
              if (e2.isObject(r3[s2]) || (r3[s2] = {}), n2[s2] != null) {
                if (o2.isDiscriminatorSchemaMerge && n2[s2].$isSingleNested && r3[s2].$isMongooseDocumentArray || n2[s2].$isMongooseDocumentArray && r3[s2].$isSingleNested)
                  continue;
                if (n2[s2].instanceOfSchema) {
                  r3[s2].instanceOfSchema ? P(r3[s2], n2[s2].clone(), o2.isDiscriminatorSchemaMerge) : r3[s2] = n2[s2].clone();
                  continue;
                }
                if (w(n2[s2], "ObjectId")) {
                  r3[s2] = new y(n2[s2]);
                  continue;
                }
              }
              t(r3[s2], n2[s2], o2, i2 ? i2 + "." + s2 : s2);
            } else
              o2.overwrite && (r3[s2] = n2[s2]);
        return r3;
      }, e2.toObject = function t(n2) {
        var o2;
        if (l || (l = r2(2400)), n2 == null)
          return n2;
        if (n2 instanceof l)
          return n2.toObject();
        if (Array.isArray(n2)) {
          o2 = [];
          var i2, a2 = s(n2);
          try {
            for (a2.s();!(i2 = a2.n()).done; ) {
              var u2 = i2.value;
              o2.push(t(u2));
            }
          } catch (t4) {
            a2.e(t4);
          } finally {
            a2.f();
          }
          return o2;
        }
        if (e2.isPOJO(n2)) {
          o2 = {}, n2[E] && (o2[E] = n2[E]);
          for (var c2 = 0, f2 = Object.keys(n2);c2 < f2.length; c2++) {
            var p2 = f2[c2];
            A.has(p2) || (o2[p2] = t(n2[p2]));
          }
          return o2;
        }
        return n2;
      }, e2.isObject = v, e2.isPOJO = r2(2789), e2.isNonBuiltinObject = function(t4) {
        return !(c(t4) !== "object" || e2.isNativeObject(t4) || e2.isMongooseType(t4) || t4 instanceof f || t4 == null);
      }, e2.isNativeObject = function(t4) {
        return Array.isArray(t4) || t4 instanceof Date || t4 instanceof Boolean || t4 instanceof Number || t4 instanceof String;
      }, e2.isEmptyObject = function(t4) {
        return t4 != null && c(t4) === "object" && Object.keys(t4).length === 0;
      }, e2.hasKey = function(t4, r3) {
        for (var n2 = 0, o2 = Object.keys(t4);n2 < o2.length; n2++) {
          var i2 = o2[n2];
          if (i2 === r3)
            return true;
          if (e2.isPOJO(t4[i2]) && e2.hasKey(t4[i2], r3))
            return true;
        }
        return false;
      }, e2.tick = function(t4) {
        if (typeof t4 == "function")
          return function() {
            try {
              t4.apply(this, arguments);
            } catch (t5) {
              m(function() {
                throw t5;
              });
            }
          };
      }, e2.isMongooseType = function(t4) {
        return w(t4, "ObjectId") || w(t4, "Decimal128") || t4 instanceof n;
      }, e2.isMongooseObject = $, e2.expires = function(t4) {
        t4 && t4.constructor.name === "Object" && "expires" in t4 && (t4.expireAfterSeconds = typeof t4.expires != "string" ? t4.expires : Math.round(p(t4.expires) / 1000), delete t4.expires);
      }, e2.populate = function(t4, r3, n2, o2, i2, a2, u2, l2) {
        var f2, p2 = null;
        if (arguments.length === 1) {
          if (t4 instanceof d)
            return t4._docs = {}, t4._childDocs = [], [t4];
          if (Array.isArray(t4)) {
            var h2 = (f2 = [], t4.forEach(function(t5) {
              x.test(t5.path) ? t5.path.split(T).forEach(function(e3) {
                var r4 = Object.assign({}, t5);
                r4.path = e3, f2.push(r4);
              }) : f2.push(t5);
            }), f2);
            return h2.map(function(t5) {
              return e2.populate(t5)[0];
            });
          }
          p2 = e2.isObject(t4) ? Object.assign({}, t4) : { path: t4 };
        } else
          p2 = c(n2) === "object" ? { path: t4, select: r3, match: n2, options: o2 } : { path: t4, select: r3, model: n2, match: o2, options: i2, populate: a2, justOne: u2, count: l2 };
        if (!(typeof p2.path == "string" || Array.isArray(p2.path) && p2.path.every(function(t5) {
          return typeof t5 == "string";
        })))
          throw new TypeError("utils.populate: invalid path. Expected string or array of strings. Got typeof `" + c(t4) + "`");
        return function(t5) {
          if (Array.isArray(t5.populate)) {
            var r4 = [];
            t5.populate.forEach(function(t6) {
              if (x.test(t6.path)) {
                var n4 = Object.assign({}, t6);
                n4.path.split(T).forEach(function(t7) {
                  n4.path = t7, r4.push(e2.populate(n4)[0]);
                });
              } else
                r4.push(e2.populate(t6)[0]);
            }), t5.populate = e2.populate(r4);
          } else
            t5.populate != null && c(t5.populate) === "object" && (t5.populate = e2.populate(t5.populate));
          var n3 = [], o3 = x.test(t5.path) ? t5.path.split(T) : Array.isArray(t5.path) ? t5.path : [t5.path];
          t5.options != null && (t5.options = b(t5.options));
          var i3, a3 = s(o3);
          try {
            for (a3.s();!(i3 = a3.n()).done; ) {
              var u3 = i3.value;
              n3.push(new d(Object.assign({}, t5, { path: u3 })));
            }
          } catch (t6) {
            a3.e(t6);
          } finally {
            a3.f();
          }
          return n3;
        }(p2);
      }, e2.getValue = function(t4, e3, r3) {
        return h.get(t4, e3, N, r3);
      };
      var k = Object.freeze({ getters: false });
      function N(t4, e3) {
        if (e3 === "$*" && t4 instanceof Map)
          return t4;
        var r3 = (t4 == null ? undefined : t4._doc) || t4;
        return r3 != null && r3.isMongooseArrayProxy && (r3 = r3.__array), r3 instanceof Map ? r3.get(e3, k) : r3[e3];
      }
      e2.setValue = function(t4, e3, r3, n2, o2) {
        h.set(t4, e3, r3, "_doc", n2, o2);
      }, e2.object = {}, e2.object.vals = function(t4) {
        for (var e3 = Object.keys(t4), r3 = e3.length, n2 = [];r3--; )
          n2.push(t4[e3[r3]]);
        return n2;
      };
      var I = Object.prototype.hasOwnProperty;
      e2.object.hasOwnProperty = function(t4, e3) {
        return I.call(t4, e3);
      }, e2.isNullOrUndefined = function(t4) {
        return t4 == null;
      }, e2.array = {}, e2.array.flatten = function t(e3, r3, n2) {
        return n2 || (n2 = []), e3.forEach(function(e4) {
          Array.isArray(e4) ? t(e4, r3, n2) : r3 && !r3(e4) || n2.push(e4);
        }), n2;
      };
      var B = Object.prototype.hasOwnProperty;
      e2.hasUserDefinedProperty = function(t4, r3) {
        if (t4 == null)
          return false;
        if (Array.isArray(r3)) {
          var n2, o2 = s(r3);
          try {
            for (o2.s();!(n2 = o2.n()).done; ) {
              var i2 = n2.value;
              if (e2.hasUserDefinedProperty(t4, i2))
                return true;
            }
          } catch (t5) {
            o2.e(t5);
          } finally {
            o2.f();
          }
          return false;
        }
        if (B.call(t4, r3))
          return true;
        if (c(t4) === "object" && r3 in t4) {
          var a2 = t4[r3];
          return a2 !== Object.prototype[r3] && a2 !== Array.prototype[r3];
        }
        return false;
      };
      var M = Math.pow(2, 32) - 1;
      e2.isArrayIndex = function(t4) {
        return typeof t4 == "number" ? t4 >= 0 && t4 <= M : typeof t4 == "string" && !!/^\d+$/.test(t4) && (t4 = +t4) >= 0 && t4 <= M;
      }, e2.array.unique = function(t4) {
        var e3, r3 = new Set, n2 = new Set, o2 = [], i2 = s(t4);
        try {
          for (i2.s();!(e3 = i2.n()).done; ) {
            var a2 = e3.value;
            if (typeof a2 == "number" || typeof a2 == "string" || a2 == null) {
              if (r3.has(a2))
                continue;
              o2.push(a2), r3.add(a2);
            } else if (w(a2, "ObjectId")) {
              if (n2.has(a2.toString()))
                continue;
              o2.push(a2), n2.add(a2.toString());
            } else
              o2.push(a2);
          }
        } catch (t5) {
          i2.e(t5);
        } finally {
          i2.f();
        }
        return o2;
      }, e2.buffer = {}, e2.buffer.areEqual = function(t4, e3) {
        if (!n.isBuffer(t4))
          return false;
        if (!n.isBuffer(e3))
          return false;
        if (t4.length !== e3.length)
          return false;
        for (var r3 = 0, o2 = t4.length;r3 < o2; ++r3)
          if (t4[r3] !== e3[r3])
            return false;
        return true;
      }, e2.getFunctionName = S, e2.decorate = function(t4, e3) {
        for (var r3 in e3)
          A.has(r3) || (t4[r3] = e3[r3]);
      }, e2.mergeClone = function(t4, r3) {
        $(r3) && (r3 = r3.toObject({ transform: false, virtuals: false, depopulate: true, getters: false, flattenDecimals: false }));
        for (var o2, i2 = Object.keys(r3), s2 = i2.length, a2 = 0;a2 < s2; )
          if (o2 = i2[a2++], !A.has(o2))
            if (t4[o2] === undefined)
              t4[o2] = b(r3[o2], { transform: false, virtuals: false, depopulate: true, getters: false, flattenDecimals: false });
            else {
              var u2 = r3[o2];
              if (u2 == null || !u2.valueOf || u2 instanceof Date || (u2 = u2.valueOf()), e2.isObject(u2)) {
                var c2 = u2;
                $(u2) && !u2.isMongooseBuffer && (c2 = c2.toObject({ transform: false, virtuals: false, depopulate: true, getters: false, flattenDecimals: false })), u2.isMongooseBuffer && (c2 = n.from(c2)), e2.mergeClone(t4[o2], c2);
              } else
                t4[o2] = b(u2, { flattenDecimals: false });
            }
      }, e2.each = function(t4, e3) {
        var r3, n2 = s(t4);
        try {
          for (n2.s();!(r3 = n2.n()).done; )
            e3(r3.value);
        } catch (t5) {
          n2.e(t5);
        } finally {
          n2.f();
        }
      }, e2.renameObjKey = function(t4, e3, r3) {
        return Object.keys(t4).reduce(function(n2, o2) {
          return o2 === e3 ? n2[r3] = t4[e3] : n2[o2] = t4[o2], n2;
        }, {});
      }, e2.getOption = function(t4) {
        var e3, r3 = s(Array.prototype.slice.call(arguments, 1));
        try {
          for (r3.s();!(e3 = r3.n()).done; ) {
            var n2 = e3.value;
            if (n2 != null && n2[t4] != null)
              return n2[t4];
          }
        } catch (t5) {
          r3.e(t5);
        } finally {
          r3.f();
        }
        return null;
      }, e2.noop = function() {}, e2.errorToPOJO = function(t4) {
        if (!(t4 instanceof Error))
          throw new Error("`error` must be `instanceof Error`.");
        var e3, r3 = {}, n2 = s(Object.getOwnPropertyNames(t4));
        try {
          for (n2.s();!(e3 = n2.n()).done; ) {
            var o2 = e3.value;
            r3[o2] = t4[o2];
          }
        } catch (t5) {
          n2.e(t5);
        } finally {
          n2.f();
        }
        return r3;
      }, e2.warn = function(t4) {
        return { env: {} }.emitWarning(t4, { code: "MONGOOSE" });
      }, e2.injectTimestampsOption = function(t4, e3) {
        e3 != null && (t4.timestamps = e3);
      };
    }, 8863: (t3, e2, r2) => {
      var n = r2(2354), o = r2(2268), i = r2(3123), s = r2(5477);
      t3.exports = function(t4) {
        if (t4.length < 1 || typeof t4[0] != "function")
          throw new o("a function is required");
        return s(n, i, t4);
      };
    }, 8866: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o(t4, e3) {
        for (var r3 = 0;r3 < e3.length; r3++) {
          var n2 = e3[r3];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t4, i(n2.key), n2);
        }
      }
      function i(t4) {
        var e3 = function(t5) {
          if (n(t5) != "object" || !t5)
            return t5;
          var e4 = t5[Symbol.toPrimitive];
          if (e4 !== undefined) {
            var r3 = e4.call(t5, "string");
            if (n(r3) != "object")
              return r3;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t5);
        }(t4);
        return n(e3) == "symbol" ? e3 : e3 + "";
      }
      function s() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (s = function() {
          return !!t4;
        })();
      }
      function a() {
        return a = typeof Reflect != "undefined" && Reflect.get ? Reflect.get.bind() : function(t4, e3, r3) {
          var n2 = function(t5, e4) {
            for (;!{}.hasOwnProperty.call(t5, e4) && (t5 = u(t5)) !== null; )
              ;
            return t5;
          }(t4, e3);
          if (n2) {
            var o2 = Object.getOwnPropertyDescriptor(n2, e3);
            return o2.get ? o2.get.call(arguments.length < 3 ? t4 : r3) : o2.value;
          }
        }, a.apply(null, arguments);
      }
      function u(t4) {
        return u = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, u(t4);
      }
      function c(t4, e3) {
        return c = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, c(t4, e3);
      }
      var l = r2(6974), f = r2(6426), p = Symbol("firstValue"), h = function(t4) {
        function e3(t5, r4) {
          var o2, i3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          if (function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), o2 = function(t6, e4, r5) {
            return e4 = u(e4), function(t7, e5) {
              if (e5 && (n(e5) == "object" || typeof e5 == "function"))
                return e5;
              if (e5 !== undefined)
                throw new TypeError("Derived constructors may only return object or undefined");
              return function(t8) {
                if (t8 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t8;
              }(t7);
            }(t6, s() ? Reflect.construct(e4, r5 || [], u(t6).constructor) : e4.apply(t6, r5));
          }(this, e3, [t5, r4, "Union"]), !r4 || !Array.isArray(r4.of) || r4.of.length === 0)
            throw new Error("Union schema type requires an array of types");
          return o2.schemaTypes = r4.of.map(function(e4) {
            return r4.parentSchema.interpretAsType(t5, e4, i3);
          }), o2;
        }
        return function(t5, e4) {
          if (typeof e4 != "function" && e4 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && c(t5, e4);
        }(e3, t4), r3 = e3, i2 = [{ key: "cast", value: function(t5, e4, r4, n2, o2) {
          for (var i3, s2 = p, a2 = 0;a2 < this.schemaTypes.length; ++a2)
            try {
              var u2 = this.schemaTypes[a2].cast(t5, e4, r4, n2, o2);
              if (u2 === t5)
                return u2;
              s2 === p && (s2 = u2);
            } catch (t6) {
              i3 = t6;
            }
          if (s2 !== p)
            return s2;
          throw i3;
        } }, { key: "applySetters", value: function(t5, e4, r4, n2, o2) {
          for (var i3, s2 = p, a2 = 0;a2 < this.schemaTypes.length; ++a2)
            try {
              var u2 = this.schemaTypes[a2]._applySetters(t5, e4, r4, n2, o2);
              if ((u2 = u2 == null ? this.schemaTypes[a2]._castNullish(u2) : this.schemaTypes[a2].cast(u2, e4, r4, n2, o2)) === t5)
                return u2;
              s2 === p && (s2 = u2);
            } catch (t6) {
              i3 = t6;
            }
          if (s2 !== p)
            return s2;
          throw i3;
        } }, { key: "clone", value: function() {
          var t5, r4, n2, o2 = (t5 = e3, r4 = this, typeof (n2 = a(u(1 & 3 ? t5.prototype : t5), "clone", r4)) == "function" ? function(t6) {
            return n2.apply(r4, t6);
          } : n2)([]);
          return o2.schemaTypes = this.schemaTypes.map(function(t6) {
            return t6.clone();
          }), o2;
        } }], i2 && o(r3.prototype, i2), Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3, i2;
      }(f);
      h.schemaName = "Union", h.defaultOptions = {}, h.prototype.OptionsConstructor = l, t3.exports = h;
    }, 8879: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o(t4, e3) {
        for (var r3 = 0;r3 < e3.length; r3++) {
          var n2 = e3[r3];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t4, s(n2.key), n2);
        }
      }
      function i(t4, e3, r3) {
        return e3 && o(t4.prototype, e3), r3 && o(t4, r3), Object.defineProperty(t4, "prototype", { writable: false }), t4;
      }
      function s(t4) {
        var e3 = function(t5) {
          if (n(t5) != "object" || !t5)
            return t5;
          var e4 = t5[Symbol.toPrimitive];
          if (e4 !== undefined) {
            var r3 = e4.call(t5, "string");
            if (n(r3) != "object")
              return r3;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t5);
        }(t4);
        return n(e3) == "symbol" ? e3 : e3 + "";
      }
      var a = r2(4450), u = i(function t(e3) {
        if (function(t4, e4) {
          if (!(t4 instanceof e4))
            throw new TypeError("Cannot call a class as a function");
        }(this, t), e3 == null)
          return this;
        Object.assign(this, a(e3));
      }), c = r2(5761);
      Object.defineProperty(u.prototype, "type", c), Object.defineProperty(u.prototype, "validate", c), Object.defineProperty(u.prototype, "cast", c), Object.defineProperty(u.prototype, "required", c), Object.defineProperty(u.prototype, "default", c), Object.defineProperty(u.prototype, "ref", c), Object.defineProperty(u.prototype, "refPath", c), Object.defineProperty(u.prototype, "select", c), Object.defineProperty(u.prototype, "index", c), Object.defineProperty(u.prototype, "unique", c), Object.defineProperty(u.prototype, "immutable", c), Object.defineProperty(u.prototype, "sparse", c), Object.defineProperty(u.prototype, "text", c), Object.defineProperty(u.prototype, "transform", c), t3.exports = u;
    }, 8920: (t3, e2, r2) => {
      var n = r2(5832).hp;
      function o(t4) {
        return o = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, o(t4);
      }
      function i(t4, e3) {
        var r3 = typeof Symbol != "undefined" && t4[Symbol.iterator] || t4["@@iterator"];
        if (!r3) {
          if (Array.isArray(t4) || (r3 = s(t4)) || e3 && t4 && typeof t4.length == "number") {
            r3 && (t4 = r3);
            var n2 = 0, o2 = function() {};
            return { s: o2, n: function() {
              return n2 >= t4.length ? { done: true } : { done: false, value: t4[n2++] };
            }, e: function(t5) {
              throw t5;
            }, f: o2 };
          }
          throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        var i2, a2 = true, u2 = false;
        return { s: function() {
          r3 = r3.call(t4);
        }, n: function() {
          var t5 = r3.next();
          return a2 = t5.done, t5;
        }, e: function(t5) {
          u2 = true, i2 = t5;
        }, f: function() {
          try {
            a2 || r3.return == null || r3.return();
          } finally {
            if (u2)
              throw i2;
          }
        } };
      }
      function s(t4, e3) {
        if (t4) {
          if (typeof t4 == "string")
            return a(t4, e3);
          var r3 = {}.toString.call(t4).slice(8, -1);
          return r3 === "Object" && t4.constructor && (r3 = t4.constructor.name), r3 === "Map" || r3 === "Set" ? Array.from(t4) : r3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? a(t4, e3) : undefined;
        }
      }
      function a(t4, e3) {
        (e3 == null || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = Array(e3);r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      var u = r2(2400), c = r2(6547), l = r2(8213), f = r2(4473), p = r2(4450), h = r2(3303)._, y = r2(5678), d = r2(8768), b = r2(3305), m = r2(7930).arrayAtomicsSymbol, v = r2(7930).arrayParentSymbol, g = r2(7930).arrayPathSymbol, _ = r2(7930).arraySchemaSymbol, w = r2(7930).populateModelSymbol, O = Symbol("mongoose#Array#sliced"), S = Array.prototype.push, $ = { $__getAtomics: function() {
        var t4 = [], e3 = Object.keys(this[m] || {}), r3 = e3.length, n2 = Object.assign({}, h, { _isNested: true });
        if (r3 === 0)
          return t4[0] = ["$set", this.toObject(n2)], t4;
        for (;r3--; ) {
          var o2 = e3[r3], i2 = this[m][o2];
          d.isMongooseObject(i2) ? i2 = i2.toObject(n2) : Array.isArray(i2) ? i2 = this.toObject.call(i2, n2) : i2 != null && Array.isArray(i2.$each) ? i2.$each = this.toObject.call(i2.$each, n2) : i2 != null && typeof i2.valueOf == "function" && (i2 = i2.valueOf()), o2 === "$addToSet" && (i2 = { $each: i2 }), t4.push([o2, i2]);
        }
        return t4;
      }, $atomics: function() {
        return this[m];
      }, $parent: function() {
        return this[v];
      }, $path: function() {
        return this[g];
      }, $shift: function() {
        this._registerAtomic("$pop", -1), this._markModified();
        var t4 = this.__array;
        if (!t4._shifted)
          return t4._shifted = true, [].shift.call(t4);
      }, $pop: function() {
        if (this._registerAtomic("$pop", 1), this._markModified(), !this._popped)
          return this._popped = true, [].pop.call(this);
      }, $schema: function() {
        return this[_];
      }, _cast: function(t4) {
        var e3, r3 = false, o2 = this[v];
        if (o2 && (r3 = o2.$populated(this[g], true)), r3 && t4 != null) {
          if ((e3 = r3.options[w]) == null)
            throw new l("No populated model found for path `" + this[g] + "`. This is likely a bug in Mongoose, please report an issue on github.com/Automattic/mongoose.");
          return (n.isBuffer(t4) || b(t4, "ObjectId") || !d.isObject(t4)) && (t4 = { _id: t4 }), t4.schema && t4.schema.discriminatorMapping && t4.schema.discriminatorMapping.key !== undefined || (t4 = new e3(t4)), this[_].caster.applySetters(t4, o2, true);
        }
        return this[_].caster.applySetters(t4, o2, false);
      }, _mapCast: function(t4, e3) {
        return this._cast(t4, this.length + e3);
      }, _markModified: function(t4) {
        var e3, r3 = this[v];
        if (r3) {
          if (e3 = this[g], arguments.length && (e3 = e3 + "." + t4), e3 != null && e3.endsWith(".$"))
            return this;
          r3.markModified(e3, arguments.length !== 0 ? t4 : r3);
        }
        return this;
      }, _registerAtomic: function(t4, e3) {
        if (!this[O]) {
          if (t4 === "$set")
            return this[m] = { $set: e3 }, f(this[v], this[g]), this._markModified(), this;
          var r3, n2 = this[m];
          if (t4 === "$pop" && !("$pop" in n2)) {
            var o2 = this;
            this[v].once("save", function() {
              o2._popped = o2._shifted = null;
            });
          }
          if (n2.$set || Object.keys(n2).length && !(t4 in n2))
            return this[m] = { $set: this }, this;
          if (t4 === "$pullAll" || t4 === "$addToSet")
            n2[t4] || (n2[t4] = []), n2[t4] = n2[t4].concat(e3);
          else if (t4 === "$pullDocs") {
            var u2 = n2.$pull || (n2.$pull = {});
            e3[0] instanceof c ? (r3 = u2.$or || (u2.$or = []), Array.prototype.push.apply(r3, e3.map(function(t5) {
              return t5.toObject({ transform: function(e4, r4) {
                return t5 == null || t5.$__ == null || Object.keys(t5.$__.activePaths.getStatePaths("default")).forEach(function(t6) {
                  y.unset(t6, r4), j(r4, t6);
                }), r4;
              }, virtuals: false });
            }))) : (r3 = u2._id || (u2._id = { $in: [] })).$in = r3.$in.concat(e3);
          } else if (t4 === "$push")
            if (n2.$push = n2.$push || { $each: [] }, e3 != null && d.hasUserDefinedProperty(e3, "$each"))
              n2.$push = e3;
            else if (e3.length === 1)
              n2.$push.$each.push(e3[0]);
            else if (e3.length < 1e4) {
              var l2;
              (l2 = n2.$push.$each).push.apply(l2, function(t5) {
                if (Array.isArray(t5))
                  return a(t5);
              }(_2 = e3) || function(t5) {
                if (typeof Symbol != "undefined" && t5[Symbol.iterator] != null || t5["@@iterator"] != null)
                  return Array.from(t5);
              }(_2) || s(_2) || function() {
                throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
              }());
            } else {
              var p2, h2 = i(e3);
              try {
                for (h2.s();!(p2 = h2.n()).done; ) {
                  var b2 = p2.value;
                  n2.$push.$each.push(b2);
                }
              } catch (t5) {
                h2.e(t5);
              } finally {
                h2.f();
              }
            }
          else
            n2[t4] = e3;
          return this;
        }
        var _2;
      }, addToSet: function() {
        P(this, arguments), A(this, arguments);
        var t4 = [].map.call(arguments, this._mapCast, this), e3 = [], r3 = "";
        t4[0] instanceof c ? r3 = "doc" : t4[0] instanceof Date ? r3 = "date" : b(t4[0], "ObjectId") && (r3 = "ObjectId");
        var n2 = d.isMongooseArray(t4) ? t4.__array : t4, o2 = d.isMongooseArray(this) ? this.__array : this;
        return n2.forEach(function(t5) {
          var n3, i2 = +t5;
          switch (r3) {
            case "doc":
              n3 = this.some(function(e4) {
                return e4.equals(t5);
              });
              break;
            case "date":
              n3 = this.some(function(t6) {
                return +t6 === i2;
              });
              break;
            case "ObjectId":
              n3 = this.find(function(e4) {
                return e4.toString() === t5.toString();
              });
              break;
            default:
              n3 = ~this.indexOf(t5);
          }
          n3 || (this._markModified(), o2.push(t5), this._registerAtomic("$addToSet", t5), [].push.call(e3, t5));
        }, this), e3;
      }, hasAtomics: function() {
        return d.isPOJO(this[m]) ? Object.keys(this[m]).length : 0;
      }, includes: function(t4, e3) {
        return this.indexOf(t4, e3) !== -1;
      }, indexOf: function(t4, e3) {
        b(t4, "ObjectId") && (t4 = t4.toString()), e3 = e3 == null ? 0 : e3;
        for (var r3 = this.length, n2 = e3;n2 < r3; ++n2)
          if (t4 == this[n2])
            return n2;
        return -1;
      }, inspect: function() {
        return JSON.stringify(this);
      }, nonAtomicPush: function() {
        var t4 = [].map.call(arguments, this._mapCast, this);
        this._markModified();
        var e3 = [].push.apply(this, t4);
        return this._registerAtomic("$set", this), e3;
      }, pop: function() {
        this._markModified();
        var t4 = [].pop.call(this);
        return this._registerAtomic("$set", this), t4;
      }, pull: function() {
        var t4 = this, e3 = [].map.call(arguments, function(e4, r4) {
          return t4._cast(e4, r4, { defaults: false });
        }, this), r3 = this[v].get(this[g]);
        d.isMongooseArray(r3) && (r3 = r3.__array);
        var n2, o2 = r3.length;
        for (this._markModified();o2--; )
          (n2 = r3[o2]) instanceof u ? e3.some(function(t5) {
            return n2.equals(t5);
          }) && r3.splice(o2, 1) : ~this.indexOf.call(e3, n2) && r3.splice(o2, 1);
        return e3[0] instanceof c ? this._registerAtomic("$pullDocs", e3.map(function(t5) {
          var e4 = t5.$__getValue("_id");
          return e4 === undefined || t5.$isDefault("_id") ? t5 : e4;
        })) : this._registerAtomic("$pullAll", e3), f(this[v], this[g]) > 0 && this._registerAtomic("$set", this), this;
      }, push: function() {
        var t4, e3 = arguments, r3 = e3, n2 = e3[0] != null && d.hasUserDefinedProperty(e3[0], "$each"), o2 = d.isMongooseArray(this) ? this.__array : this;
        if (n2 && (r3 = e3[0], e3 = e3[0].$each), this[_] == null)
          return S.apply(this, e3);
        P(this, e3), A(this, e3), e3 = [].map.call(e3, this._mapCast, this);
        var i2 = this[m];
        return this._markModified(), n2 ? (r3.$each = e3, (i2.$push && i2.$push.$each && i2.$push.$each.length || 0) !== 0 && i2.$push.$position != r3.$position ? (r3.$position != null ? ([].splice.apply(o2, [r3.$position, 0].concat(e3)), t4 = o2.length) : t4 = [].push.apply(o2, e3), this._registerAtomic("$set", this)) : r3.$position != null ? ([].splice.apply(o2, [r3.$position, 0].concat(e3)), t4 = this.length) : t4 = [].push.apply(o2, e3)) : (r3 = e3, t4 = S.apply(o2, e3)), this._registerAtomic("$push", r3), t4;
      }, remove: function() {
        return this.pull.apply(this, arguments);
      }, set: function(t4, e3, r3) {
        var n2 = this.__array;
        if (r3)
          return n2[t4] = e3, this;
        var o2 = $._cast.call(this, e3, t4);
        return $._markModified.call(this, t4), n2[t4] = o2, this;
      }, shift: function() {
        var t4 = d.isMongooseArray(this) ? this.__array : this;
        this._markModified();
        var e3 = [].shift.call(t4);
        return this._registerAtomic("$set", this), e3;
      }, sort: function() {
        var t4 = d.isMongooseArray(this) ? this.__array : this, e3 = [].sort.apply(t4, arguments);
        return this._registerAtomic("$set", this), e3;
      }, splice: function() {
        var t4, e3 = d.isMongooseArray(this) ? this.__array : this;
        if (this._markModified(), P(this, Array.prototype.slice.call(arguments, 2)), arguments.length) {
          var r3;
          if (this[_] == null)
            r3 = arguments;
          else {
            r3 = [];
            for (var n2 = 0;n2 < arguments.length; ++n2)
              r3[n2] = n2 < 2 ? arguments[n2] : this._cast(arguments[n2], arguments[0] + (n2 - 2));
          }
          t4 = [].splice.apply(e3, r3), this._registerAtomic("$set", this);
        }
        return t4;
      }, toBSON: function() {
        return this.toObject(h);
      }, toObject: function(t4) {
        var e3 = d.isMongooseArray(this) ? this.__array : this;
        return t4 && t4.depopulate ? ((t4 = p(t4))._isNested = true, [].concat(e3).map(function(e4) {
          return e4 instanceof u ? e4.toObject(t4) : e4;
        })) : [].concat(e3);
      }, $toObject: function() {
        return this.constructor.prototype.toObject.apply(this, arguments);
      }, unshift: function() {
        var t4;
        P(this, arguments), t4 = this[_] == null ? arguments : [].map.call(arguments, this._cast, this);
        var e3 = d.isMongooseArray(this) ? this.__array : this;
        return this._markModified(), [].unshift.apply(e3, t4), this._registerAtomic("$set", this), this.length;
      } };
      function j(t4, e3, r3) {
        if (typeof e3 == "string") {
          if (e3.indexOf(".") === -1)
            return;
          e3 = y.stringToParts(e3);
        }
        (r3 = r3 || 0) >= e3.length || t4 != null && o(t4) === "object" && (j(t4[e3[0]], e3, r3 + 1), t4[e3[0]] != null && o(t4[e3[0]]) === "object" && Object.keys(t4[e3[0]]).length === 0 && delete t4[e3[0]]);
      }
      function P(t4, e3) {
        var r3, n2, s2, a2 = t4 == null ? null : t4[_] && t4[_].caster && t4[_].caster.options && t4[_].caster.options.ref || null;
        t4.length === 0 && e3.length !== 0 && function(t5, e4) {
          if (!e4)
            return false;
          var r4, n3 = i(t5);
          try {
            for (n3.s();!(r4 = n3.n()).done; ) {
              var o2 = r4.value;
              if (o2 == null)
                return false;
              var s3 = o2.constructor;
              if (!(o2 instanceof u) || s3.modelName !== e4 && s3.baseModelName !== e4)
                return false;
            }
          } catch (t6) {
            n3.e(t6);
          } finally {
            n3.f();
          }
          return true;
        }(e3, a2) && t4[v].$populated(t4[g], [], (r3 = {}, n2 = w, s2 = e3[0].constructor, ((n2 = function(t5) {
          var e4 = function(t6) {
            if (o(t6) != "object" || !t6)
              return t6;
            var e5 = t6[Symbol.toPrimitive];
            if (e5 !== undefined) {
              var r4 = e5.call(t6, "string");
              if (o(r4) != "object")
                return r4;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t6);
          }(t5);
          return o(e4) == "symbol" ? e4 : e4 + "";
        }(n2)) in r3) ? Object.defineProperty(r3, n2, { value: s2, enumerable: true, configurable: true, writable: true }) : r3[n2] = s2, r3));
      }
      function A(t4, e3) {
        var r3 = t4 == null ? null : t4[_] && t4[_].caster && t4[_].caster.options && t4[_].caster.options.ref || null, s2 = t4[v], a2 = t4[g];
        if (r3 && s2.populated(a2)) {
          var u2, c2 = i(e3);
          try {
            for (c2.s();!(u2 = c2.n()).done; ) {
              var l2 = u2.value;
              if (l2 != null && (o(l2) !== "object" || l2 instanceof String || l2 instanceof Number || l2 instanceof n || d.isMongooseType(l2))) {
                s2.depopulate(a2);
                break;
              }
            }
          } catch (t5) {
            c2.e(t5);
          } finally {
            c2.f();
          }
        }
      }
      for (var E = function() {
        var t4 = T[x];
        if (Array.prototype[t4] == null)
          return 1;
        $[t4] = function() {
          var e3 = d.isMongooseArray(this) ? this.__array : this, r3 = [].concat(e3);
          return r3[t4].apply(r3, arguments);
        };
      }, x = 0, T = ["filter", "flat", "flatMap", "map", "slice"];x < T.length; x++)
        E();
      t3.exports = $;
    }, 8953: (t3, e2, r2) => {
      var n = r2(3609);
      t3.exports = function(e3, r3) {
        if (t3.exports.convertToTrue.has(e3))
          return true;
        if (t3.exports.convertToFalse.has(e3))
          return false;
        if (e3 == null)
          return e3;
        throw new n("boolean", e3, r3);
      }, t3.exports.convertToTrue = new Set([true, "true", 1, "1", "yes"]), t3.exports.convertToFalse = new Set([false, "false", 0, "0", "no"]);
    }, 8995: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (o = function() {
          return !!t4;
        })();
      }
      function i(t4) {
        return i = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, i(t4);
      }
      function s(t4, e3) {
        return s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s(t4, e3);
      }
      var a = function(t4) {
        function e3(t5, r4, s2) {
          var a2;
          return function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), (a2 = function(t6, e4, r5) {
            return e4 = i(e4), function(t7, e5) {
              if (e5 && (n(e5) == "object" || typeof e5 == "function"))
                return e5;
              if (e5 !== undefined)
                throw new TypeError("Derived constructors may only return object or undefined");
              return function(t8) {
                if (t8 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t8;
              }(t7);
            }(t6, o() ? Reflect.construct(e4, r5 || [], i(t6).constructor) : e4.apply(t6, r5));
          }(this, e3, [r4 = r4 || "Field `" + t5 + "` is not in schema and strict mode is set to throw."])).isImmutableError = !!s2, a2.path = t5, a2;
        }
        return function(t5, e4) {
          if (typeof e4 != "function" && e4 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(8213));
      Object.defineProperty(a.prototype, "name", { value: "StrictModeError" }), t3.exports = a;
    }, 9064: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var o = r2(3609), i = r2(8953), s = r2(1244);
      t3.exports = function(t4, e3) {
        if (t4 == null || n(t4) !== "object")
          throw new o("$text", t4, e3);
        return t4.$search != null && (t4.$search = s(t4.$search, e3 + ".$search")), t4.$language != null && (t4.$language = s(t4.$language, e3 + ".$language")), t4.$caseSensitive != null && (t4.$caseSensitive = i(t4.$caseSensitive, e3 + ".$castSensitive")), t4.$diacriticSensitive != null && (t4.$diacriticSensitive = i(t4.$diacriticSensitive, e3 + ".$diacriticSensitive")), t4;
      };
    }, 9068: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o(t4, e3, r3) {
        return e3 in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      function i(t4, e3) {
        for (var r3 = 0;r3 < e3.length; r3++) {
          var n2 = e3[r3];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t4, n2.key, n2);
        }
      }
      function s(t4, e3) {
        return !e3 || p(e3) !== "object" && typeof e3 != "function" ? a(t4) : e3;
      }
      function a(t4) {
        if (t4 === undefined)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t4;
      }
      function u(t4) {
        var e3 = typeof Map == "function" ? new Map : undefined;
        return u = function(t5) {
          if (t5 === null || (r3 = t5, Function.toString.call(r3).indexOf("[native code]") === -1))
            return t5;
          var r3;
          if (typeof t5 != "function")
            throw new TypeError("Super expression must either be null or a function");
          if (e3 !== undefined) {
            if (e3.has(t5))
              return e3.get(t5);
            e3.set(t5, n2);
          }
          function n2() {
            return c(t5, arguments, f(this).constructor);
          }
          return n2.prototype = Object.create(t5.prototype, { constructor: { value: n2, enumerable: false, writable: true, configurable: true } }), l(n2, t5);
        }, u(t4);
      }
      function c(t4, e3, r3) {
        return c = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), true;
          } catch (t5) {
            return false;
          }
        }() ? Reflect.construct : function(t5, e4, r4) {
          var n2 = [null];
          n2.push.apply(n2, e4);
          var o2 = new (Function.bind.apply(t5, n2));
          return r4 && l(o2, r4.prototype), o2;
        }, c.apply(null, arguments);
      }
      function l(t4, e3) {
        return l = Object.setPrototypeOf || function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, l(t4, e3);
      }
      function f(t4) {
        return f = Object.setPrototypeOf ? Object.getPrototypeOf : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, f(t4);
      }
      function p(t4) {
        return p = typeof Symbol == "function" && n(Symbol.iterator) === "symbol" ? function(t5) {
          return n(t5);
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : n(t5);
        }, p(t4);
      }
      var h = r2(7352).inspect, y = r2(3743).codes.ERR_INVALID_ARG_TYPE;
      function d(t4, e3, r3) {
        return (r3 === undefined || r3 > t4.length) && (r3 = t4.length), t4.substring(r3 - e3.length, r3) === e3;
      }
      var b = "", m = "", v = "", g = "", _ = { deepStrictEqual: "Expected values to be strictly deep-equal:", strictEqual: "Expected values to be strictly equal:", strictEqualObject: 'Expected "actual" to be reference-equal to "expected":', deepEqual: "Expected values to be loosely deep-equal:", equal: "Expected values to be loosely equal:", notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:', notStrictEqual: 'Expected "actual" to be strictly unequal to:', notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":', notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:', notEqual: 'Expected "actual" to be loosely unequal to:', notIdentical: "Values identical but not reference-equal:" };
      function w(t4) {
        var e3 = Object.keys(t4), r3 = Object.create(Object.getPrototypeOf(t4));
        return e3.forEach(function(e4) {
          r3[e4] = t4[e4];
        }), Object.defineProperty(r3, "message", { value: t4.message }), r3;
      }
      function O(t4) {
        return h(t4, { compact: false, customInspect: false, depth: 1000, maxArrayLength: 1 / 0, showHidden: false, breakLength: 1 / 0, showProxy: false, sorted: true, getters: true });
      }
      var S = function(t4) {
        function e3(t5) {
          var r4;
          if (function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), p(t5) !== "object" || t5 === null)
            throw new y("options", "Object", t5);
          var { message: n3, operator: o2, stackStartFn: i2, actual: u2, expected: c2 } = t5, l2 = Error.stackTraceLimit;
          if (Error.stackTraceLimit = 0, n3 != null)
            r4 = s(this, f(e3).call(this, String(n3)));
          else if ({ env: {} }.stderr && { env: {} }.stderr.isTTY && ({ env: {} }.stderr && { env: {} }.stderr.getColorDepth && { env: {} }.stderr.getColorDepth() !== 1 ? (b = "\x1B[34m", m = "\x1B[32m", g = "\x1B[39m", v = "\x1B[31m") : (b = "", m = "", g = "", v = "")), p(u2) === "object" && u2 !== null && p(c2) === "object" && c2 !== null && "stack" in u2 && u2 instanceof Error && "stack" in c2 && c2 instanceof Error && (u2 = w(u2), c2 = w(c2)), o2 === "deepStrictEqual" || o2 === "strictEqual")
            r4 = s(this, f(e3).call(this, function(t6, e4, r5) {
              var n4 = "", o3 = "", i3 = 0, s2 = "", a2 = false, u3 = O(t6), c3 = u3.split(`
`), l3 = O(e4).split(`
`), f2 = 0, h3 = "";
              if (r5 === "strictEqual" && p(t6) === "object" && p(e4) === "object" && t6 !== null && e4 !== null && (r5 = "strictEqualObject"), c3.length === 1 && l3.length === 1 && c3[0] !== l3[0]) {
                var y2 = c3[0].length + l3[0].length;
                if (y2 <= 10) {
                  if (!(p(t6) === "object" && t6 !== null || p(e4) === "object" && e4 !== null || t6 === 0 && e4 === 0))
                    return "".concat(_[r5], `

`) + "".concat(c3[0], " !== ").concat(l3[0], `
`);
                } else if (r5 !== "strictEqualObject" && y2 < ({ env: {} }.stderr && { env: {} }.stderr.isTTY ? { env: {} }.stderr.columns : 80)) {
                  for (;c3[0][f2] === l3[0][f2]; )
                    f2++;
                  f2 > 2 && (h3 = `
  `.concat(function(t7, e5) {
                    if (e5 = Math.floor(e5), t7.length == 0 || e5 == 0)
                      return "";
                    var r6 = t7.length * e5;
                    for (e5 = Math.floor(Math.log(e5) / Math.log(2));e5; )
                      t7 += t7, e5--;
                    return t7 + t7.substring(0, r6 - t7.length);
                  }(" ", f2), "^"), f2 = 0);
                }
              }
              for (var w2 = c3[c3.length - 1], S3 = l3[l3.length - 1];w2 === S3 && (f2++ < 2 ? s2 = `
  `.concat(w2).concat(s2) : n4 = w2, c3.pop(), l3.pop(), c3.length !== 0 && l3.length !== 0); )
                w2 = c3[c3.length - 1], S3 = l3[l3.length - 1];
              var $2 = Math.max(c3.length, l3.length);
              if ($2 === 0) {
                var j2 = u3.split(`
`);
                if (j2.length > 30)
                  for (j2[26] = "".concat(b, "...").concat(g);j2.length > 27; )
                    j2.pop();
                return "".concat(_.notIdentical, `

`).concat(j2.join(`
`), `
`);
              }
              f2 > 3 && (s2 = `
`.concat(b, "...").concat(g).concat(s2), a2 = true), n4 !== "" && (s2 = `
  `.concat(n4).concat(s2), n4 = "");
              var P2 = 0, A = _[r5] + `
`.concat(m, "+ actual").concat(g, " ").concat(v, "- expected").concat(g), E = " ".concat(b, "...").concat(g, " Lines skipped");
              for (f2 = 0;f2 < $2; f2++) {
                var x = f2 - i3;
                if (c3.length < f2 + 1)
                  x > 1 && f2 > 2 && (x > 4 ? (o3 += `
`.concat(b, "...").concat(g), a2 = true) : x > 3 && (o3 += `
  `.concat(l3[f2 - 2]), P2++), o3 += `
  `.concat(l3[f2 - 1]), P2++), i3 = f2, n4 += `
`.concat(v, "-").concat(g, " ").concat(l3[f2]), P2++;
                else if (l3.length < f2 + 1)
                  x > 1 && f2 > 2 && (x > 4 ? (o3 += `
`.concat(b, "...").concat(g), a2 = true) : x > 3 && (o3 += `
  `.concat(c3[f2 - 2]), P2++), o3 += `
  `.concat(c3[f2 - 1]), P2++), i3 = f2, o3 += `
`.concat(m, "+").concat(g, " ").concat(c3[f2]), P2++;
                else {
                  var T = l3[f2], k = c3[f2], N = k !== T && (!d(k, ",") || k.slice(0, -1) !== T);
                  N && d(T, ",") && T.slice(0, -1) === k && (N = false, k += ","), N ? (x > 1 && f2 > 2 && (x > 4 ? (o3 += `
`.concat(b, "...").concat(g), a2 = true) : x > 3 && (o3 += `
  `.concat(c3[f2 - 2]), P2++), o3 += `
  `.concat(c3[f2 - 1]), P2++), i3 = f2, o3 += `
`.concat(m, "+").concat(g, " ").concat(k), n4 += `
`.concat(v, "-").concat(g, " ").concat(T), P2 += 2) : (o3 += n4, n4 = "", x !== 1 && f2 !== 0 || (o3 += `
  `.concat(k), P2++));
                }
                if (P2 > 20 && f2 < $2 - 2)
                  return "".concat(A).concat(E, `
`).concat(o3, `
`).concat(b, "...").concat(g).concat(n4, `
`) + "".concat(b, "...").concat(g);
              }
              return "".concat(A).concat(a2 ? E : "", `
`).concat(o3).concat(n4).concat(s2).concat(h3);
            }(u2, c2, o2)));
          else if (o2 === "notDeepStrictEqual" || o2 === "notStrictEqual") {
            var h2 = _[o2], S2 = O(u2).split(`
`);
            if (o2 === "notStrictEqual" && p(u2) === "object" && u2 !== null && (h2 = _.notStrictEqualObject), S2.length > 30)
              for (S2[26] = "".concat(b, "...").concat(g);S2.length > 27; )
                S2.pop();
            r4 = S2.length === 1 ? s(this, f(e3).call(this, "".concat(h2, " ").concat(S2[0]))) : s(this, f(e3).call(this, "".concat(h2, `

`).concat(S2.join(`
`), `
`)));
          } else {
            var $ = O(u2), j = "", P = _[o2];
            o2 === "notDeepEqual" || o2 === "notEqual" ? ($ = "".concat(_[o2], `

`).concat($)).length > 1024 && ($ = "".concat($.slice(0, 1021), "...")) : (j = "".concat(O(c2)), $.length > 512 && ($ = "".concat($.slice(0, 509), "...")), j.length > 512 && (j = "".concat(j.slice(0, 509), "...")), o2 === "deepEqual" || o2 === "equal" ? $ = "".concat(P, `

`).concat($, `

should equal

`) : j = " ".concat(o2, " ").concat(j)), r4 = s(this, f(e3).call(this, "".concat($).concat(j)));
          }
          return Error.stackTraceLimit = l2, r4.generatedMessage = !n3, Object.defineProperty(a(r4), "name", { value: "AssertionError [ERR_ASSERTION]", enumerable: false, writable: true, configurable: true }), r4.code = "ERR_ASSERTION", r4.actual = u2, r4.expected = c2, r4.operator = o2, Error.captureStackTrace && Error.captureStackTrace(a(r4), i2), r4.stack, r4.name = "AssertionError", s(r4);
        }
        var r3, n2;
        return function(t5, e4) {
          if (typeof e4 != "function" && e4 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), e4 && l(t5, e4);
        }(e3, t4), r3 = e3, n2 = [{ key: "toString", value: function() {
          return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
        } }, { key: h.custom, value: function(t5, e4) {
          return h(this, function(t6) {
            for (var e5 = 1;e5 < arguments.length; e5++) {
              var r4 = arguments[e5] != null ? arguments[e5] : {}, n3 = Object.keys(r4);
              typeof Object.getOwnPropertySymbols == "function" && (n3 = n3.concat(Object.getOwnPropertySymbols(r4).filter(function(t7) {
                return Object.getOwnPropertyDescriptor(r4, t7).enumerable;
              }))), n3.forEach(function(e6) {
                o(t6, e6, r4[e6]);
              });
            }
            return t6;
          }({}, e4, { customInspect: false, depth: 0 }));
        } }], n2 && i(r3.prototype, n2), e3;
      }(u(Error));
      t3.exports = S;
    }, 9122: (t3, e2, r2) => {
      var n = r2(3900), o = r2(988), i = r2(8863), s = r2(5804);
      t3.exports = function(t4) {
        var e3 = i(arguments), r3 = t4.length - (arguments.length - 1);
        return n(e3, 1 + (r3 > 0 ? r3 : 0), true);
      }, o ? o(t3.exports, "apply", { value: s }) : t3.exports.apply = s;
    }, 9123: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function i(t4) {
        for (var e3 = 1;e3 < arguments.length; e3++) {
          var r3 = arguments[e3] != null ? arguments[e3] : {};
          e3 % 2 ? o(Object(r3), true).forEach(function(e4) {
            s(t4, e4, r3[e4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : o(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      function s(t4, e3, r3) {
        return (e3 = function(t5) {
          var e4 = function(t6) {
            if (n(t6) != "object" || !t6)
              return t6;
            var e5 = t6[Symbol.toPrimitive];
            if (e5 !== undefined) {
              var r4 = e5.call(t6, "string");
              if (n(r4) != "object")
                return r4;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t6);
          }(t5);
          return n(e4) == "symbol" ? e4 : e4 + "";
        }(e3)) in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      var a, u, c = r2(3609), l = r2(8235), f = r2(3550).EventEmitter, p = r2(7760), h = r2(4561), y = r2(6426), d = r2(7982), b = r2(4327), m = r2(1469), v = r2(1313), g = r2(3216), _ = r2(5110), w = r2(8768), O = r2(7910), S = r2(5537), $ = r2(7930).arrayAtomicsSymbol, j = r2(7930).arrayPathSymbol, P = r2(7930).documentArrayParent;
      function A(t4, e3, r3, n2) {
        if (e3.options && e3.options.timeseries)
          throw new S(t4, "timeseries");
        var o2 = A.defaultOptions && A.defaultOptions._id;
        o2 != null && ((n2 = n2 || {})._id = o2), n2 != null && n2._id != null ? e3 = v(e3, n2) : r3 != null && r3._id != null && (e3 = v(e3, r3));
        var s2 = E(e3, r3);
        s2.prototype.$basePath = t4, p.call(this, t4, s2, r3), this.schema = e3, this.schemaOptions = n2 || {}, this.$isMongooseDocumentArray = true, this.Constructor = s2, s2.base = e3.base;
        var a2 = this.defaultValue;
        "defaultValue" in this && a2 == null || this.default(function() {
          var t5 = a2.call(this);
          return t5 == null || Array.isArray(t5) || (t5 = [t5]), t5;
        }), this.$embeddedSchemaType = new l(t4 + ".$", i(i({}, n2 || {}), {}, { $parentSchemaType: this })), this.$embeddedSchemaType.caster = this.Constructor, this.$embeddedSchemaType.schema = this.schema;
      }
      function E(t4, e3, n2) {
        function o2() {
          u.apply(this, arguments), this.__parentArray != null && this.__parentArray.getArrayParent() != null && this.$session(this.__parentArray.getArrayParent().$session());
        }
        u || (u = r2(6547)), t4._preCompile();
        var i2 = n2 != null ? n2.prototype : u.prototype;
        for (var s2 in o2.prototype = Object.create(i2), o2.prototype.$__setSchema(t4), o2.schema = t4, o2.prototype.constructor = o2, o2.$isArraySubdocument = true, o2.events = new f, o2.base = t4.base, t4.methods)
          o2.prototype[s2] = t4.methods[s2];
        for (var a2 in t4.statics)
          o2[a2] = t4.statics[a2];
        for (var c2 in f.prototype)
          o2[c2] = f.prototype[c2];
        return o2.options = e3, o2;
      }
      A.schemaName = "DocumentArray", A.options = { castNonArrays: true }, A.prototype = Object.create(p.prototype), A.prototype.constructor = A, A.prototype.OptionsConstructor = h, Object.defineProperty(A.prototype, "$conditionalHandlers", { enumerable: false, value: i({}, p.prototype.$conditionalHandlers) }), A.prototype.discriminator = function(t4, e3, r3) {
        var n2;
        typeof t4 == "function" && (t4 = w.getFunctionName(t4)), r3 = r3 || {};
        var o2 = w.isPOJO(r3) ? r3.value : r3, i2 = typeof r3.clone != "boolean" || r3.clone;
        e3.instanceOfSchema && i2 && (e3 = e3.clone());
        var s2 = E(e3 = m(this.casterConstructor, t4, e3, o2, null, null, (n2 = r3) === null || n2 === undefined ? undefined : n2.overwriteExisting), null, this.casterConstructor);
        s2.baseCasterConstructor = this.casterConstructor;
        try {
          Object.defineProperty(s2, "name", { value: t4 });
        } catch (t5) {}
        return this.casterConstructor.discriminators[t4] = s2, this.casterConstructor.discriminators[t4];
      }, A.prototype.doValidate = function(t4, e3, n2, o2) {
        a || (a = r2(4878));
        var i2 = this;
        try {
          y.prototype.doValidate.call(this, t4, function(r3) {
            if (r3)
              return e3(r3);
            var s2, c2 = t4 && t4.length;
            if (!c2)
              return e3();
            if (o2 && o2.updateValidator)
              return e3();
            function l2(t5) {
              t5 != null && (s2 = t5), --c2 || e3(s2);
            }
            w.isMongooseDocumentArray(t4) || (t4 = new a(t4, i2.path, n2));
            for (var f2 = 0, p2 = c2;f2 < p2; ++f2) {
              var h2 = t4[f2];
              if (h2 != null) {
                if (!(h2 instanceof u)) {
                  var y2 = O(i2.casterConstructor, t4[f2]);
                  h2 = t4[f2] = new y2(h2, t4, undefined, undefined, f2);
                }
                o2 == null || !o2.validateModifiedOnly || h2.$isModified() ? h2.$__validate(null, o2, l2) : --c2 || e3(s2);
              } else
                --c2 || e3(s2);
            }
          }, n2);
        } catch (t5) {
          return e3(t5);
        }
      }, A.prototype.doValidateSync = function(t4, e3, r3) {
        var n2 = y.prototype.doValidateSync.call(this, t4, e3);
        if (n2 != null)
          return n2;
        var o2 = t4 && t4.length, i2 = null;
        if (o2) {
          for (var s2 = 0, a2 = o2;s2 < a2; ++s2) {
            var c2 = t4[s2];
            if (c2) {
              if (!(c2 instanceof u)) {
                var l2 = O(this.casterConstructor, t4[s2]);
                c2 = t4[s2] = new l2(c2, t4, undefined, undefined, s2);
              }
              if (r3 == null || !r3.validateModifiedOnly || c2.$isModified()) {
                var f2 = c2.validateSync(r3);
                f2 && i2 == null && (i2 = f2);
              }
            }
          }
          return i2;
        }
      }, A.prototype.getDefault = function(t4, e3, n2) {
        var o2 = typeof this.defaultValue == "function" ? this.defaultValue.call(t4) : this.defaultValue;
        if (o2 == null)
          return o2;
        if (n2 && n2.skipCast)
          return o2;
        a || (a = r2(4878)), Array.isArray(o2) || (o2 = [o2]), o2 = new a(o2, this.path, t4);
        for (var i2 = 0;i2 < o2.length; ++i2) {
          var s2 = new (O(this.casterConstructor, o2[i2]))({}, o2, undefined, undefined, i2);
          s2.$init(o2[i2]), s2.isNew = true, Object.assign(s2.$__.activePaths.default, s2.$__.activePaths.init), s2.$__.activePaths.init = {}, o2[i2] = s2;
        }
        return o2;
      };
      var x = Object.freeze({ transform: false, virtuals: false }), T = Object.freeze({ skipId: false, willInit: true });
      function k(t4, e3, r3) {
        if (r3 && e3) {
          for (var n2, o2, i2, s2 = t4.path + ".", a2 = Object.keys(e3), u2 = a2.length, c2 = {};u2--; )
            if ((o2 = a2[u2]).startsWith(s2)) {
              if ((i2 = o2.substring(s2.length)) === "$")
                continue;
              i2.startsWith("$.") && (i2 = i2.substring(2)), n2 || (n2 = true), c2[i2] = e3[o2];
            }
          return n2 && c2 || undefined;
        }
      }
      A.prototype.cast = function(t4, e3, n2, o2, i2) {
        if (a || (a = r2(4878)), t4 != null && t4[j] != null && t4 === o2)
          return t4;
        var s2, l2, f2 = (i2 = i2 || {}).path || this.path;
        if (!Array.isArray(t4)) {
          if (!n2 && !A.options.castNonArrays)
            throw new c("DocumentArray", t4, this.path, null, this);
          return e3 && n2 && e3.markModified(f2), this.cast([t4], e3, n2, o2, i2);
        }
        i2.skipDocumentArrayCast && !w.isMongooseDocumentArray(t4) || (t4 = new a(t4, f2, e3, this)), o2 != null && (t4[$] = o2[$] || {}), i2.arrayPathIndex != null && (t4[j] = f2 + "." + i2.arrayPathIndex);
        for (var p2 = w.isMongooseDocumentArray(t4) ? t4.__array : t4, h2 = p2.length, y2 = 0;y2 < h2; ++y2)
          if (p2[y2]) {
            var d2 = O(this.casterConstructor, p2[y2]), b2 = g(p2[y2], true);
            if (p2[y2] !== b2 && (p2[y2] = b2), p2[y2] instanceof u) {
              if (p2[y2][P] !== e3)
                if (n2) {
                  var m2 = new d2(null, t4, T, s2, y2);
                  p2[y2] = m2.$init(p2[y2]);
                } else {
                  var v2 = new d2(p2[y2], t4, undefined, undefined, y2);
                  p2[y2] = v2;
                }
              p2[y2].__index == null && p2[y2].$setIndex(y2);
            } else if (p2[y2] != null)
              if (n2)
                e3 ? s2 || (s2 = k(this, e3.$__.selected, n2)) : s2 = true, l2 = new d2(null, t4, T, s2, y2), p2[y2] = l2.$init(p2[y2]);
              else if (o2 && typeof o2.id == "function" && (l2 = o2.id(p2[y2]._id)), o2 && l2 && w.deepEqual(l2.toObject(x), p2[y2]))
                l2.set(p2[y2]), p2[y2] = l2;
              else
                try {
                  l2 = new d2(p2[y2], t4, undefined, undefined, y2), p2[y2] = l2;
                } catch (e4) {
                  throw new c("embedded", p2[y2], t4[j], e4, this);
                }
          }
        return t4;
      }, A.prototype.clone = function() {
        var t4 = Object.assign({}, this.options), e3 = new this.constructor(this.path, this.schema, t4, this.schemaOptions);
        return e3.validators = this.validators.slice(), this.requiredValidator !== undefined && (e3.requiredValidator = this.requiredValidator), e3.Constructor.discriminators = Object.assign({}, this.Constructor.discriminators), e3._appliedDiscriminators = this._appliedDiscriminators, e3;
      }, A.prototype.applyGetters = function(t4, e3) {
        return y.prototype.applyGetters.call(this, t4, e3);
      }, A.defaultOptions = {}, A.set = y.set, A.setters = [], A.get = y.get, A.prototype.$conditionalHandlers.$elemMatch = function(t4, e3) {
        for (var r3, n2 = Object.keys(t4), o2 = n2.length, i2 = 0;i2 < o2; ++i2) {
          var s2 = n2[i2], a2 = t4[s2];
          _(s2) && a2 != null && (t4[s2] = this.castForQuery(s2, a2, e3));
        }
        var u2 = this && this.casterConstructor && this.casterConstructor.schema && this.casterConstructor.schema.options && this.casterConstructor.schema.options.discriminatorKey, c2 = this && this.casterConstructor && this.casterConstructor.schema && this.casterConstructor.schema.discriminators || {};
        if (u2 != null && t4[u2] != null && c2[t4[u2]] != null)
          return d(c2[t4[u2]], t4, null, this && this.$$context);
        var l2 = (r3 = this.casterConstructor.schema) !== null && r3 !== undefined ? r3 : e3.schema;
        return d(l2, t4, null, this && this.$$context);
      }, A.prototype.toJSONSchema = function(t4) {
        var e3 = b("object", "object", t4 == null ? undefined : t4.useBsonType, false), r3 = this.options.required && typeof this.options.required != "function";
        return i(i({}, b("array", "array", t4 == null ? undefined : t4.useBsonType, r3)), {}, { items: i(i({}, e3), this.schema.toJSONSchema(t4)) });
      }, t3.exports = A;
    }, 9166: (t3, e2, r2) => {
      function n(t4, e3) {
        var r3 = typeof Symbol != "undefined" && t4[Symbol.iterator] || t4["@@iterator"];
        if (!r3) {
          if (Array.isArray(t4) || (r3 = function(t5, e4) {
            if (t5) {
              if (typeof t5 == "string")
                return o(t5, e4);
              var r4 = {}.toString.call(t5).slice(8, -1);
              return r4 === "Object" && t5.constructor && (r4 = t5.constructor.name), r4 === "Map" || r4 === "Set" ? Array.from(t5) : r4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r4) ? o(t5, e4) : undefined;
            }
          }(t4)) || e3 && t4 && typeof t4.length == "number") {
            r3 && (t4 = r3);
            var n2 = 0, i2 = function() {};
            return { s: i2, n: function() {
              return n2 >= t4.length ? { done: true } : { done: false, value: t4[n2++] };
            }, e: function(t5) {
              throw t5;
            }, f: i2 };
          }
          throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        var s2, a2 = true, u2 = false;
        return { s: function() {
          r3 = r3.call(t4);
        }, n: function() {
          var t5 = r3.next();
          return a2 = t5.done, t5;
        }, e: function(t5) {
          u2 = true, s2 = t5;
        }, f: function() {
          try {
            a2 || r3.return == null || r3.return();
          } finally {
            if (u2)
              throw s2;
          }
        } };
      }
      function o(t4, e3) {
        (e3 == null || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = Array(e3);r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      var i = r2(8759), s = r2(3696);
      function a(t4, e3, r3) {
        if (e3 != null) {
          var o2 = Object.keys(e3).some(function(t5) {
            return t5[0] === "$";
          });
          if (o2) {
            if (e3.$push && v(e3.$push), e3.$addToSet && v(e3.$addToSet), e3.$set != null)
              for (var i2 = 0, c = Object.keys(e3.$set);i2 < c.length; i2++) {
                var l = c[i2];
                u(r3, l, e3.$set, t4);
              }
            if (e3.$setOnInsert != null)
              for (var f = 0, p = Object.keys(e3.$setOnInsert);f < p.length; f++) {
                var h = p[f];
                u(r3, h, e3.$setOnInsert, t4);
              }
          }
          var y, d = Object.keys(e3).filter(function(t5) {
            return t5[0] !== "$";
          }), b = n(d);
          try {
            for (b.s();!(y = b.n()).done; ) {
              var m = y.value;
              u(r3, m, e3, t4);
            }
          } catch (t5) {
            b.e(t5);
          } finally {
            b.f();
          }
        }
        function v(e4) {
          for (var n2 = function() {
            var n3 = i3[o3], u2 = r3.path(n3.replace(/\.\$\./i, ".").replace(/.\$$/, ""));
            if (e4[n3] && u2 && u2.$isMongooseDocumentArray && u2.schema.options.timestamps) {
              var c2 = u2.schema.options.timestamps, l2 = s(c2, "createdAt"), f2 = s(c2, "updatedAt");
              e4[n3].$each ? e4[n3].$each.forEach(function(e5) {
                f2 != null && (e5[f2] = t4), l2 != null && (e5[l2] = t4), a(t4, e5, u2.schema);
              }) : (f2 != null && (e4[n3][f2] = t4), l2 != null && (e4[n3][l2] = t4), a(t4, e4[n3], u2.schema));
            }
          }, o3 = 0, i3 = Object.keys(e4);o3 < i3.length; o3++)
            n2();
        }
      }
      function u(t4, e3, r3, o2) {
        var u2 = i(e3), c = t4.path(u2);
        if (c) {
          for (var l = [], f = u2.split("."), p = f.length - 1;p > 0; --p) {
            var h = t4.path(f.slice(0, p).join("."));
            h != null && (h.$isMongooseDocumentArray || h.$isSingleNested) && l.push({ parentPath: e3.split(".").slice(0, p).join("."), parentSchemaType: h });
          }
          if (Array.isArray(r3[e3]) && c.$isMongooseDocumentArray)
            (function(t5, e4, r4) {
              var n2 = e4.schema.options.timestamps, o3 = t5.length;
              if (n2)
                for (var i2 = s(n2, "createdAt"), u3 = s(n2, "updatedAt"), c2 = 0;c2 < o3; ++c2)
                  u3 != null && (t5[c2][u3] = r4), i2 != null && (t5[c2][i2] = r4), a(r4, t5[c2], e4.schema);
              else
                for (var l2 = 0;l2 < o3; ++l2)
                  a(r4, t5[l2], e4.schema);
            })(r3[e3], c, o2);
          else if (r3[e3] && c.$isSingleNested)
            (function(t5, e4, r4) {
              var n2 = e4.schema.options.timestamps;
              if (n2) {
                var o3 = s(n2, "createdAt"), i2 = s(n2, "updatedAt");
                i2 != null && (t5[i2] = r4), o3 != null && (t5[o3] = r4), a(r4, t5, e4.schema);
              } else
                a(r4, t5, e4.schema);
            })(r3[e3], c, o2);
          else if (l.length > 0) {
            var y, d = n(l);
            try {
              for (d.s();!(y = d.n()).done; ) {
                var b = y.value, m = b.parentPath, v = b.parentSchemaType, g = v.schema.options.timestamps, _ = s(g, "updatedAt");
                if (g && _ != null) {
                  if (v.$isSingleNested)
                    r3[m + "." + _] = o2;
                  else if (v.$isMongooseDocumentArray) {
                    var w = e3.substring(m.length + 1);
                    if (/^\d+$/.test(w)) {
                      r3[m + "." + w][_] = o2;
                      continue;
                    }
                    var O = w.indexOf(".");
                    r3[m + "." + (w = O !== -1 ? w.substring(0, O) : w) + "." + _] = o2;
                  }
                }
              }
            } catch (t5) {
              d.e(t5);
            } finally {
              d.f();
            }
          } else if (c.schema != null && c.schema != t4 && r3[e3]) {
            var S = c.schema.options.timestamps, $ = s(S, "createdAt"), j = s(S, "updatedAt");
            if (!S)
              return;
            j != null && (r3[e3][j] = o2), $ != null && (r3[e3][$] = o2);
          }
        }
      }
      t3.exports = a;
    }, 9183: (t3) => {
      t3.exports = function(t4) {
        return typeof t4 == "function" && t4.constructor && t4.constructor.name === "AsyncFunction";
      };
    }, 9206: (t3) => {
      t3.exports = EvalError;
    }, 9247: (t3, e2, r2) => {
      var n = r2(2481), o = r2(2273);
      t3.exports = function() {
        var t4 = n();
        return o(Object, { is: t4 }, { is: function() {
          return Object.is !== t4;
        } }), t4;
      };
    }, 9344: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var o, i = r2(3071), s = r2(953)(), a = r2(5994), u = r2(1464);
      if (s) {
        var c = i("RegExp.prototype.exec"), l = {}, f = function() {
          throw l;
        }, p = { toString: f, valueOf: f };
        n(Symbol.toPrimitive) === "symbol" && (p[Symbol.toPrimitive] = f), o = function(t4) {
          if (!t4 || n(t4) !== "object")
            return false;
          var e3 = u(t4, "lastIndex");
          if (!e3 || !a(e3, "value"))
            return false;
          try {
            c(t4, p);
          } catch (t5) {
            return t5 === l;
          }
        };
      } else {
        var h = i("Object.prototype.toString");
        o = function(t4) {
          return !(!t4 || n(t4) !== "object" && typeof t4 != "function") && h(t4) === "[object RegExp]";
        };
      }
      t3.exports = o;
    }, 9380: (t3, e2, r2) => {
      function n() {
        var t4, e3, r3 = typeof Symbol == "function" ? Symbol : {}, i2 = r3.iterator || "@@iterator", s2 = r3.toStringTag || "@@toStringTag";
        function a2(r4, n2, i3, s3) {
          var a3 = n2 && n2.prototype instanceof c2 ? n2 : c2, l3 = Object.create(a3.prototype);
          return o(l3, "_invoke", function(r5, n3, o2) {
            var i4, s4, a4, c3 = 0, l4 = o2 || [], f3 = false, p3 = { p: 0, n: 0, v: t4, a: h2, f: h2.bind(t4, 4), d: function(e4, r6) {
              return i4 = e4, s4 = 0, a4 = t4, p3.n = r6, u2;
            } };
            function h2(r6, n4) {
              for (s4 = r6, a4 = n4, e3 = 0;!f3 && c3 && !o3 && e3 < l4.length; e3++) {
                var o3, i5 = l4[e3], h3 = p3.p, y2 = i5[2];
                r6 > 3 ? (o3 = y2 === n4) && (a4 = i5[(s4 = i5[4]) ? 5 : (s4 = 3, 3)], i5[4] = i5[5] = t4) : i5[0] <= h3 && ((o3 = r6 < 2 && h3 < i5[1]) ? (s4 = 0, p3.v = n4, p3.n = i5[1]) : h3 < y2 && (o3 = r6 < 3 || i5[0] > n4 || n4 > y2) && (i5[4] = r6, i5[5] = n4, p3.n = y2, s4 = 0));
              }
              if (o3 || r6 > 1)
                return u2;
              throw f3 = true, n4;
            }
            return function(o3, l5, y2) {
              if (c3 > 1)
                throw TypeError("Generator is already running");
              for (f3 && l5 === 1 && h2(l5, y2), s4 = l5, a4 = y2;(e3 = s4 < 2 ? t4 : a4) || !f3; ) {
                i4 || (s4 ? s4 < 3 ? (s4 > 1 && (p3.n = -1), h2(s4, a4)) : p3.n = a4 : p3.v = a4);
                try {
                  if (c3 = 2, i4) {
                    if (s4 || (o3 = "next"), e3 = i4[o3]) {
                      if (!(e3 = e3.call(i4, a4)))
                        throw TypeError("iterator result is not an object");
                      if (!e3.done)
                        return e3;
                      a4 = e3.value, s4 < 2 && (s4 = 0);
                    } else
                      s4 === 1 && (e3 = i4.return) && e3.call(i4), s4 < 2 && (a4 = TypeError("The iterator does not provide a '" + o3 + "' method"), s4 = 1);
                    i4 = t4;
                  } else if ((e3 = (f3 = p3.n < 0) ? a4 : r5.call(n3, p3)) !== u2)
                    break;
                } catch (e4) {
                  i4 = t4, s4 = 1, a4 = e4;
                } finally {
                  c3 = 1;
                }
              }
              return { value: e3, done: f3 };
            };
          }(r4, i3, s3), true), l3;
        }
        var u2 = {};
        function c2() {}
        function l2() {}
        function f2() {}
        e3 = Object.getPrototypeOf;
        var p2 = [][i2] ? e3(e3([][i2]())) : (o(e3 = {}, i2, function() {
          return this;
        }), e3), h = f2.prototype = c2.prototype = Object.create(p2);
        function y(t5) {
          return Object.setPrototypeOf ? Object.setPrototypeOf(t5, f2) : (t5.__proto__ = f2, o(t5, s2, "GeneratorFunction")), t5.prototype = Object.create(h), t5;
        }
        return l2.prototype = f2, o(h, "constructor", f2), o(f2, "constructor", l2), l2.displayName = "GeneratorFunction", o(f2, s2, "GeneratorFunction"), o(h), o(h, s2, "Generator"), o(h, i2, function() {
          return this;
        }), o(h, "toString", function() {
          return "[object Generator]";
        }), (n = function() {
          return { w: a2, m: y };
        })();
      }
      function o(t4, e3, r3, n2) {
        var i2 = Object.defineProperty;
        try {
          i2({}, "", {});
        } catch (t5) {
          i2 = 0;
        }
        o = function(t5, e4, r4, n3) {
          function s2(e5, r5) {
            o(t5, e5, function(t6) {
              return this._invoke(e5, r5, t6);
            });
          }
          e4 ? i2 ? i2(t5, e4, { value: r4, enumerable: !n3, configurable: !n3, writable: !n3 }) : t5[e4] = r4 : (s2("next", 0), s2("throw", 1), s2("return", 2));
        }, o(t4, e3, r3, n2);
      }
      function i(t4, e3, r3, n2, o2, i2, s2) {
        try {
          var a2 = t4[i2](s2), u2 = a2.value;
        } catch (t5) {
          return void r3(t5);
        }
        a2.done ? e3(u2) : Promise.resolve(u2).then(n2, o2);
      }
      function s(t4) {
        return s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, s(t4);
      }
      var a = r2(2400), u = r2(2746), c = r2(3303)._, l = r2(7352), f = r2(8768);
      function p(t4, e3, r3, n2, o2) {
        if (s(n2) === "object" && n2 != null && o2 == null && (o2 = n2, n2 = undefined), r3 != null) {
          var i2 = { isNew: r3.isNew };
          "defaults" in r3.$__ && (i2.defaults = r3.$__.defaults), o2 = Object.assign(i2, o2);
        }
        o2 != null && o2.path != null && (this.$basePath = o2.path), a.call(this, t4, e3, n2, o2), delete this.$__.priorDoc;
      }
      t3.exports = p, p.prototype = Object.create(a.prototype), Object.defineProperty(p.prototype, "$isSubdocument", { configurable: false, writable: false, value: true }), Object.defineProperty(p.prototype, "$isSingleNested", { configurable: false, writable: false, value: true }), p.prototype.toBSON = function() {
        return this.toObject(c);
      }, p.prototype.save = function() {
        var t4, e3 = (t4 = n().m(function t(e4) {
          var r3 = this;
          return n().w(function(t5) {
            for (;; )
              if (t5.n === 0)
                return (e4 = e4 || {}).suppressWarning || f.warn("mongoose: calling `save()` on a subdoc does **not** save the document to MongoDB, it only runs save middleware. Use `subdoc.save({ suppressWarning: true })` to hide this warning if you're sure this behavior is right for your app."), t5.a(2, new Promise(function(t6, e5) {
                  r3.$__save(function(n2) {
                    if (n2 != null)
                      return e5(n2);
                    t6(r3);
                  });
                }));
          }, t);
        }), function() {
          var e4 = this, r3 = arguments;
          return new Promise(function(n2, o2) {
            var s2 = t4.apply(e4, r3);
            function a2(t5) {
              i(s2, n2, o2, a2, u2, "next", t5);
            }
            function u2(t5) {
              i(s2, n2, o2, a2, u2, "throw", t5);
            }
            a2(undefined);
          });
        });
        return function(t5) {
          return e3.apply(this, arguments);
        };
      }(), p.prototype.$__fullPath = function(t4) {
        return this.$__.fullPath || this.ownerDocument(), t4 ? this.$__.fullPath + "." + t4 : this.$__.fullPath;
      }, p.prototype.$__pathRelativeToParent = function(t4) {
        return t4 == null ? this.$basePath : [this.$basePath, t4].join(".");
      }, p.prototype.$__save = function(t4) {
        var e3 = this;
        return u(function() {
          return t4(null, e3);
        });
      }, p.prototype.$isValid = function(t4) {
        var e3 = this.$parent(), r3 = this.$__pathRelativeToParent(t4);
        return e3 != null && r3 != null ? e3.$isValid(r3) : a.prototype.$isValid.call(this, t4);
      }, p.prototype.markModified = function(t4) {
        a.prototype.markModified.call(this, t4);
        var e3 = this.$parent(), r3 = this.$__pathRelativeToParent(t4);
        if (e3 != null && r3 != null) {
          var n2 = this.$__pathRelativeToParent().replace(/\.$/, "");
          e3.isDirectModified(n2) || this.isNew || this.$__parent.markModified(r3, this);
        }
      }, p.prototype.isModified = function(t4, e3, r3) {
        var n2 = this, o2 = this.$parent();
        return o2 != null ? (Array.isArray(t4) || typeof t4 == "string" ? t4 = (t4 = Array.isArray(t4) ? t4 : t4.split(" ")).map(function(t5) {
          return n2.$__pathRelativeToParent(t5);
        }).filter(function(t5) {
          return t5 != null;
        }) : t4 || (t4 = this.$__pathRelativeToParent()), o2.$isModified(t4, e3, r3)) : a.prototype.isModified.call(this, t4, e3, r3);
      }, p.prototype.$markValid = function(t4) {
        a.prototype.$markValid.call(this, t4);
        var e3 = this.$parent(), r3 = this.$__pathRelativeToParent(t4);
        e3 != null && r3 != null && e3.$markValid(r3);
      }, p.prototype.invalidate = function(t4, e3, r3) {
        a.prototype.invalidate.call(this, t4, e3, r3);
        var n2 = this.$parent(), o2 = this.$__pathRelativeToParent(t4);
        if (n2 != null && o2 != null)
          n2.invalidate(o2, e3, r3);
        else if (e3.kind === "cast" || e3.name === "CastError" || o2 == null)
          throw e3;
        return this.ownerDocument().$__.validationError;
      }, p.prototype.$ignore = function(t4) {
        a.prototype.$ignore.call(this, t4);
        var e3 = this.$parent(), r3 = this.$__pathRelativeToParent(t4);
        e3 != null && r3 != null && e3.$ignore(r3);
      }, p.prototype.ownerDocument = function() {
        if (this.$__.ownerDocument)
          return this.$__.ownerDocument;
        for (var t4 = this, e3 = [], r3 = new Set([t4]);typeof t4.$__pathRelativeToParent == "function"; ) {
          e3.unshift(t4.$__pathRelativeToParent(undefined, true));
          var n2 = t4.$parent();
          if (n2 == null)
            break;
          if (t4 = n2, r3.has(t4))
            throw new Error("Infinite subdocument loop: subdoc with _id " + t4._id + " is a parent of itself");
          r3.add(t4);
        }
        return this.$__.fullPath = e3.join("."), this.$__.ownerDocument = t4, this.$__.ownerDocument;
      }, p.prototype.$__fullPathWithIndexes = function() {
        for (var t4 = this, e3 = [], r3 = new Set([t4]);typeof t4.$__pathRelativeToParent == "function"; ) {
          e3.unshift(t4.$__pathRelativeToParent(undefined, false));
          var n2 = t4.$parent();
          if (n2 == null)
            break;
          if (t4 = n2, r3.has(t4))
            throw new Error("Infinite subdocument loop: subdoc with _id " + t4._id + " is a parent of itself");
          r3.add(t4);
        }
        return e3.join(".");
      }, p.prototype.parent = function() {
        return this.$__parent;
      }, p.prototype.$parent = p.prototype.parent, p.prototype.$__deleteOne = function(t4) {
        if (t4 != null)
          return t4(null, this);
      }, p.prototype.$__removeFromParent = function() {
        this.$__parent.set(this.$basePath, null);
      }, p.prototype.deleteOne = function(t4, e3) {
        if (typeof t4 == "function" && (e3 = t4, t4 = null), function(t5) {
          var e4 = t5.ownerDocument();
          function r4() {
            e4.$removeListener("save", r4), e4.$removeListener("deleteOne", r4), t5.emit("deleteOne", t5), t5.constructor.emit("deleteOne", t5);
          }
          e4.$on("save", r4), e4.$on("deleteOne", r4);
        }(this), !t4 || !t4.noop) {
          this.$__removeFromParent();
          var r3 = this.ownerDocument();
          r3.$__.removedSubdocs = r3.$__.removedSubdocs || [], r3.$__.removedSubdocs.push(this);
        }
        return this.$__deleteOne(e3);
      }, p.prototype.populate = function() {
        throw new Error('Mongoose does not support calling populate() on nested docs. Instead of `doc.nested.populate("path")`, use `doc.populate("nested.path")`');
      }, p.prototype.inspect = function() {
        return this.toObject();
      }, l.inspect.custom && (p.prototype[l.inspect.custom] = p.prototype.inspect), p.prototype.$toObject = function(t4, e3) {
        var r3, n2, o2, i2, s2 = a.prototype.$toObject.call(this, t4, e3);
        if (Object.keys(s2).length !== 0 || (t4 == null ? undefined : t4._calledWithOptions) == null || !((r3 = (n2 = (o2 = t4._calledWithOptions) === null || o2 === undefined ? undefined : o2.minimize) !== null && n2 !== undefined ? n2 : this == null || (i2 = this.$__schemaTypeOptions) === null || i2 === undefined ? undefined : i2.minimize) !== null && r3 !== undefined ? r3 : t4.minimize) || this.constructor.$__required)
          return s2;
      };
    }, 9460: (t3, e2, r2) => {
      var n = r2(5832).hp, o = r2(3609);
      function i(t4, e3) {
        var r3 = Number(e3);
        if (isNaN(r3))
          throw new o("number", e3, t4);
        return r3;
      }
      t3.exports = function(t4) {
        var e3 = this;
        return Array.isArray(t4) ? t4.map(function(t5) {
          return i(e3.path, t5);
        }) : n.isBuffer(t4) ? t4 : i(e3.path, t4);
      };
    }, 9471: (t3) => {
      t3.exports = Math.abs;
    }, 9528: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (o = function() {
          return !!t4;
        })();
      }
      function i(t4) {
        return i = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, i(t4);
      }
      function s(t4, e3) {
        return s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s(t4, e3);
      }
      var a = function(t4) {
        function e3() {
          return function(t5, e4) {
            if (!(t5 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), function(t5, e4, r4) {
            return e4 = i(e4), function(t6, e5) {
              if (e5 && (n(e5) == "object" || typeof e5 == "function"))
                return e5;
              if (e5 !== undefined)
                throw new TypeError("Derived constructors may only return object or undefined");
              return function(t7) {
                if (t7 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t7;
              }(t6);
            }(t5, o() ? Reflect.construct(e4, r4 || [], i(t5).constructor) : e4.apply(t5, r4));
          }(this, e3, arguments);
        }
        return function(t5, e4) {
          if (typeof e4 != "function" && e4 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(8879)), u = r2(5761);
      Object.defineProperty(a.prototype, "enum", u), Object.defineProperty(a.prototype, "match", u), Object.defineProperty(a.prototype, "lowercase", u), Object.defineProperty(a.prototype, "trim", u), Object.defineProperty(a.prototype, "uppercase", u), Object.defineProperty(a.prototype, "minLength", u), Object.defineProperty(a.prototype, "minlength", u), Object.defineProperty(a.prototype, "maxLength", u), Object.defineProperty(a.prototype, "maxlength", u), Object.defineProperty(a.prototype, "populate", u), t3.exports = a;
    }, 9538: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function o(t4, e3) {
        for (var r3 = 0;r3 < e3.length; r3++) {
          var n2 = e3[r3];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t4, i(n2.key), n2);
        }
      }
      function i(t4) {
        var e3 = function(t5) {
          if (n(t5) != "object" || !t5)
            return t5;
          var e4 = t5[Symbol.toPrimitive];
          if (e4 !== undefined) {
            var r3 = e4.call(t5, "string");
            if (n(r3) != "object")
              return r3;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t5);
        }(t4);
        return n(e3) == "symbol" ? e3 : e3 + "";
      }
      function s() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t5) {}
        return (s = function() {
          return !!t4;
        })();
      }
      function a(t4) {
        return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, a(t4);
      }
      function u(t4, e3) {
        return u = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, u(t4, e3);
      }
      var c = r2(8213), l = function(t4) {
        function e3(t5, r4) {
          var o2;
          (function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          })(this, e3);
          var i3 = t5.message;
          i3 || (i3 = c.messages.general.default);
          var u2 = f(i3, t5, r4);
          return o2 = function(t6, e4, r5) {
            return e4 = a(e4), function(t7, e5) {
              if (e5 && (n(e5) == "object" || typeof e5 == "function"))
                return e5;
              if (e5 !== undefined)
                throw new TypeError("Derived constructors may only return object or undefined");
              return function(t8) {
                if (t8 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t8;
              }(t7);
            }(t6, s() ? Reflect.construct(e4, r5 || [], a(t6).constructor) : e4.apply(t6, r5));
          }(this, e3, [u2]), t5 = Object.assign({}, t5, { message: u2 }), o2.properties = t5, o2.kind = t5.type, o2.path = t5.path, o2.value = t5.value, o2.reason = t5.reason, o2;
        }
        return function(t5, e4) {
          if (typeof e4 != "function" && e4 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && u(t5, e4);
        }(e3, t4), r3 = e3, (i2 = [{ key: "toString", value: function() {
          return this.message;
        } }, { key: "toJSON", value: function() {
          return Object.assign({ name: this.name, message: this.message }, this);
        } }]) && o(r3.prototype, i2), Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3, i2;
      }(c);
      function f(t4, e3, r3) {
        if (typeof t4 == "function")
          return t4(e3, r3);
        for (var n2 = 0, o2 = Object.keys(e3);n2 < o2.length; n2++) {
          var i2 = o2[n2];
          i2 !== "message" && (t4 = t4.replace("{" + i2.toUpperCase() + "}", e3[i2]));
        }
        return t4;
      }
      Object.defineProperty(l.prototype, "name", { value: "ValidatorError" }), Object.defineProperty(l.prototype, "properties", { enumerable: false, writable: true, value: null }), l.prototype.formatMessage = f, t3.exports = l;
    }, 9539: (t3) => {
      function e2(t4, e3) {
        return function(t5) {
          if (Array.isArray(t5))
            return t5;
        }(t4) || function(t5, e4) {
          var r3 = t5 == null ? null : typeof Symbol != "undefined" && t5[Symbol.iterator] || t5["@@iterator"];
          if (r3 != null) {
            var n, o, i, s, a = [], u = true, c = false;
            try {
              if (i = (r3 = r3.call(t5)).next, e4 === 0) {
                if (Object(r3) !== r3)
                  return;
                u = false;
              } else
                for (;!(u = (n = i.call(r3)).done) && (a.push(n.value), a.length !== e4); u = true)
                  ;
            } catch (t6) {
              c = true, o = t6;
            } finally {
              try {
                if (!u && r3.return != null && (s = r3.return(), Object(s) !== s))
                  return;
              } finally {
                if (c)
                  throw o;
              }
            }
            return a;
          }
        }(t4, e3) || function(t5, e4) {
          if (t5) {
            if (typeof t5 == "string")
              return r2(t5, e4);
            var n = {}.toString.call(t5).slice(8, -1);
            return n === "Object" && t5.constructor && (n = t5.constructor.name), n === "Map" || n === "Set" ? Array.from(t5) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? r2(t5, e4) : undefined;
          }
        }(t4, e3) || function() {
          throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }();
      }
      function r2(t4, e3) {
        (e3 == null || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n = Array(e3);r3 < e3; r3++)
          n[r3] = t4[r3];
        return n;
      }
      t3.exports = function(t4, r3, n) {
        for (var o = {}, i = 0, s = Object.keys(r3.tree);i < s.length; i++) {
          var a = s[i];
          n && (t4.paths[a] || t4.nested[a] || t4.singleNestedPaths[a]) || (o[a] = r3.tree[a]);
        }
        t4.options._isMerging = true, t4.add(o, null), delete t4.options._isMerging, t4.callQueue = t4.callQueue.concat(r3.callQueue), t4.method(r3.methods), t4.static(r3.statics);
        for (var u = 0, c = Object.entries(r3._userProvidedOptions);u < c.length; u++) {
          var l = e2(c[u], 2), f = l[0], p = l[1];
          f in t4._userProvidedOptions || t4.set(f, p);
        }
        for (var h in r3.query)
          t4.query[h] = r3.query[h];
        for (var y in r3.virtuals)
          t4.virtuals[y] = r3.virtuals[y].clone();
        t4._indexes = t4._indexes.concat(r3._indexes || []), t4.s.hooks.merge(r3.s.hooks, false);
      };
    }, 9553: (t3, e2, r2) => {
      var n = r2(5832).hp;
      function o(t4) {
        return o = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, o(t4);
      }
      var i = r2(9639), s = r2(2402);
      t3.exports = function(t4) {
        return t4 == null ? t4 : o(t4) === "object" && typeof t4.$numberDecimal == "string" ? i.fromString(t4.$numberDecimal) : t4 instanceof i ? t4 : typeof t4 == "string" ? i.fromString(t4) : typeof n == "function" && n.isBuffer(t4) || typeof Uint8Array == "function" && t4 instanceof Uint8Array ? new i(t4) : typeof t4 == "number" ? i.fromString(String(t4)) : typeof t4.valueOf == "function" && typeof t4.valueOf() == "string" ? i.fromString(t4.valueOf()) : void s.ok(false);
      };
    }, 9600: (t3, e2, r2) => {
      e2.Array = r2(7557), e2.Buffer = r2(6365), e2.Document = e2.Embedded = r2(6547), e2.DocumentArray = r2(4878), e2.Double = r2(2822), e2.Decimal128 = r2(9639), e2.ObjectId = r2(5549), e2.Map = r2(2081), e2.Subdocument = r2(9380), e2.UUID = r2(1344);
    }, 9604: (t3, e2, r2) => {
      var n = r2(5558).p, o = r2(5558).G;
      function i(t4, e3) {
        switch (t4.$geometry.type) {
          case "Polygon":
          case "LineString":
          case "Point":
            n(t4.$geometry.coordinates, e3);
        }
        return s(e3, t4), t4;
      }
      function s(t4, e3) {
        e3.$maxDistance && (e3.$maxDistance = o.call(t4, e3.$maxDistance)), e3.$minDistance && (e3.$minDistance = o.call(t4, e3.$minDistance));
      }
      e2.cast$geoIntersects = function(t4) {
        if (t4.$geometry)
          return i(t4, this), t4;
      }, e2.cast$near = function(t4) {
        var e3 = r2(7760);
        if (Array.isArray(t4))
          return n(t4, this), t4;
        if (s(this, t4), t4 && t4.$geometry)
          return i(t4, this);
        if (!Array.isArray(t4))
          throw new TypeError("$near must be either an array or an object with a $geometry property");
        return e3.prototype.castForQuery.call(this, null, t4);
      }, e2.cast$within = function(t4) {
        var e3 = this;
        if (s(this, t4), t4.$box || t4.$polygon) {
          var r3 = t4.$box ? "$box" : "$polygon";
          t4[r3].forEach(function(t5) {
            if (!Array.isArray(t5))
              throw new TypeError("Invalid $within $box argument. Expected an array, received " + t5);
            t5.forEach(function(r4, n3) {
              t5[n3] = o.call(e3, r4);
            });
          });
        } else if (t4.$center || t4.$centerSphere) {
          var n2 = t4.$center ? "$center" : "$centerSphere";
          t4[n2].forEach(function(r4, i2) {
            Array.isArray(r4) ? r4.forEach(function(t5, n3) {
              r4[n3] = o.call(e3, t5);
            }) : t4[n2][i2] = o.call(e3, r4);
          });
        } else
          t4.$geometry && i(t4, this);
        return t4;
      };
    }, 9639: (t3, e2, r2) => {
      t3.exports = r2(6353).Decimal128;
    }, 9696: (t3) => {
      var e2 = /^function\s*([^\s(]+)/;
      t3.exports = function(t4) {
        return t4.name || (t4.toString().trim().match(e2) || [])[1];
      };
    }, 9809: (t3) => {
      function e2(t4) {
        return e2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      var r2, n, o = Function.prototype.toString, i = (typeof Reflect == "undefined" ? "undefined" : e2(Reflect)) === "object" && Reflect !== null && Reflect.apply;
      if (typeof i == "function" && typeof Object.defineProperty == "function")
        try {
          r2 = Object.defineProperty({}, "length", { get: function() {
            throw n;
          } }), n = {}, i(function() {
            throw 42;
          }, null, r2);
        } catch (t4) {
          t4 !== n && (i = null);
        }
      else
        i = null;
      var s = /^\s*class\b/, a = function(t4) {
        try {
          var e3 = o.call(t4);
          return s.test(e3);
        } catch (t5) {
          return false;
        }
      }, u = function(t4) {
        try {
          return !a(t4) && (o.call(t4), true);
        } catch (t5) {
          return false;
        }
      }, c = Object.prototype.toString, l = typeof Symbol == "function" && !!Symbol.toStringTag, f = !(0 in [,]), p = function() {
        return false;
      };
      if ((typeof document == "undefined" ? "undefined" : e2(document)) === "object") {
        var h = document.all;
        c.call(h) === c.call(document.all) && (p = function(t4) {
          if ((f || !t4) && (t4 === undefined || e2(t4) === "object"))
            try {
              var r3 = c.call(t4);
              return (r3 === "[object HTMLAllCollection]" || r3 === "[object HTML document.all class]" || r3 === "[object HTMLCollection]" || r3 === "[object Object]") && t4("") == null;
            } catch (t5) {}
          return false;
        });
      }
      t3.exports = i ? function(t4) {
        if (p(t4))
          return true;
        if (!t4)
          return false;
        if (typeof t4 != "function" && e2(t4) !== "object")
          return false;
        try {
          i(t4, null, r2);
        } catch (t5) {
          if (t5 !== n)
            return false;
        }
        return !a(t4) && u(t4);
      } : function(t4) {
        if (p(t4))
          return true;
        if (!t4)
          return false;
        if (typeof t4 != "function" && e2(t4) !== "object")
          return false;
        if (l)
          return u(t4);
        if (a(t4))
          return false;
        var r3 = c.call(t4);
        return !(r3 !== "[object Function]" && r3 !== "[object GeneratorFunction]" && !/^\[object HTML/.test(r3)) && u(t4);
      };
    }, 9834: (t3, e2, r2) => {
      function n(t4) {
        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var o = r2(3777), i = r2(3426), s = r2(9122), a = r2(3071), u = r2(1464), c = r2(209), l = a("Object.prototype.toString"), f = r2(953)(), p = typeof globalThis == "undefined" ? r2.g : globalThis, h = i(), y = a("String.prototype.slice"), d = a("Array.prototype.indexOf", true) || function(t4, e3) {
        for (var r3 = 0;r3 < t4.length; r3 += 1)
          if (t4[r3] === e3)
            return r3;
        return -1;
      }, b = { __proto__: null };
      o(h, f && u && c ? function(t4) {
        var e3 = new p[t4];
        if (Symbol.toStringTag in e3 && c) {
          var r3 = c(e3), n2 = u(r3, Symbol.toStringTag);
          if (!n2 && r3) {
            var o2 = c(r3);
            n2 = u(o2, Symbol.toStringTag);
          }
          b["$" + t4] = s(n2.get);
        }
      } : function(t4) {
        var e3 = new p[t4], r3 = e3.slice || e3.set;
        r3 && (b["$" + t4] = s(r3));
      }), t3.exports = function(t4) {
        if (!t4 || n(t4) !== "object")
          return false;
        if (!f) {
          var e3 = y(l(t4), 8, -1);
          return d(h, e3) > -1 ? e3 : e3 === "Object" && function(t5) {
            var e4 = false;
            return o(b, function(r3, n2) {
              if (!e4)
                try {
                  r3(t5), e4 = y(n2, 1);
                } catch (t6) {}
            }), e4;
          }(t4);
        }
        return u ? function(t5) {
          var e4 = false;
          return o(b, function(r3, n2) {
            if (!e4)
              try {
                "$" + r3(t5) === n2 && (e4 = y(n2, 1));
              } catch (t6) {}
          }), e4;
        }(t4) : null;
      };
    }, 9848: (t3) => {
      function e2(t4) {
        return e2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && typeof Symbol == "function" && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      t3.exports = function(t4) {
        t4.pre("save", false, function(t5, r2) {
          var n = this, o = this;
          if (this.$isSubdocument)
            return t5();
          if (r2 && e2(r2) === "object" && "validateBeforeSave" in r2 ? r2.validateBeforeSave : this.$__schema.options.validateBeforeSave) {
            var i = r2 && e2(r2) === "object" && "validateModifiedOnly" in r2 ? { validateModifiedOnly: r2.validateModifiedOnly } : null;
            this.$validate(i).then(function() {
              n.$op = "save", t5();
            }, function(e3) {
              o.$__schema.s.hooks.execPost("save:error", o, [o], { error: e3 }, function(e4) {
                o.$op = "save", t5(e4);
              });
            });
          } else
            t5();
        }, null, true);
      };
    }, 9870: (t3) => {
      t3.exports = Error;
    }, 9907: (t3) => {
      t3.exports = SyntaxError;
    }, 9939: (t3) => {
      t3.exports = RangeError;
    } }, e = {};
    function r(n) {
      var o = e[n];
      if (o !== undefined)
        return o.exports;
      var i = e[n] = { exports: {} };
      return t2[n](i, i.exports, r), i.exports;
    }
    return r.d = (t3, e2) => {
      for (var n in e2)
        r.o(e2, n) && !r.o(t3, n) && Object.defineProperty(t3, n, { enumerable: true, get: e2[n] });
    }, r.g = function() {
      if (typeof globalThis == "object")
        return globalThis;
      try {
        return this || new Function("return this")();
      } catch (t3) {
        if (typeof window == "object")
          return window;
      }
    }(), r.o = (t3, e2) => Object.prototype.hasOwnProperty.call(t3, e2), r.r = (t3) => {
      typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(t3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t3, "__esModule", { value: true });
    }, r(4829);
  })());
});

// node:buffer
var exports_buffer2 = {};
__export(exports_buffer2, {
  transcode: () => transcode,
  resolveObjectURL: () => resolveObjectURL,
  kStringMaxLength: () => kStringMaxLength,
  kMaxLength: () => kMaxLength,
  isUtf8: () => isUtf8,
  isAscii: () => isAscii,
  default: () => buffer_default,
  constants: () => constants,
  btoa: () => btoa2,
  atob: () => atob2,
  INSPECT_MAX_BYTES: () => INSPECT_MAX_BYTES,
  File: () => File,
  Buffer: () => Buffer2,
  Blob: () => Blob2
});
function getLens(b64) {
  var len2 = b64.length;
  if (len2 % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len2;
  var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function _byteLength(validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp, lens = getLens(b64), validLen = lens[0], placeHoldersLen = lens[1], arr = new Uint8Array(_byteLength(validLen, placeHoldersLen)), curByte = 0, len2 = placeHoldersLen > 0 ? validLen - 4 : validLen, i2;
  for (i2 = 0;i2 < len2; i2 += 4)
    tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)], arr[curByte++] = tmp >> 16 & 255, arr[curByte++] = tmp >> 8 & 255, arr[curByte++] = tmp & 255;
  if (placeHoldersLen === 2)
    tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4, arr[curByte++] = tmp & 255;
  if (placeHoldersLen === 1)
    tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2, arr[curByte++] = tmp >> 8 & 255, arr[curByte++] = tmp & 255;
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp, output = [];
  for (var i2 = start;i2 < end; i2 += 3)
    tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255), output.push(tripletToBase64(tmp));
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp, len2 = uint8.length, extraBytes = len2 % 3, parts = [], maxChunkLength = 16383;
  for (var i2 = 0, len22 = len2 - extraBytes;i2 < len22; i2 += maxChunkLength)
    parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
  if (extraBytes === 1)
    tmp = uint8[len2 - 1], parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
  else if (extraBytes === 2)
    tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1], parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
  return parts.join("");
}
function read(buffer, offset, isLE, mLen, nBytes) {
  var e, m, eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i2 = isLE ? nBytes - 1 : 0, d = isLE ? -1 : 1, s = buffer[offset + i2];
  i2 += d, e = s & (1 << -nBits) - 1, s >>= -nBits, nBits += eLen;
  for (;nBits > 0; e = e * 256 + buffer[offset + i2], i2 += d, nBits -= 8)
    ;
  m = e & (1 << -nBits) - 1, e >>= -nBits, nBits += mLen;
  for (;nBits > 0; m = m * 256 + buffer[offset + i2], i2 += d, nBits -= 8)
    ;
  if (e === 0)
    e = 1 - eBias;
  else if (e === eMax)
    return m ? NaN : (s ? -1 : 1) * (1 / 0);
  else
    m = m + Math.pow(2, mLen), e = e - eBias;
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}
function write(buffer, value2, offset, isLE, mLen, nBytes) {
  var e, m, c, eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, i2 = isLE ? 0 : nBytes - 1, d = isLE ? 1 : -1, s = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
  if (value2 = Math.abs(value2), isNaN(value2) || value2 === 1 / 0)
    m = isNaN(value2) ? 1 : 0, e = eMax;
  else {
    if (e = Math.floor(Math.log(value2) / Math.LN2), value2 * (c = Math.pow(2, -e)) < 1)
      e--, c *= 2;
    if (e + eBias >= 1)
      value2 += rt / c;
    else
      value2 += rt * Math.pow(2, 1 - eBias);
    if (value2 * c >= 2)
      e++, c /= 2;
    if (e + eBias >= eMax)
      m = 0, e = eMax;
    else if (e + eBias >= 1)
      m = (value2 * c - 1) * Math.pow(2, mLen), e = e + eBias;
    else
      m = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen), e = 0;
  }
  for (;mLen >= 8; buffer[offset + i2] = m & 255, i2 += d, m /= 256, mLen -= 8)
    ;
  e = e << mLen | m, eLen += mLen;
  for (;eLen > 0; buffer[offset + i2] = e & 255, i2 += d, e /= 256, eLen -= 8)
    ;
  buffer[offset + i2 - d] |= s * 128;
}
function createBuffer(length) {
  if (length > kMaxLength)
    throw new RangeError('The value "' + length + '" is invalid for option "size"');
  let buf = new Uint8Array(length);
  return Object.setPrototypeOf(buf, Buffer2.prototype), buf;
}
function E(sym, getMessage, Base) {
  return class NodeError extends Base {
    constructor() {
      super();
      Object.defineProperty(this, "message", { value: getMessage.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${sym}]`, this.stack, delete this.name;
    }
    get code() {
      return sym;
    }
    set code(value2) {
      Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: value2, writable: true });
    }
    toString() {
      return `${this.name} [${sym}]: ${this.message}`;
    }
  };
}
function Buffer2(arg, encodingOrOffset, length) {
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string")
      throw new TypeError('The "string" argument must be of type string. Received type number');
    return allocUnsafe(arg);
  }
  return from(arg, encodingOrOffset, length);
}
function from(value2, encodingOrOffset, length) {
  if (typeof value2 === "string")
    return fromString(value2, encodingOrOffset);
  if (ArrayBuffer.isView(value2))
    return fromArrayView(value2);
  if (value2 == null)
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2);
  if (isInstance(value2, ArrayBuffer) || value2 && isInstance(value2.buffer, ArrayBuffer))
    return fromArrayBuffer(value2, encodingOrOffset, length);
  if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value2, SharedArrayBuffer) || value2 && isInstance(value2.buffer, SharedArrayBuffer)))
    return fromArrayBuffer(value2, encodingOrOffset, length);
  if (typeof value2 === "number")
    throw new TypeError('The "value" argument must not be of type number. Received type number');
  let valueOf = value2.valueOf && value2.valueOf();
  if (valueOf != null && valueOf !== value2)
    return Buffer2.from(valueOf, encodingOrOffset, length);
  let b = fromObject(value2);
  if (b)
    return b;
  if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value2[Symbol.toPrimitive] === "function")
    return Buffer2.from(value2[Symbol.toPrimitive]("string"), encodingOrOffset, length);
  throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2);
}
function assertSize(size) {
  if (typeof size !== "number")
    throw new TypeError('"size" argument must be of type number');
  else if (size < 0)
    throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
  if (assertSize(size), size <= 0)
    return createBuffer(size);
  if (fill !== undefined)
    return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
  return createBuffer(size);
}
function allocUnsafe(size) {
  return assertSize(size), createBuffer(size < 0 ? 0 : checked(size) | 0);
}
function fromString(string3, encoding) {
  if (typeof encoding !== "string" || encoding === "")
    encoding = "utf8";
  if (!Buffer2.isEncoding(encoding))
    throw new TypeError("Unknown encoding: " + encoding);
  let length = byteLength(string3, encoding) | 0, buf = createBuffer(length), actual = buf.write(string3, encoding);
  if (actual !== length)
    buf = buf.slice(0, actual);
  return buf;
}
function fromArrayLike(array3) {
  let length = array3.length < 0 ? 0 : checked(array3.length) | 0, buf = createBuffer(length);
  for (let i2 = 0;i2 < length; i2 += 1)
    buf[i2] = array3[i2] & 255;
  return buf;
}
function fromArrayView(arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    let copy = new Uint8Array(arrayView);
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
  }
  return fromArrayLike(arrayView);
}
function fromArrayBuffer(array3, byteOffset, length) {
  if (byteOffset < 0 || array3.byteLength < byteOffset)
    throw new RangeError('"offset" is outside of buffer bounds');
  if (array3.byteLength < byteOffset + (length || 0))
    throw new RangeError('"length" is outside of buffer bounds');
  let buf;
  if (byteOffset === undefined && length === undefined)
    buf = new Uint8Array(array3);
  else if (length === undefined)
    buf = new Uint8Array(array3, byteOffset);
  else
    buf = new Uint8Array(array3, byteOffset, length);
  return Object.setPrototypeOf(buf, Buffer2.prototype), buf;
}
function fromObject(obj) {
  if (Buffer2.isBuffer(obj)) {
    let len2 = checked(obj.length) | 0, buf = createBuffer(len2);
    if (buf.length === 0)
      return buf;
    return obj.copy(buf, 0, 0, len2), buf;
  }
  if (obj.length !== undefined) {
    if (typeof obj.length !== "number" || numberIsNaN(obj.length))
      return createBuffer(0);
    return fromArrayLike(obj);
  }
  if (obj.type === "Buffer" && Array.isArray(obj.data))
    return fromArrayLike(obj.data);
}
function checked(length) {
  if (length >= kMaxLength)
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength.toString(16) + " bytes");
  return length | 0;
}
function byteLength(string3, encoding) {
  if (Buffer2.isBuffer(string3))
    return string3.length;
  if (ArrayBuffer.isView(string3) || isInstance(string3, ArrayBuffer))
    return string3.byteLength;
  if (typeof string3 !== "string")
    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string3);
  let len2 = string3.length, mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len2 === 0)
    return 0;
  let loweredCase = false;
  for (;; )
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len2;
      case "utf8":
      case "utf-8":
        return utf8ToBytes(string3).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len2 * 2;
      case "hex":
        return len2 >>> 1;
      case "base64":
        return base64ToBytes(string3).length;
      default:
        if (loweredCase)
          return mustMatch ? -1 : utf8ToBytes(string3).length;
        encoding = ("" + encoding).toLowerCase(), loweredCase = true;
    }
}
function slowToString(encoding, start, end) {
  let loweredCase = false;
  if (start === undefined || start < 0)
    start = 0;
  if (start > this.length)
    return "";
  if (end === undefined || end > this.length)
    end = this.length;
  if (end <= 0)
    return "";
  if (end >>>= 0, start >>>= 0, end <= start)
    return "";
  if (!encoding)
    encoding = "utf8";
  while (true)
    switch (encoding) {
      case "hex":
        return hexSlice(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start, end);
      case "ascii":
        return asciiSlice(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice(this, start, end);
      case "base64":
        return base64Slice(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase(), loweredCase = true;
    }
}
function swap(b, n, m) {
  let i2 = b[n];
  b[n] = b[m], b[m] = i2;
}
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1;
  if (typeof byteOffset === "string")
    encoding = byteOffset, byteOffset = 0;
  else if (byteOffset > 2147483647)
    byteOffset = 2147483647;
  else if (byteOffset < -2147483648)
    byteOffset = -2147483648;
  if (byteOffset = +byteOffset, Number.isNaN(byteOffset))
    byteOffset = dir ? 0 : buffer.length - 1;
  if (byteOffset < 0)
    byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length)
    if (dir)
      return -1;
    else
      byteOffset = buffer.length - 1;
  else if (byteOffset < 0)
    if (dir)
      byteOffset = 0;
    else
      return -1;
  if (typeof val === "string")
    val = Buffer2.from(val, encoding);
  if (Buffer2.isBuffer(val)) {
    if (val.length === 0)
      return -1;
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    if (val = val & 255, typeof Uint8Array.prototype.indexOf === "function")
      if (dir)
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      else
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  let indexSize = 1, arrLength = arr.length, valLength = val.length;
  if (encoding !== undefined) {
    if (encoding = String(encoding).toLowerCase(), encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2)
        return -1;
      indexSize = 2, arrLength /= 2, valLength /= 2, byteOffset /= 2;
    }
  }
  function read2(buf, i3) {
    if (indexSize === 1)
      return buf[i3];
    else
      return buf.readUInt16BE(i3 * indexSize);
  }
  let i2;
  if (dir) {
    let foundIndex = -1;
    for (i2 = byteOffset;i2 < arrLength; i2++)
      if (read2(arr, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i2;
        if (i2 - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i2 -= i2 - foundIndex;
        foundIndex = -1;
      }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i2 = byteOffset;i2 >= 0; i2--) {
      let found = true;
      for (let j = 0;j < valLength; j++)
        if (read2(arr, i2 + j) !== read2(val, j)) {
          found = false;
          break;
        }
      if (found)
        return i2;
    }
  }
  return -1;
}
function hexWrite(buf, string3, offset, length) {
  offset = Number(offset) || 0;
  let remaining = buf.length - offset;
  if (!length)
    length = remaining;
  else if (length = Number(length), length > remaining)
    length = remaining;
  let strLen = string3.length;
  if (length > strLen / 2)
    length = strLen / 2;
  let i2;
  for (i2 = 0;i2 < length; ++i2) {
    let parsed = parseInt(string3.substr(i2 * 2, 2), 16);
    if (numberIsNaN(parsed))
      return i2;
    buf[offset + i2] = parsed;
  }
  return i2;
}
function utf8Write(buf, string3, offset, length) {
  return blitBuffer(utf8ToBytes(string3, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string3, offset, length) {
  return blitBuffer(asciiToBytes(string3), buf, offset, length);
}
function base64Write(buf, string3, offset, length) {
  return blitBuffer(base64ToBytes(string3), buf, offset, length);
}
function ucs2Write(buf, string3, offset, length) {
  return blitBuffer(utf16leToBytes(string3, buf.length - offset), buf, offset, length);
}
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length)
    return fromByteArray(buf);
  else
    return fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  let res = [], i2 = start;
  while (i2 < end) {
    let firstByte = buf[i2], codePoint = null, bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i2 + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128)
            codePoint = firstByte;
          break;
        case 2:
          if (secondByte = buf[i2 + 1], (secondByte & 192) === 128) {
            if (tempCodePoint = (firstByte & 31) << 6 | secondByte & 63, tempCodePoint > 127)
              codePoint = tempCodePoint;
          }
          break;
        case 3:
          if (secondByte = buf[i2 + 1], thirdByte = buf[i2 + 2], (secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            if (tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63, tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343))
              codePoint = tempCodePoint;
          }
          break;
        case 4:
          if (secondByte = buf[i2 + 1], thirdByte = buf[i2 + 2], fourthByte = buf[i2 + 3], (secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            if (tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63, tempCodePoint > 65535 && tempCodePoint < 1114112)
              codePoint = tempCodePoint;
          }
      }
    }
    if (codePoint === null)
      codePoint = 65533, bytesPerSequence = 1;
    else if (codePoint > 65535)
      codePoint -= 65536, res.push(codePoint >>> 10 & 1023 | 55296), codePoint = 56320 | codePoint & 1023;
    res.push(codePoint), i2 += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
function decodeCodePointsArray(codePoints) {
  let len2 = codePoints.length;
  if (len2 <= MAX_ARGUMENTS_LENGTH)
    return String.fromCharCode.apply(String, codePoints);
  let res = "", i2 = 0;
  while (i2 < len2)
    res += String.fromCharCode.apply(String, codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH));
  return res;
}
function asciiSlice(buf, start, end) {
  let ret = "";
  end = Math.min(buf.length, end);
  for (let i2 = start;i2 < end; ++i2)
    ret += String.fromCharCode(buf[i2] & 127);
  return ret;
}
function latin1Slice(buf, start, end) {
  let ret = "";
  end = Math.min(buf.length, end);
  for (let i2 = start;i2 < end; ++i2)
    ret += String.fromCharCode(buf[i2]);
  return ret;
}
function hexSlice(buf, start, end) {
  let len2 = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len2)
    end = len2;
  let out = "";
  for (let i2 = start;i2 < end; ++i2)
    out += hexSliceLookupTable[buf[i2]];
  return out;
}
function utf16leSlice(buf, start, end) {
  let bytes = buf.slice(start, end), res = "";
  for (let i2 = 0;i2 < bytes.length - 1; i2 += 2)
    res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
  return res;
}
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
function checkInt(buf, value2, offset, ext, max, min) {
  if (!Buffer2.isBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value2 > max || value2 < min)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
}
function wrtBigUInt64LE(buf, value2, offset, min, max) {
  checkIntBI(value2, min, max, buf, offset, 7);
  let lo = Number(value2 & BigInt(4294967295));
  buf[offset++] = lo, lo = lo >> 8, buf[offset++] = lo, lo = lo >> 8, buf[offset++] = lo, lo = lo >> 8, buf[offset++] = lo;
  let hi = Number(value2 >> BigInt(32) & BigInt(4294967295));
  return buf[offset++] = hi, hi = hi >> 8, buf[offset++] = hi, hi = hi >> 8, buf[offset++] = hi, hi = hi >> 8, buf[offset++] = hi, offset;
}
function wrtBigUInt64BE(buf, value2, offset, min, max) {
  checkIntBI(value2, min, max, buf, offset, 7);
  let lo = Number(value2 & BigInt(4294967295));
  buf[offset + 7] = lo, lo = lo >> 8, buf[offset + 6] = lo, lo = lo >> 8, buf[offset + 5] = lo, lo = lo >> 8, buf[offset + 4] = lo;
  let hi = Number(value2 >> BigInt(32) & BigInt(4294967295));
  return buf[offset + 3] = hi, hi = hi >> 8, buf[offset + 2] = hi, hi = hi >> 8, buf[offset + 1] = hi, hi = hi >> 8, buf[offset] = hi, offset + 8;
}
function checkIEEE754(buf, value2, offset, ext, max, min) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(buf, value2, offset, littleEndian, noAssert) {
  if (value2 = +value2, offset = offset >>> 0, !noAssert)
    checkIEEE754(buf, value2, offset, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000);
  return write(buf, value2, offset, littleEndian, 23, 4), offset + 4;
}
function writeDouble(buf, value2, offset, littleEndian, noAssert) {
  if (value2 = +value2, offset = offset >>> 0, !noAssert)
    checkIEEE754(buf, value2, offset, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
  return write(buf, value2, offset, littleEndian, 52, 8), offset + 8;
}
function addNumericalSeparator(val) {
  let res = "", i2 = val.length, start = val[0] === "-" ? 1 : 0;
  for (;i2 >= start + 4; i2 -= 3)
    res = `_${val.slice(i2 - 3, i2)}${res}`;
  return `${val.slice(0, i2)}${res}`;
}
function checkBounds(buf, offset, byteLength2) {
  if (validateNumber(offset, "offset"), buf[offset] === undefined || buf[offset + byteLength2] === undefined)
    boundsError(offset, buf.length - (byteLength2 + 1));
}
function checkIntBI(value2, min, max, buf, offset, byteLength2) {
  if (value2 > max || value2 < min) {
    let n = typeof min === "bigint" ? "n" : "", range;
    if (byteLength2 > 3)
      if (min === 0 || min === BigInt(0))
        range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
      else
        range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
    else
      range = `>= ${min}${n} and <= ${max}${n}`;
    throw new ERR_OUT_OF_RANGE("value", range, value2);
  }
  checkBounds(buf, offset, byteLength2);
}
function validateNumber(value2, name) {
  if (typeof value2 !== "number")
    throw new ERR_INVALID_ARG_TYPE(name, "number", value2);
}
function boundsError(value2, length, type3) {
  if (Math.floor(value2) !== value2)
    throw validateNumber(value2, type3), new ERR_OUT_OF_RANGE(type3 || "offset", "an integer", value2);
  if (length < 0)
    throw new ERR_BUFFER_OUT_OF_BOUNDS;
  throw new ERR_OUT_OF_RANGE(type3 || "offset", `>= ${type3 ? 1 : 0} and <= ${length}`, value2);
}
function base64clean(str) {
  if (str = str.split("=")[0], str = str.trim().replace(INVALID_BASE64_RE, ""), str.length < 2)
    return "";
  while (str.length % 4 !== 0)
    str = str + "=";
  return str;
}
function utf8ToBytes(string3, units) {
  units = units || 1 / 0;
  let codePoint, length = string3.length, leadSurrogate = null, bytes = [];
  for (let i2 = 0;i2 < length; ++i2) {
    if (codePoint = string3.charCodeAt(i2), codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i2 + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    if (leadSurrogate = null, codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else
      throw new Error("Invalid code point");
  }
  return bytes;
}
function asciiToBytes(str) {
  let byteArray = [];
  for (let i2 = 0;i2 < str.length; ++i2)
    byteArray.push(str.charCodeAt(i2) & 255);
  return byteArray;
}
function utf16leToBytes(str, units) {
  let c, hi, lo, byteArray = [];
  for (let i2 = 0;i2 < str.length; ++i2) {
    if ((units -= 2) < 0)
      break;
    c = str.charCodeAt(i2), hi = c >> 8, lo = c % 256, byteArray.push(lo), byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  let i2;
  for (i2 = 0;i2 < length; ++i2) {
    if (i2 + offset >= dst.length || i2 >= src.length)
      break;
    dst[i2 + offset] = src[i2];
  }
  return i2;
}
function isInstance(obj, type3) {
  return obj instanceof type3 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type3.name;
}
function defineBigIntMethod(fn) {
  return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
  throw new Error("BigInt not supported");
}
function notimpl(name) {
  return () => {
    throw new Error(name + " is not implemented for node:buffer browser polyfill");
  };
}
var lookup, revLookup, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i, len, customInspectSymbol, INSPECT_MAX_BYTES = 50, kMaxLength = 2147483647, kStringMaxLength = 536870888, btoa2, atob2, File, Blob2, constants, ERR_BUFFER_OUT_OF_BOUNDS, ERR_INVALID_ARG_TYPE, ERR_OUT_OF_RANGE, MAX_ARGUMENTS_LENGTH = 4096, INVALID_BASE64_RE, hexSliceLookupTable, resolveObjectURL, isUtf8, isAscii = (str) => {
  for (let char of str)
    if (char.charCodeAt(0) > 127)
      return false;
  return true;
}, transcode, buffer_default;
var init_buffer = __esm(() => {
  lookup = [];
  revLookup = [];
  for (i = 0, len = code.length;i < len; ++i)
    lookup[i] = code[i], revLookup[code.charCodeAt(i)] = i;
  revLookup[45] = 62;
  revLookup[95] = 63;
  customInspectSymbol = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  btoa2 = globalThis.btoa;
  atob2 = globalThis.atob;
  File = globalThis.File;
  Blob2 = globalThis.Blob;
  constants = { MAX_LENGTH: kMaxLength, MAX_STRING_LENGTH: kStringMaxLength };
  ERR_BUFFER_OUT_OF_BOUNDS = E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
    if (name)
      return `${name} is outside of buffer bounds`;
    return "Attempt to access memory outside buffer bounds";
  }, RangeError);
  ERR_INVALID_ARG_TYPE = E("ERR_INVALID_ARG_TYPE", function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
  }, TypeError);
  ERR_OUT_OF_RANGE = E("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`, received = input;
    if (Number.isInteger(input) && Math.abs(input) > 4294967296)
      received = addNumericalSeparator(String(input));
    else if (typeof input === "bigint") {
      if (received = String(input), input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32)))
        received = addNumericalSeparator(received);
      received += "n";
    }
    return msg += ` It must be ${range}. Received ${received}`, msg;
  }, RangeError);
  Object.defineProperty(Buffer2.prototype, "parent", { enumerable: true, get: function() {
    if (!Buffer2.isBuffer(this))
      return;
    return this.buffer;
  } });
  Object.defineProperty(Buffer2.prototype, "offset", { enumerable: true, get: function() {
    if (!Buffer2.isBuffer(this))
      return;
    return this.byteOffset;
  } });
  Buffer2.poolSize = 8192;
  Buffer2.from = function(value2, encodingOrOffset, length) {
    return from(value2, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  Buffer2.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  Buffer2.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer2.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  Buffer2.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array))
      a = Buffer2.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array))
      b = Buffer2.from(b, b.offset, b.byteLength);
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b))
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b)
      return 0;
    let x = a.length, y = b.length;
    for (let i2 = 0, len2 = Math.min(x, y);i2 < len2; ++i2)
      if (a[i2] !== b[i2]) {
        x = a[i2], y = b[i2];
        break;
      }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat(list, length) {
    if (!Array.isArray(list))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0)
      return Buffer2.alloc(0);
    let i2;
    if (length === undefined) {
      length = 0;
      for (i2 = 0;i2 < list.length; ++i2)
        length += list[i2].length;
    }
    let buffer = Buffer2.allocUnsafe(length), pos = 0;
    for (i2 = 0;i2 < list.length; ++i2) {
      let buf = list[i2];
      if (isInstance(buf, Uint8Array))
        if (pos + buf.length > buffer.length) {
          if (!Buffer2.isBuffer(buf))
            buf = Buffer2.from(buf);
          buf.copy(buffer, pos);
        } else
          Uint8Array.prototype.set.call(buffer, buf, pos);
      else if (!Buffer2.isBuffer(buf))
        throw new TypeError('"list" argument must be an Array of Buffers');
      else
        buf.copy(buffer, pos);
      pos += buf.length;
    }
    return buffer;
  };
  Buffer2.byteLength = byteLength;
  Buffer2.prototype._isBuffer = true;
  Buffer2.prototype.swap16 = function swap16() {
    let len2 = this.length;
    if (len2 % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let i2 = 0;i2 < len2; i2 += 2)
      swap(this, i2, i2 + 1);
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    let len2 = this.length;
    if (len2 % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let i2 = 0;i2 < len2; i2 += 4)
      swap(this, i2, i2 + 3), swap(this, i2 + 1, i2 + 2);
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    let len2 = this.length;
    if (len2 % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let i2 = 0;i2 < len2; i2 += 8)
      swap(this, i2, i2 + 7), swap(this, i2 + 1, i2 + 6), swap(this, i2 + 2, i2 + 5), swap(this, i2 + 3, i2 + 4);
    return this;
  };
  Buffer2.prototype.toString = function toString() {
    let length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b) {
    if (!Buffer2.isBuffer(b))
      throw new TypeError("Argument must be a Buffer");
    if (this === b)
      return true;
    return Buffer2.compare(this, b) === 0;
  };
  Buffer2.prototype.inspect = function inspect() {
    let str = "", max = exports_buffer.INSPECT_MAX_BYTES;
    if (str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim(), this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol)
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array))
      target = Buffer2.from(target, target.offset, target.byteLength);
    if (!Buffer2.isBuffer(target))
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined)
      start = 0;
    if (end === undefined)
      end = target ? target.length : 0;
    if (thisStart === undefined)
      thisStart = 0;
    if (thisEnd === undefined)
      thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length)
      throw new RangeError("out of range index");
    if (thisStart >= thisEnd && start >= end)
      return 0;
    if (thisStart >= thisEnd)
      return -1;
    if (start >= end)
      return 1;
    if (start >>>= 0, end >>>= 0, thisStart >>>= 0, thisEnd >>>= 0, this === target)
      return 0;
    let x = thisEnd - thisStart, y = end - start, len2 = Math.min(x, y), thisCopy = this.slice(thisStart, thisEnd), targetCopy = target.slice(start, end);
    for (let i2 = 0;i2 < len2; ++i2)
      if (thisCopy[i2] !== targetCopy[i2]) {
        x = thisCopy[i2], y = targetCopy[i2];
        break;
      }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  Buffer2.prototype.write = function write2(string3, offset, length, encoding) {
    if (offset === undefined)
      encoding = "utf8", length = this.length, offset = 0;
    else if (length === undefined && typeof offset === "string")
      encoding = offset, length = this.length, offset = 0;
    else if (isFinite(offset))
      if (offset = offset >>> 0, isFinite(length)) {
        if (length = length >>> 0, encoding === undefined)
          encoding = "utf8";
      } else
        encoding = length, length = undefined;
    else
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    let remaining = this.length - offset;
    if (length === undefined || length > remaining)
      length = remaining;
    if (string3.length > 0 && (length < 0 || offset < 0) || offset > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (;; )
      switch (encoding) {
        case "hex":
          return hexWrite(this, string3, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string3, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string3, offset, length);
        case "base64":
          return base64Write(this, string3, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string3, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase(), loweredCase = true;
      }
  };
  Buffer2.prototype.toJSON = function toJSON() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  Buffer2.prototype.slice = function slice(start, end) {
    let len2 = this.length;
    if (start = ~~start, end = end === undefined ? len2 : ~~end, start < 0) {
      if (start += len2, start < 0)
        start = 0;
    } else if (start > len2)
      start = len2;
    if (end < 0) {
      if (end += len2, end < 0)
        end = 0;
    } else if (end > len2)
      end = len2;
    if (end < start)
      end = start;
    let newBuf = this.subarray(start, end);
    return Object.setPrototypeOf(newBuf, Buffer2.prototype), newBuf;
  };
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
    if (offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset], mul = 1, i2 = 0;
    while (++i2 < byteLength2 && (mul *= 256))
      val += this[offset + i2] * mul;
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
    if (offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset + --byteLength2], mul = 1;
    while (byteLength2 > 0 && (mul *= 256))
      val += this[offset + --byteLength2] * mul;
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0, validateNumber(offset, "offset");
    let first = this[offset], last = this[offset + 7];
    if (first === undefined || last === undefined)
      boundsError(offset, this.length - 8);
    let lo = first + this[++offset] * 256 + this[++offset] * 65536 + this[++offset] * 16777216, hi = this[++offset] + this[++offset] * 256 + this[++offset] * 65536 + last * 16777216;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0, validateNumber(offset, "offset");
    let first = this[offset], last = this[offset + 7];
    if (first === undefined || last === undefined)
      boundsError(offset, this.length - 8);
    let hi = first * 16777216 + this[++offset] * 65536 + this[++offset] * 256 + this[++offset], lo = this[++offset] * 16777216 + this[++offset] * 65536 + this[++offset] * 256 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
    if (offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset], mul = 1, i2 = 0;
    while (++i2 < byteLength2 && (mul *= 256))
      val += this[offset + i2] * mul;
    if (mul *= 128, val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
    if (offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert)
      checkOffset(offset, byteLength2, this.length);
    let i2 = byteLength2, mul = 1, val = this[offset + --i2];
    while (i2 > 0 && (mul *= 256))
      val += this[offset + --i2] * mul;
    if (mul *= 128, val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 2, this.length);
    let val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 2, this.length);
    let val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0, validateNumber(offset, "offset");
    let first = this[offset], last = this[offset + 7];
    if (first === undefined || last === undefined)
      boundsError(offset, this.length - 8);
    let val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 65536 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 65536 + this[++offset] * 16777216);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0, validateNumber(offset, "offset");
    let first = this[offset], last = this[offset + 7];
    if (first === undefined || last === undefined)
      boundsError(offset, this.length - 8);
    let val = (first << 24) + this[++offset] * 65536 + this[++offset] * 256 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 16777216 + this[++offset] * 65536 + this[++offset] * 256 + last);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 4, this.length);
    return read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 4, this.length);
    return read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 8, this.length);
    return read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 8, this.length);
    return read(this, offset, false, 52, 8);
  };
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value2, offset, byteLength2, noAssert) {
    if (value2 = +value2, offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert) {
      let maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value2, offset, byteLength2, maxBytes, 0);
    }
    let mul = 1, i2 = 0;
    this[offset] = value2 & 255;
    while (++i2 < byteLength2 && (mul *= 256))
      this[offset + i2] = value2 / mul & 255;
    return offset + byteLength2;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value2, offset, byteLength2, noAssert) {
    if (value2 = +value2, offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert) {
      let maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value2, offset, byteLength2, maxBytes, 0);
    }
    let i2 = byteLength2 - 1, mul = 1;
    this[offset + i2] = value2 & 255;
    while (--i2 >= 0 && (mul *= 256))
      this[offset + i2] = value2 / mul & 255;
    return offset + byteLength2;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value2, offset, noAssert) {
    if (value2 = +value2, offset = offset >>> 0, !noAssert)
      checkInt(this, value2, offset, 1, 255, 0);
    return this[offset] = value2 & 255, offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value2, offset, noAssert) {
    if (value2 = +value2, offset = offset >>> 0, !noAssert)
      checkInt(this, value2, offset, 2, 65535, 0);
    return this[offset] = value2 & 255, this[offset + 1] = value2 >>> 8, offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value2, offset, noAssert) {
    if (value2 = +value2, offset = offset >>> 0, !noAssert)
      checkInt(this, value2, offset, 2, 65535, 0);
    return this[offset] = value2 >>> 8, this[offset + 1] = value2 & 255, offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value2, offset, noAssert) {
    if (value2 = +value2, offset = offset >>> 0, !noAssert)
      checkInt(this, value2, offset, 4, 4294967295, 0);
    return this[offset + 3] = value2 >>> 24, this[offset + 2] = value2 >>> 16, this[offset + 1] = value2 >>> 8, this[offset] = value2 & 255, offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value2, offset, noAssert) {
    if (value2 = +value2, offset = offset >>> 0, !noAssert)
      checkInt(this, value2, offset, 4, 4294967295, 0);
    return this[offset] = value2 >>> 24, this[offset + 1] = value2 >>> 16, this[offset + 2] = value2 >>> 8, this[offset + 3] = value2 & 255, offset + 4;
  };
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value2, offset = 0) {
    return wrtBigUInt64LE(this, value2, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value2, offset = 0) {
    return wrtBigUInt64BE(this, value2, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value2, offset, byteLength2, noAssert) {
    if (value2 = +value2, offset = offset >>> 0, !noAssert) {
      let limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value2, offset, byteLength2, limit - 1, -limit);
    }
    let i2 = 0, mul = 1, sub = 0;
    this[offset] = value2 & 255;
    while (++i2 < byteLength2 && (mul *= 256)) {
      if (value2 < 0 && sub === 0 && this[offset + i2 - 1] !== 0)
        sub = 1;
      this[offset + i2] = (value2 / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value2, offset, byteLength2, noAssert) {
    if (value2 = +value2, offset = offset >>> 0, !noAssert) {
      let limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value2, offset, byteLength2, limit - 1, -limit);
    }
    let i2 = byteLength2 - 1, mul = 1, sub = 0;
    this[offset + i2] = value2 & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      if (value2 < 0 && sub === 0 && this[offset + i2 + 1] !== 0)
        sub = 1;
      this[offset + i2] = (value2 / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value2, offset, noAssert) {
    if (value2 = +value2, offset = offset >>> 0, !noAssert)
      checkInt(this, value2, offset, 1, 127, -128);
    if (value2 < 0)
      value2 = 255 + value2 + 1;
    return this[offset] = value2 & 255, offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value2, offset, noAssert) {
    if (value2 = +value2, offset = offset >>> 0, !noAssert)
      checkInt(this, value2, offset, 2, 32767, -32768);
    return this[offset] = value2 & 255, this[offset + 1] = value2 >>> 8, offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value2, offset, noAssert) {
    if (value2 = +value2, offset = offset >>> 0, !noAssert)
      checkInt(this, value2, offset, 2, 32767, -32768);
    return this[offset] = value2 >>> 8, this[offset + 1] = value2 & 255, offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value2, offset, noAssert) {
    if (value2 = +value2, offset = offset >>> 0, !noAssert)
      checkInt(this, value2, offset, 4, 2147483647, -2147483648);
    return this[offset] = value2 & 255, this[offset + 1] = value2 >>> 8, this[offset + 2] = value2 >>> 16, this[offset + 3] = value2 >>> 24, offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value2, offset, noAssert) {
    if (value2 = +value2, offset = offset >>> 0, !noAssert)
      checkInt(this, value2, offset, 4, 2147483647, -2147483648);
    if (value2 < 0)
      value2 = 4294967295 + value2 + 1;
    return this[offset] = value2 >>> 24, this[offset + 1] = value2 >>> 16, this[offset + 2] = value2 >>> 8, this[offset + 3] = value2 & 255, offset + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value2, offset = 0) {
    return wrtBigUInt64LE(this, value2, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value2, offset = 0) {
    return wrtBigUInt64BE(this, value2, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value2, offset, noAssert) {
    return writeFloat(this, value2, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value2, offset, noAssert) {
    return writeFloat(this, value2, offset, false, noAssert);
  };
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value2, offset, noAssert) {
    return writeDouble(this, value2, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value2, offset, noAssert) {
    return writeDouble(this, value2, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0)
      throw new RangeError("targetStart out of bounds");
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start)
      end = target.length - targetStart + start;
    let len2 = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function")
      this.copyWithin(targetStart, start, end);
    else
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len2;
  };
  Buffer2.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string")
        encoding = start, start = 0, end = this.length;
      else if (typeof end === "string")
        encoding = end, end = this.length;
      if (encoding !== undefined && typeof encoding !== "string")
        throw new TypeError("encoding must be a string");
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding))
        throw new TypeError("Unknown encoding: " + encoding);
      if (val.length === 1) {
        let code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1")
          val = code2;
      }
    } else if (typeof val === "number")
      val = val & 255;
    else if (typeof val === "boolean")
      val = Number(val);
    if (start < 0 || this.length < start || this.length < end)
      throw new RangeError("Out of range index");
    if (end <= start)
      return this;
    if (start = start >>> 0, end = end === undefined ? this.length : end >>> 0, !val)
      val = 0;
    let i2;
    if (typeof val === "number")
      for (i2 = start;i2 < end; ++i2)
        this[i2] = val;
    else {
      let bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding), len2 = bytes.length;
      if (len2 === 0)
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      for (i2 = 0;i2 < end - start; ++i2)
        this[i2 + start] = bytes[i2 % len2];
    }
    return this;
  };
  INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  hexSliceLookupTable = function() {
    let table = new Array(256);
    for (let i2 = 0;i2 < 16; ++i2) {
      let i16 = i2 * 16;
      for (let j = 0;j < 16; ++j)
        table[i16 + j] = "0123456789abcdef"[i2] + "0123456789abcdef"[j];
    }
    return table;
  }();
  resolveObjectURL = notimpl("resolveObjectURL");
  isUtf8 = notimpl("isUtf8");
  transcode = notimpl("transcode");
  buffer_default = Buffer2;
});

// node:util
var exports_util = {};
__export(exports_util, {
  types: () => types,
  promisify: () => promisify,
  log: () => log,
  isUndefined: () => isUndefined,
  isSymbol: () => isSymbol,
  isString: () => isString,
  isRegExp: () => isRegExp,
  isPrimitive: () => isPrimitive,
  isObject: () => isObject2,
  isNumber: () => isNumber,
  isNullOrUndefined: () => isNullOrUndefined,
  isNull: () => isNull,
  isFunction: () => isFunction,
  isError: () => isError,
  isDate: () => isDate2,
  isBuffer: () => isBuffer2,
  isBoolean: () => isBoolean,
  isArray: () => isArray,
  inspect: () => inspect2,
  inherits: () => inherits,
  format: () => format,
  deprecate: () => deprecate,
  default: () => util_default,
  debuglog: () => debuglog,
  callbackifyOnRejected: () => callbackifyOnRejected,
  callbackify: () => callbackify,
  _extend: () => _extend,
  TextEncoder: () => TextEncoder2,
  TextDecoder: () => TextDecoder2
});
function format(f, ...args) {
  if (!isString(f)) {
    var objects = [f];
    for (var i2 = 0;i2 < args.length; i2++)
      objects.push(inspect2(args[i2]));
    return objects.join(" ");
  }
  var i2 = 0, len2 = args.length, str = String(f).replace(formatRegExp, function(x2) {
    if (x2 === "%%")
      return "%";
    if (i2 >= len2)
      return x2;
    switch (x2) {
      case "%s":
        return String(args[i2++]);
      case "%d":
        return Number(args[i2++]);
      case "%j":
        try {
          return JSON.stringify(args[i2++]);
        } catch (_) {
          return "[Circular]";
        }
      default:
        return x2;
    }
  });
  for (var x = args[i2];i2 < len2; x = args[++i2])
    if (isNull(x) || !isObject2(x))
      str += " " + x;
    else
      str += " " + inspect2(x);
  return str;
}
function deprecate(fn, msg) {
  if (typeof process === "undefined" || process?.noDeprecation === true)
    return fn;
  var warned = false;
  function deprecated(...args) {
    if (!warned) {
      if (process.throwDeprecation)
        throw new Error(msg);
      else if (process.traceDeprecation)
        console.trace(msg);
      else
        console.error(msg);
      warned = true;
    }
    return fn.apply(this, ...args);
  }
  return deprecated;
}
function stylizeWithColor(str, styleType) {
  var style = inspect2.styles[styleType];
  if (style)
    return "\x1B[" + inspect2.colors[style][0] + "m" + str + "\x1B[" + inspect2.colors[style][1] + "m";
  else
    return str;
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array3) {
  var hash3 = {};
  return array3.forEach(function(val, idx) {
    hash3[val] = true;
  }), hash3;
}
function formatValue(ctx, value2, recurseTimes) {
  if (ctx.customInspect && value2 && isFunction(value2.inspect) && value2.inspect !== inspect2 && !(value2.constructor && value2.constructor.prototype === value2)) {
    var ret = value2.inspect(recurseTimes, ctx);
    if (!isString(ret))
      ret = formatValue(ctx, ret, recurseTimes);
    return ret;
  }
  var primitive = formatPrimitive(ctx, value2);
  if (primitive)
    return primitive;
  var keys = Object.keys(value2), visibleKeys = arrayToHash(keys);
  if (ctx.showHidden)
    keys = Object.getOwnPropertyNames(value2);
  if (isError(value2) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0))
    return formatError(value2);
  if (keys.length === 0) {
    if (isFunction(value2)) {
      var name = value2.name ? ": " + value2.name : "";
      return ctx.stylize("[Function" + name + "]", "special");
    }
    if (isRegExp(value2))
      return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
    if (isDate2(value2))
      return ctx.stylize(Date.prototype.toString.call(value2), "date");
    if (isError(value2))
      return formatError(value2);
  }
  var base = "", array3 = false, braces = ["{", "}"];
  if (isArray(value2))
    array3 = true, braces = ["[", "]"];
  if (isFunction(value2)) {
    var n = value2.name ? ": " + value2.name : "";
    base = " [Function" + n + "]";
  }
  if (isRegExp(value2))
    base = " " + RegExp.prototype.toString.call(value2);
  if (isDate2(value2))
    base = " " + Date.prototype.toUTCString.call(value2);
  if (isError(value2))
    base = " " + formatError(value2);
  if (keys.length === 0 && (!array3 || value2.length == 0))
    return braces[0] + base + braces[1];
  if (recurseTimes < 0)
    if (isRegExp(value2))
      return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
    else
      return ctx.stylize("[Object]", "special");
  ctx.seen.push(value2);
  var output;
  if (array3)
    output = formatArray(ctx, value2, recurseTimes, visibleKeys, keys);
  else
    output = keys.map(function(key) {
      return formatProperty(ctx, value2, recurseTimes, visibleKeys, key, array3);
    });
  return ctx.seen.pop(), reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value2) {
  if (isUndefined(value2))
    return ctx.stylize("undefined", "undefined");
  if (isString(value2)) {
    var simple = "'" + JSON.stringify(value2).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber(value2))
    return ctx.stylize("" + value2, "number");
  if (isBoolean(value2))
    return ctx.stylize("" + value2, "boolean");
  if (isNull(value2))
    return ctx.stylize("null", "null");
}
function formatError(value2) {
  return "[" + Error.prototype.toString.call(value2) + "]";
}
function formatArray(ctx, value2, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i2 = 0, l = value2.length;i2 < l; ++i2)
    if (hasOwnProperty(value2, String(i2)))
      output.push(formatProperty(ctx, value2, recurseTimes, visibleKeys, String(i2), true));
    else
      output.push("");
  return keys.forEach(function(key) {
    if (!key.match(/^\d+$/))
      output.push(formatProperty(ctx, value2, recurseTimes, visibleKeys, key, true));
  }), output;
}
function formatProperty(ctx, value2, recurseTimes, visibleKeys, key, array3) {
  var name, str, desc;
  if (desc = Object.getOwnPropertyDescriptor(value2, key) || { value: value2[key] }, desc.get)
    if (desc.set)
      str = ctx.stylize("[Getter/Setter]", "special");
    else
      str = ctx.stylize("[Getter]", "special");
  else if (desc.set)
    str = ctx.stylize("[Setter]", "special");
  if (!hasOwnProperty(visibleKeys, key))
    name = "[" + key + "]";
  if (!str)
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes))
        str = formatValue(ctx, desc.value, null);
      else
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      if (str.indexOf(`
`) > -1)
        if (array3)
          str = str.split(`
`).map(function(line) {
            return "  " + line;
          }).join(`
`).slice(2);
        else
          str = `
` + str.split(`
`).map(function(line) {
            return "   " + line;
          }).join(`
`);
    } else
      str = ctx.stylize("[Circular]", "special");
  if (isUndefined(name)) {
    if (array3 && key.match(/^\d+$/))
      return str;
    if (name = JSON.stringify("" + key), name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/))
      name = name.slice(1, -1), name = ctx.stylize(name, "name");
    else
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), name = ctx.stylize(name, "string");
  }
  return name + ": " + str;
}
function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0, length = output.reduce(function(prev, cur) {
    if (numLinesEst++, cur.indexOf(`
`) >= 0)
      numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length > 60)
    return braces[0] + (base === "" ? "" : base + `
 `) + " " + output.join(`,
  `) + " " + braces[1];
  return braces[0] + base + " " + output.join(", ") + " " + braces[1];
}
function isArray(ar) {
  return Array.isArray(ar);
}
function isBoolean(arg) {
  return typeof arg === "boolean";
}
function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return arg == null;
}
function isNumber(arg) {
  return typeof arg === "number";
}
function isString(arg) {
  return typeof arg === "string";
}
function isSymbol(arg) {
  return typeof arg === "symbol";
}
function isUndefined(arg) {
  return arg === undefined;
}
function isRegExp(re) {
  return isObject2(re) && objectToString(re) === "[object RegExp]";
}
function isObject2(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate2(d) {
  return isObject2(d) && objectToString(d) === "[object Date]";
}
function isError(e) {
  return isObject2(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
}
function isFunction(arg) {
  return typeof arg === "function";
}
function isPrimitive(arg) {
  return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
}
function isBuffer2(arg) {
  return arg instanceof Buffer;
}
function objectToString(o) {
  return Object.prototype.toString.call(o);
}
function pad(n) {
  return n < 10 ? "0" + n.toString(10) : n.toString(10);
}
function timestamp() {
  var d = new Date, time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(":");
  return [d.getDate(), months[d.getMonth()], time].join(" ");
}
function log(...args) {
  console.log("%s - %s", timestamp(), format.apply(null, args));
}
function inherits(ctor, superCtor) {
  if (superCtor)
    ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, { constructor: { value: ctor, enumerable: false, writable: true, configurable: true } });
}
function _extend(origin, add) {
  if (!add || !isObject2(add))
    return origin;
  var keys = Object.keys(add), i2 = keys.length;
  while (i2--)
    origin[keys[i2]] = add[keys[i2]];
  return origin;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function callbackifyOnRejected(reason, cb) {
  if (!reason) {
    var newReason = new Error("Promise was rejected with a falsy value");
    newReason.reason = reason, reason = newReason;
  }
  return cb(reason);
}
function callbackify(original) {
  if (typeof original !== "function")
    throw new TypeError('The "original" argument must be of type Function');
  function callbackified(...args) {
    var maybeCb = args.pop();
    if (typeof maybeCb !== "function")
      throw new TypeError("The last argument must be of type Function");
    var self2 = this, cb = function(...args2) {
      return maybeCb.apply(self2, ...args2);
    };
    original.apply(this, args).then(function(ret) {
      process.nextTick(cb.bind(null, null, ret));
    }, function(rej) {
      process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
    });
  }
  return Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original)), Object.defineProperties(callbackified, Object.getOwnPropertyDescriptors(original)), callbackified;
}
var formatRegExp, debuglog, inspect2, types = () => {}, months, promisify, TextEncoder2, TextDecoder2, util_default;
var init_util = __esm(() => {
  formatRegExp = /%[sdj%]/g;
  debuglog = ((debugs = {}, debugEnvRegex = {}, debugEnv) => ((debugEnv = typeof process !== "undefined" && false) && (debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase()), debugEnvRegex = new RegExp("^" + debugEnv + "$", "i"), (set2) => {
    if (set2 = set2.toUpperCase(), !debugs[set2])
      if (debugEnvRegex.test(set2))
        debugs[set2] = function(...args) {
          console.error("%s: %s", set2, pid, format.apply(null, ...args));
        };
      else
        debugs[set2] = function() {};
    return debugs[set2];
  }))();
  inspect2 = ((i2) => (i2.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, i2.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, i2.custom = Symbol.for("nodejs.util.inspect.custom"), i2))(function inspect22(obj, opts, ...rest3) {
    var ctx = { seen: [], stylize: stylizeNoColor };
    if (rest3.length >= 1)
      ctx.depth = rest3[0];
    if (rest3.length >= 2)
      ctx.colors = rest3[1];
    if (isBoolean(opts))
      ctx.showHidden = opts;
    else if (opts)
      _extend(ctx, opts);
    if (isUndefined(ctx.showHidden))
      ctx.showHidden = false;
    if (isUndefined(ctx.depth))
      ctx.depth = 2;
    if (isUndefined(ctx.colors))
      ctx.colors = false;
    if (ctx.colors)
      ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  });
  months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  promisify = ((x) => (x.custom = Symbol.for("nodejs.util.promisify.custom"), x))(function promisify2(original) {
    if (typeof original !== "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
      var fn = original[kCustomPromisifiedSymbol];
      if (typeof fn !== "function")
        throw new TypeError('The "nodejs.util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(fn, kCustomPromisifiedSymbol, { value: fn, enumerable: false, writable: false, configurable: true }), fn;
    }
    function fn(...args) {
      var promiseResolve, promiseReject, promise3 = new Promise(function(resolve, reject) {
        promiseResolve = resolve, promiseReject = reject;
      });
      args.push(function(err, value2) {
        if (err)
          promiseReject(err);
        else
          promiseResolve(value2);
      });
      try {
        original.apply(this, args);
      } catch (err) {
        promiseReject(err);
      }
      return promise3;
    }
    if (Object.setPrototypeOf(fn, Object.getPrototypeOf(original)), kCustomPromisifiedSymbol)
      Object.defineProperty(fn, kCustomPromisifiedSymbol, { value: fn, enumerable: false, writable: false, configurable: true });
    return Object.defineProperties(fn, Object.getOwnPropertyDescriptors(original));
  });
  ({ TextEncoder: TextEncoder2, TextDecoder: TextDecoder2 } = globalThis);
  util_default = { TextEncoder: TextEncoder2, TextDecoder: TextDecoder2, promisify, log, inherits, _extend, callbackifyOnRejected, callbackify };
});

// node:events
var exports_events = {};
__export(exports_events, {
  setMaxListeners: () => setMaxListeners2,
  once: () => once2,
  listenerCount: () => listenerCount2,
  init: () => EventEmitter2,
  getMaxListeners: () => getMaxListeners2,
  getEventListeners: () => getEventListeners,
  default: () => events_default,
  captureRejectionSymbol: () => captureRejectionSymbol,
  addAbortListener: () => addAbortListener,
  EventEmitter: () => EventEmitter2
});
function emitError(emitter, args) {
  var { _events: events } = emitter;
  if (args[0] ??= new Error("Unhandled error."), !events)
    throw args[0];
  var errorMonitor = events[kErrorMonitor];
  if (errorMonitor)
    for (var handler of ArrayPrototypeSlice.call(errorMonitor))
      handler.apply(emitter, args);
  var handlers = events.error;
  if (!handlers)
    throw args[0];
  for (var handler of ArrayPrototypeSlice.call(handlers))
    handler.apply(emitter, args);
  return true;
}
function addCatch(emitter, promise3, type3, args) {
  promise3.then(undefined, function(err) {
    queueMicrotask(() => emitUnhandledRejectionOrErr(emitter, err, type3, args));
  });
}
function emitUnhandledRejectionOrErr(emitter, err, type3, args) {
  if (typeof emitter[kRejection] === "function")
    emitter[kRejection](err, type3, ...args);
  else
    try {
      emitter[kCapture] = false, emitter.emit("error", err);
    } finally {
      emitter[kCapture] = true;
    }
}
function overflowWarning(emitter, type3, handlers) {
  handlers.warned = true;
  let warn = new Error(`Possible EventEmitter memory leak detected. ${handlers.length} ${String(type3)} listeners added to [${emitter.constructor.name}]. Use emitter.setMaxListeners() to increase limit`);
  warn.name = "MaxListenersExceededWarning", warn.emitter = emitter, warn.type = type3, warn.count = handlers.length, console.warn(warn);
}
function onceWrapper(type3, listener, ...args) {
  this.removeListener(type3, listener), listener.apply(this, args);
}
function once2(emitter, type3, options) {
  var signal = options?.signal;
  if (validateAbortSignal(signal, "options.signal"), signal?.aborted)
    throw new AbortError(undefined, { cause: signal?.reason });
  let { resolve, reject, promise: promise3 } = $newPromiseCapability(Promise), errorListener = (err) => {
    if (emitter.removeListener(type3, resolver2), signal != null)
      eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
    reject(err);
  }, resolver2 = (...args) => {
    if (typeof emitter.removeListener === "function")
      emitter.removeListener("error", errorListener);
    if (signal != null)
      eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
    resolve(args);
  };
  if (eventTargetAgnosticAddListener(emitter, type3, resolver2, { once: true }), type3 !== "error" && typeof emitter.once === "function")
    emitter.once("error", errorListener);
  function abortListener() {
    eventTargetAgnosticRemoveListener(emitter, type3, resolver2), eventTargetAgnosticRemoveListener(emitter, "error", errorListener), reject(new AbortError(undefined, { cause: signal?.reason }));
  }
  if (signal != null)
    eventTargetAgnosticAddListener(signal, "abort", abortListener, { once: true });
  return promise3;
}
function getEventListeners(emitter, type3) {
  return emitter.listeners(type3);
}
function setMaxListeners2(n, ...eventTargets) {
  validateNumber2(n, "setMaxListeners", 0);
  var length;
  if (eventTargets && (length = eventTargets.length))
    for (let i2 = 0;i2 < length; i2++)
      eventTargets[i2].setMaxListeners(n);
  else
    defaultMaxListeners = n;
}
function listenerCount2(emitter, type3) {
  return emitter.listenerCount(type3);
}
function eventTargetAgnosticRemoveListener(emitter, name, listener, flags) {
  if (typeof emitter.removeListener === "function")
    emitter.removeListener(name, listener);
  else
    emitter.removeEventListener(name, listener, flags);
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === "function")
    if (flags.once)
      emitter.once(name, listener);
    else
      emitter.on(name, listener);
  else
    emitter.addEventListener(name, listener, flags);
}
function ERR_INVALID_ARG_TYPE2(name, type3, value2) {
  let err = new TypeError(`The "${name}" argument must be of type ${type3}. Received ${value2}`);
  return err.code = "ERR_INVALID_ARG_TYPE", err;
}
function ERR_OUT_OF_RANGE2(name, range, value2) {
  let err = new RangeError(`The "${name}" argument is out of range. It must be ${range}. Received ${value2}`);
  return err.code = "ERR_OUT_OF_RANGE", err;
}
function validateAbortSignal(signal, name) {
  if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal)))
    throw ERR_INVALID_ARG_TYPE2(name, "AbortSignal", signal);
}
function validateNumber2(value2, name, min, max) {
  if (typeof value2 !== "number")
    throw ERR_INVALID_ARG_TYPE2(name, "number", value2);
  if (min != null && value2 < min || max != null && value2 > max || (min != null || max != null) && Number.isNaN(value2))
    throw ERR_OUT_OF_RANGE2(name, `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`, value2);
}
function checkListener(listener) {
  if (typeof listener !== "function")
    throw new TypeError("The listener must be a function");
}
function validateBoolean(value2, name) {
  if (typeof value2 !== "boolean")
    throw ERR_INVALID_ARG_TYPE2(name, "boolean", value2);
}
function getMaxListeners2(emitterOrTarget) {
  return emitterOrTarget?._maxListeners ?? defaultMaxListeners;
}
function addAbortListener(signal, listener) {
  if (signal === undefined)
    throw ERR_INVALID_ARG_TYPE2("signal", "AbortSignal", signal);
  if (validateAbortSignal(signal, "signal"), typeof listener !== "function")
    throw ERR_INVALID_ARG_TYPE2("listener", "function", listener);
  let removeEventListener;
  if (signal.aborted)
    queueMicrotask(() => listener());
  else
    signal.addEventListener("abort", listener, { __proto__: null, once: true }), removeEventListener = () => {
      signal.removeEventListener("abort", listener);
    };
  return { __proto__: null, [Symbol.dispose]() {
    removeEventListener?.();
  } };
}
var SymbolFor, kCapture, kErrorMonitor, kMaxEventTargetListeners, kMaxEventTargetListenersWarned, kRejection, captureRejectionSymbol, ArrayPrototypeSlice, defaultMaxListeners = 10, EventEmitter2 = function EventEmitter22(opts) {
  if (this._events === undefined || this._events === this.__proto__._events)
    this._events = { __proto__: null }, this._eventsCount = 0;
  if (this._maxListeners ??= undefined, this[kCapture] = opts?.captureRejections ? Boolean(opts?.captureRejections) : EventEmitterPrototype[kCapture])
    this.emit = emitWithRejectionCapture;
}, EventEmitterPrototype, emitWithoutRejectionCapture = function emit(type3, ...args) {
  if (type3 === "error")
    return emitError(this, args);
  var { _events: events } = this;
  if (events === undefined)
    return false;
  var handlers = events[type3];
  if (handlers === undefined)
    return false;
  let maybeClonedHandlers = handlers.length > 1 ? handlers.slice() : handlers;
  for (let i2 = 0, { length } = maybeClonedHandlers;i2 < length; i2++) {
    let handler = maybeClonedHandlers[i2];
    switch (args.length) {
      case 0:
        handler.call(this);
        break;
      case 1:
        handler.call(this, args[0]);
        break;
      case 2:
        handler.call(this, args[0], args[1]);
        break;
      case 3:
        handler.call(this, args[0], args[1], args[2]);
        break;
      default:
        handler.apply(this, args);
        break;
    }
  }
  return true;
}, emitWithRejectionCapture = function emit2(type3, ...args) {
  if (type3 === "error")
    return emitError(this, args);
  var { _events: events } = this;
  if (events === undefined)
    return false;
  var handlers = events[type3];
  if (handlers === undefined)
    return false;
  let maybeClonedHandlers = handlers.length > 1 ? handlers.slice() : handlers;
  for (let i2 = 0, { length } = maybeClonedHandlers;i2 < length; i2++) {
    let handler = maybeClonedHandlers[i2], result;
    switch (args.length) {
      case 0:
        result = handler.call(this);
        break;
      case 1:
        result = handler.call(this, args[0]);
        break;
      case 2:
        result = handler.call(this, args[0], args[1]);
        break;
      case 3:
        result = handler.call(this, args[0], args[1], args[2]);
        break;
      default:
        result = handler.apply(this, args);
        break;
    }
    if (result !== undefined && typeof result?.then === "function" && result.then === Promise.prototype.then)
      addCatch(this, result, type3, args);
  }
  return true;
}, AbortError, events_default;
var init_events = __esm(() => {
  SymbolFor = Symbol.for;
  kCapture = Symbol("kCapture");
  kErrorMonitor = SymbolFor("events.errorMonitor");
  kMaxEventTargetListeners = Symbol("events.maxEventTargetListeners");
  kMaxEventTargetListenersWarned = Symbol("events.maxEventTargetListenersWarned");
  kRejection = SymbolFor("nodejs.rejection");
  captureRejectionSymbol = SymbolFor("nodejs.rejection");
  ArrayPrototypeSlice = Array.prototype.slice;
  EventEmitterPrototype = EventEmitter2.prototype = {};
  EventEmitterPrototype._events = undefined;
  EventEmitterPrototype._eventsCount = 0;
  EventEmitterPrototype._maxListeners = undefined;
  EventEmitterPrototype.setMaxListeners = function setMaxListeners(n) {
    return validateNumber2(n, "setMaxListeners", 0), this._maxListeners = n, this;
  };
  EventEmitterPrototype.constructor = EventEmitter2;
  EventEmitterPrototype.getMaxListeners = function getMaxListeners() {
    return this?._maxListeners ?? defaultMaxListeners;
  };
  EventEmitterPrototype.emit = emitWithoutRejectionCapture;
  EventEmitterPrototype.addListener = function addListener(type3, fn) {
    checkListener(fn);
    var events = this._events;
    if (!events)
      events = this._events = { __proto__: null }, this._eventsCount = 0;
    else if (events.newListener)
      this.emit("newListener", type3, fn.listener ?? fn);
    var handlers = events[type3];
    if (!handlers)
      events[type3] = [fn], this._eventsCount++;
    else {
      handlers.push(fn);
      var m = this._maxListeners ?? defaultMaxListeners;
      if (m > 0 && handlers.length > m && !handlers.warned)
        overflowWarning(this, type3, handlers);
    }
    return this;
  };
  EventEmitterPrototype.on = EventEmitterPrototype.addListener;
  EventEmitterPrototype.prependListener = function prependListener(type3, fn) {
    checkListener(fn);
    var events = this._events;
    if (!events)
      events = this._events = { __proto__: null }, this._eventsCount = 0;
    else if (events.newListener)
      this.emit("newListener", type3, fn.listener ?? fn);
    var handlers = events[type3];
    if (!handlers)
      events[type3] = [fn], this._eventsCount++;
    else {
      handlers.unshift(fn);
      var m = this._maxListeners ?? defaultMaxListeners;
      if (m > 0 && handlers.length > m && !handlers.warned)
        overflowWarning(this, type3, handlers);
    }
    return this;
  };
  EventEmitterPrototype.once = function once(type3, fn) {
    checkListener(fn);
    let bound = onceWrapper.bind(this, type3, fn);
    return bound.listener = fn, this.addListener(type3, bound), this;
  };
  EventEmitterPrototype.prependOnceListener = function prependOnceListener(type3, fn) {
    checkListener(fn);
    let bound = onceWrapper.bind(this, type3, fn);
    return bound.listener = fn, this.prependListener(type3, bound), this;
  };
  EventEmitterPrototype.removeListener = function removeListener(type3, fn) {
    checkListener(fn);
    var { _events: events } = this;
    if (!events)
      return this;
    var handlers = events[type3];
    if (!handlers)
      return this;
    var length = handlers.length;
    let position = -1;
    for (let i2 = length - 1;i2 >= 0; i2--)
      if (handlers[i2] === fn || handlers[i2].listener === fn) {
        position = i2;
        break;
      }
    if (position < 0)
      return this;
    if (position === 0)
      handlers.shift();
    else
      handlers.splice(position, 1);
    if (handlers.length === 0)
      delete events[type3], this._eventsCount--;
    return this;
  };
  EventEmitterPrototype.off = EventEmitterPrototype.removeListener;
  EventEmitterPrototype.removeAllListeners = function removeAllListeners(type3) {
    var { _events: events } = this;
    if (type3 && events) {
      if (events[type3])
        delete events[type3], this._eventsCount--;
    } else
      this._events = { __proto__: null };
    return this;
  };
  EventEmitterPrototype.listeners = function listeners(type3) {
    var { _events: events } = this;
    if (!events)
      return [];
    var handlers = events[type3];
    if (!handlers)
      return [];
    return handlers.map((x) => x.listener ?? x);
  };
  EventEmitterPrototype.rawListeners = function rawListeners(type3) {
    var { _events } = this;
    if (!_events)
      return [];
    var handlers = _events[type3];
    if (!handlers)
      return [];
    return handlers.slice();
  };
  EventEmitterPrototype.listenerCount = function listenerCount(type3) {
    var { _events: events } = this;
    if (!events)
      return 0;
    return events[type3]?.length ?? 0;
  };
  EventEmitterPrototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
  };
  EventEmitterPrototype[kCapture] = false;
  AbortError = class AbortError extends Error {
    constructor(message = "The operation was aborted", options = undefined) {
      if (options !== undefined && typeof options !== "object")
        throw ERR_INVALID_ARG_TYPE2("options", "Object", options);
      super(message, options);
      this.code = "ABORT_ERR", this.name = "AbortError";
    }
  };
  Object.defineProperties(EventEmitter2, { captureRejections: { get() {
    return EventEmitterPrototype[kCapture];
  }, set(value2) {
    validateBoolean(value2, "EventEmitter.captureRejections"), EventEmitterPrototype[kCapture] = value2;
  }, enumerable: true }, defaultMaxListeners: { enumerable: true, get: () => {
    return defaultMaxListeners;
  }, set: (arg) => {
    validateNumber2(arg, "defaultMaxListeners", 0), defaultMaxListeners = arg;
  } }, kMaxEventTargetListeners: { value: kMaxEventTargetListeners, enumerable: false, configurable: false, writable: false }, kMaxEventTargetListenersWarned: { value: kMaxEventTargetListenersWarned, enumerable: false, configurable: false, writable: false } });
  Object.assign(EventEmitter2, { once: once2, getEventListeners, getMaxListeners: getMaxListeners2, setMaxListeners: setMaxListeners2, EventEmitter: EventEmitter2, usingDomains: false, captureRejectionSymbol, errorMonitor: kErrorMonitor, addAbortListener, init: EventEmitter2, listenerCount: listenerCount2 });
  events_default = EventEmitter2;
});

// node:stream
var require_stream = __commonJS((exports, module) => {
  var __commonJS2 = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
  var require_primordials = __commonJS2((exports2, module2) => {

    class AggregateError2 extends Error {
      constructor(errors2) {
        if (!Array.isArray(errors2))
          throw new TypeError(`Expected input to be an Array, got ${typeof errors2}`);
        let message = "";
        for (let i2 = 0;i2 < errors2.length; i2++)
          message += `    ${errors2[i2].stack}
`;
        super(message);
        this.name = "AggregateError", this.errors = errors2;
      }
    }
    module2.exports = { AggregateError: AggregateError2, ArrayIsArray(self2) {
      return Array.isArray(self2);
    }, ArrayPrototypeIncludes(self2, el) {
      return self2.includes(el);
    }, ArrayPrototypeIndexOf(self2, el) {
      return self2.indexOf(el);
    }, ArrayPrototypeJoin(self2, sep) {
      return self2.join(sep);
    }, ArrayPrototypeMap(self2, fn) {
      return self2.map(fn);
    }, ArrayPrototypePop(self2, el) {
      return self2.pop(el);
    }, ArrayPrototypePush(self2, el) {
      return self2.push(el);
    }, ArrayPrototypeSlice(self2, start, end) {
      return self2.slice(start, end);
    }, Error, FunctionPrototypeCall(fn, thisArgs, ...args) {
      return fn.call(thisArgs, ...args);
    }, FunctionPrototypeSymbolHasInstance(self2, instance) {
      return Function.prototype[Symbol.hasInstance].call(self2, instance);
    }, MathFloor: Math.floor, Number, NumberIsInteger: Number.isInteger, NumberIsNaN: Number.isNaN, NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER, NumberParseInt: Number.parseInt, ObjectDefineProperties(self2, props) {
      return Object.defineProperties(self2, props);
    }, ObjectDefineProperty(self2, name, prop) {
      return Object.defineProperty(self2, name, prop);
    }, ObjectGetOwnPropertyDescriptor(self2, name) {
      return Object.getOwnPropertyDescriptor(self2, name);
    }, ObjectKeys(obj) {
      return Object.keys(obj);
    }, ObjectSetPrototypeOf(target, proto) {
      return Object.setPrototypeOf(target, proto);
    }, Promise, PromisePrototypeCatch(self2, fn) {
      return self2.catch(fn);
    }, PromisePrototypeThen(self2, thenFn, catchFn) {
      return self2.then(thenFn, catchFn);
    }, PromiseReject(err) {
      return Promise.reject(err);
    }, PromiseResolve(val) {
      return Promise.resolve(val);
    }, ReflectApply: Reflect.apply, RegExpPrototypeTest(self2, value2) {
      return self2.test(value2);
    }, SafeSet: Set, String, StringPrototypeSlice(self2, start, end) {
      return self2.slice(start, end);
    }, StringPrototypeToLowerCase(self2) {
      return self2.toLowerCase();
    }, StringPrototypeToUpperCase(self2) {
      return self2.toUpperCase();
    }, StringPrototypeTrim(self2) {
      return self2.trim();
    }, Symbol, SymbolFor: Symbol.for, SymbolAsyncIterator: Symbol.asyncIterator, SymbolHasInstance: Symbol.hasInstance, SymbolIterator: Symbol.iterator, SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"), SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"), TypedArrayPrototypeSet(self2, buf, len2) {
      return self2.set(buf, len2);
    }, Boolean, Uint8Array };
  });
  var require_inspect = __commonJS2((exports2, module2) => {
    module2.exports = { format(format2, ...args) {
      return format2.replace(/%([sdifj])/g, function(...[_unused, type3]) {
        let replacement = args.shift();
        if (type3 === "f")
          return replacement.toFixed(6);
        else if (type3 === "j")
          return JSON.stringify(replacement);
        else if (type3 === "s" && typeof replacement === "object")
          return `${replacement.constructor !== Object ? replacement.constructor.name : ""} {}`.trim();
        else
          return replacement.toString();
      });
    }, inspect(value2) {
      switch (typeof value2) {
        case "string":
          if (value2.includes("'")) {
            if (!value2.includes('"'))
              return `"${value2}"`;
            else if (!value2.includes("`") && !value2.includes("${"))
              return `\`${value2}\``;
          }
          return `'${value2}'`;
        case "number":
          if (isNaN(value2))
            return "NaN";
          else if (Object.is(value2, -0))
            return String(value2);
          return value2;
        case "bigint":
          return `${String(value2)}n`;
        case "boolean":
        case "undefined":
          return String(value2);
        case "object":
          return "{}";
      }
    } };
  });
  var require_errors = __commonJS2((exports2, module2) => {
    var { format: format2, inspect: inspect3 } = require_inspect(), { AggregateError: CustomAggregateError } = require_primordials(), AggregateError2 = globalThis.AggregateError || CustomAggregateError, kIsNodeError = Symbol("kIsNodeError"), kTypes = ["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"], classRegExp = /^([A-Z][a-z0-9]*)+$/, codes = {};
    function assert(value2, message) {
      if (!value2)
        throw new codes.ERR_INTERNAL_ASSERTION(message);
    }
    function addNumericalSeparator2(val) {
      let res = "", i2 = val.length, start = val[0] === "-" ? 1 : 0;
      for (;i2 >= start + 4; i2 -= 3)
        res = `_${val.slice(i2 - 3, i2)}${res}`;
      return `${val.slice(0, i2)}${res}`;
    }
    function getMessage(key, msg, args) {
      if (typeof msg === "function")
        return assert(msg.length <= args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`), msg(...args);
      let expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
      if (assert(expectedLength === args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`), args.length === 0)
        return msg;
      return format2(msg, ...args);
    }
    function E2(code2, message, Base) {
      if (!Base)
        Base = Error;

      class NodeError extends Base {
        constructor(...args) {
          super(getMessage(code2, message, args));
        }
        toString() {
          return `${this.name} [${code2}]: ${this.message}`;
        }
      }
      Object.defineProperties(NodeError.prototype, { name: { value: Base.name, writable: true, enumerable: false, configurable: true }, toString: { value() {
        return `${this.name} [${code2}]: ${this.message}`;
      }, writable: true, enumerable: false, configurable: true } }), NodeError.prototype.code = code2, NodeError.prototype[kIsNodeError] = true, codes[code2] = NodeError;
    }
    function hideStackFrames(fn) {
      let hidden = "__node_internal_" + fn.name;
      return Object.defineProperty(fn, "name", { value: hidden }), fn;
    }
    function aggregateTwoErrors(innerError, outerError) {
      if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors))
          return outerError.errors.push(innerError), outerError;
        let err = new AggregateError2([outerError, innerError], outerError.message);
        return err.code = outerError.code, err;
      }
      return innerError || outerError;
    }

    class AbortError2 extends Error {
      constructor(message = "The operation was aborted", options = undefined) {
        if (options !== undefined && typeof options !== "object")
          throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
        super(message, options);
        this.code = "ABORT_ERR", this.name = "AbortError";
      }
    }
    E2("ERR_ASSERTION", "%s", Error);
    E2("ERR_INVALID_ARG_TYPE", (name, expected, actual) => {
      if (assert(typeof name === "string", "'name' must be a string"), !Array.isArray(expected))
        expected = [expected];
      let msg = "The ";
      if (name.endsWith(" argument"))
        msg += `${name} `;
      else
        msg += `"${name}" ${name.includes(".") ? "property" : "argument"} `;
      msg += "must be ";
      let types2 = [], instances = [], other = [];
      for (let value2 of expected)
        if (assert(typeof value2 === "string", "All expected entries have to be of type string"), kTypes.includes(value2))
          types2.push(value2.toLowerCase());
        else if (classRegExp.test(value2))
          instances.push(value2);
        else
          assert(value2 !== "object", 'The value "object" should be written as "Object"'), other.push(value2);
      if (instances.length > 0) {
        let pos = types2.indexOf("object");
        if (pos !== -1)
          types2.splice(types2, pos, 1), instances.push("Object");
      }
      if (types2.length > 0) {
        switch (types2.length) {
          case 1:
            msg += `of type ${types2[0]}`;
            break;
          case 2:
            msg += `one of type ${types2[0]} or ${types2[1]}`;
            break;
          default: {
            let last = types2.pop();
            msg += `one of type ${types2.join(", ")}, or ${last}`;
          }
        }
        if (instances.length > 0 || other.length > 0)
          msg += " or ";
      }
      if (instances.length > 0) {
        switch (instances.length) {
          case 1:
            msg += `an instance of ${instances[0]}`;
            break;
          case 2:
            msg += `an instance of ${instances[0]} or ${instances[1]}`;
            break;
          default: {
            let last = instances.pop();
            msg += `an instance of ${instances.join(", ")}, or ${last}`;
          }
        }
        if (other.length > 0)
          msg += " or ";
      }
      switch (other.length) {
        case 0:
          break;
        case 1:
          if (other[0].toLowerCase() !== other[0])
            msg += "an ";
          msg += `${other[0]}`;
          break;
        case 2:
          msg += `one of ${other[0]} or ${other[1]}`;
          break;
        default: {
          let last = other.pop();
          msg += `one of ${other.join(", ")}, or ${last}`;
        }
      }
      if (actual == null)
        msg += `. Received ${actual}`;
      else if (typeof actual === "function" && actual.name)
        msg += `. Received function ${actual.name}`;
      else if (typeof actual === "object") {
        var _actual$constructor;
        if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== undefined && _actual$constructor.name)
          msg += `. Received an instance of ${actual.constructor.name}`;
        else {
          let inspected = inspect3(actual, { depth: -1 });
          msg += `. Received ${inspected}`;
        }
      } else {
        let inspected = inspect3(actual, { colors: false });
        if (inspected.length > 25)
          inspected = `${inspected.slice(0, 25)}...`;
        msg += `. Received type ${typeof actual} (${inspected})`;
      }
      return msg;
    }, TypeError);
    E2("ERR_INVALID_ARG_VALUE", (name, value2, reason = "is invalid") => {
      let inspected = inspect3(value2);
      if (inspected.length > 128)
        inspected = inspected.slice(0, 128) + "...";
      return `The ${name.includes(".") ? "property" : "argument"} '${name}' ${reason}. Received ${inspected}`;
    }, TypeError);
    E2("ERR_INVALID_RETURN_VALUE", (input, name, value2) => {
      var _value$constructor;
      let type3 = value2 !== null && value2 !== undefined && (_value$constructor = value2.constructor) !== null && _value$constructor !== undefined && _value$constructor.name ? `instance of ${value2.constructor.name}` : `type ${typeof value2}`;
      return `Expected ${input} to be returned from the "${name}" function but got ${type3}.`;
    }, TypeError);
    E2("ERR_MISSING_ARGS", (...args) => {
      assert(args.length > 0, "At least one arg needs to be specified");
      let msg, len2 = args.length;
      switch (args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(" or "), len2) {
        case 1:
          msg += `The ${args[0]} argument`;
          break;
        case 2:
          msg += `The ${args[0]} and ${args[1]} arguments`;
          break;
        default:
          {
            let last = args.pop();
            msg += `The ${args.join(", ")}, and ${last} arguments`;
          }
          break;
      }
      return `${msg} must be specified`;
    }, TypeError);
    E2("ERR_OUT_OF_RANGE", (str, range, input) => {
      assert(range, 'Missing "range" argument');
      let received;
      if (Number.isInteger(input) && Math.abs(input) > 4294967296)
        received = addNumericalSeparator2(String(input));
      else if (typeof input === "bigint") {
        received = String(input);
        let limit = BigInt(2) ** BigInt(32);
        if (input > limit || input < -limit)
          received = addNumericalSeparator2(received);
        received += "n";
      } else
        received = inspect3(input);
      return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`;
    }, RangeError);
    E2("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    E2("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    E2("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    E2("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    E2("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    E2("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    E2("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    E2("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    E2("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    E2("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    E2("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    module2.exports = { AbortError: AbortError2, aggregateTwoErrors: hideStackFrames(aggregateTwoErrors), hideStackFrames, codes };
  });
  var require_event_target_shim = __commonJS2((exports2, module2) => {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var privateData = new WeakMap, wrappers = new WeakMap;
    function pd(event) {
      let retv = privateData.get(event);
      return console.assert(retv != null, "'this' is expected an Event object, but got", event), retv;
    }
    function setCancelFlag(data) {
      if (data.passiveListener != null) {
        if (typeof console !== "undefined" && typeof console.error === "function")
          console.error("Unable to preventDefault inside passive event listener invocation.", data.passiveListener);
        return;
      }
      if (!data.event.cancelable)
        return;
      if (data.canceled = true, typeof data.event.preventDefault === "function")
        data.event.preventDefault();
    }
    function Event(eventTarget, event) {
      privateData.set(this, { eventTarget, event, eventPhase: 2, currentTarget: eventTarget, canceled: false, stopped: false, immediateStopped: false, passiveListener: null, timeStamp: event.timeStamp || Date.now() }), Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
      let keys = Object.keys(event);
      for (let i2 = 0;i2 < keys.length; ++i2) {
        let key = keys[i2];
        if (!(key in this))
          Object.defineProperty(this, key, defineRedirectDescriptor(key));
      }
    }
    Event.prototype = { get type() {
      return pd(this).event.type;
    }, get target() {
      return pd(this).eventTarget;
    }, get currentTarget() {
      return pd(this).currentTarget;
    }, composedPath() {
      let currentTarget = pd(this).currentTarget;
      if (currentTarget == null)
        return [];
      return [currentTarget];
    }, get NONE() {
      return 0;
    }, get CAPTURING_PHASE() {
      return 1;
    }, get AT_TARGET() {
      return 2;
    }, get BUBBLING_PHASE() {
      return 3;
    }, get eventPhase() {
      return pd(this).eventPhase;
    }, stopPropagation() {
      let data = pd(this);
      if (data.stopped = true, typeof data.event.stopPropagation === "function")
        data.event.stopPropagation();
    }, stopImmediatePropagation() {
      let data = pd(this);
      if (data.stopped = true, data.immediateStopped = true, typeof data.event.stopImmediatePropagation === "function")
        data.event.stopImmediatePropagation();
    }, get bubbles() {
      return Boolean(pd(this).event.bubbles);
    }, get cancelable() {
      return Boolean(pd(this).event.cancelable);
    }, preventDefault() {
      setCancelFlag(pd(this));
    }, get defaultPrevented() {
      return pd(this).canceled;
    }, get composed() {
      return Boolean(pd(this).event.composed);
    }, get timeStamp() {
      return pd(this).timeStamp;
    }, get srcElement() {
      return pd(this).eventTarget;
    }, get cancelBubble() {
      return pd(this).stopped;
    }, set cancelBubble(value2) {
      if (!value2)
        return;
      let data = pd(this);
      if (data.stopped = true, typeof data.event.cancelBubble === "boolean")
        data.event.cancelBubble = true;
    }, get returnValue() {
      return !pd(this).canceled;
    }, set returnValue(value2) {
      if (!value2)
        setCancelFlag(pd(this));
    }, initEvent() {} };
    Object.defineProperty(Event.prototype, "constructor", { value: Event, configurable: true, writable: true });
    if (typeof window !== "undefined" && typeof window.Event !== "undefined")
      Object.setPrototypeOf(Event.prototype, window.Event.prototype), wrappers.set(window.Event.prototype, Event);
    function defineRedirectDescriptor(key) {
      return { get() {
        return pd(this).event[key];
      }, set(value2) {
        pd(this).event[key] = value2;
      }, configurable: true, enumerable: true };
    }
    function defineCallDescriptor(key) {
      return { value() {
        let event = pd(this).event;
        return event[key].apply(event, arguments);
      }, configurable: true, enumerable: true };
    }
    function defineWrapper(BaseEvent, proto) {
      let keys = Object.keys(proto);
      if (keys.length === 0)
        return BaseEvent;
      function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
      }
      CustomEvent.prototype = Object.create(BaseEvent.prototype, { constructor: { value: CustomEvent, configurable: true, writable: true } });
      for (let i2 = 0;i2 < keys.length; ++i2) {
        let key = keys[i2];
        if (!(key in BaseEvent.prototype)) {
          let isFunc = typeof Object.getOwnPropertyDescriptor(proto, key).value === "function";
          Object.defineProperty(CustomEvent.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));
        }
      }
      return CustomEvent;
    }
    function getWrapper(proto) {
      if (proto == null || proto === Object.prototype)
        return Event;
      let wrapper = wrappers.get(proto);
      if (wrapper == null)
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto), wrappers.set(proto, wrapper);
      return wrapper;
    }
    function wrapEvent(eventTarget, event) {
      return new (getWrapper(Object.getPrototypeOf(event)))(eventTarget, event);
    }
    function isStopped(event) {
      return pd(event).immediateStopped;
    }
    function setEventPhase(event, eventPhase) {
      pd(event).eventPhase = eventPhase;
    }
    function setCurrentTarget(event, currentTarget) {
      pd(event).currentTarget = currentTarget;
    }
    function setPassiveListener(event, passiveListener) {
      pd(event).passiveListener = passiveListener;
    }
    var listenersMap = new WeakMap, CAPTURE = 1, BUBBLE = 2, ATTRIBUTE = 3;
    function isObject3(x) {
      return x !== null && typeof x === "object";
    }
    function getListeners(eventTarget) {
      let listeners2 = listenersMap.get(eventTarget);
      if (listeners2 == null)
        throw new TypeError("'this' is expected an EventTarget object, but got another value.");
      return listeners2;
    }
    function defineEventAttributeDescriptor(eventName) {
      return { get() {
        let node = getListeners(this).get(eventName);
        while (node != null) {
          if (node.listenerType === ATTRIBUTE)
            return node.listener;
          node = node.next;
        }
        return null;
      }, set(listener) {
        if (typeof listener !== "function" && !isObject3(listener))
          listener = null;
        let listeners2 = getListeners(this), prev = null, node = listeners2.get(eventName);
        while (node != null) {
          if (node.listenerType === ATTRIBUTE)
            if (prev !== null)
              prev.next = node.next;
            else if (node.next !== null)
              listeners2.set(eventName, node.next);
            else
              listeners2.delete(eventName);
          else
            prev = node;
          node = node.next;
        }
        if (listener !== null) {
          let newNode = { listener, listenerType: ATTRIBUTE, passive: false, once: false, next: null };
          if (prev === null)
            listeners2.set(eventName, newNode);
          else
            prev.next = newNode;
        }
      }, configurable: true, enumerable: true };
    }
    function defineEventAttribute(eventTargetPrototype, eventName) {
      Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));
    }
    function defineCustomEventTarget(eventNames2) {
      function CustomEventTarget() {
        EventTarget.call(this);
      }
      CustomEventTarget.prototype = Object.create(EventTarget.prototype, { constructor: { value: CustomEventTarget, configurable: true, writable: true } });
      for (let i2 = 0;i2 < eventNames2.length; ++i2)
        defineEventAttribute(CustomEventTarget.prototype, eventNames2[i2]);
      return CustomEventTarget;
    }
    function EventTarget() {
      if (this instanceof EventTarget) {
        listenersMap.set(this, new Map);
        return;
      }
      if (arguments.length === 1 && Array.isArray(arguments[0]))
        return defineCustomEventTarget(arguments[0]);
      if (arguments.length > 0) {
        let types2 = new Array(arguments.length);
        for (let i2 = 0;i2 < arguments.length; ++i2)
          types2[i2] = arguments[i2];
        return defineCustomEventTarget(types2);
      }
      throw new TypeError("Cannot call a class as a function");
    }
    EventTarget.prototype = { addEventListener(eventName, listener, options) {
      if (listener == null)
        return;
      if (typeof listener !== "function" && !isObject3(listener))
        throw new TypeError("'listener' should be a function or an object.");
      let listeners2 = getListeners(this), optionsIsObj = isObject3(options), listenerType = (optionsIsObj ? Boolean(options.capture) : Boolean(options)) ? CAPTURE : BUBBLE, newNode = { listener, listenerType, passive: optionsIsObj && Boolean(options.passive), once: optionsIsObj && Boolean(options.once), next: null }, node = listeners2.get(eventName);
      if (node === undefined) {
        listeners2.set(eventName, newNode);
        return;
      }
      let prev = null;
      while (node != null) {
        if (node.listener === listener && node.listenerType === listenerType)
          return;
        prev = node, node = node.next;
      }
      prev.next = newNode;
    }, removeEventListener(eventName, listener, options) {
      if (listener == null)
        return;
      let listeners2 = getListeners(this), listenerType = (isObject3(options) ? Boolean(options.capture) : Boolean(options)) ? CAPTURE : BUBBLE, prev = null, node = listeners2.get(eventName);
      while (node != null) {
        if (node.listener === listener && node.listenerType === listenerType) {
          if (prev !== null)
            prev.next = node.next;
          else if (node.next !== null)
            listeners2.set(eventName, node.next);
          else
            listeners2.delete(eventName);
          return;
        }
        prev = node, node = node.next;
      }
    }, dispatchEvent(event) {
      if (event == null || typeof event.type !== "string")
        throw new TypeError('"event.type" should be a string.');
      let listeners2 = getListeners(this), eventName = event.type, node = listeners2.get(eventName);
      if (node == null)
        return true;
      let wrappedEvent = wrapEvent(this, event), prev = null;
      while (node != null) {
        if (node.once)
          if (prev !== null)
            prev.next = node.next;
          else if (node.next !== null)
            listeners2.set(eventName, node.next);
          else
            listeners2.delete(eventName);
        else
          prev = node;
        if (setPassiveListener(wrappedEvent, node.passive ? node.listener : null), typeof node.listener === "function")
          try {
            node.listener.call(this, wrappedEvent);
          } catch (err) {
            if (typeof console !== "undefined" && typeof console.error === "function")
              console.error(err);
          }
        else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function")
          node.listener.handleEvent(wrappedEvent);
        if (isStopped(wrappedEvent))
          break;
        node = node.next;
      }
      return setPassiveListener(wrappedEvent, null), setEventPhase(wrappedEvent, 0), setCurrentTarget(wrappedEvent, null), !wrappedEvent.defaultPrevented;
    } };
    Object.defineProperty(EventTarget.prototype, "constructor", { value: EventTarget, configurable: true, writable: true });
    if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined")
      Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
    exports2.defineEventAttribute = defineEventAttribute;
    exports2.EventTarget = EventTarget;
    exports2.default = EventTarget;
    module2.exports = EventTarget;
    module2.exports.EventTarget = module2.exports.default = EventTarget;
    module2.exports.defineEventAttribute = defineEventAttribute;
  });
  var require_abort_controller = __commonJS2((exports2, module2) => {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var eventTargetShim = require_event_target_shim();

    class AbortSignal extends eventTargetShim.EventTarget {
      constructor() {
        super();
        throw new TypeError("AbortSignal cannot be constructed directly");
      }
      get aborted() {
        let aborted = abortedFlags.get(this);
        if (typeof aborted !== "boolean")
          throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        return aborted;
      }
    }
    eventTargetShim.defineEventAttribute(AbortSignal.prototype, "abort");
    function createAbortSignal() {
      let signal = Object.create(AbortSignal.prototype);
      return eventTargetShim.EventTarget.call(signal), abortedFlags.set(signal, false), signal;
    }
    function abortSignal(signal) {
      if (abortedFlags.get(signal) !== false)
        return;
      abortedFlags.set(signal, true), signal.dispatchEvent({ type: "abort" });
    }
    var abortedFlags = new WeakMap;
    Object.defineProperties(AbortSignal.prototype, { aborted: { enumerable: true } });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol")
      Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, { configurable: true, value: "AbortSignal" });

    class AbortController {
      constructor() {
        signals.set(this, createAbortSignal());
      }
      get signal() {
        return getSignal(this);
      }
      abort() {
        abortSignal(getSignal(this));
      }
    }
    var signals = new WeakMap;
    function getSignal(controller) {
      let signal = signals.get(controller);
      if (signal == null)
        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
      return signal;
    }
    Object.defineProperties(AbortController.prototype, { signal: { enumerable: true }, abort: { enumerable: true } });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol")
      Object.defineProperty(AbortController.prototype, Symbol.toStringTag, { configurable: true, value: "AbortController" });
    exports2.AbortController = AbortController;
    exports2.AbortSignal = AbortSignal;
    exports2.default = AbortController;
    module2.exports = AbortController;
    module2.exports.AbortController = module2.exports.default = AbortController;
    module2.exports.AbortSignal = AbortSignal;
  });
  var require_util = __commonJS2((exports2, module2) => {
    var bufferModule = (init_buffer(), __toCommonJS(exports_buffer2)), { format: format2, inspect: inspect3 } = require_inspect(), { codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3 } } = require_errors(), { kResistStopPropagation, AggregateError: AggregateError2, SymbolDispose } = require_primordials(), AbortSignal = globalThis.AbortSignal || require_abort_controller().AbortSignal, AbortController = globalThis.AbortController || require_abort_controller().AbortController, AsyncFunction = Object.getPrototypeOf(async function() {}).constructor, Blob3 = globalThis.Blob || bufferModule.Blob, isBlob = typeof Blob3 !== "undefined" ? function isBlob(b) {
      return b instanceof Blob3;
    } : function isBlob(b) {
      return false;
    }, validateAbortSignal2 = (signal, name) => {
      if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal)))
        throw new ERR_INVALID_ARG_TYPE3(name, "AbortSignal", signal);
    }, validateFunction = (value2, name) => {
      if (typeof value2 !== "function")
        throw new ERR_INVALID_ARG_TYPE3(name, "Function", value2);
    };
    module2.exports = { AggregateError: AggregateError2, kEmptyObject: Object.freeze({}), once(callback) {
      let called = false;
      return function(...args) {
        if (called)
          return;
        called = true, callback.apply(this, args);
      };
    }, createDeferredPromise: function() {
      let resolve, reject;
      return { promise: new Promise((res, rej) => {
        resolve = res, reject = rej;
      }), resolve, reject };
    }, promisify(fn) {
      return new Promise((resolve, reject) => {
        fn((err, ...args) => {
          if (err)
            return reject(err);
          return resolve(...args);
        });
      });
    }, debuglog() {
      return function() {};
    }, format: format2, inspect: inspect3, types: { isAsyncFunction(fn) {
      return fn instanceof AsyncFunction;
    }, isArrayBufferView(arr) {
      return ArrayBuffer.isView(arr);
    } }, isBlob, deprecate(fn, message) {
      return fn;
    }, addAbortListener: (init_events(), __toCommonJS(exports_events)).addAbortListener || function addAbortListener(signal, listener) {
      if (signal === undefined)
        throw new ERR_INVALID_ARG_TYPE3("signal", "AbortSignal", signal);
      validateAbortSignal2(signal, "signal"), validateFunction(listener, "listener");
      let removeEventListener;
      if (signal.aborted)
        queueMicrotask(() => listener());
      else
        signal.addEventListener("abort", listener, { __proto__: null, once: true, [kResistStopPropagation]: true }), removeEventListener = () => {
          signal.removeEventListener("abort", listener);
        };
      return { __proto__: null, [SymbolDispose]() {
        var _removeEventListener;
        (_removeEventListener = removeEventListener) === null || _removeEventListener === undefined || _removeEventListener();
      } };
    }, AbortSignalAny: AbortSignal.any || function AbortSignalAny(signals) {
      if (signals.length === 1)
        return signals[0];
      let ac = new AbortController, abort = () => ac.abort();
      return signals.forEach((signal) => {
        validateAbortSignal2(signal, "signals"), signal.addEventListener("abort", abort, { once: true });
      }), ac.signal.addEventListener("abort", () => {
        signals.forEach((signal) => signal.removeEventListener("abort", abort));
      }, { once: true }), ac.signal;
    } };
    module2.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  });
  var require_validators = __commonJS2((exports2, module2) => {
    var { ArrayIsArray, ArrayPrototypeIncludes, ArrayPrototypeJoin, ArrayPrototypeMap, NumberIsInteger, NumberIsNaN, NumberMAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER, NumberParseInt, ObjectPrototypeHasOwnProperty, RegExpPrototypeExec, String: String22, StringPrototypeToUpperCase, StringPrototypeTrim } = require_primordials(), { hideStackFrames, codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE: ERR_OUT_OF_RANGE3, ERR_UNKNOWN_SIGNAL } } = require_errors(), { normalizeEncoding } = require_util(), { isAsyncFunction, isArrayBufferView } = require_util().types, signals = {};
    function isInt32(value2) {
      return value2 === (value2 | 0);
    }
    function isUint32(value2) {
      return value2 === value2 >>> 0;
    }
    var octalReg = /^[0-7]+$/, modeDesc = "must be a 32-bit unsigned integer or an octal string";
    function parseFileMode(value2, name, def) {
      if (typeof value2 === "undefined")
        value2 = def;
      if (typeof value2 === "string") {
        if (RegExpPrototypeExec(octalReg, value2) === null)
          throw new ERR_INVALID_ARG_VALUE(name, value2, modeDesc);
        value2 = NumberParseInt(value2, 8);
      }
      return validateUint32(value2, name), value2;
    }
    var validateInteger = hideStackFrames((value2, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
      if (typeof value2 !== "number")
        throw new ERR_INVALID_ARG_TYPE3(name, "number", value2);
      if (!NumberIsInteger(value2))
        throw new ERR_OUT_OF_RANGE3(name, "an integer", value2);
      if (value2 < min || value2 > max)
        throw new ERR_OUT_OF_RANGE3(name, `>= ${min} && <= ${max}`, value2);
    }), validateInt32 = hideStackFrames((value2, name, min = -2147483648, max = 2147483647) => {
      if (typeof value2 !== "number")
        throw new ERR_INVALID_ARG_TYPE3(name, "number", value2);
      if (!NumberIsInteger(value2))
        throw new ERR_OUT_OF_RANGE3(name, "an integer", value2);
      if (value2 < min || value2 > max)
        throw new ERR_OUT_OF_RANGE3(name, `>= ${min} && <= ${max}`, value2);
    }), validateUint32 = hideStackFrames((value2, name, positive = false) => {
      if (typeof value2 !== "number")
        throw new ERR_INVALID_ARG_TYPE3(name, "number", value2);
      if (!NumberIsInteger(value2))
        throw new ERR_OUT_OF_RANGE3(name, "an integer", value2);
      let min = positive ? 1 : 0, max = 4294967295;
      if (value2 < min || value2 > max)
        throw new ERR_OUT_OF_RANGE3(name, `>= ${min} && <= ${max}`, value2);
    });
    function validateString(value2, name) {
      if (typeof value2 !== "string")
        throw new ERR_INVALID_ARG_TYPE3(name, "string", value2);
    }
    function validateNumber3(value2, name, min = undefined, max) {
      if (typeof value2 !== "number")
        throw new ERR_INVALID_ARG_TYPE3(name, "number", value2);
      if (min != null && value2 < min || max != null && value2 > max || (min != null || max != null) && NumberIsNaN(value2))
        throw new ERR_OUT_OF_RANGE3(name, `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`, value2);
    }
    var validateOneOf = hideStackFrames((value2, name, oneOf) => {
      if (!ArrayPrototypeIncludes(oneOf, value2)) {
        let reason = "must be one of: " + ArrayPrototypeJoin(ArrayPrototypeMap(oneOf, (v) => typeof v === "string" ? `'${v}'` : String22(v)), ", ");
        throw new ERR_INVALID_ARG_VALUE(name, value2, reason);
      }
    });
    function validateBoolean2(value2, name) {
      if (typeof value2 !== "boolean")
        throw new ERR_INVALID_ARG_TYPE3(name, "boolean", value2);
    }
    function getOwnPropertyValueOrDefault(options, key, defaultValue) {
      return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
    }
    var validateObject = hideStackFrames((value2, name, options = null) => {
      let allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false), allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
      if (!getOwnPropertyValueOrDefault(options, "nullable", false) && value2 === null || !allowArray && ArrayIsArray(value2) || typeof value2 !== "object" && (!allowFunction || typeof value2 !== "function"))
        throw new ERR_INVALID_ARG_TYPE3(name, "Object", value2);
    }), validateDictionary = hideStackFrames((value2, name) => {
      if (value2 != null && typeof value2 !== "object" && typeof value2 !== "function")
        throw new ERR_INVALID_ARG_TYPE3(name, "a dictionary", value2);
    }), validateArray = hideStackFrames((value2, name, minLength = 0) => {
      if (!ArrayIsArray(value2))
        throw new ERR_INVALID_ARG_TYPE3(name, "Array", value2);
      if (value2.length < minLength) {
        let reason = `must be longer than ${minLength}`;
        throw new ERR_INVALID_ARG_VALUE(name, value2, reason);
      }
    });
    function validateStringArray(value2, name) {
      validateArray(value2, name);
      for (let i2 = 0;i2 < value2.length; i2++)
        validateString(value2[i2], `${name}[${i2}]`);
    }
    function validateBooleanArray(value2, name) {
      validateArray(value2, name);
      for (let i2 = 0;i2 < value2.length; i2++)
        validateBoolean2(value2[i2], `${name}[${i2}]`);
    }
    function validateAbortSignalArray(value2, name) {
      validateArray(value2, name);
      for (let i2 = 0;i2 < value2.length; i2++) {
        let signal = value2[i2], indexedName = `${name}[${i2}]`;
        if (signal == null)
          throw new ERR_INVALID_ARG_TYPE3(indexedName, "AbortSignal", signal);
        validateAbortSignal2(signal, indexedName);
      }
    }
    function validateSignalName(signal, name = "signal") {
      if (validateString(signal, name), signals[signal] === undefined) {
        if (signals[StringPrototypeToUpperCase(signal)] !== undefined)
          throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
        throw new ERR_UNKNOWN_SIGNAL(signal);
      }
    }
    var validateBuffer = hideStackFrames((buffer, name = "buffer") => {
      if (!isArrayBufferView(buffer))
        throw new ERR_INVALID_ARG_TYPE3(name, ["Buffer", "TypedArray", "DataView"], buffer);
    });
    function validateEncoding(data, encoding) {
      let normalizedEncoding = normalizeEncoding(encoding), length = data.length;
      if (normalizedEncoding === "hex" && length % 2 !== 0)
        throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
    }
    function validatePort(port, name = "Port", allowZero = true) {
      if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero)
        throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);
      return port | 0;
    }
    var validateAbortSignal2 = hideStackFrames((signal, name) => {
      if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal)))
        throw new ERR_INVALID_ARG_TYPE3(name, "AbortSignal", signal);
    }), validateFunction = hideStackFrames((value2, name) => {
      if (typeof value2 !== "function")
        throw new ERR_INVALID_ARG_TYPE3(name, "Function", value2);
    }), validatePlainFunction = hideStackFrames((value2, name) => {
      if (typeof value2 !== "function" || isAsyncFunction(value2))
        throw new ERR_INVALID_ARG_TYPE3(name, "Function", value2);
    }), validateUndefined = hideStackFrames((value2, name) => {
      if (value2 !== undefined)
        throw new ERR_INVALID_ARG_TYPE3(name, "undefined", value2);
    });
    function validateUnion(value2, name, union4) {
      if (!ArrayPrototypeIncludes(union4, value2))
        throw new ERR_INVALID_ARG_TYPE3(name, `('${ArrayPrototypeJoin(union4, "|")}')`, value2);
    }
    var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
    function validateLinkHeaderFormat(value2, name) {
      if (typeof value2 === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value2))
        throw new ERR_INVALID_ARG_VALUE(name, value2, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
    }
    function validateLinkHeaderValue(hints) {
      if (typeof hints === "string")
        return validateLinkHeaderFormat(hints, "hints"), hints;
      else if (ArrayIsArray(hints)) {
        let hintsLength = hints.length, result = "";
        if (hintsLength === 0)
          return result;
        for (let i2 = 0;i2 < hintsLength; i2++) {
          let link = hints[i2];
          if (validateLinkHeaderFormat(link, "hints"), result += link, i2 !== hintsLength - 1)
            result += ", ";
        }
        return result;
      }
      throw new ERR_INVALID_ARG_VALUE("hints", hints, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
    }
    module2.exports = { isInt32, isUint32, parseFileMode, validateArray, validateStringArray, validateBooleanArray, validateAbortSignalArray, validateBoolean: validateBoolean2, validateBuffer, validateDictionary, validateEncoding, validateFunction, validateInt32, validateInteger, validateNumber: validateNumber3, validateObject, validateOneOf, validatePlainFunction, validatePort, validateSignalName, validateString, validateUint32, validateUndefined, validateUnion, validateAbortSignal: validateAbortSignal2, validateLinkHeaderValue };
  });
  var require_process = __commonJS2((exports2, module2) => {
    module2.exports = globalThis.process;
  });
  var require_utils = __commonJS2((exports2, module2) => {
    var { SymbolAsyncIterator, SymbolIterator, SymbolFor: SymbolFor2 } = require_primordials(), kIsDestroyed = SymbolFor2("nodejs.stream.destroyed"), kIsErrored = SymbolFor2("nodejs.stream.errored"), kIsReadable = SymbolFor2("nodejs.stream.readable"), kIsWritable = SymbolFor2("nodejs.stream.writable"), kIsDisturbed = SymbolFor2("nodejs.stream.disturbed"), kIsClosedPromise = SymbolFor2("nodejs.webstream.isClosedPromise"), kControllerErrorFunction = SymbolFor2("nodejs.webstream.controllerErrorFunction");
    function isReadableNodeStream(obj, strict3 = false) {
      var _obj$_readableState;
      return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict3 || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === undefined ? undefined : _obj$_readableState.readable) !== false) && (!obj._writableState || obj._readableState));
    }
    function isWritableNodeStream(obj) {
      var _obj$_writableState;
      return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === undefined ? undefined : _obj$_writableState.writable) !== false));
    }
    function isDuplexNodeStream(obj) {
      return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
    }
    function isNodeStream(obj) {
      return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
    }
    function isReadableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
    }
    function isWritableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
    }
    function isTransformStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
    }
    function isWebStream(obj) {
      return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);
    }
    function isIterable(obj, isAsync2) {
      if (obj == null)
        return false;
      if (isAsync2 === true)
        return typeof obj[SymbolAsyncIterator] === "function";
      if (isAsync2 === false)
        return typeof obj[SymbolIterator] === "function";
      return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
    }
    function isDestroyed(stream) {
      if (!isNodeStream(stream))
        return null;
      let { _writableState: wState, _readableState: rState } = stream, state = wState || rState;
      return !!(stream.destroyed || stream[kIsDestroyed] || state !== null && state !== undefined && state.destroyed);
    }
    function isWritableEnded(stream) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableEnded === true)
        return true;
      let wState = stream._writableState;
      if (wState !== null && wState !== undefined && wState.errored)
        return false;
      if (typeof (wState === null || wState === undefined ? undefined : wState.ended) !== "boolean")
        return null;
      return wState.ended;
    }
    function isWritableFinished(stream, strict3) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableFinished === true)
        return true;
      let wState = stream._writableState;
      if (wState !== null && wState !== undefined && wState.errored)
        return false;
      if (typeof (wState === null || wState === undefined ? undefined : wState.finished) !== "boolean")
        return null;
      return !!(wState.finished || strict3 === false && wState.ended === true && wState.length === 0);
    }
    function isReadableEnded(stream) {
      if (!isReadableNodeStream(stream))
        return null;
      if (stream.readableEnded === true)
        return true;
      let rState = stream._readableState;
      if (!rState || rState.errored)
        return false;
      if (typeof (rState === null || rState === undefined ? undefined : rState.ended) !== "boolean")
        return null;
      return rState.ended;
    }
    function isReadableFinished(stream, strict3) {
      if (!isReadableNodeStream(stream))
        return null;
      let rState = stream._readableState;
      if (rState !== null && rState !== undefined && rState.errored)
        return false;
      if (typeof (rState === null || rState === undefined ? undefined : rState.endEmitted) !== "boolean")
        return null;
      return !!(rState.endEmitted || strict3 === false && rState.ended === true && rState.length === 0);
    }
    function isReadable(stream) {
      if (stream && stream[kIsReadable] != null)
        return stream[kIsReadable];
      if (typeof (stream === null || stream === undefined ? undefined : stream.readable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
    }
    function isWritable(stream) {
      if (stream && stream[kIsWritable] != null)
        return stream[kIsWritable];
      if (typeof (stream === null || stream === undefined ? undefined : stream.writable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
    }
    function isFinished(stream, opts) {
      if (!isNodeStream(stream))
        return null;
      if (isDestroyed(stream))
        return true;
      if ((opts === null || opts === undefined ? undefined : opts.readable) !== false && isReadable(stream))
        return false;
      if ((opts === null || opts === undefined ? undefined : opts.writable) !== false && isWritable(stream))
        return false;
      return true;
    }
    function isWritableErrored(stream) {
      var _stream$_writableStat, _stream$_writableStat2;
      if (!isNodeStream(stream))
        return null;
      if (stream.writableErrored)
        return stream.writableErrored;
      return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === undefined ? undefined : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== undefined ? _stream$_writableStat : null;
    }
    function isReadableErrored(stream) {
      var _stream$_readableStat, _stream$_readableStat2;
      if (!isNodeStream(stream))
        return null;
      if (stream.readableErrored)
        return stream.readableErrored;
      return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === undefined ? undefined : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== undefined ? _stream$_readableStat : null;
    }
    function isClosed(stream) {
      if (!isNodeStream(stream))
        return null;
      if (typeof stream.closed === "boolean")
        return stream.closed;
      let { _writableState: wState, _readableState: rState } = stream;
      if (typeof (wState === null || wState === undefined ? undefined : wState.closed) === "boolean" || typeof (rState === null || rState === undefined ? undefined : rState.closed) === "boolean")
        return (wState === null || wState === undefined ? undefined : wState.closed) || (rState === null || rState === undefined ? undefined : rState.closed);
      if (typeof stream._closed === "boolean" && isOutgoingMessage(stream))
        return stream._closed;
      return null;
    }
    function isOutgoingMessage(stream) {
      return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
    }
    function isServerResponse(stream) {
      return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
    }
    function isServerRequest(stream) {
      var _stream$req;
      return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === undefined ? undefined : _stream$req.upgradeOrConnect) === undefined;
    }
    function willEmitClose(stream) {
      if (!isNodeStream(stream))
        return null;
      let { _writableState: wState, _readableState: rState } = stream, state = wState || rState;
      return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
    }
    function isDisturbed(stream) {
      var _stream$kIsDisturbed;
      return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== undefined ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
    }
    function isErrored(stream) {
      var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
      return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== undefined ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== undefined ? _ref5 : stream.writableErrored) !== null && _ref4 !== undefined ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === undefined ? undefined : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== undefined ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === undefined ? undefined : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== undefined ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === undefined ? undefined : _stream$_readableStat4.errored) !== null && _ref !== undefined ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === undefined ? undefined : _stream$_writableStat4.errored));
    }
    module2.exports = { isDestroyed, kIsDestroyed, isDisturbed, kIsDisturbed, isErrored, kIsErrored, isReadable, kIsReadable, kIsClosedPromise, kControllerErrorFunction, kIsWritable, isClosed, isDuplexNodeStream, isFinished, isIterable, isReadableNodeStream, isReadableStream, isReadableEnded, isReadableFinished, isReadableErrored, isNodeStream, isWebStream, isWritable, isWritableNodeStream, isWritableStream, isWritableEnded, isWritableFinished, isWritableErrored, isServerRequest, isServerResponse, willEmitClose, isTransformStream };
  });
  var require_end_of_stream = __commonJS2((exports2, module2) => {
    var process2 = require_process(), { AbortError: AbortError2, codes } = require_errors(), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_STREAM_PREMATURE_CLOSE } = codes, { kEmptyObject, once: once3 } = require_util(), { validateAbortSignal: validateAbortSignal2, validateFunction, validateObject, validateBoolean: validateBoolean2 } = require_validators(), { Promise: Promise22, PromisePrototypeThen, SymbolDispose } = require_primordials(), { isClosed, isReadable, isReadableNodeStream, isReadableStream, isReadableFinished, isReadableErrored, isWritable, isWritableNodeStream, isWritableStream, isWritableFinished, isWritableErrored, isNodeStream, willEmitClose: _willEmitClose, kIsClosedPromise } = require_utils(), addAbortListener2;
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    var nop = () => {};
    function eos(stream, options, callback) {
      var _options$readable, _options$writable;
      if (arguments.length === 2)
        callback = options, options = kEmptyObject;
      else if (options == null)
        options = kEmptyObject;
      else
        validateObject(options, "options");
      if (validateFunction(callback, "callback"), validateAbortSignal2(options.signal, "options.signal"), callback = once3(callback), isReadableStream(stream) || isWritableStream(stream))
        return eosWeb(stream, options, callback);
      if (!isNodeStream(stream))
        throw new ERR_INVALID_ARG_TYPE3("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      let readable = (_options$readable = options.readable) !== null && _options$readable !== undefined ? _options$readable : isReadableNodeStream(stream), writable = (_options$writable = options.writable) !== null && _options$writable !== undefined ? _options$writable : isWritableNodeStream(stream), wState = stream._writableState, rState = stream._readableState, onlegacyfinish = () => {
        if (!stream.writable)
          onfinish();
      }, willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable, writableFinished = isWritableFinished(stream, false), onfinish = () => {
        if (writableFinished = true, stream.destroyed)
          willEmitClose = false;
        if (willEmitClose && (!stream.readable || readable))
          return;
        if (!readable || readableFinished)
          callback.call(stream);
      }, readableFinished = isReadableFinished(stream, false), onend = () => {
        if (readableFinished = true, stream.destroyed)
          willEmitClose = false;
        if (willEmitClose && (!stream.writable || writable))
          return;
        if (!writable || writableFinished)
          callback.call(stream);
      }, onerror = (err) => {
        callback.call(stream, err);
      }, closed = isClosed(stream), onclose = () => {
        closed = true;
        let errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean")
          return callback.call(stream, errored);
        if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
          if (!isReadableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE);
        }
        if (writable && !writableFinished) {
          if (!isWritableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE);
        }
        callback.call(stream);
      }, onclosed = () => {
        closed = true;
        let errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean")
          return callback.call(stream, errored);
        callback.call(stream);
      }, onrequest = () => {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        if (stream.on("complete", onfinish), !willEmitClose)
          stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !wState)
        stream.on("end", onlegacyfinish), stream.on("close", onlegacyfinish);
      if (!willEmitClose && typeof stream.aborted === "boolean")
        stream.on("aborted", onclose);
      if (stream.on("end", onend), stream.on("finish", onfinish), options.error !== false)
        stream.on("error", onerror);
      if (stream.on("close", onclose), closed)
        process2.nextTick(onclose);
      else if (wState !== null && wState !== undefined && wState.errorEmitted || rState !== null && rState !== undefined && rState.errorEmitted) {
        if (!willEmitClose)
          process2.nextTick(onclosed);
      } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false))
        process2.nextTick(onclosed);
      else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false))
        process2.nextTick(onclosed);
      else if (rState && stream.req && stream.aborted)
        process2.nextTick(onclosed);
      let cleanup = () => {
        if (callback = nop, stream.removeListener("aborted", onclose), stream.removeListener("complete", onfinish), stream.removeListener("abort", onclose), stream.removeListener("request", onrequest), stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish), stream.removeListener("close", onlegacyfinish), stream.removeListener("finish", onfinish), stream.removeListener("end", onend), stream.removeListener("error", onerror), stream.removeListener("close", onclose);
      };
      if (options.signal && !closed) {
        let abort = () => {
          let endCallback = callback;
          cleanup(), endCallback.call(stream, new AbortError2(undefined, { cause: options.signal.reason }));
        };
        if (options.signal.aborted)
          process2.nextTick(abort);
        else {
          addAbortListener2 = addAbortListener2 || require_util().addAbortListener;
          let disposable = addAbortListener2(options.signal, abort), originalCallback = callback;
          callback = once3((...args) => {
            disposable[SymbolDispose](), originalCallback.apply(stream, args);
          });
        }
      }
      return cleanup;
    }
    function eosWeb(stream, options, callback) {
      let isAborted = false, abort = nop;
      if (options.signal)
        if (abort = () => {
          isAborted = true, callback.call(stream, new AbortError2(undefined, { cause: options.signal.reason }));
        }, options.signal.aborted)
          process2.nextTick(abort);
        else {
          addAbortListener2 = addAbortListener2 || require_util().addAbortListener;
          let disposable = addAbortListener2(options.signal, abort), originalCallback = callback;
          callback = once3((...args) => {
            disposable[SymbolDispose](), originalCallback.apply(stream, args);
          });
        }
      let resolverFn = (...args) => {
        if (!isAborted)
          process2.nextTick(() => callback.apply(stream, args));
      };
      return PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn), nop;
    }
    function finished(stream, opts) {
      var _opts;
      let autoCleanup = false;
      if (opts === null)
        opts = kEmptyObject;
      if ((_opts = opts) !== null && _opts !== undefined && _opts.cleanup)
        validateBoolean2(opts.cleanup, "cleanup"), autoCleanup = opts.cleanup;
      return new Promise22((resolve, reject) => {
        let cleanup = eos(stream, opts, (err) => {
          if (autoCleanup)
            cleanup();
          if (err)
            reject(err);
          else
            resolve();
        });
      });
    }
    module2.exports = eos;
    module2.exports.finished = finished;
  });
  var require_destroy = __commonJS2((exports2, module2) => {
    var process2 = require_process(), { aggregateTwoErrors, codes: { ERR_MULTIPLE_CALLBACK }, AbortError: AbortError2 } = require_errors(), { Symbol: Symbol22 } = require_primordials(), { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils(), kDestroy = Symbol22("kDestroy"), kConstruct = Symbol22("kConstruct");
    function checkError(err, w, r) {
      if (err) {
        if (err.stack, w && !w.errored)
          w.errored = err;
        if (r && !r.errored)
          r.errored = err;
      }
    }
    function destroy(err, cb) {
      let r = this._readableState, w = this._writableState, s = w || r;
      if (w !== null && w !== undefined && w.destroyed || r !== null && r !== undefined && r.destroyed) {
        if (typeof cb === "function")
          cb();
        return this;
      }
      if (checkError(err, w, r), w)
        w.destroyed = true;
      if (r)
        r.destroyed = true;
      if (!s.constructed)
        this.once(kDestroy, function(er) {
          _destroy(this, aggregateTwoErrors(er, err), cb);
        });
      else
        _destroy(this, err, cb);
      return this;
    }
    function _destroy(self2, err, cb) {
      let called = false;
      function onDestroy(err2) {
        if (called)
          return;
        called = true;
        let { _readableState: r, _writableState: w } = self2;
        if (checkError(err2, w, r), w)
          w.closed = true;
        if (r)
          r.closed = true;
        if (typeof cb === "function")
          cb(err2);
        if (err2)
          process2.nextTick(emitErrorCloseNT, self2, err2);
        else
          process2.nextTick(emitCloseNT, self2);
      }
      try {
        self2._destroy(err || null, onDestroy);
      } catch (err2) {
        onDestroy(err2);
      }
    }
    function emitErrorCloseNT(self2, err) {
      emitErrorNT(self2, err), emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      let { _readableState: r, _writableState: w } = self2;
      if (w)
        w.closeEmitted = true;
      if (r)
        r.closeEmitted = true;
      if (w !== null && w !== undefined && w.emitClose || r !== null && r !== undefined && r.emitClose)
        self2.emit("close");
    }
    function emitErrorNT(self2, err) {
      let { _readableState: r, _writableState: w } = self2;
      if (w !== null && w !== undefined && w.errorEmitted || r !== null && r !== undefined && r.errorEmitted)
        return;
      if (w)
        w.errorEmitted = true;
      if (r)
        r.errorEmitted = true;
      self2.emit("error", err);
    }
    function undestroy() {
      let r = this._readableState, w = this._writableState;
      if (r)
        r.constructed = true, r.closed = false, r.closeEmitted = false, r.destroyed = false, r.errored = null, r.errorEmitted = false, r.reading = false, r.ended = r.readable === false, r.endEmitted = r.readable === false;
      if (w)
        w.constructed = true, w.destroyed = false, w.closed = false, w.closeEmitted = false, w.errored = null, w.errorEmitted = false, w.finalCalled = false, w.prefinished = false, w.ended = w.writable === false, w.ending = w.writable === false, w.finished = w.writable === false;
    }
    function errorOrDestroy(stream, err, sync) {
      let { _readableState: r, _writableState: w } = stream;
      if (w !== null && w !== undefined && w.destroyed || r !== null && r !== undefined && r.destroyed)
        return this;
      if (r !== null && r !== undefined && r.autoDestroy || w !== null && w !== undefined && w.autoDestroy)
        stream.destroy(err);
      else if (err) {
        if (err.stack, w && !w.errored)
          w.errored = err;
        if (r && !r.errored)
          r.errored = err;
        if (sync)
          process2.nextTick(emitErrorNT, stream, err);
        else
          emitErrorNT(stream, err);
      }
    }
    function construct(stream, cb) {
      if (typeof stream._construct !== "function")
        return;
      let { _readableState: r, _writableState: w } = stream;
      if (r)
        r.constructed = false;
      if (w)
        w.constructed = false;
      if (stream.once(kConstruct, cb), stream.listenerCount(kConstruct) > 1)
        return;
      process2.nextTick(constructNT, stream);
    }
    function constructNT(stream) {
      let called = false;
      function onConstruct(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== undefined ? err : new ERR_MULTIPLE_CALLBACK);
          return;
        }
        called = true;
        let { _readableState: r, _writableState: w } = stream, s = w || r;
        if (r)
          r.constructed = true;
        if (w)
          w.constructed = true;
        if (s.destroyed)
          stream.emit(kDestroy, err);
        else if (err)
          errorOrDestroy(stream, err, true);
        else
          process2.nextTick(emitConstructNT, stream);
      }
      try {
        stream._construct((err) => {
          process2.nextTick(onConstruct, err);
        });
      } catch (err) {
        process2.nextTick(onConstruct, err);
      }
    }
    function emitConstructNT(stream) {
      stream.emit(kConstruct);
    }
    function isRequest(stream) {
      return (stream === null || stream === undefined ? undefined : stream.setHeader) && typeof stream.abort === "function";
    }
    function emitCloseLegacy(stream) {
      stream.emit("close");
    }
    function emitErrorCloseLegacy(stream, err) {
      stream.emit("error", err), process2.nextTick(emitCloseLegacy, stream);
    }
    function destroyer(stream, err) {
      if (!stream || isDestroyed(stream))
        return;
      if (!err && !isFinished(stream))
        err = new AbortError2;
      if (isServerRequest(stream))
        stream.socket = null, stream.destroy(err);
      else if (isRequest(stream))
        stream.abort();
      else if (isRequest(stream.req))
        stream.req.abort();
      else if (typeof stream.destroy === "function")
        stream.destroy(err);
      else if (typeof stream.close === "function")
        stream.close();
      else if (err)
        process2.nextTick(emitErrorCloseLegacy, stream, err);
      else
        process2.nextTick(emitCloseLegacy, stream);
      if (!stream.destroyed)
        stream[kIsDestroyed] = true;
    }
    module2.exports = { construct, destroyer, destroy, undestroy, errorOrDestroy };
  });
  var require_legacy = __commonJS2((exports2, module2) => {
    var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials(), { EventEmitter: EE } = (init_events(), __toCommonJS(exports_events));
    function Stream(opts) {
      EE.call(this, opts);
    }
    ObjectSetPrototypeOf(Stream.prototype, EE.prototype);
    ObjectSetPrototypeOf(Stream, EE);
    Stream.prototype.pipe = function(dest, options) {
      let source = this;
      function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause)
          source.pause();
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume)
          source.resume();
      }
      if (dest.on("drain", ondrain), !dest._isStdio && (!options || options.end !== false))
        source.on("end", onend), source.on("close", onclose);
      let didOnEnd = false;
      function onend() {
        if (didOnEnd)
          return;
        didOnEnd = true, dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        if (didOnEnd = true, typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        if (cleanup(), EE.listenerCount(this, "error") === 0)
          this.emit("error", er);
      }
      prependListener2(source, "error", onerror), prependListener2(dest, "error", onerror);
      function cleanup() {
        source.removeListener("data", ondata), dest.removeListener("drain", ondrain), source.removeListener("end", onend), source.removeListener("close", onclose), source.removeListener("error", onerror), dest.removeListener("error", onerror), source.removeListener("end", cleanup), source.removeListener("close", cleanup), dest.removeListener("close", cleanup);
      }
      return source.on("end", cleanup), source.on("close", cleanup), dest.on("close", cleanup), dest.emit("pipe", source), dest;
    };
    function prependListener2(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (ArrayIsArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    module2.exports = { Stream, prependListener: prependListener2 };
  });
  var require_add_abort_signal = __commonJS2((exports2, module2) => {
    var { SymbolDispose } = require_primordials(), { AbortError: AbortError2, codes } = require_errors(), { isNodeStream, isWebStream, kControllerErrorFunction } = require_utils(), eos = require_end_of_stream(), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3 } = codes, addAbortListener2, validateAbortSignal2 = (signal, name) => {
      if (typeof signal !== "object" || !("aborted" in signal))
        throw new ERR_INVALID_ARG_TYPE3(name, "AbortSignal", signal);
    };
    module2.exports.addAbortSignal = function addAbortSignal(signal, stream) {
      if (validateAbortSignal2(signal, "signal"), !isNodeStream(stream) && !isWebStream(stream))
        throw new ERR_INVALID_ARG_TYPE3("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      return module2.exports.addAbortSignalNoValidate(signal, stream);
    };
    module2.exports.addAbortSignalNoValidate = function(signal, stream) {
      if (typeof signal !== "object" || !("aborted" in signal))
        return stream;
      let onAbort = isNodeStream(stream) ? () => {
        stream.destroy(new AbortError2(undefined, { cause: signal.reason }));
      } : () => {
        stream[kControllerErrorFunction](new AbortError2(undefined, { cause: signal.reason }));
      };
      if (signal.aborted)
        onAbort();
      else {
        addAbortListener2 = addAbortListener2 || require_util().addAbortListener;
        let disposable = addAbortListener2(signal, onAbort);
        eos(stream, disposable[SymbolDispose]);
      }
      return stream;
    };
  });
  var require_buffer_list = __commonJS2((exports2, module2) => {
    var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array22 } = require_primordials(), { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(exports_buffer2)), { inspect: inspect3 } = require_util();
    module2.exports = class BufferList {
      constructor() {
        this.head = null, this.tail = null, this.length = 0;
      }
      push(v) {
        let entry = { data: v, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry, ++this.length;
      }
      unshift(v) {
        let entry = { data: v, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry, ++this.length;
      }
      shift() {
        if (this.length === 0)
          return;
        let ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        return --this.length, ret;
      }
      clear() {
        this.head = this.tail = null, this.length = 0;
      }
      join(s) {
        if (this.length === 0)
          return "";
        let p = this.head, ret = "" + p.data;
        while ((p = p.next) !== null)
          ret += s + p.data;
        return ret;
      }
      concat(n) {
        if (this.length === 0)
          return Buffer3.alloc(0);
        let ret = Buffer3.allocUnsafe(n >>> 0), p = this.head, i2 = 0;
        while (p)
          TypedArrayPrototypeSet(ret, p.data, i2), i2 += p.data.length, p = p.next;
        return ret;
      }
      consume(n, hasStrings) {
        let data = this.head.data;
        if (n < data.length) {
          let slice2 = data.slice(0, n);
          return this.head.data = data.slice(n), slice2;
        }
        if (n === data.length)
          return this.shift();
        return hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      first() {
        return this.head.data;
      }
      *[SymbolIterator]() {
        for (let p = this.head;p; p = p.next)
          yield p.data;
      }
      _getString(n) {
        let ret = "", p = this.head, c = 0;
        do {
          let str = p.data;
          if (n > str.length)
            ret += str, n -= str.length;
          else {
            if (n === str.length)
              if (ret += str, ++c, p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            else
              ret += StringPrototypeSlice(str, 0, n), this.head = p, p.data = StringPrototypeSlice(str, n);
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        return this.length -= c, ret;
      }
      _getBuffer(n) {
        let ret = Buffer3.allocUnsafe(n), retLen = n, p = this.head, c = 0;
        do {
          let buf = p.data;
          if (n > buf.length)
            TypedArrayPrototypeSet(ret, buf, retLen - n), n -= buf.length;
          else {
            if (n === buf.length)
              if (TypedArrayPrototypeSet(ret, buf, retLen - n), ++c, p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            else
              TypedArrayPrototypeSet(ret, new Uint8Array22(buf.buffer, buf.byteOffset, n), retLen - n), this.head = p, p.data = buf.slice(n);
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        return this.length -= c, ret;
      }
      [Symbol.for("nodejs.util.inspect.custom")](_, options) {
        return inspect3(this, { ...options, depth: 0, customInspect: false });
      }
    };
  });
  var require_state = __commonJS2((exports2, module2) => {
    var { MathFloor, NumberIsInteger } = require_primordials(), { validateInteger } = require_validators(), { ERR_INVALID_ARG_VALUE } = require_errors().codes, defaultHighWaterMarkBytes = 16384, defaultHighWaterMarkObjectMode = 16;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getDefaultHighWaterMark(objectMode) {
      return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;
    }
    function setDefaultHighWaterMark(objectMode, value2) {
      if (validateInteger(value2, "value", 0), objectMode)
        defaultHighWaterMarkObjectMode = value2;
      else
        defaultHighWaterMarkBytes = value2;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      let hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!NumberIsInteger(hwm) || hwm < 0) {
          let name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
          throw new ERR_INVALID_ARG_VALUE(name, hwm);
        }
        return MathFloor(hwm);
      }
      return getDefaultHighWaterMark(state.objectMode);
    }
    module2.exports = { getHighWaterMark, getDefaultHighWaterMark, setDefaultHighWaterMark };
  });
  var require_safe_buffer = __commonJS2((exports2, module2) => {
    /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
    var buffer = (init_buffer(), __toCommonJS(exports_buffer2)), Buffer3 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src)
        dst[key] = src[key];
    }
    if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow)
      module2.exports = buffer;
    else
      copyProps(buffer, exports2), exports2.Buffer = SafeBuffer;
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer3(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer3.prototype);
    copyProps(Buffer3, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number")
        throw new TypeError("Argument must not be a number");
      return Buffer3(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill2, encoding) {
      if (typeof size !== "number")
        throw new TypeError("Argument must be a number");
      var buf = Buffer3(size);
      if (fill2 !== undefined)
        if (typeof encoding === "string")
          buf.fill(fill2, encoding);
        else
          buf.fill(fill2);
      else
        buf.fill(0);
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number")
        throw new TypeError("Argument must be a number");
      return Buffer3(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number")
        throw new TypeError("Argument must be a number");
      return buffer.SlowBuffer(size);
    };
  });
  var require_string_decoder = __commonJS2((exports2) => {
    var Buffer3 = require_safe_buffer().Buffer, isEncoding2 = Buffer3.isEncoding || function(encoding) {
      switch (encoding = "" + encoding, encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true)
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase(), retried = true;
        }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer3.isEncoding === isEncoding2 || !isEncoding2(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text, this.end = utf16End, nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast, nb = 4;
          break;
        case "base64":
          this.text = base64Text, this.end = base64End, nb = 3;
          break;
        default:
          this.write = simpleWrite, this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Buffer3.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r, i2;
      if (this.lastNeed) {
        if (r = this.fillLast(buf), r === undefined)
          return "";
        i2 = this.lastNeed, this.lastNeed = 0;
      } else
        i2 = 0;
      if (i2 < buf.length)
        return r ? r + this.text(buf, i2) : this.text(buf, i2);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length)
        return buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length), this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i2) {
      var j = buf.length - 1;
      if (j < i2)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i2 || nb === -2)
        return 0;
      if (nb = utf8CheckByte(buf[j]), nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i2 || nb === -2)
        return 0;
      if (nb = utf8CheckByte(buf[j]), nb >= 0) {
        if (nb > 0)
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128)
        return self2.lastNeed = 0, "";
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128)
          return self2.lastNeed = 1, "";
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128)
            return self2.lastNeed = 2, "";
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed, r = utf8CheckExtraBytes(this, buf, p);
      if (r !== undefined)
        return r;
      if (this.lastNeed <= buf.length)
        return buf.copy(this.lastChar, p, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      buf.copy(this.lastChar, p, 0, buf.length), this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i2) {
      var total = utf8CheckIncomplete(this, buf, i2);
      if (!this.lastNeed)
        return buf.toString("utf8", i2);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      return buf.copy(this.lastChar, 0, end), buf.toString("utf8", i2, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "";
      return r;
    }
    function utf16Text(buf, i2) {
      if ((buf.length - i2) % 2 === 0) {
        var r = buf.toString("utf16le", i2);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = buf[buf.length - 2], this.lastChar[1] = buf[buf.length - 1], r.slice(0, -1);
        }
        return r;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = buf[buf.length - 1], buf.toString("utf16le", i2, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i2) {
      var n = (buf.length - i2) % 3;
      if (n === 0)
        return buf.toString("base64", i2);
      if (this.lastNeed = 3 - n, this.lastTotal = 3, n === 1)
        this.lastChar[0] = buf[buf.length - 1];
      else
        this.lastChar[0] = buf[buf.length - 2], this.lastChar[1] = buf[buf.length - 1];
      return buf.toString("base64", i2, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  });
  var require_from = __commonJS2((exports2, module2) => {
    var process2 = require_process(), { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials(), { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(exports_buffer2)), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_STREAM_NULL_VALUES } = require_errors().codes;
    function from2(Readable, iterable, opts) {
      let iterator3;
      if (typeof iterable === "string" || iterable instanceof Buffer3)
        return new Readable({ objectMode: true, ...opts, read() {
          this.push(iterable), this.push(null);
        } });
      let isAsync2;
      if (iterable && iterable[SymbolAsyncIterator])
        isAsync2 = true, iterator3 = iterable[SymbolAsyncIterator]();
      else if (iterable && iterable[SymbolIterator])
        isAsync2 = false, iterator3 = iterable[SymbolIterator]();
      else
        throw new ERR_INVALID_ARG_TYPE3("iterable", ["Iterable"], iterable);
      let readable = new Readable({ objectMode: true, highWaterMark: 1, ...opts }), reading = false;
      readable._read = function() {
        if (!reading)
          reading = true, next();
      }, readable._destroy = function(error3, cb) {
        PromisePrototypeThen(close(error3), () => process2.nextTick(cb, error3), (e) => process2.nextTick(cb, e || error3));
      };
      async function close(error3) {
        let hadError = error3 !== undefined && error3 !== null, hasThrow = typeof iterator3.throw === "function";
        if (hadError && hasThrow) {
          let { value: value2, done } = await iterator3.throw(error3);
          if (await value2, done)
            return;
        }
        if (typeof iterator3.return === "function") {
          let { value: value2 } = await iterator3.return();
          await value2;
        }
      }
      async function next() {
        for (;; ) {
          try {
            let { value: value2, done } = isAsync2 ? await iterator3.next() : iterator3.next();
            if (done)
              readable.push(null);
            else {
              let res = value2 && typeof value2.then === "function" ? await value2 : value2;
              if (res === null)
                throw reading = false, new ERR_STREAM_NULL_VALUES;
              else if (readable.push(res))
                continue;
              else
                reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
          break;
        }
      }
      return readable;
    }
    module2.exports = from2;
  });
  var require_readable = __commonJS2((exports2, module2) => {
    var process2 = require_process(), { ArrayPrototypeIndexOf, NumberIsInteger, NumberIsNaN, NumberParseInt, ObjectDefineProperties, ObjectKeys, ObjectSetPrototypeOf, Promise: Promise22, SafeSet, SymbolAsyncDispose, SymbolAsyncIterator, Symbol: Symbol22 } = require_primordials();
    module2.exports = Readable;
    Readable.ReadableState = ReadableState;
    var { EventEmitter: EE } = (init_events(), __toCommonJS(exports_events)), { Stream, prependListener: prependListener2 } = require_legacy(), { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(exports_buffer2)), { addAbortSignal } = require_add_abort_signal(), eos = require_end_of_stream(), debug = require_util().debuglog("stream", (fn) => {
      debug = fn;
    }), BufferList = require_buffer_list(), destroyImpl = require_destroy(), { getHighWaterMark, getDefaultHighWaterMark } = require_state(), { aggregateTwoErrors, codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_METHOD_NOT_IMPLEMENTED, ERR_OUT_OF_RANGE: ERR_OUT_OF_RANGE3, ERR_STREAM_PUSH_AFTER_EOF, ERR_STREAM_UNSHIFT_AFTER_END_EVENT }, AbortError: AbortError2 } = require_errors(), { validateObject } = require_validators(), kPaused = Symbol22("kPaused"), { StringDecoder } = require_string_decoder(), from2 = require_from();
    ObjectSetPrototypeOf(Readable.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Readable, Stream);
    var nop = () => {}, { errorOrDestroy } = destroyImpl, kObjectMode = 1, kEnded = 2, kEndEmitted = 4, kReading = 8, kConstructed = 16, kSync = 32, kNeedReadable = 64, kEmittedReadable = 128, kReadableListening = 256, kResumeScheduled = 512, kErrorEmitted = 1024, kEmitClose = 2048, kAutoDestroy = 4096, kDestroyed = 8192, kClosed = 16384, kCloseEmitted = 32768, kMultiAwaitDrain = 65536, kReadingMore = 131072, kDataEmitted = 262144;
    function makeBitMapDescriptor(bit) {
      return { enumerable: false, get() {
        return (this.state & bit) !== 0;
      }, set(value2) {
        if (value2)
          this.state |= bit;
        else
          this.state &= ~bit;
      } };
    }
    ObjectDefineProperties(ReadableState.prototype, { objectMode: makeBitMapDescriptor(kObjectMode), ended: makeBitMapDescriptor(kEnded), endEmitted: makeBitMapDescriptor(kEndEmitted), reading: makeBitMapDescriptor(kReading), constructed: makeBitMapDescriptor(kConstructed), sync: makeBitMapDescriptor(kSync), needReadable: makeBitMapDescriptor(kNeedReadable), emittedReadable: makeBitMapDescriptor(kEmittedReadable), readableListening: makeBitMapDescriptor(kReadableListening), resumeScheduled: makeBitMapDescriptor(kResumeScheduled), errorEmitted: makeBitMapDescriptor(kErrorEmitted), emitClose: makeBitMapDescriptor(kEmitClose), autoDestroy: makeBitMapDescriptor(kAutoDestroy), destroyed: makeBitMapDescriptor(kDestroyed), closed: makeBitMapDescriptor(kClosed), closeEmitted: makeBitMapDescriptor(kCloseEmitted), multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain), readingMore: makeBitMapDescriptor(kReadingMore), dataEmitted: makeBitMapDescriptor(kDataEmitted) });
    function ReadableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex();
      if (this.state = kEmitClose | kAutoDestroy | kConstructed | kSync, options && options.objectMode)
        this.state |= kObjectMode;
      if (isDuplex && options && options.readableObjectMode)
        this.state |= kObjectMode;
      if (this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false), this.buffer = new BufferList, this.length = 0, this.pipes = [], this.flowing = null, this[kPaused] = null, options && options.emitClose === false)
        this.state &= ~kEmitClose;
      if (options && options.autoDestroy === false)
        this.state &= ~kAutoDestroy;
      if (this.errored = null, this.defaultEncoding = options && options.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.decoder = null, this.encoding = null, options && options.encoding)
        this.decoder = new StringDecoder(options.encoding), this.encoding = options.encoding;
    }
    function Readable(options) {
      if (!(this instanceof Readable))
        return new Readable(options);
      let isDuplex = this instanceof require_duplex();
      if (this._readableState = new ReadableState(options, this, isDuplex), options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.construct === "function")
          this._construct = options.construct;
        if (options.signal && !isDuplex)
          addAbortSignal(options.signal, this);
      }
      Stream.call(this, options), destroyImpl.construct(this, () => {
        if (this._readableState.needReadable)
          maybeReadMore(this, this._readableState);
      });
    }
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    Readable.prototype[SymbolAsyncDispose] = function() {
      let error3;
      if (!this.destroyed)
        error3 = this.readableEnded ? null : new AbortError2, this.destroy(error3);
      return new Promise22((resolve, reject) => eos(this, (err) => err && err !== error3 ? reject(err) : resolve(null)));
    };
    Readable.prototype.push = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, true);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront) {
      debug("readableAddChunk", chunk);
      let state = stream._readableState, err;
      if ((state.state & kObjectMode) === 0) {
        if (typeof chunk === "string") {
          if (encoding = encoding || state.defaultEncoding, state.encoding !== encoding)
            if (addToFront && state.encoding)
              chunk = Buffer3.from(chunk, encoding).toString(state.encoding);
            else
              chunk = Buffer3.from(chunk, encoding), encoding = "";
        } else if (chunk instanceof Buffer3)
          encoding = "";
        else if (Stream._isUint8Array(chunk))
          chunk = Stream._uint8ArrayToBuffer(chunk), encoding = "";
        else if (chunk != null)
          err = new ERR_INVALID_ARG_TYPE3("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      if (err)
        errorOrDestroy(stream, err);
      else if (chunk === null)
        state.state &= ~kReading, onEofChunk(stream, state);
      else if ((state.state & kObjectMode) !== 0 || chunk && chunk.length > 0)
        if (addToFront)
          if ((state.state & kEndEmitted) !== 0)
            errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT);
          else if (state.destroyed || state.errored)
            return false;
          else
            addChunk(stream, state, chunk, true);
        else if (state.ended)
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF);
        else if (state.destroyed || state.errored)
          return false;
        else if (state.state &= ~kReading, state.decoder && !encoding)
          if (chunk = state.decoder.write(chunk), state.objectMode || chunk.length !== 0)
            addChunk(stream, state, chunk, false);
          else
            maybeReadMore(stream, state);
        else
          addChunk(stream, state, chunk, false);
      else if (!addToFront)
        state.state &= ~kReading, maybeReadMore(stream, state);
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
        if ((state.state & kMultiAwaitDrain) !== 0)
          state.awaitDrainWriters.clear();
        else
          state.awaitDrainWriters = null;
        state.dataEmitted = true, stream.emit("data", chunk);
      } else {
        if (state.length += state.objectMode ? 1 : chunk.length, addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if ((state.state & kNeedReadable) !== 0)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    Readable.prototype.isPaused = function() {
      let state = this._readableState;
      return state[kPaused] === true || state.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      let decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder, this._readableState.encoding = this._readableState.decoder.encoding;
      let buffer = this._readableState.buffer, content = "";
      for (let data of buffer)
        content += decoder.write(data);
      if (buffer.clear(), content !== "")
        buffer.push(content);
      return this._readableState.length = content.length, this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n > MAX_HWM)
        throw new ERR_OUT_OF_RANGE3("size", "<= 1GiB", n);
      else
        n--, n |= n >>> 1, n |= n >>> 2, n |= n >>> 4, n |= n >>> 8, n |= n >>> 16, n++;
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if ((state.state & kObjectMode) !== 0)
        return 1;
      if (NumberIsNaN(n)) {
        if (state.flowing && state.length)
          return state.buffer.first().length;
        return state.length;
      }
      if (n <= state.length)
        return n;
      return state.ended ? state.length : 0;
    }
    Readable.prototype.read = function(n) {
      if (debug("read", n), n === undefined)
        n = NaN;
      else if (!NumberIsInteger(n))
        n = NumberParseInt(n, 10);
      let state = this._readableState, nOrig = n;
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n !== 0)
        state.state &= ~kEmittedReadable;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        if (debug("read: emitReadable", state.length, state.ended), state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      if (n = howMuchToRead(n, state), n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      let doRead = (state.state & kNeedReadable) !== 0;
      if (debug("need readable", doRead), state.length === 0 || state.length - n < state.highWaterMark)
        doRead = true, debug("length less than watermark", doRead);
      if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed)
        doRead = false, debug("reading, ended or constructing", doRead);
      else if (doRead) {
        if (debug("do read"), state.state |= kReading | kSync, state.length === 0)
          state.state |= kNeedReadable;
        try {
          this._read(state.highWaterMark);
        } catch (err) {
          errorOrDestroy(this, err);
        }
        if (state.state &= ~kSync, !state.reading)
          n = howMuchToRead(nOrig, state);
      }
      let ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null)
        state.needReadable = state.length <= state.highWaterMark, n = 0;
      else if (state.length -= n, state.multiAwaitDrain)
        state.awaitDrainWriters.clear();
      else
        state.awaitDrainWriters = null;
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null && !state.errorEmitted && !state.closeEmitted)
        state.dataEmitted = true, this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      if (debug("onEofChunk"), state.ended)
        return;
      if (state.decoder) {
        let chunk = state.decoder.end();
        if (chunk && chunk.length)
          state.buffer.push(chunk), state.length += state.objectMode ? 1 : chunk.length;
      }
      if (state.ended = true, state.sync)
        emitReadable(stream);
      else
        state.needReadable = false, state.emittedReadable = true, emitReadable_(stream);
    }
    function emitReadable(stream) {
      let state = stream._readableState;
      if (debug("emitReadable", state.needReadable, state.emittedReadable), state.needReadable = false, !state.emittedReadable)
        debug("emitReadable", state.flowing), state.emittedReadable = true, process2.nextTick(emitReadable_, stream);
    }
    function emitReadable_(stream) {
      let state = stream._readableState;
      if (debug("emitReadable_", state.destroyed, state.length, state.ended), !state.destroyed && !state.errored && (state.length || state.ended))
        stream.emit("readable"), state.emittedReadable = false;
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark, flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore && state.constructed)
        state.readingMore = true, process2.nextTick(maybeReadMore_, stream, state);
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        let len2 = state.length;
        if (debug("maybeReadMore read 0"), stream.read(0), len2 === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      let src = this, state = this._readableState;
      if (state.pipes.length === 1) {
        if (!state.multiAwaitDrain)
          state.multiAwaitDrain = true, state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
      }
      state.pipes.push(dest), debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
      let endFn = (!pipeOpts || pipeOpts.end !== false) && dest !== process2.stdout && dest !== process2.stderr ? onend : unpipe;
      if (state.endEmitted)
        process2.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        if (debug("onunpipe"), readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false)
            unpipeInfo.hasUnpiped = true, cleanup();
        }
      }
      function onend() {
        debug("onend"), dest.end();
      }
      let ondrain, cleanedUp = false;
      function cleanup() {
        if (debug("cleanup"), dest.removeListener("close", onclose), dest.removeListener("finish", onfinish), ondrain)
          dest.removeListener("drain", ondrain);
        if (dest.removeListener("error", onerror), dest.removeListener("unpipe", onunpipe), src.removeListener("end", onend), src.removeListener("end", unpipe), src.removeListener("data", ondata), cleanedUp = true, ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      function pause() {
        if (!cleanedUp) {
          if (state.pipes.length === 1 && state.pipes[0] === dest)
            debug("false write response, pause", 0), state.awaitDrainWriters = dest, state.multiAwaitDrain = false;
          else if (state.pipes.length > 1 && state.pipes.includes(dest))
            debug("false write response, pause", state.awaitDrainWriters.size), state.awaitDrainWriters.add(dest);
          src.pause();
        }
        if (!ondrain)
          ondrain = pipeOnDrain(src, dest), dest.on("drain", ondrain);
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        let ret = dest.write(chunk);
        if (debug("dest.write", ret), ret === false)
          pause();
      }
      function onerror(er) {
        if (debug("onerror", er), unpipe(), dest.removeListener("error", onerror), dest.listenerCount("error") === 0) {
          let s = dest._writableState || dest._readableState;
          if (s && !s.errorEmitted)
            errorOrDestroy(dest, er);
          else
            dest.emit("error", er);
        }
      }
      prependListener2(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish), unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish"), dest.removeListener("close", onclose), unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe"), src.unpipe(dest);
      }
      if (dest.emit("pipe", src), dest.writableNeedDrain === true)
        pause();
      else if (!state.flowing)
        debug("pipe resume"), src.resume();
      return dest;
    };
    function pipeOnDrain(src, dest) {
      return function pipeOnDrainFunctionResult() {
        let state = src._readableState;
        if (state.awaitDrainWriters === dest)
          debug("pipeOnDrain", 1), state.awaitDrainWriters = null;
        else if (state.multiAwaitDrain)
          debug("pipeOnDrain", state.awaitDrainWriters.size), state.awaitDrainWriters.delete(dest);
        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount("data"))
          src.resume();
      };
    }
    Readable.prototype.unpipe = function(dest) {
      let state = this._readableState, unpipeInfo = { hasUnpiped: false };
      if (state.pipes.length === 0)
        return this;
      if (!dest) {
        let dests = state.pipes;
        state.pipes = [], this.pause();
        for (let i2 = 0;i2 < dests.length; i2++)
          dests[i2].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      let index = ArrayPrototypeIndexOf(state.pipes, dest);
      if (index === -1)
        return this;
      if (state.pipes.splice(index, 1), state.pipes.length === 0)
        this.pause();
      return dest.emit("unpipe", this, unpipeInfo), this;
    };
    Readable.prototype.on = function(ev, fn) {
      let res = Stream.prototype.on.call(this, ev, fn), state = this._readableState;
      if (ev === "data") {
        if (state.readableListening = this.listenerCount("readable") > 0, state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          if (state.readableListening = state.needReadable = true, state.flowing = false, state.emittedReadable = false, debug("on readable", state.length, state.reading), state.length)
            emitReadable(this);
          else if (!state.reading)
            process2.nextTick(nReadingNextTick, this);
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      let res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable")
        process2.nextTick(updateReadableListening, this);
      return res;
    };
    Readable.prototype.off = Readable.prototype.removeListener;
    Readable.prototype.removeAllListeners = function(ev) {
      let res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === undefined)
        process2.nextTick(updateReadableListening, this);
      return res;
    };
    function updateReadableListening(self2) {
      let state = self2._readableState;
      if (state.readableListening = self2.listenerCount("readable") > 0, state.resumeScheduled && state[kPaused] === false)
        state.flowing = true;
      else if (self2.listenerCount("data") > 0)
        self2.resume();
      else if (!state.readableListening)
        state.flowing = null;
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0"), self2.read(0);
    }
    Readable.prototype.resume = function() {
      let state = this._readableState;
      if (!state.flowing)
        debug("resume"), state.flowing = !state.readableListening, resume(this, state);
      return state[kPaused] = false, this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled)
        state.resumeScheduled = true, process2.nextTick(resume_, stream, state);
    }
    function resume_(stream, state) {
      if (debug("resume", state.reading), !state.reading)
        stream.read(0);
      if (state.resumeScheduled = false, stream.emit("resume"), flow(stream), state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      if (debug("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false)
        debug("pause"), this._readableState.flowing = false, this.emit("pause");
      return this._readableState[kPaused] = true, this;
    };
    function flow(stream) {
      let state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      let paused = false;
      stream.on("data", (chunk) => {
        if (!this.push(chunk) && stream.pause)
          paused = true, stream.pause();
      }), stream.on("end", () => {
        this.push(null);
      }), stream.on("error", (err) => {
        errorOrDestroy(this, err);
      }), stream.on("close", () => {
        this.destroy();
      }), stream.on("destroy", () => {
        this.destroy();
      }), this._read = () => {
        if (paused && stream.resume)
          paused = false, stream.resume();
      };
      let streamKeys = ObjectKeys(stream);
      for (let j = 1;j < streamKeys.length; j++) {
        let i2 = streamKeys[j];
        if (this[i2] === undefined && typeof stream[i2] === "function")
          this[i2] = stream[i2].bind(stream);
      }
      return this;
    };
    Readable.prototype[SymbolAsyncIterator] = function() {
      return streamToAsyncIterator(this);
    };
    Readable.prototype.iterator = function(options) {
      if (options !== undefined)
        validateObject(options, "options");
      return streamToAsyncIterator(this, options);
    };
    function streamToAsyncIterator(stream, options) {
      if (typeof stream.read !== "function")
        stream = Readable.wrap(stream, { objectMode: true });
      let iter = createAsyncIterator(stream, options);
      return iter.stream = stream, iter;
    }
    async function* createAsyncIterator(stream, options) {
      let callback = nop;
      function next(resolve) {
        if (this === stream)
          callback(), callback = nop;
        else
          callback = resolve;
      }
      stream.on("readable", next);
      let error3, cleanup = eos(stream, { writable: false }, (err) => {
        error3 = err ? aggregateTwoErrors(error3, err) : null, callback(), callback = nop;
      });
      try {
        while (true) {
          let chunk = stream.destroyed ? null : stream.read();
          if (chunk !== null)
            yield chunk;
          else if (error3)
            throw error3;
          else if (error3 === null)
            return;
          else
            await new Promise22(next);
        }
      } catch (err) {
        throw error3 = aggregateTwoErrors(error3, err), error3;
      } finally {
        if ((error3 || (options === null || options === undefined ? undefined : options.destroyOnReturn) !== false) && (error3 === undefined || stream._readableState.autoDestroy))
          destroyImpl.destroyer(stream, null);
        else
          stream.off("readable", next), cleanup();
      }
    }
    ObjectDefineProperties(Readable.prototype, { readable: { __proto__: null, get() {
      let r = this._readableState;
      return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
    }, set(val) {
      if (this._readableState)
        this._readableState.readable = !!val;
    } }, readableDidRead: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.dataEmitted;
    } }, readableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
    } }, readableHighWaterMark: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } }, readableBuffer: { __proto__: null, enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } }, readableFlowing: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(state) {
      if (this._readableState)
        this._readableState.flowing = state;
    } }, readableLength: { __proto__: null, enumerable: false, get() {
      return this._readableState.length;
    } }, readableObjectMode: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.objectMode : false;
    } }, readableEncoding: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.encoding : null;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.errored : null;
    } }, closed: { __proto__: null, get() {
      return this._readableState ? this._readableState.closed : false;
    } }, destroyed: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.destroyed : false;
    }, set(value2) {
      if (!this._readableState)
        return;
      this._readableState.destroyed = value2;
    } }, readableEnded: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.endEmitted : false;
    } } });
    ObjectDefineProperties(ReadableState.prototype, { pipesCount: { __proto__: null, get() {
      return this.pipes.length;
    } }, paused: { __proto__: null, get() {
      return this[kPaused] !== false;
    }, set(value2) {
      this[kPaused] = !!value2;
    } } });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      let ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else
        ret = state.buffer.consume(n, state.decoder);
      return ret;
    }
    function endReadable(stream) {
      let state = stream._readableState;
      if (debug("endReadable", state.endEmitted), !state.endEmitted)
        state.ended = true, process2.nextTick(endReadableNT, state, stream);
    }
    function endReadableNT(state, stream) {
      if (debug("endReadableNT", state.endEmitted, state.length), !state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
        if (state.endEmitted = true, stream.emit("end"), stream.writable && stream.allowHalfOpen === false)
          process2.nextTick(endWritableNT, stream);
        else if (state.autoDestroy) {
          let wState = stream._writableState;
          if (!wState || wState.autoDestroy && (wState.finished || wState.writable === false))
            stream.destroy();
        }
      }
    }
    function endWritableNT(stream) {
      if (stream.writable && !stream.writableEnded && !stream.destroyed)
        stream.end();
    }
    Readable.from = function(iterable, opts) {
      return from2(Readable, iterable, opts);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === undefined)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Readable.fromWeb = function(readableStream, options) {
      return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
    };
    Readable.toWeb = function(streamReadable, options) {
      return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
    };
    Readable.wrap = function(src, options) {
      var _ref, _src$readableObjectMo;
      return new Readable({ objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== undefined ? _src$readableObjectMo : src.objectMode) !== null && _ref !== undefined ? _ref : true, ...options, destroy(err, callback) {
        destroyImpl.destroyer(src, err), callback(err);
      } }).wrap(src);
    };
  });
  var require_writable = __commonJS2((exports2, module2) => {
    var process2 = require_process(), { ArrayPrototypeSlice: ArrayPrototypeSlice2, Error: Error2, FunctionPrototypeSymbolHasInstance, ObjectDefineProperty, ObjectDefineProperties, ObjectSetPrototypeOf, StringPrototypeToLowerCase, Symbol: Symbol22, SymbolHasInstance } = require_primordials();
    module2.exports = Writable;
    Writable.WritableState = WritableState;
    var { EventEmitter: EE } = (init_events(), __toCommonJS(exports_events)), Stream = require_legacy().Stream, { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(exports_buffer2)), destroyImpl = require_destroy(), { addAbortSignal } = require_add_abort_signal(), { getHighWaterMark, getDefaultHighWaterMark } = require_state(), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED, ERR_STREAM_ALREADY_FINISHED, ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING } = require_errors().codes, { errorOrDestroy } = destroyImpl;
    ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Writable, Stream);
    function nop() {}
    var kOnFinished = Symbol22("kOnFinished");
    function WritableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex();
      if (this.objectMode = !!(options && options.objectMode), isDuplex)
        this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
      this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      let noDecode = !!(options && options.decodeStrings === false);
      this.decodeStrings = !noDecode, this.defaultEncoding = options && options.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = onwrite.bind(undefined, stream), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, resetBuffer(this), this.pendingcb = 0, this.constructed = true, this.prefinished = false, this.errorEmitted = false, this.emitClose = !options || options.emitClose !== false, this.autoDestroy = !options || options.autoDestroy !== false, this.errored = null, this.closed = false, this.closeEmitted = false, this[kOnFinished] = [];
    }
    function resetBuffer(state) {
      state.buffered = [], state.bufferedIndex = 0, state.allBuffers = true, state.allNoop = true;
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      return ArrayPrototypeSlice2(this.buffered, this.bufferedIndex);
    };
    ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", { __proto__: null, get() {
      return this.buffered.length - this.bufferedIndex;
    } });
    function Writable(options) {
      let isDuplex = this instanceof require_duplex();
      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this))
        return new Writable(options);
      if (this._writableState = new WritableState(options, this, isDuplex), options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
        if (typeof options.construct === "function")
          this._construct = options.construct;
        if (options.signal)
          addAbortSignal(options.signal, this);
      }
      Stream.call(this, options), destroyImpl.construct(this, () => {
        let state = this._writableState;
        if (!state.writing)
          clearBuffer(this, state);
        finishMaybe(this, state);
      });
    }
    ObjectDefineProperty(Writable, SymbolHasInstance, { __proto__: null, value: function(object3) {
      if (FunctionPrototypeSymbolHasInstance(this, object3))
        return true;
      if (this !== Writable)
        return false;
      return object3 && object3._writableState instanceof WritableState;
    } });
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE);
    };
    function _write(stream, chunk, encoding, cb) {
      let state = stream._writableState;
      if (typeof encoding === "function")
        cb = encoding, encoding = state.defaultEncoding;
      else {
        if (!encoding)
          encoding = state.defaultEncoding;
        else if (encoding !== "buffer" && !Buffer3.isEncoding(encoding))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        if (typeof cb !== "function")
          cb = nop;
      }
      if (chunk === null)
        throw new ERR_STREAM_NULL_VALUES;
      else if (!state.objectMode)
        if (typeof chunk === "string") {
          if (state.decodeStrings !== false)
            chunk = Buffer3.from(chunk, encoding), encoding = "buffer";
        } else if (chunk instanceof Buffer3)
          encoding = "buffer";
        else if (Stream._isUint8Array(chunk))
          chunk = Stream._uint8ArrayToBuffer(chunk), encoding = "buffer";
        else
          throw new ERR_INVALID_ARG_TYPE3("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      let err;
      if (state.ending)
        err = new ERR_STREAM_WRITE_AFTER_END;
      else if (state.destroyed)
        err = new ERR_STREAM_DESTROYED("write");
      if (err)
        return process2.nextTick(cb, err), errorOrDestroy(stream, err, true), err;
      return state.pendingcb++, writeOrBuffer(stream, state, chunk, encoding, cb);
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      return _write(this, chunk, encoding, cb) === true;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      let state = this._writableState;
      if (state.corked) {
        if (state.corked--, !state.writing)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = StringPrototypeToLowerCase(encoding);
      if (!Buffer3.isEncoding(encoding))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      return this._writableState.defaultEncoding = encoding, this;
    };
    function writeOrBuffer(stream, state, chunk, encoding, callback) {
      let len2 = state.objectMode ? 1 : chunk.length;
      state.length += len2;
      let ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked || state.errored || !state.constructed) {
        if (state.buffered.push({ chunk, encoding, callback }), state.allBuffers && encoding !== "buffer")
          state.allBuffers = false;
        if (state.allNoop && callback !== nop)
          state.allNoop = false;
      } else
        state.writelen = len2, state.writecb = callback, state.writing = true, state.sync = true, stream._write(chunk, encoding, state.onwrite), state.sync = false;
      return ret && !state.errored && !state.destroyed;
    }
    function doWrite(stream, state, writev, len2, chunk, encoding, cb) {
      if (state.writelen = len2, state.writecb = cb, state.writing = true, state.sync = true, state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, er, cb) {
      --state.pendingcb, cb(er), errorBuffer(state), errorOrDestroy(stream, er);
    }
    function onwrite(stream, er) {
      let state = stream._writableState, sync = state.sync, cb = state.writecb;
      if (typeof cb !== "function") {
        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK);
        return;
      }
      if (state.writing = false, state.writecb = null, state.length -= state.writelen, state.writelen = 0, er) {
        if (er.stack, !state.errored)
          state.errored = er;
        if (stream._readableState && !stream._readableState.errored)
          stream._readableState.errored = er;
        if (sync)
          process2.nextTick(onwriteError, stream, state, er, cb);
        else
          onwriteError(stream, state, er, cb);
      } else {
        if (state.buffered.length > state.bufferedIndex)
          clearBuffer(stream, state);
        if (sync)
          if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb)
            state.afterWriteTickInfo.count++;
          else
            state.afterWriteTickInfo = { count: 1, cb, stream, state }, process2.nextTick(afterWriteTick, state.afterWriteTickInfo);
        else
          afterWrite(stream, state, 1, cb);
      }
    }
    function afterWriteTick({ stream, state, count, cb }) {
      return state.afterWriteTickInfo = null, afterWrite(stream, state, count, cb);
    }
    function afterWrite(stream, state, count, cb) {
      if (!state.ending && !stream.destroyed && state.length === 0 && state.needDrain)
        state.needDrain = false, stream.emit("drain");
      while (count-- > 0)
        state.pendingcb--, cb();
      if (state.destroyed)
        errorBuffer(state);
      finishMaybe(stream, state);
    }
    function errorBuffer(state) {
      if (state.writing)
        return;
      for (let n = state.bufferedIndex;n < state.buffered.length; ++n) {
        var _state$errored;
        let { chunk, callback } = state.buffered[n], len2 = state.objectMode ? 1 : chunk.length;
        state.length -= len2, callback((_state$errored = state.errored) !== null && _state$errored !== undefined ? _state$errored : new ERR_STREAM_DESTROYED("write"));
      }
      let onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i2 = 0;i2 < onfinishCallbacks.length; i2++) {
        var _state$errored2;
        onfinishCallbacks[i2]((_state$errored2 = state.errored) !== null && _state$errored2 !== undefined ? _state$errored2 : new ERR_STREAM_DESTROYED("end"));
      }
      resetBuffer(state);
    }
    function clearBuffer(stream, state) {
      if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed)
        return;
      let { buffered, bufferedIndex, objectMode } = state, bufferedLength = buffered.length - bufferedIndex;
      if (!bufferedLength)
        return;
      let i2 = bufferedIndex;
      if (state.bufferProcessing = true, bufferedLength > 1 && stream._writev) {
        state.pendingcb -= bufferedLength - 1;
        let callback = state.allNoop ? nop : (err) => {
          for (let n = i2;n < buffered.length; ++n)
            buffered[n].callback(err);
        }, chunks = state.allNoop && i2 === 0 ? buffered : ArrayPrototypeSlice2(buffered, i2);
        chunks.allBuffers = state.allBuffers, doWrite(stream, state, true, state.length, chunks, "", callback), resetBuffer(state);
      } else {
        do {
          let { chunk, encoding, callback } = buffered[i2];
          buffered[i2++] = null;
          let len2 = objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len2, chunk, encoding, callback);
        } while (i2 < buffered.length && !state.writing);
        if (i2 === buffered.length)
          resetBuffer(state);
        else if (i2 > 256)
          buffered.splice(0, i2), state.bufferedIndex = 0;
        else
          state.bufferedIndex = i2;
      }
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      if (this._writev)
        this._writev([{ chunk, encoding }], cb);
      else
        throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      let state = this._writableState;
      if (typeof chunk === "function")
        cb = chunk, chunk = null, encoding = null;
      else if (typeof encoding === "function")
        cb = encoding, encoding = null;
      let err;
      if (chunk !== null && chunk !== undefined) {
        let ret = _write(this, chunk, encoding);
        if (ret instanceof Error2)
          err = ret;
      }
      if (state.corked)
        state.corked = 1, this.uncork();
      if (err)
        ;
      else if (!state.errored && !state.ending)
        state.ending = true, finishMaybe(this, state, true), state.ended = true;
      else if (state.finished)
        err = new ERR_STREAM_ALREADY_FINISHED("end");
      else if (state.destroyed)
        err = new ERR_STREAM_DESTROYED("end");
      if (typeof cb === "function")
        if (err || state.finished)
          process2.nextTick(cb, err);
        else
          state[kOnFinished].push(cb);
      return this;
    };
    function needFinish(state) {
      return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
    }
    function callFinal(stream, state) {
      let called = false;
      function onFinish(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== undefined ? err : ERR_MULTIPLE_CALLBACK());
          return;
        }
        if (called = true, state.pendingcb--, err) {
          let onfinishCallbacks = state[kOnFinished].splice(0);
          for (let i2 = 0;i2 < onfinishCallbacks.length; i2++)
            onfinishCallbacks[i2](err);
          errorOrDestroy(stream, err, state.sync);
        } else if (needFinish(state))
          state.prefinished = true, stream.emit("prefinish"), state.pendingcb++, process2.nextTick(finish, stream, state);
      }
      state.sync = true, state.pendingcb++;
      try {
        stream._final(onFinish);
      } catch (err) {
        onFinish(err);
      }
      state.sync = false;
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled)
        if (typeof stream._final === "function" && !state.destroyed)
          state.finalCalled = true, callFinal(stream, state);
        else
          state.prefinished = true, stream.emit("prefinish");
    }
    function finishMaybe(stream, state, sync) {
      if (needFinish(state)) {
        if (prefinish(stream, state), state.pendingcb === 0) {
          if (sync)
            state.pendingcb++, process2.nextTick((stream2, state2) => {
              if (needFinish(state2))
                finish(stream2, state2);
              else
                state2.pendingcb--;
            }, stream, state);
          else if (needFinish(state))
            state.pendingcb++, finish(stream, state);
        }
      }
    }
    function finish(stream, state) {
      state.pendingcb--, state.finished = true;
      let onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i2 = 0;i2 < onfinishCallbacks.length; i2++)
        onfinishCallbacks[i2]();
      if (stream.emit("finish"), state.autoDestroy) {
        let rState = stream._readableState;
        if (!rState || rState.autoDestroy && (rState.endEmitted || rState.readable === false))
          stream.destroy();
      }
    }
    ObjectDefineProperties(Writable.prototype, { closed: { __proto__: null, get() {
      return this._writableState ? this._writableState.closed : false;
    } }, destroyed: { __proto__: null, get() {
      return this._writableState ? this._writableState.destroyed : false;
    }, set(value2) {
      if (this._writableState)
        this._writableState.destroyed = value2;
    } }, writable: { __proto__: null, get() {
      let w = this._writableState;
      return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
    }, set(val) {
      if (this._writableState)
        this._writableState.writable = !!val;
    } }, writableFinished: { __proto__: null, get() {
      return this._writableState ? this._writableState.finished : false;
    } }, writableObjectMode: { __proto__: null, get() {
      return this._writableState ? this._writableState.objectMode : false;
    } }, writableBuffer: { __proto__: null, get() {
      return this._writableState && this._writableState.getBuffer();
    } }, writableEnded: { __proto__: null, get() {
      return this._writableState ? this._writableState.ending : false;
    } }, writableNeedDrain: { __proto__: null, get() {
      let wState = this._writableState;
      if (!wState)
        return false;
      return !wState.destroyed && !wState.ending && wState.needDrain;
    } }, writableHighWaterMark: { __proto__: null, get() {
      return this._writableState && this._writableState.highWaterMark;
    } }, writableCorked: { __proto__: null, get() {
      return this._writableState ? this._writableState.corked : 0;
    } }, writableLength: { __proto__: null, get() {
      return this._writableState && this._writableState.length;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._writableState ? this._writableState.errored : null;
    } }, writableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
    } } });
    var destroy = destroyImpl.destroy;
    Writable.prototype.destroy = function(err, cb) {
      let state = this._writableState;
      if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length))
        process2.nextTick(errorBuffer, state);
      return destroy.call(this, err, cb), this;
    };
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Writable.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === undefined)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Writable.fromWeb = function(writableStream, options) {
      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
    };
    Writable.toWeb = function(streamWritable) {
      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
    };
  });
  var require_duplexify = __commonJS2((exports2, module2) => {
    var process2 = require_process(), bufferModule = (init_buffer(), __toCommonJS(exports_buffer2)), { isReadable, isWritable, isIterable, isNodeStream, isReadableNodeStream, isWritableNodeStream, isDuplexNodeStream, isReadableStream, isWritableStream } = require_utils(), eos = require_end_of_stream(), { AbortError: AbortError2, codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_INVALID_RETURN_VALUE } } = require_errors(), { destroyer } = require_destroy(), Duplex = require_duplex(), Readable = require_readable(), Writable = require_writable(), { createDeferredPromise } = require_util(), from2 = require_from(), Blob3 = globalThis.Blob || bufferModule.Blob, isBlob = typeof Blob3 !== "undefined" ? function isBlob(b) {
      return b instanceof Blob3;
    } : function isBlob(b) {
      return false;
    }, AbortController = globalThis.AbortController || require_abort_controller().AbortController, { FunctionPrototypeCall } = require_primordials();

    class Duplexify extends Duplex {
      constructor(options) {
        super(options);
        if ((options === null || options === undefined ? undefined : options.readable) === false)
          this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true;
        if ((options === null || options === undefined ? undefined : options.writable) === false)
          this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true;
      }
    }
    module2.exports = function duplexify(body, name) {
      if (isDuplexNodeStream(body))
        return body;
      if (isReadableNodeStream(body))
        return _duplexify({ readable: body });
      if (isWritableNodeStream(body))
        return _duplexify({ writable: body });
      if (isNodeStream(body))
        return _duplexify({ writable: false, readable: false });
      if (isReadableStream(body))
        return _duplexify({ readable: Readable.fromWeb(body) });
      if (isWritableStream(body))
        return _duplexify({ writable: Writable.fromWeb(body) });
      if (typeof body === "function") {
        let { value: value2, write: write3, final, destroy } = fromAsyncGen(body);
        if (isIterable(value2))
          return from2(Duplexify, value2, { objectMode: true, write: write3, final, destroy });
        let then2 = value2 === null || value2 === undefined ? undefined : value2.then;
        if (typeof then2 === "function") {
          let d, promise3 = FunctionPrototypeCall(then2, value2, (val) => {
            if (val != null)
              throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
          }, (err) => {
            destroyer(d, err);
          });
          return d = new Duplexify({ objectMode: true, readable: false, write: write3, final(cb) {
            final(async () => {
              try {
                await promise3, process2.nextTick(cb, null);
              } catch (err) {
                process2.nextTick(cb, err);
              }
            });
          }, destroy });
        }
        throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name, value2);
      }
      if (isBlob(body))
        return duplexify(body.arrayBuffer());
      if (isIterable(body))
        return from2(Duplexify, body, { objectMode: true, writable: false });
      if (isReadableStream(body === null || body === undefined ? undefined : body.readable) && isWritableStream(body === null || body === undefined ? undefined : body.writable))
        return Duplexify.fromWeb(body);
      if (typeof (body === null || body === undefined ? undefined : body.writable) === "object" || typeof (body === null || body === undefined ? undefined : body.readable) === "object") {
        let readable = body !== null && body !== undefined && body.readable ? isReadableNodeStream(body === null || body === undefined ? undefined : body.readable) ? body === null || body === undefined ? undefined : body.readable : duplexify(body.readable) : undefined, writable = body !== null && body !== undefined && body.writable ? isWritableNodeStream(body === null || body === undefined ? undefined : body.writable) ? body === null || body === undefined ? undefined : body.writable : duplexify(body.writable) : undefined;
        return _duplexify({ readable, writable });
      }
      let then = body === null || body === undefined ? undefined : body.then;
      if (typeof then === "function") {
        let d;
        return FunctionPrototypeCall(then, body, (val) => {
          if (val != null)
            d.push(val);
          d.push(null);
        }, (err) => {
          destroyer(d, err);
        }), d = new Duplexify({ objectMode: true, writable: false, read() {} });
      }
      throw new ERR_INVALID_ARG_TYPE3(name, ["Blob", "ReadableStream", "WritableStream", "Stream", "Iterable", "AsyncIterable", "Function", "{ readable, writable } pair", "Promise"], body);
    };
    function fromAsyncGen(fn) {
      let { promise: promise3, resolve } = createDeferredPromise(), ac = new AbortController, signal = ac.signal;
      return { value: fn(async function* () {
        while (true) {
          let _promise = promise3;
          promise3 = null;
          let { chunk, done, cb } = await _promise;
          if (process2.nextTick(cb), done)
            return;
          if (signal.aborted)
            throw new AbortError2(undefined, { cause: signal.reason });
          ({ promise: promise3, resolve } = createDeferredPromise()), yield chunk;
        }
      }(), { signal }), write(chunk, encoding, cb) {
        let _resolve = resolve;
        resolve = null, _resolve({ chunk, done: false, cb });
      }, final(cb) {
        let _resolve = resolve;
        resolve = null, _resolve({ done: true, cb });
      }, destroy(err, cb) {
        ac.abort(), cb(err);
      } };
    }
    function _duplexify(pair) {
      let r = pair.readable && typeof pair.readable.read !== "function" ? Readable.wrap(pair.readable) : pair.readable, w = pair.writable, readable = !!isReadable(r), writable = !!isWritable(w), ondrain, onfinish, onreadable, onclose, d;
      function onfinished(err) {
        let cb = onclose;
        if (onclose = null, cb)
          cb(err);
        else if (err)
          d.destroy(err);
      }
      if (d = new Duplexify({ readableObjectMode: !!(r !== null && r !== undefined && r.readableObjectMode), writableObjectMode: !!(w !== null && w !== undefined && w.writableObjectMode), readable, writable }), writable)
        eos(w, (err) => {
          if (writable = false, err)
            destroyer(r, err);
          onfinished(err);
        }), d._write = function(chunk, encoding, callback) {
          if (w.write(chunk, encoding))
            callback();
          else
            ondrain = callback;
        }, d._final = function(callback) {
          w.end(), onfinish = callback;
        }, w.on("drain", function() {
          if (ondrain) {
            let cb = ondrain;
            ondrain = null, cb();
          }
        }), w.on("finish", function() {
          if (onfinish) {
            let cb = onfinish;
            onfinish = null, cb();
          }
        });
      if (readable)
        eos(r, (err) => {
          if (readable = false, err)
            destroyer(r, err);
          onfinished(err);
        }), r.on("readable", function() {
          if (onreadable) {
            let cb = onreadable;
            onreadable = null, cb();
          }
        }), r.on("end", function() {
          d.push(null);
        }), d._read = function() {
          while (true) {
            let buf = r.read();
            if (buf === null) {
              onreadable = d._read;
              return;
            }
            if (!d.push(buf))
              return;
          }
        };
      return d._destroy = function(err, callback) {
        if (!err && onclose !== null)
          err = new AbortError2;
        if (onreadable = null, ondrain = null, onfinish = null, onclose === null)
          callback(err);
        else
          onclose = callback, destroyer(w, err), destroyer(r, err);
      }, d;
    }
  });
  var require_duplex = __commonJS2((exports2, module2) => {
    var { ObjectDefineProperties, ObjectGetOwnPropertyDescriptor, ObjectKeys, ObjectSetPrototypeOf } = require_primordials();
    module2.exports = Duplex;
    var Readable = require_readable(), Writable = require_writable();
    ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype);
    ObjectSetPrototypeOf(Duplex, Readable);
    {
      let keys = ObjectKeys(Writable.prototype);
      for (let i2 = 0;i2 < keys.length; i2++) {
        let method = keys[i2];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      if (Readable.call(this, options), Writable.call(this, options), options) {
        if (this.allowHalfOpen = options.allowHalfOpen !== false, options.readable === false)
          this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true;
        if (options.writable === false)
          this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true;
      } else
        this.allowHalfOpen = true;
    }
    ObjectDefineProperties(Duplex.prototype, { writable: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable") }, writableHighWaterMark: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark") }, writableObjectMode: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode") }, writableBuffer: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer") }, writableLength: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength") }, writableFinished: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished") }, writableCorked: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked") }, writableEnded: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded") }, writableNeedDrain: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain") }, destroyed: { __proto__: null, get() {
      if (this._readableState === undefined || this._writableState === undefined)
        return false;
      return this._readableState.destroyed && this._writableState.destroyed;
    }, set(value2) {
      if (this._readableState && this._writableState)
        this._readableState.destroyed = value2, this._writableState.destroyed = value2;
    } } });
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === undefined)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Duplex.fromWeb = function(pair, options) {
      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
    };
    Duplex.toWeb = function(duplex) {
      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
    };
    var duplexify;
    Duplex.from = function(body) {
      if (!duplexify)
        duplexify = require_duplexify();
      return duplexify(body, "body");
    };
  });
  var require_transform = __commonJS2((exports2, module2) => {
    var { ObjectSetPrototypeOf, Symbol: Symbol22 } = require_primordials();
    module2.exports = Transform2;
    var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors().codes, Duplex = require_duplex(), { getHighWaterMark } = require_state();
    ObjectSetPrototypeOf(Transform2.prototype, Duplex.prototype);
    ObjectSetPrototypeOf(Transform2, Duplex);
    var kCallback = Symbol22("kCallback");
    function Transform2(options) {
      if (!(this instanceof Transform2))
        return new Transform2(options);
      let readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
      if (readableHighWaterMark === 0)
        options = { ...options, highWaterMark: null, readableHighWaterMark, writableHighWaterMark: options.writableHighWaterMark || 0 };
      if (Duplex.call(this, options), this._readableState.sync = false, this[kCallback] = null, options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function final(cb) {
      if (typeof this._flush === "function" && !this.destroyed)
        this._flush((er, data) => {
          if (er) {
            if (cb)
              cb(er);
            else
              this.destroy(er);
            return;
          }
          if (data != null)
            this.push(data);
          if (this.push(null), cb)
            cb();
        });
      else if (this.push(null), cb)
        cb();
    }
    function prefinish() {
      if (this._final !== final)
        final.call(this);
    }
    Transform2.prototype._final = final;
    Transform2.prototype._transform = function(chunk, encoding, callback) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
    };
    Transform2.prototype._write = function(chunk, encoding, callback) {
      let rState = this._readableState, wState = this._writableState, length = rState.length;
      this._transform(chunk, encoding, (err, val) => {
        if (err) {
          callback(err);
          return;
        }
        if (val != null)
          this.push(val);
        if (wState.ended || length === rState.length || rState.length < rState.highWaterMark)
          callback();
        else
          this[kCallback] = callback;
      });
    };
    Transform2.prototype._read = function() {
      if (this[kCallback]) {
        let callback = this[kCallback];
        this[kCallback] = null, callback();
      }
    };
  });
  var require_passthrough = __commonJS2((exports2, module2) => {
    var { ObjectSetPrototypeOf } = require_primordials();
    module2.exports = PassThrough;
    var Transform2 = require_transform();
    ObjectSetPrototypeOf(PassThrough.prototype, Transform2.prototype);
    ObjectSetPrototypeOf(PassThrough, Transform2);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform2.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  });
  var require_pipeline = __commonJS2((exports2, module2) => {
    var process2 = require_process(), { ArrayIsArray, Promise: Promise22, SymbolAsyncIterator, SymbolDispose } = require_primordials(), eos = require_end_of_stream(), { once: once3 } = require_util(), destroyImpl = require_destroy(), Duplex = require_duplex(), { aggregateTwoErrors, codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS, ERR_STREAM_DESTROYED, ERR_STREAM_PREMATURE_CLOSE }, AbortError: AbortError2 } = require_errors(), { validateFunction, validateAbortSignal: validateAbortSignal2 } = require_validators(), { isIterable, isReadable, isReadableNodeStream, isNodeStream, isTransformStream, isWebStream, isReadableStream, isReadableFinished } = require_utils(), AbortController = globalThis.AbortController || require_abort_controller().AbortController, PassThrough, Readable, addAbortListener2;
    function destroyer(stream, reading, writing) {
      let finished = false;
      stream.on("close", () => {
        finished = true;
      });
      let cleanup = eos(stream, { readable: reading, writable: writing }, (err) => {
        finished = !err;
      });
      return { destroy: (err) => {
        if (finished)
          return;
        finished = true, destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
      }, cleanup };
    }
    function popCallback(streams) {
      return validateFunction(streams[streams.length - 1], "streams[stream.length - 1]"), streams.pop();
    }
    function makeAsyncIterable(val) {
      if (isIterable(val))
        return val;
      else if (isReadableNodeStream(val))
        return fromReadable(val);
      throw new ERR_INVALID_ARG_TYPE3("val", ["Readable", "Iterable", "AsyncIterable"], val);
    }
    async function* fromReadable(val) {
      if (!Readable)
        Readable = require_readable();
      yield* Readable.prototype[SymbolAsyncIterator].call(val);
    }
    async function pumpToNode(iterable, writable, finish, { end }) {
      let error3, onresolve = null, resume = (err) => {
        if (err)
          error3 = err;
        if (onresolve) {
          let callback = onresolve;
          onresolve = null, callback();
        }
      }, wait = () => new Promise22((resolve, reject) => {
        if (error3)
          reject(error3);
        else
          onresolve = () => {
            if (error3)
              reject(error3);
            else
              resolve();
          };
      });
      writable.on("drain", resume);
      let cleanup = eos(writable, { readable: false }, resume);
      try {
        if (writable.writableNeedDrain)
          await wait();
        for await (let chunk of iterable)
          if (!writable.write(chunk))
            await wait();
        if (end)
          writable.end(), await wait();
        finish();
      } catch (err) {
        finish(error3 !== err ? aggregateTwoErrors(error3, err) : err);
      } finally {
        cleanup(), writable.off("drain", resume);
      }
    }
    async function pumpToWeb(readable, writable, finish, { end }) {
      if (isTransformStream(writable))
        writable = writable.writable;
      let writer = writable.getWriter();
      try {
        for await (let chunk of readable)
          await writer.ready, writer.write(chunk).catch(() => {});
        if (await writer.ready, end)
          await writer.close();
        finish();
      } catch (err) {
        try {
          await writer.abort(err), finish(err);
        } catch (err2) {
          finish(err2);
        }
      }
    }
    function pipeline(...streams) {
      return pipelineImpl(streams, once3(popCallback(streams)));
    }
    function pipelineImpl(streams, callback, opts) {
      if (streams.length === 1 && ArrayIsArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2)
        throw new ERR_MISSING_ARGS("streams");
      let ac = new AbortController, signal = ac.signal, outerSignal = opts === null || opts === undefined ? undefined : opts.signal, lastStreamCleanup = [];
      validateAbortSignal2(outerSignal, "options.signal");
      function abort() {
        finishImpl(new AbortError2);
      }
      addAbortListener2 = addAbortListener2 || require_util().addAbortListener;
      let disposable;
      if (outerSignal)
        disposable = addAbortListener2(outerSignal, abort);
      let error3, value2, destroys = [], finishCount = 0;
      function finish(err) {
        finishImpl(err, --finishCount === 0);
      }
      function finishImpl(err, final) {
        var _disposable;
        if (err && (!error3 || error3.code === "ERR_STREAM_PREMATURE_CLOSE"))
          error3 = err;
        if (!error3 && !final)
          return;
        while (destroys.length)
          destroys.shift()(error3);
        if ((_disposable = disposable) === null || _disposable === undefined || _disposable[SymbolDispose](), ac.abort(), final) {
          if (!error3)
            lastStreamCleanup.forEach((fn) => fn());
          process2.nextTick(callback, error3, value2);
        }
      }
      let ret;
      for (let i2 = 0;i2 < streams.length; i2++) {
        let stream = streams[i2], reading = i2 < streams.length - 1, writing = i2 > 0, end = reading || (opts === null || opts === undefined ? undefined : opts.end) !== false, isLastStream = i2 === streams.length - 1;
        if (isNodeStream(stream)) {
          let onError2 = function(err) {
            if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE")
              finish(err);
          };
          var onError = onError2;
          if (end) {
            let { destroy, cleanup } = destroyer(stream, reading, writing);
            if (destroys.push(destroy), isReadable(stream) && isLastStream)
              lastStreamCleanup.push(cleanup);
          }
          if (stream.on("error", onError2), isReadable(stream) && isLastStream)
            lastStreamCleanup.push(() => {
              stream.removeListener("error", onError2);
            });
        }
        if (i2 === 0)
          if (typeof stream === "function") {
            if (ret = stream({ signal }), !isIterable(ret))
              throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
          } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream))
            ret = stream;
          else
            ret = Duplex.from(stream);
        else if (typeof stream === "function") {
          if (isTransformStream(ret)) {
            var _ret;
            ret = makeAsyncIterable((_ret = ret) === null || _ret === undefined ? undefined : _ret.readable);
          } else
            ret = makeAsyncIterable(ret);
          if (ret = stream(ret, { signal }), reading) {
            if (!isIterable(ret, true))
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i2 - 1}]`, ret);
          } else {
            var _ret2;
            if (!PassThrough)
              PassThrough = require_passthrough();
            let pt = new PassThrough({ objectMode: true }), then = (_ret2 = ret) === null || _ret2 === undefined ? undefined : _ret2.then;
            if (typeof then === "function")
              finishCount++, then.call(ret, (val) => {
                if (value2 = val, val != null)
                  pt.write(val);
                if (end)
                  pt.end();
                process2.nextTick(finish);
              }, (err) => {
                pt.destroy(err), process2.nextTick(finish, err);
              });
            else if (isIterable(ret, true))
              finishCount++, pumpToNode(ret, pt, finish, { end });
            else if (isReadableStream(ret) || isTransformStream(ret)) {
              let toRead = ret.readable || ret;
              finishCount++, pumpToNode(toRead, pt, finish, { end });
            } else
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
            ret = pt;
            let { destroy, cleanup } = destroyer(ret, false, true);
            if (destroys.push(destroy), isLastStream)
              lastStreamCleanup.push(cleanup);
          }
        } else if (isNodeStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount += 2;
            let cleanup = pipe(ret, stream, finish, { end });
            if (isReadable(stream) && isLastStream)
              lastStreamCleanup.push(cleanup);
          } else if (isTransformStream(ret) || isReadableStream(ret)) {
            let toRead = ret.readable || ret;
            finishCount++, pumpToNode(toRead, stream, finish, { end });
          } else if (isIterable(ret))
            finishCount++, pumpToNode(ret, stream, finish, { end });
          else
            throw new ERR_INVALID_ARG_TYPE3("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], ret);
          ret = stream;
        } else if (isWebStream(stream)) {
          if (isReadableNodeStream(ret))
            finishCount++, pumpToWeb(makeAsyncIterable(ret), stream, finish, { end });
          else if (isReadableStream(ret) || isIterable(ret))
            finishCount++, pumpToWeb(ret, stream, finish, { end });
          else if (isTransformStream(ret))
            finishCount++, pumpToWeb(ret.readable, stream, finish, { end });
          else
            throw new ERR_INVALID_ARG_TYPE3("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], ret);
          ret = stream;
        } else
          ret = Duplex.from(stream);
      }
      if (signal !== null && signal !== undefined && signal.aborted || outerSignal !== null && outerSignal !== undefined && outerSignal.aborted)
        process2.nextTick(abort);
      return ret;
    }
    function pipe(src, dst, finish, { end }) {
      let ended = false;
      if (dst.on("close", () => {
        if (!ended)
          finish(new ERR_STREAM_PREMATURE_CLOSE);
      }), src.pipe(dst, { end: false }), end) {
        let endFn2 = function() {
          ended = true, dst.end();
        };
        var endFn = endFn2;
        if (isReadableFinished(src))
          process2.nextTick(endFn2);
        else
          src.once("end", endFn2);
      } else
        finish();
      return eos(src, { readable: true, writable: false }, (err) => {
        let rState = src._readableState;
        if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted)
          src.once("end", finish).once("error", finish);
        else
          finish(err);
      }), eos(dst, { readable: false, writable: true }, finish);
    }
    module2.exports = { pipelineImpl, pipeline };
  });
  var require_compose = __commonJS2((exports2, module2) => {
    var { pipeline } = require_pipeline(), Duplex = require_duplex(), { destroyer } = require_destroy(), { isNodeStream, isReadable, isWritable, isWebStream, isTransformStream, isWritableStream, isReadableStream } = require_utils(), { AbortError: AbortError2, codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS } } = require_errors(), eos = require_end_of_stream();
    module2.exports = function compose(...streams) {
      if (streams.length === 0)
        throw new ERR_MISSING_ARGS("streams");
      if (streams.length === 1)
        return Duplex.from(streams[0]);
      let orgStreams = [...streams];
      if (typeof streams[0] === "function")
        streams[0] = Duplex.from(streams[0]);
      if (typeof streams[streams.length - 1] === "function") {
        let idx = streams.length - 1;
        streams[idx] = Duplex.from(streams[idx]);
      }
      for (let n = 0;n < streams.length; ++n) {
        if (!isNodeStream(streams[n]) && !isWebStream(streams[n]))
          continue;
        if (n < streams.length - 1 && !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n])))
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
        if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n])))
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
      }
      let ondrain, onfinish, onreadable, onclose, d;
      function onfinished(err) {
        let cb = onclose;
        if (onclose = null, cb)
          cb(err);
        else if (err)
          d.destroy(err);
        else if (!readable && !writable)
          d.destroy();
      }
      let head = streams[0], tail = pipeline(streams, onfinished), writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head)), readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));
      if (d = new Duplex({ writableObjectMode: !!(head !== null && head !== undefined && head.writableObjectMode), readableObjectMode: !!(tail !== null && tail !== undefined && tail.readableObjectMode), writable, readable }), writable) {
        if (isNodeStream(head))
          d._write = function(chunk, encoding, callback) {
            if (head.write(chunk, encoding))
              callback();
            else
              ondrain = callback;
          }, d._final = function(callback) {
            head.end(), onfinish = callback;
          }, head.on("drain", function() {
            if (ondrain) {
              let cb = ondrain;
              ondrain = null, cb();
            }
          });
        else if (isWebStream(head)) {
          let writer = (isTransformStream(head) ? head.writable : head).getWriter();
          d._write = async function(chunk, encoding, callback) {
            try {
              await writer.ready, writer.write(chunk).catch(() => {}), callback();
            } catch (err) {
              callback(err);
            }
          }, d._final = async function(callback) {
            try {
              await writer.ready, writer.close().catch(() => {}), onfinish = callback;
            } catch (err) {
              callback(err);
            }
          };
        }
        let toRead = isTransformStream(tail) ? tail.readable : tail;
        eos(toRead, () => {
          if (onfinish) {
            let cb = onfinish;
            onfinish = null, cb();
          }
        });
      }
      if (readable) {
        if (isNodeStream(tail))
          tail.on("readable", function() {
            if (onreadable) {
              let cb = onreadable;
              onreadable = null, cb();
            }
          }), tail.on("end", function() {
            d.push(null);
          }), d._read = function() {
            while (true) {
              let buf = tail.read();
              if (buf === null) {
                onreadable = d._read;
                return;
              }
              if (!d.push(buf))
                return;
            }
          };
        else if (isWebStream(tail)) {
          let reader = (isTransformStream(tail) ? tail.readable : tail).getReader();
          d._read = async function() {
            while (true)
              try {
                let { value: value2, done } = await reader.read();
                if (!d.push(value2))
                  return;
                if (done) {
                  d.push(null);
                  return;
                }
              } catch {
                return;
              }
          };
        }
      }
      return d._destroy = function(err, callback) {
        if (!err && onclose !== null)
          err = new AbortError2;
        if (onreadable = null, ondrain = null, onfinish = null, onclose === null)
          callback(err);
        else if (onclose = callback, isNodeStream(tail))
          destroyer(tail, err);
      }, d;
    };
  });
  var require_operators = __commonJS2((exports2, module2) => {
    var AbortController = globalThis.AbortController || require_abort_controller().AbortController, { codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE: ERR_OUT_OF_RANGE3 }, AbortError: AbortError2 } = require_errors(), { validateAbortSignal: validateAbortSignal2, validateInteger, validateObject } = require_validators(), kWeakHandler = require_primordials().Symbol("kWeak"), kResistStopPropagation = require_primordials().Symbol("kResistStopPropagation"), { finished } = require_end_of_stream(), staticCompose = require_compose(), { addAbortSignalNoValidate } = require_add_abort_signal(), { isWritable, isNodeStream } = require_utils(), { deprecate: deprecate2 } = require_util(), { ArrayPrototypePush, Boolean: Boolean22, MathFloor, Number: Number22, NumberIsNaN, Promise: Promise22, PromiseReject, PromiseResolve, PromisePrototypeThen, Symbol: Symbol22 } = require_primordials(), kEmpty = Symbol22("kEmpty"), kEof = Symbol22("kEof");
    function compose(stream, options) {
      if (options != null)
        validateObject(options, "options");
      if ((options === null || options === undefined ? undefined : options.signal) != null)
        validateAbortSignal2(options.signal, "options.signal");
      if (isNodeStream(stream) && !isWritable(stream))
        throw new ERR_INVALID_ARG_VALUE("stream", stream, "must be writable");
      let composedStream = staticCompose(this, stream);
      if (options !== null && options !== undefined && options.signal)
        addAbortSignalNoValidate(options.signal, composedStream);
      return composedStream;
    }
    function map3(fn, options) {
      if (typeof fn !== "function")
        throw new ERR_INVALID_ARG_TYPE3("fn", ["Function", "AsyncFunction"], fn);
      if (options != null)
        validateObject(options, "options");
      if ((options === null || options === undefined ? undefined : options.signal) != null)
        validateAbortSignal2(options.signal, "options.signal");
      let concurrency = 1;
      if ((options === null || options === undefined ? undefined : options.concurrency) != null)
        concurrency = MathFloor(options.concurrency);
      let highWaterMark = concurrency - 1;
      if ((options === null || options === undefined ? undefined : options.highWaterMark) != null)
        highWaterMark = MathFloor(options.highWaterMark);
      return validateInteger(concurrency, "options.concurrency", 1), validateInteger(highWaterMark, "options.highWaterMark", 0), highWaterMark += concurrency, async function* map() {
        let signal = require_util().AbortSignalAny([options === null || options === undefined ? undefined : options.signal].filter(Boolean22)), stream = this, queue = [], signalOpt = { signal }, next, resume, done = false, cnt = 0;
        function onCatch() {
          done = true, afterItemProcessed();
        }
        function afterItemProcessed() {
          cnt -= 1, maybeResume();
        }
        function maybeResume() {
          if (resume && !done && cnt < concurrency && queue.length < highWaterMark)
            resume(), resume = null;
        }
        async function pump() {
          try {
            for await (let val of stream) {
              if (done)
                return;
              if (signal.aborted)
                throw new AbortError2;
              try {
                if (val = fn(val, signalOpt), val === kEmpty)
                  continue;
                val = PromiseResolve(val);
              } catch (err) {
                val = PromiseReject(err);
              }
              if (cnt += 1, PromisePrototypeThen(val, afterItemProcessed, onCatch), queue.push(val), next)
                next(), next = null;
              if (!done && (queue.length >= highWaterMark || cnt >= concurrency))
                await new Promise22((resolve) => {
                  resume = resolve;
                });
            }
            queue.push(kEof);
          } catch (err) {
            let val = PromiseReject(err);
            PromisePrototypeThen(val, afterItemProcessed, onCatch), queue.push(val);
          } finally {
            if (done = true, next)
              next(), next = null;
          }
        }
        pump();
        try {
          while (true) {
            while (queue.length > 0) {
              let val = await queue[0];
              if (val === kEof)
                return;
              if (signal.aborted)
                throw new AbortError2;
              if (val !== kEmpty)
                yield val;
              queue.shift(), maybeResume();
            }
            await new Promise22((resolve) => {
              next = resolve;
            });
          }
        } finally {
          if (done = true, resume)
            resume(), resume = null;
        }
      }.call(this);
    }
    function asIndexedPairs(options = undefined) {
      if (options != null)
        validateObject(options, "options");
      if ((options === null || options === undefined ? undefined : options.signal) != null)
        validateAbortSignal2(options.signal, "options.signal");
      return async function* asIndexedPairs() {
        let index = 0;
        for await (let val of this) {
          var _options$signal;
          if (options !== null && options !== undefined && (_options$signal = options.signal) !== null && _options$signal !== undefined && _options$signal.aborted)
            throw new AbortError2({ cause: options.signal.reason });
          yield [index++, val];
        }
      }.call(this);
    }
    async function some(fn, options = undefined) {
      for await (let unused of filter.call(this, fn, options))
        return true;
      return false;
    }
    async function every(fn, options = undefined) {
      if (typeof fn !== "function")
        throw new ERR_INVALID_ARG_TYPE3("fn", ["Function", "AsyncFunction"], fn);
      return !await some.call(this, async (...args) => {
        return !await fn(...args);
      }, options);
    }
    async function find(fn, options) {
      for await (let result of filter.call(this, fn, options))
        return result;
      return;
    }
    async function forEach(fn, options) {
      if (typeof fn !== "function")
        throw new ERR_INVALID_ARG_TYPE3("fn", ["Function", "AsyncFunction"], fn);
      async function forEachFn(value2, options2) {
        return await fn(value2, options2), kEmpty;
      }
      for await (let unused of map3.call(this, forEachFn, options))
        ;
    }
    function filter(fn, options) {
      if (typeof fn !== "function")
        throw new ERR_INVALID_ARG_TYPE3("fn", ["Function", "AsyncFunction"], fn);
      async function filterFn(value2, options2) {
        if (await fn(value2, options2))
          return value2;
        return kEmpty;
      }
      return map3.call(this, filterFn, options);
    }

    class ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {
      constructor() {
        super("reduce");
        this.message = "Reduce of an empty stream requires an initial value";
      }
    }
    async function reduce(reducer, initialValue, options) {
      var _options$signal2;
      if (typeof reducer !== "function")
        throw new ERR_INVALID_ARG_TYPE3("reducer", ["Function", "AsyncFunction"], reducer);
      if (options != null)
        validateObject(options, "options");
      if ((options === null || options === undefined ? undefined : options.signal) != null)
        validateAbortSignal2(options.signal, "options.signal");
      let hasInitialValue = arguments.length > 1;
      if (options !== null && options !== undefined && (_options$signal2 = options.signal) !== null && _options$signal2 !== undefined && _options$signal2.aborted) {
        let err = new AbortError2(undefined, { cause: options.signal.reason });
        throw this.once("error", () => {}), await finished(this.destroy(err)), err;
      }
      let ac = new AbortController, signal = ac.signal;
      if (options !== null && options !== undefined && options.signal) {
        let opts = { once: true, [kWeakHandler]: this, [kResistStopPropagation]: true };
        options.signal.addEventListener("abort", () => ac.abort(), opts);
      }
      let gotAnyItemFromStream = false;
      try {
        for await (let value2 of this) {
          var _options$signal3;
          if (gotAnyItemFromStream = true, options !== null && options !== undefined && (_options$signal3 = options.signal) !== null && _options$signal3 !== undefined && _options$signal3.aborted)
            throw new AbortError2;
          if (!hasInitialValue)
            initialValue = value2, hasInitialValue = true;
          else
            initialValue = await reducer(initialValue, value2, { signal });
        }
        if (!gotAnyItemFromStream && !hasInitialValue)
          throw new ReduceAwareErrMissingArgs;
      } finally {
        ac.abort();
      }
      return initialValue;
    }
    async function toArray(options) {
      if (options != null)
        validateObject(options, "options");
      if ((options === null || options === undefined ? undefined : options.signal) != null)
        validateAbortSignal2(options.signal, "options.signal");
      let result = [];
      for await (let val of this) {
        var _options$signal4;
        if (options !== null && options !== undefined && (_options$signal4 = options.signal) !== null && _options$signal4 !== undefined && _options$signal4.aborted)
          throw new AbortError2(undefined, { cause: options.signal.reason });
        ArrayPrototypePush(result, val);
      }
      return result;
    }
    function flatMap(fn, options) {
      let values = map3.call(this, fn, options);
      return async function* flatMap() {
        for await (let val of values)
          yield* val;
      }.call(this);
    }
    function toIntegerOrInfinity(number3) {
      if (number3 = Number22(number3), NumberIsNaN(number3))
        return 0;
      if (number3 < 0)
        throw new ERR_OUT_OF_RANGE3("number", ">= 0", number3);
      return number3;
    }
    function drop(number3, options = undefined) {
      if (options != null)
        validateObject(options, "options");
      if ((options === null || options === undefined ? undefined : options.signal) != null)
        validateAbortSignal2(options.signal, "options.signal");
      return number3 = toIntegerOrInfinity(number3), async function* drop() {
        var _options$signal5;
        if (options !== null && options !== undefined && (_options$signal5 = options.signal) !== null && _options$signal5 !== undefined && _options$signal5.aborted)
          throw new AbortError2;
        for await (let val of this) {
          var _options$signal6;
          if (options !== null && options !== undefined && (_options$signal6 = options.signal) !== null && _options$signal6 !== undefined && _options$signal6.aborted)
            throw new AbortError2;
          if (number3-- <= 0)
            yield val;
        }
      }.call(this);
    }
    function take(number3, options = undefined) {
      if (options != null)
        validateObject(options, "options");
      if ((options === null || options === undefined ? undefined : options.signal) != null)
        validateAbortSignal2(options.signal, "options.signal");
      return number3 = toIntegerOrInfinity(number3), async function* take() {
        var _options$signal7;
        if (options !== null && options !== undefined && (_options$signal7 = options.signal) !== null && _options$signal7 !== undefined && _options$signal7.aborted)
          throw new AbortError2;
        for await (let val of this) {
          var _options$signal8;
          if (options !== null && options !== undefined && (_options$signal8 = options.signal) !== null && _options$signal8 !== undefined && _options$signal8.aborted)
            throw new AbortError2;
          if (number3-- > 0)
            yield val;
          if (number3 <= 0)
            return;
        }
      }.call(this);
    }
    module2.exports.streamReturningOperators = { asIndexedPairs: deprecate2(asIndexedPairs, "readable.asIndexedPairs will be removed in a future version."), drop, filter, flatMap, map: map3, take, compose };
    module2.exports.promiseReturningOperators = { every, forEach, reduce, toArray, some, find };
  });
  var require_promises = __commonJS2((exports2, module2) => {
    var { ArrayPrototypePop, Promise: Promise22 } = require_primordials(), { isIterable, isNodeStream, isWebStream } = require_utils(), { pipelineImpl: pl } = require_pipeline(), { finished } = require_end_of_stream();
    require_stream2();
    function pipeline(...streams) {
      return new Promise22((resolve, reject) => {
        let signal, end, lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {
          let options = ArrayPrototypePop(streams);
          signal = options.signal, end = options.end;
        }
        pl(streams, (err, value2) => {
          if (err)
            reject(err);
          else
            resolve(value2);
        }, { signal, end });
      });
    }
    module2.exports = { finished, pipeline };
  });
  var require_stream2 = __commonJS2((exports2, module2) => {
    var { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(exports_buffer2)), { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials(), { promisify: { custom: customPromisify } } = require_util(), { streamReturningOperators, promiseReturningOperators } = require_operators(), { codes: { ERR_ILLEGAL_CONSTRUCTOR } } = require_errors(), compose = require_compose(), { setDefaultHighWaterMark, getDefaultHighWaterMark } = require_state(), { pipeline } = require_pipeline(), { destroyer } = require_destroy(), eos = require_end_of_stream(), promises = require_promises(), utils = require_utils(), Stream = module2.exports = require_legacy().Stream;
    Stream.isDestroyed = utils.isDestroyed;
    Stream.isDisturbed = utils.isDisturbed;
    Stream.isErrored = utils.isErrored;
    Stream.isReadable = utils.isReadable;
    Stream.isWritable = utils.isWritable;
    Stream.Readable = require_readable();
    for (let key of ObjectKeys(streamReturningOperators)) {
      let fn = function(...args) {
        if (new.target)
          throw ERR_ILLEGAL_CONSTRUCTOR();
        return Stream.Readable.from(ReflectApply(op, this, args));
      }, op = streamReturningOperators[key];
      ObjectDefineProperty(fn, "name", { __proto__: null, value: op.name }), ObjectDefineProperty(fn, "length", { __proto__: null, value: op.length }), ObjectDefineProperty(Stream.Readable.prototype, key, { __proto__: null, value: fn, enumerable: false, configurable: true, writable: true });
    }
    for (let key of ObjectKeys(promiseReturningOperators)) {
      let fn = function(...args) {
        if (new.target)
          throw ERR_ILLEGAL_CONSTRUCTOR();
        return ReflectApply(op, this, args);
      }, op = promiseReturningOperators[key];
      ObjectDefineProperty(fn, "name", { __proto__: null, value: op.name }), ObjectDefineProperty(fn, "length", { __proto__: null, value: op.length }), ObjectDefineProperty(Stream.Readable.prototype, key, { __proto__: null, value: fn, enumerable: false, configurable: true, writable: true });
    }
    Stream.Writable = require_writable();
    Stream.Duplex = require_duplex();
    Stream.Transform = require_transform();
    Stream.PassThrough = require_passthrough();
    Stream.pipeline = pipeline;
    var { addAbortSignal } = require_add_abort_signal();
    Stream.addAbortSignal = addAbortSignal;
    Stream.finished = eos;
    Stream.destroy = destroyer;
    Stream.compose = compose;
    Stream.setDefaultHighWaterMark = setDefaultHighWaterMark;
    Stream.getDefaultHighWaterMark = getDefaultHighWaterMark;
    ObjectDefineProperty(Stream, "promises", { __proto__: null, configurable: true, enumerable: true, get() {
      return promises;
    } });
    ObjectDefineProperty(pipeline, customPromisify, { __proto__: null, enumerable: true, get() {
      return promises.pipeline;
    } });
    ObjectDefineProperty(eos, customPromisify, { __proto__: null, enumerable: true, get() {
      return promises.finished;
    } });
    Stream.Stream = Stream;
    Stream._isUint8Array = function isUint8Array(value2) {
      return value2 instanceof Uint8Array;
    };
    Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
      return Buffer3.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    };
  });
  var require_ours = __commonJS2((exports2, module2) => {
    var Stream = require_stream();
    {
      let CustomStream = require_stream2(), promises = require_promises(), originalDestroy = CustomStream.Readable.destroy;
      module2.exports = CustomStream.Readable, module2.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer, module2.exports._isUint8Array = CustomStream._isUint8Array, module2.exports.isDisturbed = CustomStream.isDisturbed, module2.exports.isErrored = CustomStream.isErrored, module2.exports.isReadable = CustomStream.isReadable, module2.exports.Readable = CustomStream.Readable, module2.exports.Writable = CustomStream.Writable, module2.exports.Duplex = CustomStream.Duplex, module2.exports.Transform = CustomStream.Transform, module2.exports.PassThrough = CustomStream.PassThrough, module2.exports.addAbortSignal = CustomStream.addAbortSignal, module2.exports.finished = CustomStream.finished, module2.exports.destroy = CustomStream.destroy, module2.exports.destroy = originalDestroy, module2.exports.pipeline = CustomStream.pipeline, module2.exports.compose = CustomStream.compose, Object.defineProperty(CustomStream, "promises", { configurable: true, enumerable: true, get() {
        return promises;
      } }), module2.exports.Stream = CustomStream.Stream;
    }
    module2.exports.default = module2.exports;
  });
  module.exports = require_ours();
});

// node:crypto
var exports_crypto = {};
__export(exports_crypto, {
  webcrypto: () => webcrypto,
  rng: () => rng2,
  randomUUID: () => randomUUID,
  randomFillSync: () => randomFillSync2,
  randomFill: () => randomFill2,
  randomBytes: () => randomBytes2,
  publicEncrypt: () => publicEncrypt2,
  publicDecrypt: () => publicDecrypt2,
  pseudoRandomBytes: () => pseudoRandomBytes2,
  prng: () => prng2,
  privateEncrypt: () => privateEncrypt2,
  privateDecrypt: () => privateDecrypt2,
  pbkdf2Sync: () => pbkdf2Sync2,
  pbkdf2: () => pbkdf22,
  listCiphers: () => listCiphers2,
  getRandomValues: () => getRandomValues,
  getHashes: () => getHashes2,
  getDiffieHellman: () => getDiffieHellman2,
  getCurves: () => getCurves,
  getCiphers: () => getCiphers2,
  default: () => crypto_default,
  createVerify: () => createVerify2,
  createSign: () => createSign2,
  createHmac: () => createHmac2,
  createHash: () => createHash2,
  createECDH: () => createECDH2,
  createDiffieHellmanGroup: () => createDiffieHellmanGroup2,
  createDiffieHellman: () => createDiffieHellman2,
  createDecipheriv: () => createDecipheriv2,
  createDecipher: () => createDecipher2,
  createCredentials: () => createCredentials2,
  createCipheriv: () => createCipheriv2,
  createCipher: () => createCipher2,
  constants: () => constants2,
  Verify: () => Verify2,
  Sign: () => Sign2,
  Hmac: () => Hmac2,
  Hash: () => Hash22,
  DiffieHellmanGroup: () => DiffieHellmanGroup2,
  DiffieHellman: () => DiffieHellman2,
  Decipheriv: () => Decipheriv2,
  Decipher: () => Decipher2,
  DEFAULT_ENCODING: () => DEFAULT_ENCODING,
  Cipheriv: () => Cipheriv2,
  Cipher: () => Cipher2
});
function getCurves() {
  return hardcoded_curves;
}
var __create2, __getProtoOf2, __defProp2, __getOwnPropNames2, __hasOwnProp2, __toESM2 = (mod, isNodeMode, target) => {
  target = mod != null ? __create2(__getProtoOf2(mod)) : {};
  let to = isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames2(mod))
    if (!__hasOwnProp2.call(to, key))
      __defProp2(to, key, { get: () => mod[key], enumerable: true });
  return to;
}, __commonJS2 = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports), require_randombytes, require_create_hash, require_create_hmac, require_algorithms, require_precondition, require_default_encoding, require_safe_buffer, require_to_buffer, require_sync, require_async, require_pbkdf2, require_browserify_cipher, require_diffie_hellman, require_browserify_sign, require_package, require_bn, require_minimalistic_assert, require_utils, require_utils2, require_brorand, require_base, require_inherits_browser, require_inherits, require_short, require_mont, require_edwards, require_curve, require_utils3, require_common, require_common2, require_1, require_256, require_224, require_512, require_384, require_sha, require_ripemd, require_hmac, require_hash, require_secp256k1, require_curves, require_hmac_drbg, require_key, require_signature, require_ec, require_key2, require_signature2, require_eddsa, require_elliptic, require_bn2, require_browser, require_create_ecdh, require_bn3, require_api, require_reporter, require_buffer, require_node, require_base2, require_der, require_constants, require_der2, require_pem, require_decoders, require_der3, require_pem2, require_encoders, require_asn1, require_certificate, require_asn12, require_aesid, require_hash_base, require_md5, require_evp_bytestokey, require_browserify_aes, require_fixProc, require_parse_asn1, require_mgf, require_xor, require_bn4, require_withPublic, require_bn5, require_browserify_rsa, require_publicEncrypt, require_privateDecrypt, require_browser2, require_public_encrypt, require_browser3, require_randomfill, require_crypto_browserify, cryptoBrowserify, prng2, pseudoRandomBytes2, rng2, randomBytes2, Hash22, createHash2, Hmac2, createHmac2, getHashes2, pbkdf22, pbkdf2Sync2, Cipher2, createCipher2, Cipheriv2, createCipheriv2, Decipher2, createDecipher2, Decipheriv2, createDecipheriv2, getCiphers2, listCiphers2, DiffieHellmanGroup2, createDiffieHellmanGroup2, getDiffieHellman2, createDiffieHellman2, DiffieHellman2, createSign2, Sign2, createVerify2, Verify2, createECDH2, publicEncrypt2, privateEncrypt2, publicDecrypt2, privateDecrypt2, randomFill2, randomFillSync2, createCredentials2, constants2, DEFAULT_ENCODING = "buffer", getRandomValues = (array3) => {
  return crypto.getRandomValues(array3);
}, randomUUID = () => {
  return crypto.randomUUID();
}, hardcoded_curves, webcrypto, crypto_default;
var init_crypto = __esm(() => {
  __create2 = Object.create;
  ({ getPrototypeOf: __getProtoOf2, defineProperty: __defProp2, getOwnPropertyNames: __getOwnPropNames2 } = Object);
  __hasOwnProp2 = Object.prototype.hasOwnProperty;
  require_randombytes = __commonJS2((exports, module) => {
    module.exports = (init_crypto(), __toCommonJS(exports_crypto)).randomBytes;
  });
  require_create_hash = __commonJS2((exports, module) => {
    module.exports = (init_crypto(), __toCommonJS(exports_crypto)).createHash;
  });
  require_create_hmac = __commonJS2((exports, module) => {
    module.exports = (init_crypto(), __toCommonJS(exports_crypto)).createHmac;
  });
  require_algorithms = __commonJS2((exports, module) => {
    module.exports = { sha224WithRSAEncryption: { sign: "rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, "RSA-SHA224": { sign: "ecdsa/rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, sha256WithRSAEncryption: { sign: "rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, "RSA-SHA256": { sign: "ecdsa/rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, sha384WithRSAEncryption: { sign: "rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, "RSA-SHA384": { sign: "ecdsa/rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, sha512WithRSAEncryption: { sign: "rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA512": { sign: "ecdsa/rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA1": { sign: "rsa", hash: "sha1", id: "3021300906052b0e03021a05000414" }, "ecdsa-with-SHA1": { sign: "ecdsa", hash: "sha1", id: "" }, sha256: { sign: "ecdsa", hash: "sha256", id: "" }, sha224: { sign: "ecdsa", hash: "sha224", id: "" }, sha384: { sign: "ecdsa", hash: "sha384", id: "" }, sha512: { sign: "ecdsa", hash: "sha512", id: "" }, "DSA-SHA": { sign: "dsa", hash: "sha1", id: "" }, "DSA-SHA1": { sign: "dsa", hash: "sha1", id: "" }, DSA: { sign: "dsa", hash: "sha1", id: "" }, "DSA-WITH-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-WITH-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-WITH-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-WITH-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-RIPEMD160": { sign: "dsa", hash: "rmd160", id: "" }, ripemd160WithRSA: { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, "RSA-RIPEMD160": { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, md5WithRSAEncryption: { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" }, "RSA-MD5": { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" } };
  });
  require_precondition = __commonJS2((exports, module) => {
    var MAX_ALLOC = Math.pow(2, 30) - 1;
    module.exports = function(iterations, keylen) {
      if (typeof iterations !== "number")
        throw new TypeError("Iterations not a number");
      if (iterations < 0)
        throw new TypeError("Bad iterations");
      if (typeof keylen !== "number")
        throw new TypeError("Key length not a number");
      if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen)
        throw new TypeError("Bad key length");
    };
  });
  require_default_encoding = __commonJS2((exports, module) => {
    var defaultEncoding;
    if (globalThis.process && globalThis.process.browser)
      defaultEncoding = "utf-8";
    else if (globalThis.process && globalThis.process.version)
      pVersionMajor = parseInt(process.version.split(".")[0].slice(1), 10), defaultEncoding = pVersionMajor >= 6 ? "utf-8" : "binary";
    else
      defaultEncoding = "utf-8";
    var pVersionMajor;
    module.exports = defaultEncoding;
  });
  require_safe_buffer = __commonJS2((exports, module) => {
    /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
    var buffer = (init_buffer(), __toCommonJS(exports_buffer2)), Buffer22 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src)
        dst[key] = src[key];
    }
    if (Buffer22.from && Buffer22.alloc && Buffer22.allocUnsafe && Buffer22.allocUnsafeSlow)
      module.exports = buffer;
    else
      copyProps(buffer, exports), exports.Buffer = SafeBuffer;
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer22(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer22.prototype);
    copyProps(Buffer22, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number")
        throw new TypeError("Argument must not be a number");
      return Buffer22(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill2, encoding) {
      if (typeof size !== "number")
        throw new TypeError("Argument must be a number");
      var buf = Buffer22(size);
      if (fill2 !== undefined)
        if (typeof encoding === "string")
          buf.fill(fill2, encoding);
        else
          buf.fill(fill2);
      else
        buf.fill(0);
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number")
        throw new TypeError("Argument must be a number");
      return Buffer22(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number")
        throw new TypeError("Argument must be a number");
      return buffer.SlowBuffer(size);
    };
  });
  require_to_buffer = __commonJS2((exports, module) => {
    var Buffer22 = require_safe_buffer().Buffer;
    module.exports = function(thing, encoding, name) {
      if (Buffer22.isBuffer(thing))
        return thing;
      else if (typeof thing === "string")
        return Buffer22.from(thing, encoding);
      else if (ArrayBuffer.isView(thing))
        return Buffer22.from(thing.buffer);
      else
        throw new TypeError(name + " must be a string, a Buffer, a typed array or a DataView");
    };
  });
  require_sync = __commonJS2((exports, module) => {
    var sizes = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, rmd160: 20, ripemd160: 20 }, createHmac = require_create_hmac(), Buffer22 = require_safe_buffer().Buffer, checkParameters = require_precondition(), defaultEncoding = require_default_encoding(), toBuffer = require_to_buffer();
    function pbkdf2(password, salt, iterations, keylen, digest) {
      checkParameters(iterations, keylen), password = toBuffer(password, defaultEncoding, "Password"), salt = toBuffer(salt, defaultEncoding, "Salt"), digest = digest || "sha1";
      var DK = Buffer22.allocUnsafe(keylen), block1 = Buffer22.allocUnsafe(salt.length + 4);
      salt.copy(block1, 0, 0, salt.length);
      var destPos = 0, hLen = sizes[digest], l = Math.ceil(keylen / hLen);
      for (var i2 = 1;i2 <= l; i2++) {
        block1.writeUInt32BE(i2, salt.length);
        var T = createHmac(digest, password).update(block1).digest(), U = T;
        for (var j = 1;j < iterations; j++) {
          U = createHmac(digest, password).update(U).digest();
          for (var k = 0;k < hLen; k++)
            T[k] ^= U[k];
        }
        T.copy(DK, destPos), destPos += hLen;
      }
      return DK;
    }
    module.exports = pbkdf2;
  });
  require_async = __commonJS2((exports, module) => {
    var Buffer22 = require_safe_buffer().Buffer, checkParameters = require_precondition(), defaultEncoding = require_default_encoding(), sync = require_sync(), toBuffer = require_to_buffer(), ZERO_BUF, subtle = globalThis.crypto && globalThis.crypto.subtle, toBrowser = { sha: "SHA-1", "sha-1": "SHA-1", sha1: "SHA-1", sha256: "SHA-256", "sha-256": "SHA-256", sha384: "SHA-384", "sha-384": "SHA-384", "sha-512": "SHA-512", sha512: "SHA-512" }, checks = [];
    function checkNative(algo) {
      if (globalThis.process && !globalThis.process.browser)
        return Promise.resolve(false);
      if (!subtle || !subtle.importKey || !subtle.deriveBits)
        return Promise.resolve(false);
      if (checks[algo] !== undefined)
        return checks[algo];
      ZERO_BUF = ZERO_BUF || Buffer22.alloc(8);
      var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo).then(function() {
        return true;
      }).catch(function() {
        return false;
      });
      return checks[algo] = prom, prom;
    }
    var nextTick;
    function getNextTick() {
      if (nextTick)
        return nextTick;
      if (globalThis.process && globalThis.process.nextTick)
        nextTick = globalThis.process.nextTick;
      else if (globalThis.queueMicrotask)
        nextTick = globalThis.queueMicrotask;
      else if (globalThis.setImmediate)
        nextTick = globalThis.setImmediate;
      else
        nextTick = globalThis.setTimeout;
      return nextTick;
    }
    function browserPbkdf2(password, salt, iterations, length, algo) {
      return subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveBits"]).then(function(key) {
        return subtle.deriveBits({ name: "PBKDF2", salt, iterations, hash: { name: algo } }, key, length << 3);
      }).then(function(res) {
        return Buffer22.from(res);
      });
    }
    function resolvePromise(promise3, callback) {
      promise3.then(function(out) {
        getNextTick()(function() {
          callback(null, out);
        });
      }, function(e) {
        getNextTick()(function() {
          callback(e);
        });
      });
    }
    module.exports = function(password, salt, iterations, keylen, digest, callback) {
      if (typeof digest === "function")
        callback = digest, digest = undefined;
      digest = digest || "sha1";
      var algo = toBrowser[digest.toLowerCase()];
      if (!algo || typeof globalThis.Promise !== "function") {
        getNextTick()(function() {
          var out;
          try {
            out = sync(password, salt, iterations, keylen, digest);
          } catch (e) {
            return callback(e);
          }
          callback(null, out);
        });
        return;
      }
      if (checkParameters(iterations, keylen), password = toBuffer(password, defaultEncoding, "Password"), salt = toBuffer(salt, defaultEncoding, "Salt"), typeof callback !== "function")
        throw new Error("No callback provided to pbkdf2");
      resolvePromise(checkNative(algo).then(function(resp) {
        if (resp)
          return browserPbkdf2(password, salt, iterations, keylen, algo);
        return sync(password, salt, iterations, keylen, digest);
      }), callback);
    };
  });
  require_pbkdf2 = __commonJS2((exports) => {
    var native = (init_crypto(), __toCommonJS(exports_crypto)), checkParameters = require_precondition(), defaultEncoding = require_default_encoding(), toBuffer = require_to_buffer();
    function nativePBKDF2(password, salt, iterations, keylen, digest, callback) {
      if (checkParameters(iterations, keylen), password = toBuffer(password, defaultEncoding, "Password"), salt = toBuffer(salt, defaultEncoding, "Salt"), typeof digest === "function")
        callback = digest, digest = "sha1";
      if (typeof callback !== "function")
        throw new Error("No callback provided to pbkdf2");
      return native.pbkdf2(password, salt, iterations, keylen, digest, callback);
    }
    function nativePBKDF2Sync(password, salt, iterations, keylen, digest) {
      return checkParameters(iterations, keylen), password = toBuffer(password, defaultEncoding, "Password"), salt = toBuffer(salt, defaultEncoding, "Salt"), digest = digest || "sha1", native.pbkdf2Sync(password, salt, iterations, keylen, digest);
    }
    if (!native.pbkdf2Sync || native.pbkdf2Sync.toString().indexOf("keylen, digest") === -1)
      exports.pbkdf2Sync = require_sync(), exports.pbkdf2 = require_async();
    else
      exports.pbkdf2Sync = nativePBKDF2Sync, exports.pbkdf2 = nativePBKDF2;
  });
  require_browserify_cipher = __commonJS2((exports) => {
    var crypto2 = (init_crypto(), __toCommonJS(exports_crypto));
    exports.createCipher = exports.Cipher = crypto2.createCipher;
    exports.createCipheriv = exports.Cipheriv = crypto2.createCipheriv;
    exports.createDecipher = exports.Decipher = crypto2.createDecipher;
    exports.createDecipheriv = exports.Decipheriv = crypto2.createDecipheriv;
    exports.listCiphers = exports.getCiphers = crypto2.getCiphers;
  });
  require_diffie_hellman = __commonJS2((exports) => {
    var crypto2 = (init_crypto(), __toCommonJS(exports_crypto));
    exports.DiffieHellmanGroup = crypto2.DiffieHellmanGroup;
    exports.createDiffieHellmanGroup = crypto2.createDiffieHellmanGroup;
    exports.getDiffieHellman = crypto2.getDiffieHellman;
    exports.createDiffieHellman = crypto2.createDiffieHellman;
    exports.DiffieHellman = crypto2.DiffieHellman;
  });
  require_browserify_sign = __commonJS2((exports) => {
    var crypto2 = (init_crypto(), __toCommonJS(exports_crypto));
    exports.createSign = crypto2.createSign;
    exports.Sign = crypto2.Sign;
    exports.createVerify = crypto2.createVerify;
    exports.Verify = crypto2.Verify;
  });
  require_package = __commonJS2((exports, module) => {
    module.exports = { name: "elliptic", version: "6.6.1", description: "EC cryptography", main: "lib/elliptic.js", files: ["lib"], scripts: { lint: "eslint lib test", "lint:fix": "npm run lint -- --fix", unit: "istanbul test _mocha --reporter=spec test/index.js", test: "npm run lint && npm run unit", version: "grunt dist && git add dist/" }, repository: { type: "git", url: "git@github.com:indutny/elliptic" }, keywords: ["EC", "Elliptic", "curve", "Cryptography"], author: "Fedor Indutny <fedor@indutny.com>", license: "MIT", bugs: { url: "https://github.com/indutny/elliptic/issues" }, homepage: "https://github.com/indutny/elliptic", devDependencies: { brfs: "^2.0.2", coveralls: "^3.1.0", eslint: "^7.6.0", grunt: "^1.2.1", "grunt-browserify": "^5.3.0", "grunt-cli": "^1.3.2", "grunt-contrib-connect": "^3.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^5.0.0", "grunt-mocha-istanbul": "^5.0.2", "grunt-saucelabs": "^9.0.1", istanbul: "^0.4.5", mocha: "^8.0.1" }, dependencies: { "bn.js": "^4.11.9", brorand: "^1.1.0", "hash.js": "^1.0.0", "hmac-drbg": "^1.0.1", inherits: "^2.0.4", "minimalistic-assert": "^1.0.1", "minimalistic-crypto-utils": "^1.0.1" } };
  });
  require_bn = __commonJS2((exports, module) => {
    (function(module2, exports2) {
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor, ctor.prototype.constructor = ctor;
      }
      function BN(number3, base, endian) {
        if (BN.isBN(number3))
          return number3;
        if (this.negative = 0, this.words = null, this.length = 0, this.red = null, number3 !== null) {
          if (base === "le" || base === "be")
            endian = base, base = 10;
          this._init(number3 || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object")
        module2.exports = BN;
      else
        exports2.BN = BN;
      BN.BN = BN, BN.wordSize = 26;
      var Buffer22;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined")
          Buffer22 = window.Buffer;
        else
          Buffer22 = (init_buffer(), __toCommonJS(exports_buffer2)).Buffer;
      } catch (e) {}
      BN.isBN = function isBN(num) {
        if (num instanceof BN)
          return true;
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      }, BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      }, BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      }, BN.prototype._init = function init(number3, base, endian) {
        if (typeof number3 === "number")
          return this._initNumber(number3, base, endian);
        if (typeof number3 === "object")
          return this._initArray(number3, base, endian);
        if (base === "hex")
          base = 16;
        assert(base === (base | 0) && base >= 2 && base <= 36), number3 = number3.toString().replace(/\s+/g, "");
        var start = 0;
        if (number3[0] === "-")
          start++, this.negative = 1;
        if (start < number3.length) {
          if (base === 16)
            this._parseHex(number3, start, endian);
          else if (this._parseBase(number3, base, start), endian === "le")
            this._initArray(this.toArray(), base, endian);
        }
      }, BN.prototype._initNumber = function _initNumber(number3, base, endian) {
        if (number3 < 0)
          this.negative = 1, number3 = -number3;
        if (number3 < 67108864)
          this.words = [number3 & 67108863], this.length = 1;
        else if (number3 < 4503599627370496)
          this.words = [number3 & 67108863, number3 / 67108864 & 67108863], this.length = 2;
        else
          assert(number3 < 9007199254740992), this.words = [number3 & 67108863, number3 / 67108864 & 67108863, 1], this.length = 3;
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      }, BN.prototype._initArray = function _initArray(number3, base, endian) {
        if (assert(typeof number3.length === "number"), number3.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(number3.length / 3), this.words = new Array(this.length);
        for (var i2 = 0;i2 < this.length; i2++)
          this.words[i2] = 0;
        var j, w, off = 0;
        if (endian === "be") {
          for (i2 = number3.length - 1, j = 0;i2 >= 0; i2 -= 3)
            if (w = number3[i2] | number3[i2 - 1] << 8 | number3[i2 - 2] << 16, this.words[j] |= w << off & 67108863, this.words[j + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26)
              off -= 26, j++;
        } else if (endian === "le") {
          for (i2 = 0, j = 0;i2 < number3.length; i2 += 3)
            if (w = number3[i2] | number3[i2 + 1] << 8 | number3[i2 + 2] << 16, this.words[j] |= w << off & 67108863, this.words[j + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26)
              off -= 26, j++;
        }
        return this.strip();
      };
      function parseHex4Bits(string3, index) {
        var c = string3.charCodeAt(index);
        if (c >= 65 && c <= 70)
          return c - 55;
        else if (c >= 97 && c <= 102)
          return c - 87;
        else
          return c - 48 & 15;
      }
      function parseHexByte(string3, lowerBound, index) {
        var r = parseHex4Bits(string3, index);
        if (index - 1 >= lowerBound)
          r |= parseHex4Bits(string3, index - 1) << 4;
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number3, start, endian) {
        this.length = Math.ceil((number3.length - start) / 6), this.words = new Array(this.length);
        for (var i2 = 0;i2 < this.length; i2++)
          this.words[i2] = 0;
        var off = 0, j = 0, w;
        if (endian === "be")
          for (i2 = number3.length - 1;i2 >= start; i2 -= 2)
            if (w = parseHexByte(number3, start, i2) << off, this.words[j] |= w & 67108863, off >= 18)
              off -= 18, j += 1, this.words[j] |= w >>> 26;
            else
              off += 8;
        else {
          var parseLength = number3.length - start;
          for (i2 = parseLength % 2 === 0 ? start + 1 : start;i2 < number3.length; i2 += 2)
            if (w = parseHexByte(number3, start, i2) << off, this.words[j] |= w & 67108863, off >= 18)
              off -= 18, j += 1, this.words[j] |= w >>> 26;
            else
              off += 8;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0, len2 = Math.min(str.length, end);
        for (var i2 = start;i2 < len2; i2++) {
          var c = str.charCodeAt(i2) - 48;
          if (r *= mul, c >= 49)
            r += c - 49 + 10;
          else if (c >= 17)
            r += c - 17 + 10;
          else
            r += c;
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number3, base, start) {
        this.words = [0], this.length = 1;
        for (var limbLen = 0, limbPow = 1;limbPow <= 67108863; limbPow *= base)
          limbLen++;
        limbLen--, limbPow = limbPow / base | 0;
        var total = number3.length - start, mod = total % limbLen, end = Math.min(total, total - mod) + start, word = 0;
        for (var i2 = start;i2 < end; i2 += limbLen)
          if (word = parseBase(number3, i2, i2 + limbLen, base), this.imuln(limbPow), this.words[0] + word < 67108864)
            this.words[0] += word;
          else
            this._iaddn(word);
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number3, i2, number3.length, base);
          for (i2 = 0;i2 < mod; i2++)
            pow *= base;
          if (this.imuln(pow), this.words[0] + word < 67108864)
            this.words[0] += word;
          else
            this._iaddn(word);
        }
        this.strip();
      }, BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i2 = 0;i2 < this.length; i2++)
          dest.words[i2] = this.words[i2];
        dest.length = this.length, dest.negative = this.negative, dest.red = this.red;
      }, BN.prototype.clone = function clone() {
        var r = new BN(null);
        return this.copy(r), r;
      }, BN.prototype._expand = function _expand(size) {
        while (this.length < size)
          this.words[this.length++] = 0;
        return this;
      }, BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0)
          this.length--;
        return this._normSign();
      }, BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0)
          this.negative = 0;
        return this;
      }, BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      if (BN.prototype.toString = function toString(base, padding) {
        base = base || 10, padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0, carry = 0;
          for (var i2 = 0;i2 < this.length; i2++) {
            var w = this.words[i2], word = ((w << off | carry) & 16777215).toString(16);
            if (carry = w >>> 24 - off & 16777215, off += 2, off >= 26)
              off -= 26, i2--;
            if (carry !== 0 || i2 !== this.length - 1)
              out = zeros[6 - word.length] + word + out;
            else
              out = word + out;
          }
          if (carry !== 0)
            out = carry.toString(16) + out;
          while (out.length % padding !== 0)
            out = "0" + out;
          if (this.negative !== 0)
            out = "-" + out;
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base], groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            if (c = c.idivn(groupBase), !c.isZero())
              out = zeros[groupSize - r.length] + r + out;
            else
              out = r + out;
          }
          if (this.isZero())
            out = "0" + out;
          while (out.length % padding !== 0)
            out = "0" + out;
          if (this.negative !== 0)
            out = "-" + out;
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      }, BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2)
          ret += this.words[1] * 67108864;
        else if (this.length === 3 && this.words[2] === 1)
          ret += 4503599627370496 + this.words[1] * 67108864;
        else if (this.length > 2)
          assert(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -ret : ret;
      }, BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      }, BN.prototype.toBuffer = function toBuffer(endian, length) {
        return assert(typeof Buffer22 !== "undefined"), this.toArrayLike(Buffer22, endian, length);
      }, BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      }, BN.prototype.toArrayLike = function toArrayLike(ArrayType7, endian, length) {
        var byteLength2 = this.byteLength(), reqLength = length || Math.max(1, byteLength2);
        assert(byteLength2 <= reqLength, "byte array longer than desired length"), assert(reqLength > 0, "Requested array length <= 0"), this.strip();
        var littleEndian = endian === "le", res = new ArrayType7(reqLength), b, i2, q = this.clone();
        if (!littleEndian) {
          for (i2 = 0;i2 < reqLength - byteLength2; i2++)
            res[i2] = 0;
          for (i2 = 0;!q.isZero(); i2++)
            b = q.andln(255), q.iushrn(8), res[reqLength - i2 - 1] = b;
        } else {
          for (i2 = 0;!q.isZero(); i2++)
            b = q.andln(255), q.iushrn(8), res[i2] = b;
          for (;i2 < reqLength; i2++)
            res[i2] = 0;
        }
        return res;
      }, Math.clz32)
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      else
        BN.prototype._countBits = function _countBits(w) {
          var t2 = w, r = 0;
          if (t2 >= 4096)
            r += 13, t2 >>>= 13;
          if (t2 >= 64)
            r += 7, t2 >>>= 7;
          if (t2 >= 8)
            r += 4, t2 >>>= 4;
          if (t2 >= 2)
            r += 2, t2 >>>= 2;
          return r + t2;
        };
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t2 = w, r = 0;
        if ((t2 & 8191) === 0)
          r += 13, t2 >>>= 13;
        if ((t2 & 127) === 0)
          r += 7, t2 >>>= 7;
        if ((t2 & 15) === 0)
          r += 4, t2 >>>= 4;
        if ((t2 & 3) === 0)
          r += 2, t2 >>>= 2;
        if ((t2 & 1) === 0)
          r++;
        return r;
      }, BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1], hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0;bit < w.length; bit++) {
          var off = bit / 26 | 0, wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i2 = 0;i2 < this.length; i2++) {
          var b = this._zeroBits(this.words[i2]);
          if (r += b, b !== 26)
            break;
        }
        return r;
      }, BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      }, BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0)
          return this.abs().inotn(width).iaddn(1);
        return this.clone();
      }, BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1))
          return this.notn(width).iaddn(1).ineg();
        return this.clone();
      }, BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      }, BN.prototype.neg = function neg() {
        return this.clone().ineg();
      }, BN.prototype.ineg = function ineg() {
        if (!this.isZero())
          this.negative ^= 1;
        return this;
      }, BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length)
          this.words[this.length++] = 0;
        for (var i2 = 0;i2 < num.length; i2++)
          this.words[i2] = this.words[i2] | num.words[i2];
        return this.strip();
      }, BN.prototype.ior = function ior(num) {
        return assert((this.negative | num.negative) === 0), this.iuor(num);
      }, BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      }, BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      }, BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length)
          b = num;
        else
          b = this;
        for (var i2 = 0;i2 < b.length; i2++)
          this.words[i2] = this.words[i2] & num.words[i2];
        return this.length = b.length, this.strip();
      }, BN.prototype.iand = function iand(num) {
        return assert((this.negative | num.negative) === 0), this.iuand(num);
      }, BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      }, BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      }, BN.prototype.iuxor = function iuxor(num) {
        var a, b;
        if (this.length > num.length)
          a = this, b = num;
        else
          a = num, b = this;
        for (var i2 = 0;i2 < b.length; i2++)
          this.words[i2] = a.words[i2] ^ b.words[i2];
        if (this !== a)
          for (;i2 < a.length; i2++)
            this.words[i2] = a.words[i2];
        return this.length = a.length, this.strip();
      }, BN.prototype.ixor = function ixor(num) {
        return assert((this.negative | num.negative) === 0), this.iuxor(num);
      }, BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      }, BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      }, BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0, bitsLeft = width % 26;
        if (this._expand(bytesNeeded), bitsLeft > 0)
          bytesNeeded--;
        for (var i2 = 0;i2 < bytesNeeded; i2++)
          this.words[i2] = ~this.words[i2] & 67108863;
        if (bitsLeft > 0)
          this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
        return this.strip();
      }, BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      }, BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0, wbit = bit % 26;
        if (this._expand(off + 1), val)
          this.words[off] = this.words[off] | 1 << wbit;
        else
          this.words[off] = this.words[off] & ~(1 << wbit);
        return this.strip();
      }, BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0)
          return this.negative = 0, r = this.isub(num), this.negative ^= 1, this._normSign();
        else if (this.negative === 0 && num.negative !== 0)
          return num.negative = 0, r = this.isub(num), num.negative = 1, r._normSign();
        var a, b;
        if (this.length > num.length)
          a = this, b = num;
        else
          a = num, b = this;
        var carry = 0;
        for (var i2 = 0;i2 < b.length; i2++)
          r = (a.words[i2] | 0) + (b.words[i2] | 0) + carry, this.words[i2] = r & 67108863, carry = r >>> 26;
        for (;carry !== 0 && i2 < a.length; i2++)
          r = (a.words[i2] | 0) + carry, this.words[i2] = r & 67108863, carry = r >>> 26;
        if (this.length = a.length, carry !== 0)
          this.words[this.length] = carry, this.length++;
        else if (a !== this)
          for (;i2 < a.length; i2++)
            this.words[i2] = a.words[i2];
        return this;
      }, BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0)
          return num.negative = 0, res = this.sub(num), num.negative ^= 1, res;
        else if (num.negative === 0 && this.negative !== 0)
          return this.negative = 0, res = num.sub(this), this.negative = 1, res;
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      }, BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          return num.negative = 1, r._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(num), this.negative = 1, this._normSign();
        var cmp = this.cmp(num);
        if (cmp === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var a, b;
        if (cmp > 0)
          a = this, b = num;
        else
          a = num, b = this;
        var carry = 0;
        for (var i2 = 0;i2 < b.length; i2++)
          r = (a.words[i2] | 0) - (b.words[i2] | 0) + carry, carry = r >> 26, this.words[i2] = r & 67108863;
        for (;carry !== 0 && i2 < a.length; i2++)
          r = (a.words[i2] | 0) + carry, carry = r >> 26, this.words[i2] = r & 67108863;
        if (carry === 0 && i2 < a.length && a !== this)
          for (;i2 < a.length; i2++)
            this.words[i2] = a.words[i2];
        if (this.length = Math.max(this.length, i2), a !== this)
          this.negative = 1;
        return this.strip();
      }, BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len2 = self2.length + num.length | 0;
        out.length = len2, len2 = len2 - 1 | 0;
        var a = self2.words[0] | 0, b = num.words[0] | 0, r = a * b, lo = r & 67108863, carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1;k < len2; k++) {
          var ncarry = carry >>> 26, rword = carry & 67108863, maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
            var i2 = k - j | 0;
            a = self2.words[i2] | 0, b = num.words[j] | 0, r = a * b + rword, ncarry += r / 67108864 | 0, rword = r & 67108863;
          }
          out.words[k] = rword | 0, carry = ncarry | 0;
        }
        if (carry !== 0)
          out.words[k] = carry | 0;
        else
          out.length--;
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo(self2, num, out) {
        var a = self2.words, b = num.words, o = out.words, c = 0, lo, mid, hi, a0 = a[0] | 0, al0 = a0 & 8191, ah0 = a0 >>> 13, a1 = a[1] | 0, al1 = a1 & 8191, ah1 = a1 >>> 13, a2 = a[2] | 0, al2 = a2 & 8191, ah2 = a2 >>> 13, a3 = a[3] | 0, al3 = a3 & 8191, ah3 = a3 >>> 13, a4 = a[4] | 0, al4 = a4 & 8191, ah4 = a4 >>> 13, a5 = a[5] | 0, al5 = a5 & 8191, ah5 = a5 >>> 13, a6 = a[6] | 0, al6 = a6 & 8191, ah6 = a6 >>> 13, a7 = a[7] | 0, al7 = a7 & 8191, ah7 = a7 >>> 13, a8 = a[8] | 0, al8 = a8 & 8191, ah8 = a8 >>> 13, a9 = a[9] | 0, al9 = a9 & 8191, ah9 = a9 >>> 13, b0 = b[0] | 0, bl0 = b0 & 8191, bh0 = b0 >>> 13, b1 = b[1] | 0, bl1 = b1 & 8191, bh1 = b1 >>> 13, b2 = b[2] | 0, bl2 = b2 & 8191, bh2 = b2 >>> 13, b3 = b[3] | 0, bl3 = b3 & 8191, bh3 = b3 >>> 13, b4 = b[4] | 0, bl4 = b4 & 8191, bh4 = b4 >>> 13, b5 = b[5] | 0, bl5 = b5 & 8191, bh5 = b5 >>> 13, b6 = b[6] | 0, bl6 = b6 & 8191, bh6 = b6 >>> 13, b7 = b[7] | 0, bl7 = b7 & 8191, bh7 = b7 >>> 13, b8 = b[8] | 0, bl8 = b8 & 8191, bh8 = b8 >>> 13, b9 = b[9] | 0, bl9 = b9 & 8191, bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative, out.length = 19, lo = Math.imul(al0, bl0), mid = Math.imul(al0, bh0), mid = mid + Math.imul(ah0, bl0) | 0, hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0, w0 &= 67108863, lo = Math.imul(al1, bl0), mid = Math.imul(al1, bh0), mid = mid + Math.imul(ah1, bl0) | 0, hi = Math.imul(ah1, bh0), lo = lo + Math.imul(al0, bl1) | 0, mid = mid + Math.imul(al0, bh1) | 0, mid = mid + Math.imul(ah0, bl1) | 0, hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0, w1 &= 67108863, lo = Math.imul(al2, bl0), mid = Math.imul(al2, bh0), mid = mid + Math.imul(ah2, bl0) | 0, hi = Math.imul(ah2, bh0), lo = lo + Math.imul(al1, bl1) | 0, mid = mid + Math.imul(al1, bh1) | 0, mid = mid + Math.imul(ah1, bl1) | 0, hi = hi + Math.imul(ah1, bh1) | 0, lo = lo + Math.imul(al0, bl2) | 0, mid = mid + Math.imul(al0, bh2) | 0, mid = mid + Math.imul(ah0, bl2) | 0, hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0, w2 &= 67108863, lo = Math.imul(al3, bl0), mid = Math.imul(al3, bh0), mid = mid + Math.imul(ah3, bl0) | 0, hi = Math.imul(ah3, bh0), lo = lo + Math.imul(al2, bl1) | 0, mid = mid + Math.imul(al2, bh1) | 0, mid = mid + Math.imul(ah2, bl1) | 0, hi = hi + Math.imul(ah2, bh1) | 0, lo = lo + Math.imul(al1, bl2) | 0, mid = mid + Math.imul(al1, bh2) | 0, mid = mid + Math.imul(ah1, bl2) | 0, hi = hi + Math.imul(ah1, bh2) | 0, lo = lo + Math.imul(al0, bl3) | 0, mid = mid + Math.imul(al0, bh3) | 0, mid = mid + Math.imul(ah0, bl3) | 0, hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0, w3 &= 67108863, lo = Math.imul(al4, bl0), mid = Math.imul(al4, bh0), mid = mid + Math.imul(ah4, bl0) | 0, hi = Math.imul(ah4, bh0), lo = lo + Math.imul(al3, bl1) | 0, mid = mid + Math.imul(al3, bh1) | 0, mid = mid + Math.imul(ah3, bl1) | 0, hi = hi + Math.imul(ah3, bh1) | 0, lo = lo + Math.imul(al2, bl2) | 0, mid = mid + Math.imul(al2, bh2) | 0, mid = mid + Math.imul(ah2, bl2) | 0, hi = hi + Math.imul(ah2, bh2) | 0, lo = lo + Math.imul(al1, bl3) | 0, mid = mid + Math.imul(al1, bh3) | 0, mid = mid + Math.imul(ah1, bl3) | 0, hi = hi + Math.imul(ah1, bh3) | 0, lo = lo + Math.imul(al0, bl4) | 0, mid = mid + Math.imul(al0, bh4) | 0, mid = mid + Math.imul(ah0, bl4) | 0, hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0, w4 &= 67108863, lo = Math.imul(al5, bl0), mid = Math.imul(al5, bh0), mid = mid + Math.imul(ah5, bl0) | 0, hi = Math.imul(ah5, bh0), lo = lo + Math.imul(al4, bl1) | 0, mid = mid + Math.imul(al4, bh1) | 0, mid = mid + Math.imul(ah4, bl1) | 0, hi = hi + Math.imul(ah4, bh1) | 0, lo = lo + Math.imul(al3, bl2) | 0, mid = mid + Math.imul(al3, bh2) | 0, mid = mid + Math.imul(ah3, bl2) | 0, hi = hi + Math.imul(ah3, bh2) | 0, lo = lo + Math.imul(al2, bl3) | 0, mid = mid + Math.imul(al2, bh3) | 0, mid = mid + Math.imul(ah2, bl3) | 0, hi = hi + Math.imul(ah2, bh3) | 0, lo = lo + Math.imul(al1, bl4) | 0, mid = mid + Math.imul(al1, bh4) | 0, mid = mid + Math.imul(ah1, bl4) | 0, hi = hi + Math.imul(ah1, bh4) | 0, lo = lo + Math.imul(al0, bl5) | 0, mid = mid + Math.imul(al0, bh5) | 0, mid = mid + Math.imul(ah0, bl5) | 0, hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0, w5 &= 67108863, lo = Math.imul(al6, bl0), mid = Math.imul(al6, bh0), mid = mid + Math.imul(ah6, bl0) | 0, hi = Math.imul(ah6, bh0), lo = lo + Math.imul(al5, bl1) | 0, mid = mid + Math.imul(al5, bh1) | 0, mid = mid + Math.imul(ah5, bl1) | 0, hi = hi + Math.imul(ah5, bh1) | 0, lo = lo + Math.imul(al4, bl2) | 0, mid = mid + Math.imul(al4, bh2) | 0, mid = mid + Math.imul(ah4, bl2) | 0, hi = hi + Math.imul(ah4, bh2) | 0, lo = lo + Math.imul(al3, bl3) | 0, mid = mid + Math.imul(al3, bh3) | 0, mid = mid + Math.imul(ah3, bl3) | 0, hi = hi + Math.imul(ah3, bh3) | 0, lo = lo + Math.imul(al2, bl4) | 0, mid = mid + Math.imul(al2, bh4) | 0, mid = mid + Math.imul(ah2, bl4) | 0, hi = hi + Math.imul(ah2, bh4) | 0, lo = lo + Math.imul(al1, bl5) | 0, mid = mid + Math.imul(al1, bh5) | 0, mid = mid + Math.imul(ah1, bl5) | 0, hi = hi + Math.imul(ah1, bh5) | 0, lo = lo + Math.imul(al0, bl6) | 0, mid = mid + Math.imul(al0, bh6) | 0, mid = mid + Math.imul(ah0, bl6) | 0, hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0, w6 &= 67108863, lo = Math.imul(al7, bl0), mid = Math.imul(al7, bh0), mid = mid + Math.imul(ah7, bl0) | 0, hi = Math.imul(ah7, bh0), lo = lo + Math.imul(al6, bl1) | 0, mid = mid + Math.imul(al6, bh1) | 0, mid = mid + Math.imul(ah6, bl1) | 0, hi = hi + Math.imul(ah6, bh1) | 0, lo = lo + Math.imul(al5, bl2) | 0, mid = mid + Math.imul(al5, bh2) | 0, mid = mid + Math.imul(ah5, bl2) | 0, hi = hi + Math.imul(ah5, bh2) | 0, lo = lo + Math.imul(al4, bl3) | 0, mid = mid + Math.imul(al4, bh3) | 0, mid = mid + Math.imul(ah4, bl3) | 0, hi = hi + Math.imul(ah4, bh3) | 0, lo = lo + Math.imul(al3, bl4) | 0, mid = mid + Math.imul(al3, bh4) | 0, mid = mid + Math.imul(ah3, bl4) | 0, hi = hi + Math.imul(ah3, bh4) | 0, lo = lo + Math.imul(al2, bl5) | 0, mid = mid + Math.imul(al2, bh5) | 0, mid = mid + Math.imul(ah2, bl5) | 0, hi = hi + Math.imul(ah2, bh5) | 0, lo = lo + Math.imul(al1, bl6) | 0, mid = mid + Math.imul(al1, bh6) | 0, mid = mid + Math.imul(ah1, bl6) | 0, hi = hi + Math.imul(ah1, bh6) | 0, lo = lo + Math.imul(al0, bl7) | 0, mid = mid + Math.imul(al0, bh7) | 0, mid = mid + Math.imul(ah0, bl7) | 0, hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0, w7 &= 67108863, lo = Math.imul(al8, bl0), mid = Math.imul(al8, bh0), mid = mid + Math.imul(ah8, bl0) | 0, hi = Math.imul(ah8, bh0), lo = lo + Math.imul(al7, bl1) | 0, mid = mid + Math.imul(al7, bh1) | 0, mid = mid + Math.imul(ah7, bl1) | 0, hi = hi + Math.imul(ah7, bh1) | 0, lo = lo + Math.imul(al6, bl2) | 0, mid = mid + Math.imul(al6, bh2) | 0, mid = mid + Math.imul(ah6, bl2) | 0, hi = hi + Math.imul(ah6, bh2) | 0, lo = lo + Math.imul(al5, bl3) | 0, mid = mid + Math.imul(al5, bh3) | 0, mid = mid + Math.imul(ah5, bl3) | 0, hi = hi + Math.imul(ah5, bh3) | 0, lo = lo + Math.imul(al4, bl4) | 0, mid = mid + Math.imul(al4, bh4) | 0, mid = mid + Math.imul(ah4, bl4) | 0, hi = hi + Math.imul(ah4, bh4) | 0, lo = lo + Math.imul(al3, bl5) | 0, mid = mid + Math.imul(al3, bh5) | 0, mid = mid + Math.imul(ah3, bl5) | 0, hi = hi + Math.imul(ah3, bh5) | 0, lo = lo + Math.imul(al2, bl6) | 0, mid = mid + Math.imul(al2, bh6) | 0, mid = mid + Math.imul(ah2, bl6) | 0, hi = hi + Math.imul(ah2, bh6) | 0, lo = lo + Math.imul(al1, bl7) | 0, mid = mid + Math.imul(al1, bh7) | 0, mid = mid + Math.imul(ah1, bl7) | 0, hi = hi + Math.imul(ah1, bh7) | 0, lo = lo + Math.imul(al0, bl8) | 0, mid = mid + Math.imul(al0, bh8) | 0, mid = mid + Math.imul(ah0, bl8) | 0, hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0, w8 &= 67108863, lo = Math.imul(al9, bl0), mid = Math.imul(al9, bh0), mid = mid + Math.imul(ah9, bl0) | 0, hi = Math.imul(ah9, bh0), lo = lo + Math.imul(al8, bl1) | 0, mid = mid + Math.imul(al8, bh1) | 0, mid = mid + Math.imul(ah8, bl1) | 0, hi = hi + Math.imul(ah8, bh1) | 0, lo = lo + Math.imul(al7, bl2) | 0, mid = mid + Math.imul(al7, bh2) | 0, mid = mid + Math.imul(ah7, bl2) | 0, hi = hi + Math.imul(ah7, bh2) | 0, lo = lo + Math.imul(al6, bl3) | 0, mid = mid + Math.imul(al6, bh3) | 0, mid = mid + Math.imul(ah6, bl3) | 0, hi = hi + Math.imul(ah6, bh3) | 0, lo = lo + Math.imul(al5, bl4) | 0, mid = mid + Math.imul(al5, bh4) | 0, mid = mid + Math.imul(ah5, bl4) | 0, hi = hi + Math.imul(ah5, bh4) | 0, lo = lo + Math.imul(al4, bl5) | 0, mid = mid + Math.imul(al4, bh5) | 0, mid = mid + Math.imul(ah4, bl5) | 0, hi = hi + Math.imul(ah4, bh5) | 0, lo = lo + Math.imul(al3, bl6) | 0, mid = mid + Math.imul(al3, bh6) | 0, mid = mid + Math.imul(ah3, bl6) | 0, hi = hi + Math.imul(ah3, bh6) | 0, lo = lo + Math.imul(al2, bl7) | 0, mid = mid + Math.imul(al2, bh7) | 0, mid = mid + Math.imul(ah2, bl7) | 0, hi = hi + Math.imul(ah2, bh7) | 0, lo = lo + Math.imul(al1, bl8) | 0, mid = mid + Math.imul(al1, bh8) | 0, mid = mid + Math.imul(ah1, bl8) | 0, hi = hi + Math.imul(ah1, bh8) | 0, lo = lo + Math.imul(al0, bl9) | 0, mid = mid + Math.imul(al0, bh9) | 0, mid = mid + Math.imul(ah0, bl9) | 0, hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0, w9 &= 67108863, lo = Math.imul(al9, bl1), mid = Math.imul(al9, bh1), mid = mid + Math.imul(ah9, bl1) | 0, hi = Math.imul(ah9, bh1), lo = lo + Math.imul(al8, bl2) | 0, mid = mid + Math.imul(al8, bh2) | 0, mid = mid + Math.imul(ah8, bl2) | 0, hi = hi + Math.imul(ah8, bh2) | 0, lo = lo + Math.imul(al7, bl3) | 0, mid = mid + Math.imul(al7, bh3) | 0, mid = mid + Math.imul(ah7, bl3) | 0, hi = hi + Math.imul(ah7, bh3) | 0, lo = lo + Math.imul(al6, bl4) | 0, mid = mid + Math.imul(al6, bh4) | 0, mid = mid + Math.imul(ah6, bl4) | 0, hi = hi + Math.imul(ah6, bh4) | 0, lo = lo + Math.imul(al5, bl5) | 0, mid = mid + Math.imul(al5, bh5) | 0, mid = mid + Math.imul(ah5, bl5) | 0, hi = hi + Math.imul(ah5, bh5) | 0, lo = lo + Math.imul(al4, bl6) | 0, mid = mid + Math.imul(al4, bh6) | 0, mid = mid + Math.imul(ah4, bl6) | 0, hi = hi + Math.imul(ah4, bh6) | 0, lo = lo + Math.imul(al3, bl7) | 0, mid = mid + Math.imul(al3, bh7) | 0, mid = mid + Math.imul(ah3, bl7) | 0, hi = hi + Math.imul(ah3, bh7) | 0, lo = lo + Math.imul(al2, bl8) | 0, mid = mid + Math.imul(al2, bh8) | 0, mid = mid + Math.imul(ah2, bl8) | 0, hi = hi + Math.imul(ah2, bh8) | 0, lo = lo + Math.imul(al1, bl9) | 0, mid = mid + Math.imul(al1, bh9) | 0, mid = mid + Math.imul(ah1, bl9) | 0, hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0, w10 &= 67108863, lo = Math.imul(al9, bl2), mid = Math.imul(al9, bh2), mid = mid + Math.imul(ah9, bl2) | 0, hi = Math.imul(ah9, bh2), lo = lo + Math.imul(al8, bl3) | 0, mid = mid + Math.imul(al8, bh3) | 0, mid = mid + Math.imul(ah8, bl3) | 0, hi = hi + Math.imul(ah8, bh3) | 0, lo = lo + Math.imul(al7, bl4) | 0, mid = mid + Math.imul(al7, bh4) | 0, mid = mid + Math.imul(ah7, bl4) | 0, hi = hi + Math.imul(ah7, bh4) | 0, lo = lo + Math.imul(al6, bl5) | 0, mid = mid + Math.imul(al6, bh5) | 0, mid = mid + Math.imul(ah6, bl5) | 0, hi = hi + Math.imul(ah6, bh5) | 0, lo = lo + Math.imul(al5, bl6) | 0, mid = mid + Math.imul(al5, bh6) | 0, mid = mid + Math.imul(ah5, bl6) | 0, hi = hi + Math.imul(ah5, bh6) | 0, lo = lo + Math.imul(al4, bl7) | 0, mid = mid + Math.imul(al4, bh7) | 0, mid = mid + Math.imul(ah4, bl7) | 0, hi = hi + Math.imul(ah4, bh7) | 0, lo = lo + Math.imul(al3, bl8) | 0, mid = mid + Math.imul(al3, bh8) | 0, mid = mid + Math.imul(ah3, bl8) | 0, hi = hi + Math.imul(ah3, bh8) | 0, lo = lo + Math.imul(al2, bl9) | 0, mid = mid + Math.imul(al2, bh9) | 0, mid = mid + Math.imul(ah2, bl9) | 0, hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0, w11 &= 67108863, lo = Math.imul(al9, bl3), mid = Math.imul(al9, bh3), mid = mid + Math.imul(ah9, bl3) | 0, hi = Math.imul(ah9, bh3), lo = lo + Math.imul(al8, bl4) | 0, mid = mid + Math.imul(al8, bh4) | 0, mid = mid + Math.imul(ah8, bl4) | 0, hi = hi + Math.imul(ah8, bh4) | 0, lo = lo + Math.imul(al7, bl5) | 0, mid = mid + Math.imul(al7, bh5) | 0, mid = mid + Math.imul(ah7, bl5) | 0, hi = hi + Math.imul(ah7, bh5) | 0, lo = lo + Math.imul(al6, bl6) | 0, mid = mid + Math.imul(al6, bh6) | 0, mid = mid + Math.imul(ah6, bl6) | 0, hi = hi + Math.imul(ah6, bh6) | 0, lo = lo + Math.imul(al5, bl7) | 0, mid = mid + Math.imul(al5, bh7) | 0, mid = mid + Math.imul(ah5, bl7) | 0, hi = hi + Math.imul(ah5, bh7) | 0, lo = lo + Math.imul(al4, bl8) | 0, mid = mid + Math.imul(al4, bh8) | 0, mid = mid + Math.imul(ah4, bl8) | 0, hi = hi + Math.imul(ah4, bh8) | 0, lo = lo + Math.imul(al3, bl9) | 0, mid = mid + Math.imul(al3, bh9) | 0, mid = mid + Math.imul(ah3, bl9) | 0, hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0, w12 &= 67108863, lo = Math.imul(al9, bl4), mid = Math.imul(al9, bh4), mid = mid + Math.imul(ah9, bl4) | 0, hi = Math.imul(ah9, bh4), lo = lo + Math.imul(al8, bl5) | 0, mid = mid + Math.imul(al8, bh5) | 0, mid = mid + Math.imul(ah8, bl5) | 0, hi = hi + Math.imul(ah8, bh5) | 0, lo = lo + Math.imul(al7, bl6) | 0, mid = mid + Math.imul(al7, bh6) | 0, mid = mid + Math.imul(ah7, bl6) | 0, hi = hi + Math.imul(ah7, bh6) | 0, lo = lo + Math.imul(al6, bl7) | 0, mid = mid + Math.imul(al6, bh7) | 0, mid = mid + Math.imul(ah6, bl7) | 0, hi = hi + Math.imul(ah6, bh7) | 0, lo = lo + Math.imul(al5, bl8) | 0, mid = mid + Math.imul(al5, bh8) | 0, mid = mid + Math.imul(ah5, bl8) | 0, hi = hi + Math.imul(ah5, bh8) | 0, lo = lo + Math.imul(al4, bl9) | 0, mid = mid + Math.imul(al4, bh9) | 0, mid = mid + Math.imul(ah4, bl9) | 0, hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0, w13 &= 67108863, lo = Math.imul(al9, bl5), mid = Math.imul(al9, bh5), mid = mid + Math.imul(ah9, bl5) | 0, hi = Math.imul(ah9, bh5), lo = lo + Math.imul(al8, bl6) | 0, mid = mid + Math.imul(al8, bh6) | 0, mid = mid + Math.imul(ah8, bl6) | 0, hi = hi + Math.imul(ah8, bh6) | 0, lo = lo + Math.imul(al7, bl7) | 0, mid = mid + Math.imul(al7, bh7) | 0, mid = mid + Math.imul(ah7, bl7) | 0, hi = hi + Math.imul(ah7, bh7) | 0, lo = lo + Math.imul(al6, bl8) | 0, mid = mid + Math.imul(al6, bh8) | 0, mid = mid + Math.imul(ah6, bl8) | 0, hi = hi + Math.imul(ah6, bh8) | 0, lo = lo + Math.imul(al5, bl9) | 0, mid = mid + Math.imul(al5, bh9) | 0, mid = mid + Math.imul(ah5, bl9) | 0, hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0, w14 &= 67108863, lo = Math.imul(al9, bl6), mid = Math.imul(al9, bh6), mid = mid + Math.imul(ah9, bl6) | 0, hi = Math.imul(ah9, bh6), lo = lo + Math.imul(al8, bl7) | 0, mid = mid + Math.imul(al8, bh7) | 0, mid = mid + Math.imul(ah8, bl7) | 0, hi = hi + Math.imul(ah8, bh7) | 0, lo = lo + Math.imul(al7, bl8) | 0, mid = mid + Math.imul(al7, bh8) | 0, mid = mid + Math.imul(ah7, bl8) | 0, hi = hi + Math.imul(ah7, bh8) | 0, lo = lo + Math.imul(al6, bl9) | 0, mid = mid + Math.imul(al6, bh9) | 0, mid = mid + Math.imul(ah6, bl9) | 0, hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0, w15 &= 67108863, lo = Math.imul(al9, bl7), mid = Math.imul(al9, bh7), mid = mid + Math.imul(ah9, bl7) | 0, hi = Math.imul(ah9, bh7), lo = lo + Math.imul(al8, bl8) | 0, mid = mid + Math.imul(al8, bh8) | 0, mid = mid + Math.imul(ah8, bl8) | 0, hi = hi + Math.imul(ah8, bh8) | 0, lo = lo + Math.imul(al7, bl9) | 0, mid = mid + Math.imul(al7, bh9) | 0, mid = mid + Math.imul(ah7, bl9) | 0, hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0, w16 &= 67108863, lo = Math.imul(al9, bl8), mid = Math.imul(al9, bh8), mid = mid + Math.imul(ah9, bl8) | 0, hi = Math.imul(ah9, bh8), lo = lo + Math.imul(al8, bl9) | 0, mid = mid + Math.imul(al8, bh9) | 0, mid = mid + Math.imul(ah8, bl9) | 0, hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0, w17 &= 67108863, lo = Math.imul(al9, bl9), mid = Math.imul(al9, bh9), mid = mid + Math.imul(ah9, bl9) | 0, hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        if (c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0, w18 &= 67108863, o[0] = w0, o[1] = w1, o[2] = w2, o[3] = w3, o[4] = w4, o[5] = w5, o[6] = w6, o[7] = w7, o[8] = w8, o[9] = w9, o[10] = w10, o[11] = w11, o[12] = w12, o[13] = w13, o[14] = w14, o[15] = w15, o[16] = w16, o[17] = w17, o[18] = w18, c !== 0)
          o[19] = c, out.length++;
        return out;
      };
      if (!Math.imul)
        comb10MulTo = smallMulTo;
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative, out.length = self2.length + num.length;
        var carry = 0, hncarry = 0;
        for (var k = 0;k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863, maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
            var i2 = k - j, a = self2.words[i2] | 0, b = num.words[j] | 0, r = a * b, lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0, lo = lo + rword | 0, rword = lo & 67108863, ncarry = ncarry + (lo >>> 26) | 0, hncarry += ncarry >>> 26, ncarry &= 67108863;
          }
          out.words[k] = rword, carry = ncarry, ncarry = hncarry;
        }
        if (carry !== 0)
          out.words[k] = carry;
        else
          out.length--;
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM;
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res, len2 = this.length + num.length;
        if (this.length === 10 && num.length === 10)
          res = comb10MulTo(this, num, out);
        else if (len2 < 63)
          res = smallMulTo(this, num, out);
        else if (len2 < 1024)
          res = bigMulTo(this, num, out);
        else
          res = jumboMulTo(this, num, out);
        return res;
      };
      function FFTM(x, y) {
        this.x = x, this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t2 = new Array(N), l = BN.prototype._countBits(N) - 1;
        for (var i2 = 0;i2 < N; i2++)
          t2[i2] = this.revBin(i2, l, N);
        return t2;
      }, FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i2 = 0;i2 < l; i2++)
          rb |= (x & 1) << l - i2 - 1, x >>= 1;
        return rb;
      }, FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i2 = 0;i2 < N; i2++)
          rtws[i2] = rws[rbt[i2]], itws[i2] = iws[rbt[i2]];
      }, FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1;s < N; s <<= 1) {
          var l = s << 1, rtwdf = Math.cos(2 * Math.PI / l), itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0;p < N; p += l) {
            var rtwdf_ = rtwdf, itwdf_ = itwdf;
            for (var j = 0;j < s; j++) {
              var re = rtws[p + j], ie = itws[p + j], ro = rtws[p + j + s], io = itws[p + j + s], rx = rtwdf_ * ro - itwdf_ * io;
              if (io = rtwdf_ * io + itwdf_ * ro, ro = rx, rtws[p + j] = re + ro, itws[p + j] = ie + io, rtws[p + j + s] = re - ro, itws[p + j + s] = ie - io, j !== l)
                rx = rtwdf * rtwdf_ - itwdf * itwdf_, itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_, rtwdf_ = rx;
            }
          }
        }
      }, FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1, odd = N & 1, i2 = 0;
        for (N = N / 2 | 0;N; N = N >>> 1)
          i2++;
        return 1 << i2 + 1 + odd;
      }, FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i2 = 0;i2 < N / 2; i2++) {
          var t2 = rws[i2];
          rws[i2] = rws[N - i2 - 1], rws[N - i2 - 1] = t2, t2 = iws[i2], iws[i2] = -iws[N - i2 - 1], iws[N - i2 - 1] = -t2;
        }
      }, FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i2 = 0;i2 < N / 2; i2++) {
          var w = Math.round(ws[2 * i2 + 1] / N) * 8192 + Math.round(ws[2 * i2] / N) + carry;
          if (ws[i2] = w & 67108863, w < 67108864)
            carry = 0;
          else
            carry = w / 67108864 | 0;
        }
        return ws;
      }, FFTM.prototype.convert13b = function convert13b(ws, len2, rws, N) {
        var carry = 0;
        for (var i2 = 0;i2 < len2; i2++)
          carry = carry + (ws[i2] | 0), rws[2 * i2] = carry & 8191, carry = carry >>> 13, rws[2 * i2 + 1] = carry & 8191, carry = carry >>> 13;
        for (i2 = 2 * len2;i2 < N; ++i2)
          rws[i2] = 0;
        assert(carry === 0), assert((carry & -8192) === 0);
      }, FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i2 = 0;i2 < N; i2++)
          ph[i2] = 0;
        return ph;
      }, FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length), rbt = this.makeRBT(N), _ = this.stub(N), rws = new Array(N), rwst = new Array(N), iwst = new Array(N), nrws = new Array(N), nrwst = new Array(N), niwst = new Array(N), rmws = out.words;
        rmws.length = N, this.convert13b(x.words, x.length, rws, N), this.convert13b(y.words, y.length, nrws, N), this.transform(rws, _, rwst, iwst, N, rbt), this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i2 = 0;i2 < N; i2++) {
          var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
          iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2], rwst[i2] = rx;
        }
        return this.conjugate(rwst, iwst, N), this.transform(rwst, iwst, rmws, _, N, rbt), this.conjugate(rmws, _, N), this.normalize13b(rmws, N), out.negative = x.negative ^ y.negative, out.length = x.length + y.length, out.strip();
      }, BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        return out.words = new Array(this.length + num.length), this.mulTo(num, out);
      }, BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        return out.words = new Array(this.length + num.length), jumboMulTo(this, num, out);
      }, BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      }, BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number"), assert(num < 67108864);
        var carry = 0;
        for (var i2 = 0;i2 < this.length; i2++) {
          var w = (this.words[i2] | 0) * num, lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26, carry += w / 67108864 | 0, carry += lo >>> 26, this.words[i2] = lo & 67108863;
        }
        if (carry !== 0)
          this.words[i2] = carry, this.length++;
        return this.length = num === 0 ? 1 : this.length, this;
      }, BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      }, BN.prototype.sqr = function sqr() {
        return this.mul(this);
      }, BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      }, BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i2 = 0;i2 < w.length; i2++, res = res.sqr())
          if (w[i2] !== 0)
            break;
        if (++i2 < w.length)
          for (var q = res.sqr();i2 < w.length; i2++, q = q.sqr()) {
            if (w[i2] === 0)
              continue;
            res = res.mul(q);
          }
        return res;
      }, BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26, s = (bits - r) / 26, carryMask = 67108863 >>> 26 - r << 26 - r, i2;
        if (r !== 0) {
          var carry = 0;
          for (i2 = 0;i2 < this.length; i2++) {
            var newCarry = this.words[i2] & carryMask, c = (this.words[i2] | 0) - newCarry << r;
            this.words[i2] = c | carry, carry = newCarry >>> 26 - r;
          }
          if (carry)
            this.words[i2] = carry, this.length++;
        }
        if (s !== 0) {
          for (i2 = this.length - 1;i2 >= 0; i2--)
            this.words[i2 + s] = this.words[i2];
          for (i2 = 0;i2 < s; i2++)
            this.words[i2] = 0;
          this.length += s;
        }
        return this.strip();
      }, BN.prototype.ishln = function ishln(bits) {
        return assert(this.negative === 0), this.iushln(bits);
      }, BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint)
          h = (hint - hint % 26) / 26;
        else
          h = 0;
        var r = bits % 26, s = Math.min((bits - r) / 26, this.length), mask = 67108863 ^ 67108863 >>> r << r, maskedWords = extended;
        if (h -= s, h = Math.max(0, h), maskedWords) {
          for (var i2 = 0;i2 < s; i2++)
            maskedWords.words[i2] = this.words[i2];
          maskedWords.length = s;
        }
        if (s === 0)
          ;
        else if (this.length > s) {
          this.length -= s;
          for (i2 = 0;i2 < this.length; i2++)
            this.words[i2] = this.words[i2 + s];
        } else
          this.words[0] = 0, this.length = 1;
        var carry = 0;
        for (i2 = this.length - 1;i2 >= 0 && (carry !== 0 || i2 >= h); i2--) {
          var word = this.words[i2] | 0;
          this.words[i2] = carry << 26 - r | word >>> r, carry = word & mask;
        }
        if (maskedWords && carry !== 0)
          maskedWords.words[maskedWords.length++] = carry;
        if (this.length === 0)
          this.words[0] = 0, this.length = 1;
        return this.strip();
      }, BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        return assert(this.negative === 0), this.iushrn(bits, hint, extended);
      }, BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      }, BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      }, BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      }, BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      }, BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26, s = (bit - r) / 26, q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      }, BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26, s = (bits - r) / 26;
        if (assert(this.negative === 0, "imaskn works only with positive numbers"), this.length <= s)
          return this;
        if (r !== 0)
          s++;
        if (this.length = Math.min(s, this.length), r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      }, BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      }, BN.prototype.iaddn = function iaddn(num) {
        if (assert(typeof num === "number"), assert(num < 67108864), num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num)
            return this.words[0] = num - (this.words[0] | 0), this.negative = 0, this;
          return this.negative = 0, this.isubn(num), this.negative = 1, this;
        }
        return this._iaddn(num);
      }, BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i2 = 0;i2 < this.length && this.words[i2] >= 67108864; i2++)
          if (this.words[i2] -= 67108864, i2 === this.length - 1)
            this.words[i2 + 1] = 1;
          else
            this.words[i2 + 1]++;
        return this.length = Math.max(this.length, i2 + 1), this;
      }, BN.prototype.isubn = function isubn(num) {
        if (assert(typeof num === "number"), assert(num < 67108864), num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(num), this.negative = 1, this;
        if (this.words[0] -= num, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var i2 = 0;i2 < this.length && this.words[i2] < 0; i2++)
            this.words[i2] += 67108864, this.words[i2 + 1] -= 1;
        return this.strip();
      }, BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      }, BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      }, BN.prototype.iabs = function iabs() {
        return this.negative = 0, this;
      }, BN.prototype.abs = function abs() {
        return this.clone().iabs();
      }, BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len2 = num.length + shift, i2;
        this._expand(len2);
        var w, carry = 0;
        for (i2 = 0;i2 < num.length; i2++) {
          w = (this.words[i2 + shift] | 0) + carry;
          var right = (num.words[i2] | 0) * mul;
          w -= right & 67108863, carry = (w >> 26) - (right / 67108864 | 0), this.words[i2 + shift] = w & 67108863;
        }
        for (;i2 < this.length - shift; i2++)
          w = (this.words[i2 + shift] | 0) + carry, carry = w >> 26, this.words[i2 + shift] = w & 67108863;
        if (carry === 0)
          return this.strip();
        assert(carry === -1), carry = 0;
        for (i2 = 0;i2 < this.length; i2++)
          w = -(this.words[i2] | 0) + carry, carry = w >> 26, this.words[i2] = w & 67108863;
        return this.negative = 1, this.strip();
      }, BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length, a = this.clone(), b = num, bhi = b.words[b.length - 1] | 0, bhiBits = this._countBits(bhi);
        if (shift = 26 - bhiBits, shift !== 0)
          b = b.ushln(shift), a.iushln(shift), bhi = b.words[b.length - 1] | 0;
        var m = a.length - b.length, q;
        if (mode !== "mod") {
          q = new BN(null), q.length = m + 1, q.words = new Array(q.length);
          for (var i2 = 0;i2 < q.length; i2++)
            q.words[i2] = 0;
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          if (a = diff, q)
            q.words[m] = 1;
        }
        for (var j = m - 1;j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863), a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0)
            if (qj--, a.negative = 0, a._ishlnsubmul(b, 1, j), !a.isZero())
              a.negative ^= 1;
          if (q)
            q.words[j] = qj;
        }
        if (q)
          q.strip();
        if (a.strip(), mode !== "div" && shift !== 0)
          a.iushrn(shift);
        return { div: q || null, mod: a };
      }, BN.prototype.divmod = function divmod(num, mode, positive) {
        if (assert(!num.isZero()), this.isZero())
          return { div: new BN(0), mod: new BN(0) };
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          if (res = this.neg().divmod(num, mode), mode !== "mod")
            div = res.div.neg();
          if (mode !== "div") {
            if (mod = res.mod.neg(), positive && mod.negative !== 0)
              mod.iadd(num);
          }
          return { div, mod };
        }
        if (this.negative === 0 && num.negative !== 0) {
          if (res = this.divmod(num.neg(), mode), mode !== "mod")
            div = res.div.neg();
          return { div, mod: res.mod };
        }
        if ((this.negative & num.negative) !== 0) {
          if (res = this.neg().divmod(num.neg(), mode), mode !== "div") {
            if (mod = res.mod.neg(), positive && mod.negative !== 0)
              mod.isub(num);
          }
          return { div: res.div, mod };
        }
        if (num.length > this.length || this.cmp(num) < 0)
          return { div: new BN(0), mod: this };
        if (num.length === 1) {
          if (mode === "div")
            return { div: this.divn(num.words[0]), mod: null };
          if (mode === "mod")
            return { div: null, mod: new BN(this.modn(num.words[0])) };
          return { div: this.divn(num.words[0]), mod: new BN(this.modn(num.words[0])) };
        }
        return this._wordDiv(num, mode);
      }, BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      }, BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      }, BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      }, BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod, half = num.ushrn(1), r2 = num.andln(1), cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      }, BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = 67108864 % num, acc = 0;
        for (var i2 = this.length - 1;i2 >= 0; i2--)
          acc = (p * acc + (this.words[i2] | 0)) % num;
        return acc;
      }, BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i2 = this.length - 1;i2 >= 0; i2--) {
          var w = (this.words[i2] | 0) + carry * 67108864;
          this.words[i2] = w / num | 0, carry = w % num;
        }
        return this.strip();
      }, BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      }, BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0), assert(!p.isZero());
        var x = this, y = p.clone();
        if (x.negative !== 0)
          x = x.umod(p);
        else
          x = x.clone();
        var A = new BN(1), B = new BN(0), C = new BN(0), D = new BN(1), g = 0;
        while (x.isEven() && y.isEven())
          x.iushrn(1), y.iushrn(1), ++g;
        var yp = y.clone(), xp = x.clone();
        while (!x.isZero()) {
          for (var i2 = 0, im = 1;(x.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            x.iushrn(i2);
            while (i2-- > 0) {
              if (A.isOdd() || B.isOdd())
                A.iadd(yp), B.isub(xp);
              A.iushrn(1), B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1;(y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd())
                C.iadd(yp), D.isub(xp);
              C.iushrn(1), D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0)
            x.isub(y), A.isub(C), B.isub(D);
          else
            y.isub(x), C.isub(A), D.isub(B);
        }
        return { a: C, b: D, gcd: y.iushln(g) };
      }, BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0), assert(!p.isZero());
        var a = this, b = p.clone();
        if (a.negative !== 0)
          a = a.umod(p);
        else
          a = a.clone();
        var x1 = new BN(1), x2 = new BN(0), delta3 = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i2 = 0, im = 1;(a.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            a.iushrn(i2);
            while (i2-- > 0) {
              if (x1.isOdd())
                x1.iadd(delta3);
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1;(b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd())
                x2.iadd(delta3);
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0)
            a.isub(b), x1.isub(x2);
          else
            b.isub(a), x2.isub(x1);
        }
        var res;
        if (a.cmpn(1) === 0)
          res = x1;
        else
          res = x2;
        if (res.cmpn(0) < 0)
          res.iadd(p);
        return res;
      }, BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone(), b = num.clone();
        a.negative = 0, b.negative = 0;
        for (var shift = 0;a.isEven() && b.isEven(); shift++)
          a.iushrn(1), b.iushrn(1);
        do {
          while (a.isEven())
            a.iushrn(1);
          while (b.isEven())
            b.iushrn(1);
          var r = a.cmp(b);
          if (r < 0) {
            var t2 = a;
            a = b, b = t2;
          } else if (r === 0 || b.cmpn(1) === 0)
            break;
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      }, BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      }, BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      }, BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      }, BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      }, BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26, s = (bit - r) / 26, q = 1 << r;
        if (this.length <= s)
          return this._expand(s + 1), this.words[s] |= q, this;
        var carry = q;
        for (var i2 = s;carry !== 0 && i2 < this.length; i2++) {
          var w = this.words[i2] | 0;
          w += carry, carry = w >>> 26, w &= 67108863, this.words[i2] = w;
        }
        if (carry !== 0)
          this.words[i2] = carry, this.length++;
        return this;
      }, BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      }, BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1)
          res = 1;
        else {
          if (negative)
            num = -num;
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      }, BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      }, BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i2 = this.length - 1;i2 >= 0; i2--) {
          var a = this.words[i2] | 0, b = num.words[i2] | 0;
          if (a === b)
            continue;
          if (a < b)
            res = -1;
          else if (a > b)
            res = 1;
          break;
        }
        return res;
      }, BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      }, BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      }, BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      }, BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      }, BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      }, BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      }, BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      }, BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      }, BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      }, BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      }, BN.red = function red(num) {
        return new Red(num);
      }, BN.prototype.toRed = function toRed(ctx) {
        return assert(!this.red, "Already a number in reduction context"), assert(this.negative === 0, "red works only with positives"), ctx.convertTo(this)._forceRed(ctx);
      }, BN.prototype.fromRed = function fromRed() {
        return assert(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, BN.prototype._forceRed = function _forceRed(ctx) {
        return this.red = ctx, this;
      }, BN.prototype.forceRed = function forceRed(ctx) {
        return assert(!this.red, "Already a number in reduction context"), this._forceRed(ctx);
      }, BN.prototype.redAdd = function redAdd(num) {
        return assert(this.red, "redAdd works only with red numbers"), this.red.add(this, num);
      }, BN.prototype.redIAdd = function redIAdd(num) {
        return assert(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, num);
      }, BN.prototype.redSub = function redSub(num) {
        return assert(this.red, "redSub works only with red numbers"), this.red.sub(this, num);
      }, BN.prototype.redISub = function redISub(num) {
        return assert(this.red, "redISub works only with red numbers"), this.red.isub(this, num);
      }, BN.prototype.redShl = function redShl(num) {
        return assert(this.red, "redShl works only with red numbers"), this.red.shl(this, num);
      }, BN.prototype.redMul = function redMul(num) {
        return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.mul(this, num);
      }, BN.prototype.redIMul = function redIMul(num) {
        return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.imul(this, num);
      }, BN.prototype.redSqr = function redSqr() {
        return assert(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, BN.prototype.redISqr = function redISqr() {
        return assert(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, BN.prototype.redSqrt = function redSqrt() {
        return assert(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, BN.prototype.redInvm = function redInvm() {
        return assert(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, BN.prototype.redNeg = function redNeg() {
        return assert(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, BN.prototype.redPow = function redPow(num) {
        return assert(this.red && !num.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, num);
      };
      var primes = { k256: null, p224: null, p192: null, p25519: null };
      function MPrime(name, p) {
        this.name = name, this.p = new BN(p, 16), this.n = this.p.bitLength(), this.k = new BN(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        return tmp.words = new Array(Math.ceil(this.n / 13)), tmp;
      }, MPrime.prototype.ireduce = function ireduce(num) {
        var r = num, rlen;
        do
          this.split(r, this.tmp), r = this.imulK(r), r = r.iadd(this.tmp), rlen = r.bitLength();
        while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0)
          r.words[0] = 0, r.length = 1;
        else if (cmp > 0)
          r.isub(this.p);
        else if (r.strip !== undefined)
          r.strip();
        else
          r._strip();
        return r;
      }, MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      }, MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      inherits2(K256, MPrime), K256.prototype.split = function split(input, output) {
        var mask = 4194303, outLen = Math.min(input.length, 9);
        for (var i2 = 0;i2 < outLen; i2++)
          output.words[i2] = input.words[i2];
        if (output.length = outLen, input.length <= 9) {
          input.words[0] = 0, input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i2 = 10;i2 < input.length; i2++) {
          var next = input.words[i2] | 0;
          input.words[i2 - 10] = (next & mask) << 4 | prev >>> 22, prev = next;
        }
        if (prev >>>= 22, input.words[i2 - 10] = prev, prev === 0 && input.length > 10)
          input.length -= 10;
        else
          input.length -= 9;
      }, K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0, num.words[num.length + 1] = 0, num.length += 2;
        var lo = 0;
        for (var i2 = 0;i2 < num.length; i2++) {
          var w = num.words[i2] | 0;
          lo += w * 977, num.words[i2] = lo & 67108863, lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          if (num.length--, num.words[num.length - 1] === 0)
            num.length--;
        }
        return num;
      };
      function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      inherits2(P25519, MPrime), P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i2 = 0;i2 < num.length; i2++) {
          var hi = (num.words[i2] | 0) * 19 + carry, lo = hi & 67108863;
          hi >>>= 26, num.words[i2] = lo, carry = hi;
        }
        if (carry !== 0)
          num.words[num.length++] = carry;
        return num;
      }, BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime;
        if (name === "k256")
          prime = new K256;
        else if (name === "p224")
          prime = new P224;
        else if (name === "p192")
          prime = new P192;
        else if (name === "p25519")
          prime = new P25519;
        else
          throw new Error("Unknown prime " + name);
        return primes[name] = prime, prime;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p, this.prime = prime;
        } else
          assert(m.gtn(1), "modulus must be greater than 1"), this.m = m, this.prime = null;
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives"), assert(a.red, "red works only with red numbers");
      }, Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives"), assert(a.red && a.red === b.red, "red works only with red numbers");
      }, Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      }, Red.prototype.neg = function neg(a) {
        if (a.isZero())
          return a.clone();
        return this.m.sub(a)._forceRed(this);
      }, Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0)
          res.isub(this.m);
        return res._forceRed(this);
      }, Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0)
          res.isub(this.m);
        return res;
      }, Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0)
          res.iadd(this.m);
        return res._forceRed(this);
      }, Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0)
          res.iadd(this.m);
        return res;
      }, Red.prototype.shl = function shl(a, num) {
        return this._verify1(a), this.imod(a.ushln(num));
      }, Red.prototype.imul = function imul(a, b) {
        return this._verify2(a, b), this.imod(a.imul(b));
      }, Red.prototype.mul = function mul(a, b) {
        return this._verify2(a, b), this.imod(a.mul(b));
      }, Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      }, Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      }, Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        if (assert(mod3 % 2 === 1), mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1), s = 0;
        while (!q.isZero() && q.andln(1) === 0)
          s++, q.iushrn(1);
        assert(!q.isZero());
        var one = new BN(1).toRed(this), nOne = one.redNeg(), lpow = this.m.subn(1).iushrn(1), z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0)
          z.redIAdd(nOne);
        var c = this.pow(z, q), r = this.pow(a, q.addn(1).iushrn(1)), t2 = this.pow(a, q), m = s;
        while (t2.cmp(one) !== 0) {
          var tmp = t2;
          for (var i2 = 0;tmp.cmp(one) !== 0; i2++)
            tmp = tmp.redSqr();
          assert(i2 < m);
          var b = this.pow(c, new BN(1).iushln(m - i2 - 1));
          r = r.redMul(b), c = b.redSqr(), t2 = t2.redMul(c), m = i2;
        }
        return r;
      }, Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0)
          return inv.negative = 0, this.imod(inv).redNeg();
        else
          return this.imod(inv);
      }, Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4, wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this), wnd[1] = a;
        for (var i2 = 2;i2 < wnd.length; i2++)
          wnd[i2] = this.mul(wnd[i2 - 1], a);
        var res = wnd[0], current = 0, currentLen = 0, start = num.bitLength() % 26;
        if (start === 0)
          start = 26;
        for (i2 = num.length - 1;i2 >= 0; i2--) {
          var word = num.words[i2];
          for (var j = start - 1;j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0])
              res = this.sqr(res);
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            if (current <<= 1, current |= bit, currentLen++, currentLen !== windowSize && (i2 !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]), currentLen = 0, current = 0;
          }
          start = 26;
        }
        return res;
      }, Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      }, Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        return res.red = null, res;
      }, BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        if (Red.call(this, m), this.shift = this.m.bitLength(), this.shift % 26 !== 0)
          this.shift += 26 - this.shift % 26;
        this.r = new BN(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red), Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      }, Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        return r.red = null, r;
      }, Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero())
          return a.words[0] = 0, a.length = 1, a;
        var t2 = a.imul(b), c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t2.isub(c).iushrn(this.shift), res = u;
        if (u.cmp(this.m) >= 0)
          res = u.isub(this.m);
        else if (u.cmpn(0) < 0)
          res = u.iadd(this.m);
        return res._forceRed(this);
      }, Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t2 = a.mul(b), c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t2.isub(c).iushrn(this.shift), res = u;
        if (u.cmp(this.m) >= 0)
          res = u.isub(this.m);
        else if (u.cmpn(0) < 0)
          res = u.iadd(this.m);
        return res._forceRed(this);
      }, Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  });
  require_minimalistic_assert = __commonJS2((exports, module) => {
    module.exports = assert;
    function assert(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert.equal = function assertEqual(l, r, msg) {
      if (l != r)
        throw new Error(msg || "Assertion failed: " + l + " != " + r);
    };
  });
  require_utils = __commonJS2((exports) => {
    var utils = exports;
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg !== "string") {
        for (var i2 = 0;i2 < msg.length; i2++)
          res[i2] = msg[i2] | 0;
        return res;
      }
      if (enc === "hex") {
        if (msg = msg.replace(/[^a-z0-9]+/ig, ""), msg.length % 2 !== 0)
          msg = "0" + msg;
        for (var i2 = 0;i2 < msg.length; i2 += 2)
          res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
      } else
        for (var i2 = 0;i2 < msg.length; i2++) {
          var c = msg.charCodeAt(i2), hi = c >> 8, lo = c & 255;
          if (hi)
            res.push(hi, lo);
          else
            res.push(lo);
        }
      return res;
    }
    utils.toArray = toArray;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    utils.zero2 = zero2;
    function toHex(msg) {
      var res = "";
      for (var i2 = 0;i2 < msg.length; i2++)
        res += zero2(msg[i2].toString(16));
      return res;
    }
    utils.toHex = toHex;
    utils.encode = function encode(arr, enc) {
      if (enc === "hex")
        return toHex(arr);
      else
        return arr;
    };
  });
  require_utils2 = __commonJS2((exports) => {
    var utils = exports, BN = require_bn(), minAssert = require_minimalistic_assert(), minUtils = require_utils();
    utils.assert = minAssert;
    utils.toArray = minUtils.toArray;
    utils.zero2 = minUtils.zero2;
    utils.toHex = minUtils.toHex;
    utils.encode = minUtils.encode;
    function getNAF(num, w, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1), i2;
      for (i2 = 0;i2 < naf.length; i2 += 1)
        naf[i2] = 0;
      var ws = 1 << w + 1, k = num.clone();
      for (i2 = 0;i2 < naf.length; i2++) {
        var z, mod = k.andln(ws - 1);
        if (k.isOdd()) {
          if (mod > (ws >> 1) - 1)
            z = (ws >> 1) - mod;
          else
            z = mod;
          k.isubn(z);
        } else
          z = 0;
        naf[i2] = z, k.iushrn(1);
      }
      return naf;
    }
    utils.getNAF = getNAF;
    function getJSF(k1, k2) {
      var jsf = [[], []];
      k1 = k1.clone(), k2 = k2.clone();
      var d1 = 0, d2 = 0, m8;
      while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
        var m14 = k1.andln(3) + d1 & 3, m24 = k2.andln(3) + d2 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0)
          u1 = 0;
        else if (m8 = k1.andln(7) + d1 & 7, (m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
        jsf[0].push(u1);
        var u2;
        if ((m24 & 1) === 0)
          u2 = 0;
        else if (m8 = k2.andln(7) + d2 & 7, (m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
        if (jsf[1].push(u2), 2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d2 === u2 + 1)
          d2 = 1 - d2;
        k1.iushrn(1), k2.iushrn(1);
      }
      return jsf;
    }
    utils.getJSF = getJSF;
    function cachedProperty(obj, name, computer) {
      var key = "_" + name;
      obj.prototype[name] = function cachedProperty() {
        return this[key] !== undefined ? this[key] : this[key] = computer.call(this);
      };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
      return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes) {
      return new BN(bytes, "hex", "le");
    }
    utils.intFromLE = intFromLE;
  });
  require_brorand = __commonJS2((exports, module) => {
    var r;
    module.exports = function rand(len2) {
      if (!r)
        r = new Rand(null);
      return r.generate(len2);
    };
    function Rand(rand) {
      this.rand = rand;
    }
    module.exports.Rand = Rand;
    Rand.prototype.generate = function generate(len2) {
      return this._rand(len2);
    };
    Rand.prototype._rand = function _rand(n) {
      if (this.rand.getBytes)
        return this.rand.getBytes(n);
      var res = new Uint8Array(n);
      for (var i2 = 0;i2 < res.length; i2++)
        res[i2] = this.rand.getByte();
      return res;
    };
    if (typeof self === "object") {
      if (self.crypto && self.crypto.getRandomValues)
        Rand.prototype._rand = function _rand(n) {
          var arr = new Uint8Array(n);
          return self.crypto.getRandomValues(arr), arr;
        };
      else if (self.msCrypto && self.msCrypto.getRandomValues)
        Rand.prototype._rand = function _rand(n) {
          var arr = new Uint8Array(n);
          return self.msCrypto.getRandomValues(arr), arr;
        };
      else if (typeof window === "object")
        Rand.prototype._rand = function() {
          throw new Error("Not implemented yet");
        };
    } else
      try {
        if (crypto2 = (init_crypto(), __toCommonJS(exports_crypto)), typeof crypto2.randomBytes !== "function")
          throw new Error("Not supported");
        Rand.prototype._rand = function _rand(n) {
          return crypto2.randomBytes(n);
        };
      } catch (e) {}
    var crypto2;
  });
  require_base = __commonJS2((exports, module) => {
    var BN = require_bn(), utils = require_utils2(), getNAF = utils.getNAF, getJSF = utils.getJSF, assert = utils.assert;
    function BaseCurve(type3, conf) {
      this.type = type3, this.p = new BN(conf.p, 16), this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p), this.zero = new BN(0).toRed(this.red), this.one = new BN(1).toRed(this.red), this.two = new BN(2).toRed(this.red), this.n = conf.n && new BN(conf.n, 16), this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0)
        this.redN = null;
      else
        this._maxwellTrick = true, this.redN = this.n.toRed(this.red);
    }
    module.exports = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
      assert(p.precomputed);
      var doubles = p._getDoubles(), naf = getNAF(k, 1, this._bitLength), I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I /= 3;
      var repr = [], j, nafW;
      for (j = 0;j < naf.length; j += doubles.step) {
        nafW = 0;
        for (var l = j + doubles.step - 1;l >= j; l--)
          nafW = (nafW << 1) + naf[l];
        repr.push(nafW);
      }
      var a = this.jpoint(null, null, null), b = this.jpoint(null, null, null);
      for (var i2 = I;i2 > 0; i2--) {
        for (j = 0;j < repr.length; j++)
          if (nafW = repr[j], nafW === i2)
            b = b.mixedAdd(doubles.points[j]);
          else if (nafW === -i2)
            b = b.mixedAdd(doubles.points[j].neg());
        a = a.add(b);
      }
      return a.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
      var w = 4, nafPoints = p._getNAFPoints(w);
      w = nafPoints.wnd;
      var wnd = nafPoints.points, naf = getNAF(k, w, this._bitLength), acc = this.jpoint(null, null, null);
      for (var i2 = naf.length - 1;i2 >= 0; i2--) {
        for (var l = 0;i2 >= 0 && naf[i2] === 0; i2--)
          l++;
        if (i2 >= 0)
          l++;
        if (acc = acc.dblp(l), i2 < 0)
          break;
        var z = naf[i2];
        if (assert(z !== 0), p.type === "affine")
          if (z > 0)
            acc = acc.mixedAdd(wnd[z - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
        else if (z > 0)
          acc = acc.add(wnd[z - 1 >> 1]);
        else
          acc = acc.add(wnd[-z - 1 >> 1].neg());
      }
      return p.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len2, jacobianResult) {
      var wndWidth = this._wnafT1, wnd = this._wnafT2, naf = this._wnafT3, max = 0, i2, j, p;
      for (i2 = 0;i2 < len2; i2++) {
        p = points[i2];
        var nafPoints = p._getNAFPoints(defW);
        wndWidth[i2] = nafPoints.wnd, wnd[i2] = nafPoints.points;
      }
      for (i2 = len2 - 1;i2 >= 1; i2 -= 2) {
        var a = i2 - 1, b = i2;
        if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
          naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength), naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength), max = Math.max(naf[a].length, max), max = Math.max(naf[b].length, max);
          continue;
        }
        var comb = [points[a], null, null, points[b]];
        if (points[a].y.cmp(points[b].y) === 0)
          comb[1] = points[a].add(points[b]), comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        else if (points[a].y.cmp(points[b].y.redNeg()) === 0)
          comb[1] = points[a].toJ().mixedAdd(points[b]), comb[2] = points[a].add(points[b].neg());
        else
          comb[1] = points[a].toJ().mixedAdd(points[b]), comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        var index = [-3, -1, -5, -7, 0, 7, 5, 1, 3], jsf = getJSF(coeffs[a], coeffs[b]);
        max = Math.max(jsf[0].length, max), naf[a] = new Array(max), naf[b] = new Array(max);
        for (j = 0;j < max; j++) {
          var ja = jsf[0][j] | 0, jb = jsf[1][j] | 0;
          naf[a][j] = index[(ja + 1) * 3 + (jb + 1)], naf[b][j] = 0, wnd[a] = comb;
        }
      }
      var acc = this.jpoint(null, null, null), tmp = this._wnafT4;
      for (i2 = max;i2 >= 0; i2--) {
        var k = 0;
        while (i2 >= 0) {
          var zero = true;
          for (j = 0;j < len2; j++)
            if (tmp[j] = naf[j][i2] | 0, tmp[j] !== 0)
              zero = false;
          if (!zero)
            break;
          k++, i2--;
        }
        if (i2 >= 0)
          k++;
        if (acc = acc.dblp(k), i2 < 0)
          break;
        for (j = 0;j < len2; j++) {
          var z = tmp[j];
          if (z === 0)
            continue;
          else if (z > 0)
            p = wnd[j][z - 1 >> 1];
          else if (z < 0)
            p = wnd[j][-z - 1 >> 1].neg();
          if (p.type === "affine")
            acc = acc.mixedAdd(p);
          else
            acc = acc.add(p);
        }
      }
      for (i2 = 0;i2 < len2; i2++)
        wnd[i2] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    function BasePoint(curve, type3) {
      this.curve = curve, this.type = type3, this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      bytes = utils.toArray(bytes, enc);
      var len2 = this.p.byteLength();
      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len2) {
        if (bytes[0] === 6)
          assert(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 7)
          assert(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(bytes.slice(1, 1 + len2), bytes.slice(1 + len2, 1 + 2 * len2));
        return res;
      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len2)
        return this.pointFromX(bytes.slice(1, 1 + len2), bytes[0] === 3);
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode(compact) {
      var len2 = this.curve.p.byteLength(), x = this.getX().toArray("be", len2);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x);
      return [4].concat(x, this.getY().toArray("be", len2));
    };
    BasePoint.prototype.encode = function encode(enc, compact) {
      return utils.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = { doubles: null, naf: null, beta: null };
      return precomputed.naf = this._getNAFPoints(8), precomputed.doubles = this._getDoubles(4, power), precomputed.beta = this._getBeta(), this.precomputed = precomputed, this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this], acc = this;
      for (var i2 = 0;i2 < power; i2 += step) {
        for (var j = 0;j < step; j++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return { step, points: doubles };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this], max = (1 << wnd) - 1, dbl = max === 1 ? null : this.dbl();
      for (var i2 = 1;i2 < max; i2++)
        res[i2] = res[i2 - 1].add(dbl);
      return { wnd, points: res };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k) {
      var r = this;
      for (var i2 = 0;i2 < k; i2++)
        r = r.dbl();
      return r;
    };
  });
  require_inherits_browser = __commonJS2((exports, module) => {
    if (typeof Object.create === "function")
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor)
          ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, { constructor: { value: ctor, enumerable: false, writable: true, configurable: true } });
      };
    else
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {};
          TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor, ctor.prototype.constructor = ctor;
        }
      };
  });
  require_inherits = __commonJS2((exports, module) => {
    try {
      if (util = (init_util(), __toCommonJS(exports_util)), typeof util.inherits !== "function")
        throw "";
      module.exports = util.inherits;
    } catch (e) {
      module.exports = require_inherits_browser();
    }
    var util;
  });
  require_short = __commonJS2((exports, module) => {
    var utils = require_utils2(), BN = require_bn(), inherits2 = require_inherits(), Base = require_base(), assert = utils.assert;
    function ShortCurve(conf) {
      Base.call(this, "short", conf), this.a = new BN(conf.a, 16).toRed(this.red), this.b = new BN(conf.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(conf), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
    }
    inherits2(ShortCurve, Base);
    module.exports = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta, lambda;
      if (conf.beta)
        beta = new BN(conf.beta, 16).toRed(this.red);
      else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1], beta = beta.toRed(this.red);
      }
      if (conf.lambda)
        lambda = new BN(conf.lambda, 16);
      else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0)
          lambda = lambdas[0];
        else
          lambda = lambdas[1], assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
      }
      var basis;
      if (conf.basis)
        basis = conf.basis.map(function(vec) {
          return { a: new BN(vec.a, 16), b: new BN(vec.b, 16) };
        });
      else
        basis = this._getEndoBasis(lambda);
      return { beta, lambda, basis };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : BN.mont(num), tinv = new BN(2).toRed(red).redInvm(), ntinv = tinv.redNeg(), s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv), l1 = ntinv.redAdd(s).fromRed(), l2 = ntinv.redSub(s).fromRed();
      return [l1, l2];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), u = lambda, v = this.n.clone(), x1 = new BN(1), y1 = new BN(0), x2 = new BN(0), y2 = new BN(1), a0, b0, a1, b1, a2, b2, prevR, i2 = 0, r, x;
      while (u.cmpn(0) !== 0) {
        var q = v.div(u);
        r = v.sub(q.mul(u)), x = x2.sub(q.mul(x1));
        var y = y2.sub(q.mul(y1));
        if (!a1 && r.cmp(aprxSqrt) < 0)
          a0 = prevR.neg(), b0 = x1, a1 = r.neg(), b1 = x;
        else if (a1 && ++i2 === 2)
          break;
        prevR = r, v = u, u = r, x2 = x1, x1 = x, y2 = y1, y1 = y;
      }
      a2 = r.neg(), b2 = x;
      var len1 = a1.sqr().add(b1.sqr()), len2 = a2.sqr().add(b2.sqr());
      if (len2.cmp(len1) >= 0)
        a2 = a0, b2 = b0;
      if (a1.negative)
        a1 = a1.neg(), b1 = b1.neg();
      if (a2.negative)
        a2 = a2.neg(), b2 = b2.neg();
      return [{ a: a1, b: b1 }, { a: a2, b: b2 }];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k) {
      var basis = this.endo.basis, v1 = basis[0], v2 = basis[1], c1 = v2.b.mul(k).divRound(this.n), c2 = v1.b.neg().mul(k).divRound(this.n), p1 = c1.mul(v1.a), p2 = c2.mul(v2.a), q1 = c1.mul(v1.b), q2 = c2.mul(v2.b), k1 = k.sub(p1).sub(p2), k2 = q1.add(q2).neg();
      return { k1, k2 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
      if (x = new BN(x, 16), !x.red)
        x = x.toRed(this.red);
      var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b), y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x, y);
    };
    ShortCurve.prototype.validate = function validate(point) {
      if (point.inf)
        return true;
      var { x, y } = point, ax = this.a.redMul(x), rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
      return y.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1, ncoeffs = this._endoWnafT2;
      for (var i2 = 0;i2 < points.length; i2++) {
        var split = this._endoSplit(coeffs[i2]), p = points[i2], beta = p._getBeta();
        if (split.k1.negative)
          split.k1.ineg(), p = p.neg(true);
        if (split.k2.negative)
          split.k2.ineg(), beta = beta.neg(true);
        npoints[i2 * 2] = p, npoints[i2 * 2 + 1] = beta, ncoeffs[i2 * 2] = split.k1, ncoeffs[i2 * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i2 * 2, jacobianResult);
      for (var j = 0;j < i2 * 2; j++)
        npoints[j] = null, ncoeffs[j] = null;
      return res;
    };
    function Point(curve, x, y, isRed) {
      if (Base.BasePoint.call(this, curve, "affine"), x === null && y === null)
        this.x = null, this.y = null, this.inf = true;
      else {
        if (this.x = new BN(x, 16), this.y = new BN(y, 16), isRed)
          this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    inherits2(Point, Base.BasePoint);
    ShortCurve.prototype.point = function point(x, y, isRed) {
      return new Point(this, x, y, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point.fromJSON(this, obj, red);
    };
    Point.prototype._getBeta = function _getBeta() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve, endoMul = function(p) {
          return curve.point(p.x.redMul(curve.endo.beta), p.y);
        };
        pre.beta = beta, beta.precomputed = { beta: null, naf: pre.naf && { wnd: pre.naf.wnd, points: pre.naf.points.map(endoMul) }, doubles: pre.doubles && { step: pre.doubles.step, points: pre.doubles.points.map(endoMul) } };
      }
      return beta;
    };
    Point.prototype.toJSON = function toJSON() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }];
    };
    Point.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      return res.precomputed = { beta: null, doubles: pre.doubles && { step: pre.doubles.step, points: [res].concat(pre.doubles.points.map(obj2point)) }, naf: pre.naf && { wnd: pre.naf.wnd, points: [res].concat(pre.naf.points.map(obj2point)) } }, res;
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point.prototype.add = function add(p) {
      if (this.inf)
        return p;
      if (p.inf)
        return this;
      if (this.eq(p))
        return this.dbl();
      if (this.neg().eq(p))
        return this.curve.point(null, null);
      if (this.x.cmp(p.x) === 0)
        return this.curve.point(null, null);
      var c = this.y.redSub(p.y);
      if (c.cmpn(0) !== 0)
        c = c.redMul(this.x.redSub(p.x).redInvm());
      var nx = c.redSqr().redISub(this.x).redISub(p.x), ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a = this.curve.a, x2 = this.x.redSqr(), dyinv = ys1.redInvm(), c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv), nx = c.redSqr().redISub(this.x.redAdd(this.x)), ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point.prototype.mul = function mul(k) {
      if (k = new BN(k, 16), this.isInfinity())
        return this;
      else if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k]);
      else
        return this.curve._wnafMul(this, k);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
      var points = [this, p2], coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
      var points = [this, p2], coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point.prototype.eq = function eq(p) {
      return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
    };
    Point.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed, negate = function(p) {
          return p.neg();
        };
        res.precomputed = { naf: pre.naf && { wnd: pre.naf.wnd, points: pre.naf.points.map(negate) }, doubles: pre.doubles && { step: pre.doubles.step, points: pre.doubles.points.map(negate) } };
      }
      return res;
    };
    Point.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    function JPoint(curve, x, y, z) {
      if (Base.BasePoint.call(this, curve, "jacobian"), x === null && y === null && z === null)
        this.x = this.curve.one, this.y = this.curve.one, this.z = new BN(0);
      else
        this.x = new BN(x, 16), this.y = new BN(y, 16), this.z = new BN(z, 16);
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    inherits2(JPoint, Base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
      return new JPoint(this, x, y, z);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm(), zinv2 = zinv.redSqr(), ax = this.x.redMul(zinv2), ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      var pz2 = p.z.redSqr(), z2 = this.z.redSqr(), u1 = this.x.redMul(pz2), u2 = p.x.redMul(z2), s1 = this.y.redMul(pz2.redMul(p.z)), s2 = p.y.redMul(z2.redMul(this.z)), h = u1.redSub(u2), r = s1.redSub(s2);
      if (h.cmpn(0) === 0)
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      var h2 = h.redSqr(), h3 = h2.redMul(h), v = u1.redMul(h2), nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v), ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3)), nz = this.z.redMul(p.z).redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p) {
      if (this.isInfinity())
        return p.toJ();
      if (p.isInfinity())
        return this;
      var z2 = this.z.redSqr(), u1 = this.x, u2 = p.x.redMul(z2), s1 = this.y, s2 = p.y.redMul(z2).redMul(this.z), h = u1.redSub(u2), r = s1.redSub(s2);
      if (h.cmpn(0) === 0)
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      var h2 = h.redSqr(), h3 = h2.redMul(h), v = u1.redMul(h2), nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v), ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3)), nz = this.z.redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i2;
      if (this.curve.zeroA || this.curve.threeA) {
        var r = this;
        for (i2 = 0;i2 < pow; i2++)
          r = r.dbl();
        return r;
      }
      var a = this.curve.a, tinv = this.curve.tinv, jx = this.x, jy = this.y, jz = this.z, jz4 = jz.redSqr().redSqr(), jyd = jy.redAdd(jy);
      for (i2 = 0;i2 < pow; i2++) {
        var jx2 = jx.redSqr(), jyd2 = jyd.redSqr(), jyd4 = jyd2.redSqr(), c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4)), t1 = jx.redMul(jyd2), nx = c.redSqr().redISub(t1.redAdd(t1)), t2 = t1.redISub(nx), dny = c.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i2 + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx, jz = nz, jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx, ny, nz;
      if (this.zOne) {
        var xx = this.x.redSqr(), yy = this.y.redSqr(), yyyy = yy.redSqr(), s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx), t2 = m.redSqr().redISub(s).redISub(s), yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8), yyyy8 = yyyy8.redIAdd(yyyy8), nx = t2, ny = m.redMul(s.redISub(t2)).redISub(yyyy8), nz = this.y.redAdd(this.y);
      } else {
        var a = this.x.redSqr(), b = this.y.redSqr(), c = b.redSqr(), d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
        d = d.redIAdd(d);
        var e = a.redAdd(a).redIAdd(a), f = e.redSqr(), c8 = c.redIAdd(c);
        c8 = c8.redIAdd(c8), c8 = c8.redIAdd(c8), nx = f.redISub(d).redISub(d), ny = e.redMul(d.redISub(nx)).redISub(c8), nz = this.y.redMul(this.z), nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx, ny, nz;
      if (this.zOne) {
        var xx = this.x.redSqr(), yy = this.y.redSqr(), yyyy = yy.redSqr(), s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a), t2 = m.redSqr().redISub(s).redISub(s);
        nx = t2;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8), yyyy8 = yyyy8.redIAdd(yyyy8), ny = m.redMul(s.redISub(t2)).redISub(yyyy8), nz = this.y.redAdd(this.y);
      } else {
        var delta3 = this.z.redSqr(), gamma = this.y.redSqr(), beta = this.x.redMul(gamma), alpha = this.x.redSub(delta3).redMul(this.x.redAdd(delta3));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8), nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta3);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8), ggamma8 = ggamma8.redIAdd(ggamma8), ggamma8 = ggamma8.redIAdd(ggamma8), ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a = this.curve.a, jx = this.x, jy = this.y, jz = this.z, jz4 = jz.redSqr().redSqr(), jx2 = jx.redSqr(), jy2 = jy.redSqr(), c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4)), jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2), nx = c.redSqr().redISub(t1.redAdd(t1)), t2 = t1.redISub(nx), jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8), jyd8 = jyd8.redIAdd(jyd8), jyd8 = jyd8.redIAdd(jyd8);
      var ny = c.redMul(t2).redISub(jyd8), nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr(), yy = this.y.redSqr(), zz = this.z.redSqr(), yyyy = yy.redSqr(), m = xx.redAdd(xx).redIAdd(xx), mm = m.redSqr(), e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e = e.redIAdd(e), e = e.redAdd(e).redIAdd(e), e = e.redISub(mm);
      var ee = e.redSqr(), t2 = yyyy.redIAdd(yyyy);
      t2 = t2.redIAdd(t2), t2 = t2.redIAdd(t2), t2 = t2.redIAdd(t2);
      var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t2), yyu4 = yy.redMul(u);
      yyu4 = yyu4.redIAdd(yyu4), yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee).redISub(yyu4);
      nx = nx.redIAdd(nx), nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u.redMul(t2.redISub(u)).redISub(e.redMul(ee)));
      ny = ny.redIAdd(ny), ny = ny.redIAdd(ny), ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul(k, kbase) {
      return k = new BN(k, kbase), this.curve._wnafMul(this, k);
    };
    JPoint.prototype.eq = function eq(p) {
      if (p.type === "affine")
        return this.eq(p.toJ());
      if (this === p)
        return true;
      var z2 = this.z.redSqr(), pz2 = p.z.redSqr();
      if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
        return false;
      var z3 = z2.redMul(this.z), pz3 = pz2.redMul(p.z);
      return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x) {
      var zs = this.z.redSqr(), rx = x.toRed(this.curve.red).redMul(zs);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone(), t2 = this.curve.redN.redMul(zs);
      for (;; ) {
        if (xc.iadd(this.curve.n), xc.cmp(this.curve.p) >= 0)
          return false;
        if (rx.redIAdd(t2), this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
  });
  require_mont = __commonJS2((exports, module) => {
    var BN = require_bn(), inherits2 = require_inherits(), Base = require_base(), utils = require_utils2();
    function MontCurve(conf) {
      Base.call(this, "mont", conf), this.a = new BN(conf.a, 16).toRed(this.red), this.b = new BN(conf.b, 16).toRed(this.red), this.i4 = new BN(4).toRed(this.red).redInvm(), this.two = new BN(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits2(MontCurve, Base);
    module.exports = MontCurve;
    MontCurve.prototype.validate = function validate(point) {
      var x = point.normalize().x, x2 = x.redSqr(), rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x), y = rhs.redSqrt();
      return y.redSqr().cmp(rhs) === 0;
    };
    function Point(curve, x, z) {
      if (Base.BasePoint.call(this, curve, "projective"), x === null && z === null)
        this.x = this.curve.one, this.z = this.curve.zero;
      else {
        if (this.x = new BN(x, 16), this.z = new BN(z, 16), !this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    inherits2(Point, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      return this.point(utils.toArray(bytes, enc), 1);
    };
    MontCurve.prototype.point = function point(x, z) {
      return new Point(this, x, z);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    Point.prototype.precompute = function precompute() {};
    Point.prototype._encode = function _encode() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1] || curve.one);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
    Point.prototype.dbl = function dbl() {
      var a = this.x.redAdd(this.z), aa = a.redSqr(), b = this.x.redSub(this.z), bb = b.redSqr(), c = aa.redSub(bb), nx = aa.redMul(bb), nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
      return this.curve.point(nx, nz);
    };
    Point.prototype.add = function add() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.diffAdd = function diffAdd(p, diff) {
      var a = this.x.redAdd(this.z), b = this.x.redSub(this.z), c = p.x.redAdd(p.z), d = p.x.redSub(p.z), da = d.redMul(a), cb = c.redMul(b), nx = diff.z.redMul(da.redAdd(cb).redSqr()), nz = diff.x.redMul(da.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    };
    Point.prototype.mul = function mul(k) {
      var t2 = k.clone(), a = this, b = this.curve.point(null, null), c = this;
      for (var bits = [];t2.cmpn(0) !== 0; t2.iushrn(1))
        bits.push(t2.andln(1));
      for (var i2 = bits.length - 1;i2 >= 0; i2--)
        if (bits[i2] === 0)
          a = a.diffAdd(b, c), b = b.dbl();
        else
          b = a.diffAdd(b, c), a = a.dbl();
      return b;
    };
    Point.prototype.mulAdd = function mulAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.jumlAdd = function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.eq = function eq(other) {
      return this.getX().cmp(other.getX()) === 0;
    };
    Point.prototype.normalize = function normalize() {
      return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
    };
    Point.prototype.getX = function getX() {
      return this.normalize(), this.x.fromRed();
    };
  });
  require_edwards = __commonJS2((exports, module) => {
    var utils = require_utils2(), BN = require_bn(), inherits2 = require_inherits(), Base = require_base(), assert = utils.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1, this.mOneA = this.twisted && (conf.a | 0) === -1, this.extended = this.mOneA, Base.call(this, "edwards", conf), this.a = new BN(conf.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new BN(conf.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new BN(conf.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), assert(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (conf.c | 0) === 1;
    }
    inherits2(EdwardsCurve, Base);
    module.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t2) {
      return this.point(x, y, z, t2);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
      if (x = new BN(x, 16), !x.red)
        x = x.toRed(this.red);
      var x2 = x.redSqr(), rhs = this.c2.redSub(this.a.redMul(x2)), lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2)), y2 = rhs.redMul(lhs.redInvm()), y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x, y);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
      if (y = new BN(y, 16), !y.red)
        y = y.toRed(this.red);
      var y2 = y.redSqr(), lhs = y2.redSub(this.c2), rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a), x2 = lhs.redMul(rhs.redInvm());
      if (x2.cmp(this.zero) === 0)
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y);
      var x = x2.redSqrt();
      if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x.fromRed().isOdd() !== odd)
        x = x.redNeg();
      return this.point(x, y);
    };
    EdwardsCurve.prototype.validate = function validate(point) {
      if (point.isInfinity())
        return true;
      point.normalize();
      var x2 = point.x.redSqr(), y2 = point.y.redSqr(), lhs = x2.redMul(this.a).redAdd(y2), rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
      return lhs.cmp(rhs) === 0;
    };
    function Point(curve, x, y, z, t2) {
      if (Base.BasePoint.call(this, curve, "projective"), x === null && y === null && z === null)
        this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = true;
      else {
        if (this.x = new BN(x, 16), this.y = new BN(y, 16), this.z = z ? new BN(z, 16) : this.curve.one, this.t = t2 && new BN(t2, 16), !this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        if (this.zOne = this.z === this.curve.one, this.curve.extended && !this.t) {
          if (this.t = this.x.redMul(this.y), !this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    inherits2(Point, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point(x, y, z, t2) {
      return new Point(this, x, y, z, t2);
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1], obj[2]);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point.prototype._extDbl = function _extDbl() {
      var a = this.x.redSqr(), b = this.y.redSqr(), c = this.z.redSqr();
      c = c.redIAdd(c);
      var d = this.curve._mulA(a), e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b), g = d.redAdd(b), f = g.redSub(c), h = d.redSub(b), nx = e.redMul(f), ny = g.redMul(h), nt = e.redMul(h), nz = f.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projDbl = function _projDbl() {
      var b = this.x.redAdd(this.y).redSqr(), c = this.x.redSqr(), d = this.y.redSqr(), nx, ny, nz, e, h, j;
      if (this.curve.twisted) {
        e = this.curve._mulA(c);
        var f = e.redAdd(d);
        if (this.zOne)
          nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two)), ny = f.redMul(e.redSub(d)), nz = f.redSqr().redSub(f).redSub(f);
        else
          h = this.z.redSqr(), j = f.redSub(h).redISub(h), nx = b.redSub(c).redISub(d).redMul(j), ny = f.redMul(e.redSub(d)), nz = f.redMul(j);
      } else
        e = c.redAdd(d), h = this.curve._mulC(this.z).redSqr(), j = e.redSub(h).redSub(h), nx = this.curve._mulC(b.redISub(e)).redMul(j), ny = this.curve._mulC(e).redMul(c.redISub(d)), nz = e.redMul(j);
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    };
    Point.prototype._extAdd = function _extAdd(p) {
      var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x)), b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x)), c = this.t.redMul(this.curve.dd).redMul(p.t), d = this.z.redMul(p.z.redAdd(p.z)), e = b.redSub(a), f = d.redSub(c), g = d.redAdd(c), h = b.redAdd(a), nx = e.redMul(f), ny = g.redMul(h), nt = e.redMul(h), nz = f.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projAdd = function _projAdd(p) {
      var a = this.z.redMul(p.z), b = a.redSqr(), c = this.x.redMul(p.x), d = this.y.redMul(p.y), e = this.curve.d.redMul(c).redMul(d), f = b.redSub(e), g = b.redAdd(e), tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d), nx = a.redMul(f).redMul(tmp), ny, nz;
      if (this.curve.twisted)
        ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c))), nz = f.redMul(g);
      else
        ny = a.redMul(g).redMul(d.redSub(c)), nz = this.curve._mulC(f).redMul(g);
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.add = function add(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p);
      else
        return this._projAdd(p);
    };
    Point.prototype.mul = function mul(k) {
      if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else
        return this.curve._wnafMul(this, k);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
    };
    Point.prototype.normalize = function normalize() {
      if (this.zOne)
        return this;
      var zi = this.z.redInvm();
      if (this.x = this.x.redMul(zi), this.y = this.y.redMul(zi), this.t)
        this.t = this.t.redMul(zi);
      return this.z = this.curve.one, this.zOne = true, this;
    };
    Point.prototype.neg = function neg() {
      return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
    };
    Point.prototype.getX = function getX() {
      return this.normalize(), this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      return this.normalize(), this.y.fromRed();
    };
    Point.prototype.eq = function eq(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point.prototype.eqXToP = function eqXToP(x) {
      var rx = x.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone(), t2 = this.curve.redN.redMul(this.z);
      for (;; ) {
        if (xc.iadd(this.curve.n), xc.cmp(this.curve.p) >= 0)
          return false;
        if (rx.redIAdd(t2), this.x.cmp(rx) === 0)
          return true;
      }
    };
    Point.prototype.toP = Point.prototype.normalize;
    Point.prototype.mixedAdd = Point.prototype.add;
  });
  require_curve = __commonJS2((exports) => {
    var curve = exports;
    curve.base = require_base();
    curve.short = require_short();
    curve.mont = require_mont();
    curve.edwards = require_edwards();
  });
  require_utils3 = __commonJS2((exports) => {
    var assert = require_minimalistic_assert(), inherits2 = require_inherits();
    exports.inherits = inherits2;
    function isSurrogatePair(msg, i2) {
      if ((msg.charCodeAt(i2) & 64512) !== 55296)
        return false;
      if (i2 < 0 || i2 + 1 >= msg.length)
        return false;
      return (msg.charCodeAt(i2 + 1) & 64512) === 56320;
    }
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg === "string") {
        if (!enc) {
          var p = 0;
          for (var i2 = 0;i2 < msg.length; i2++) {
            var c = msg.charCodeAt(i2);
            if (c < 128)
              res[p++] = c;
            else if (c < 2048)
              res[p++] = c >> 6 | 192, res[p++] = c & 63 | 128;
            else if (isSurrogatePair(msg, i2))
              c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i2) & 1023), res[p++] = c >> 18 | 240, res[p++] = c >> 12 & 63 | 128, res[p++] = c >> 6 & 63 | 128, res[p++] = c & 63 | 128;
            else
              res[p++] = c >> 12 | 224, res[p++] = c >> 6 & 63 | 128, res[p++] = c & 63 | 128;
          }
        } else if (enc === "hex") {
          if (msg = msg.replace(/[^a-z0-9]+/ig, ""), msg.length % 2 !== 0)
            msg = "0" + msg;
          for (i2 = 0;i2 < msg.length; i2 += 2)
            res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
        }
      } else
        for (i2 = 0;i2 < msg.length; i2++)
          res[i2] = msg[i2] | 0;
      return res;
    }
    exports.toArray = toArray;
    function toHex(msg) {
      var res = "";
      for (var i2 = 0;i2 < msg.length; i2++)
        res += zero2(msg[i2].toString(16));
      return res;
    }
    exports.toHex = toHex;
    function htonl(w) {
      var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
      return res >>> 0;
    }
    exports.htonl = htonl;
    function toHex32(msg, endian) {
      var res = "";
      for (var i2 = 0;i2 < msg.length; i2++) {
        var w = msg[i2];
        if (endian === "little")
          w = htonl(w);
        res += zero8(w.toString(16));
      }
      return res;
    }
    exports.toHex32 = toHex32;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    exports.zero2 = zero2;
    function zero8(word) {
      if (word.length === 7)
        return "0" + word;
      else if (word.length === 6)
        return "00" + word;
      else if (word.length === 5)
        return "000" + word;
      else if (word.length === 4)
        return "0000" + word;
      else if (word.length === 3)
        return "00000" + word;
      else if (word.length === 2)
        return "000000" + word;
      else if (word.length === 1)
        return "0000000" + word;
      else
        return word;
    }
    exports.zero8 = zero8;
    function join32(msg, start, end, endian) {
      var len2 = end - start;
      assert(len2 % 4 === 0);
      var res = new Array(len2 / 4);
      for (var i2 = 0, k = start;i2 < res.length; i2++, k += 4) {
        var w;
        if (endian === "big")
          w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
        else
          w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
        res[i2] = w >>> 0;
      }
      return res;
    }
    exports.join32 = join32;
    function split32(msg, endian) {
      var res = new Array(msg.length * 4);
      for (var i2 = 0, k = 0;i2 < msg.length; i2++, k += 4) {
        var m = msg[i2];
        if (endian === "big")
          res[k] = m >>> 24, res[k + 1] = m >>> 16 & 255, res[k + 2] = m >>> 8 & 255, res[k + 3] = m & 255;
        else
          res[k + 3] = m >>> 24, res[k + 2] = m >>> 16 & 255, res[k + 1] = m >>> 8 & 255, res[k] = m & 255;
      }
      return res;
    }
    exports.split32 = split32;
    function rotr32(w, b) {
      return w >>> b | w << 32 - b;
    }
    exports.rotr32 = rotr32;
    function rotl32(w, b) {
      return w << b | w >>> 32 - b;
    }
    exports.rotl32 = rotl32;
    function sum32(a, b) {
      return a + b >>> 0;
    }
    exports.sum32 = sum32;
    function sum32_3(a, b, c) {
      return a + b + c >>> 0;
    }
    exports.sum32_3 = sum32_3;
    function sum32_4(a, b, c, d) {
      return a + b + c + d >>> 0;
    }
    exports.sum32_4 = sum32_4;
    function sum32_5(a, b, c, d, e) {
      return a + b + c + d + e >>> 0;
    }
    exports.sum32_5 = sum32_5;
    function sum64(buf, pos, ah, al) {
      var bh = buf[pos], bl = buf[pos + 1], lo = al + bl >>> 0, hi = (lo < al ? 1 : 0) + ah + bh;
      buf[pos] = hi >>> 0, buf[pos + 1] = lo;
    }
    exports.sum64 = sum64;
    function sum64_hi(ah, al, bh, bl) {
      var lo = al + bl >>> 0, hi = (lo < al ? 1 : 0) + ah + bh;
      return hi >>> 0;
    }
    exports.sum64_hi = sum64_hi;
    function sum64_lo(ah, al, bh, bl) {
      var lo = al + bl;
      return lo >>> 0;
    }
    exports.sum64_lo = sum64_lo;
    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
      var carry = 0, lo = al;
      lo = lo + bl >>> 0, carry += lo < al ? 1 : 0, lo = lo + cl >>> 0, carry += lo < cl ? 1 : 0, lo = lo + dl >>> 0, carry += lo < dl ? 1 : 0;
      var hi = ah + bh + ch + dh + carry;
      return hi >>> 0;
    }
    exports.sum64_4_hi = sum64_4_hi;
    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
      var lo = al + bl + cl + dl;
      return lo >>> 0;
    }
    exports.sum64_4_lo = sum64_4_lo;
    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var carry = 0, lo = al;
      lo = lo + bl >>> 0, carry += lo < al ? 1 : 0, lo = lo + cl >>> 0, carry += lo < cl ? 1 : 0, lo = lo + dl >>> 0, carry += lo < dl ? 1 : 0, lo = lo + el >>> 0, carry += lo < el ? 1 : 0;
      var hi = ah + bh + ch + dh + eh + carry;
      return hi >>> 0;
    }
    exports.sum64_5_hi = sum64_5_hi;
    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var lo = al + bl + cl + dl + el;
      return lo >>> 0;
    }
    exports.sum64_5_lo = sum64_5_lo;
    function rotr64_hi(ah, al, num) {
      var r = al << 32 - num | ah >>> num;
      return r >>> 0;
    }
    exports.rotr64_hi = rotr64_hi;
    function rotr64_lo(ah, al, num) {
      var r = ah << 32 - num | al >>> num;
      return r >>> 0;
    }
    exports.rotr64_lo = rotr64_lo;
    function shr64_hi(ah, al, num) {
      return ah >>> num;
    }
    exports.shr64_hi = shr64_hi;
    function shr64_lo(ah, al, num) {
      var r = ah << 32 - num | al >>> num;
      return r >>> 0;
    }
    exports.shr64_lo = shr64_lo;
  });
  require_common = __commonJS2((exports) => {
    var utils = require_utils3(), assert = require_minimalistic_assert();
    function BlockHash() {
      this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
    }
    exports.BlockHash = BlockHash;
    BlockHash.prototype.update = function update(msg, enc) {
      if (msg = utils.toArray(msg, enc), !this.pending)
        this.pending = msg;
      else
        this.pending = this.pending.concat(msg);
      if (this.pendingTotal += msg.length, this.pending.length >= this._delta8) {
        msg = this.pending;
        var r = msg.length % this._delta8;
        if (this.pending = msg.slice(msg.length - r, msg.length), this.pending.length === 0)
          this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r, this.endian);
        for (var i2 = 0;i2 < msg.length; i2 += this._delta32)
          this._update(msg, i2, i2 + this._delta32);
      }
      return this;
    };
    BlockHash.prototype.digest = function digest(enc) {
      return this.update(this._pad()), assert(this.pending === null), this._digest(enc);
    };
    BlockHash.prototype._pad = function pad() {
      var len2 = this.pendingTotal, bytes = this._delta8, k = bytes - (len2 + this.padLength) % bytes, res = new Array(k + this.padLength);
      res[0] = 128;
      for (var i2 = 1;i2 < k; i2++)
        res[i2] = 0;
      if (len2 <<= 3, this.endian === "big") {
        for (var t2 = 8;t2 < this.padLength; t2++)
          res[i2++] = 0;
        res[i2++] = 0, res[i2++] = 0, res[i2++] = 0, res[i2++] = 0, res[i2++] = len2 >>> 24 & 255, res[i2++] = len2 >>> 16 & 255, res[i2++] = len2 >>> 8 & 255, res[i2++] = len2 & 255;
      } else {
        res[i2++] = len2 & 255, res[i2++] = len2 >>> 8 & 255, res[i2++] = len2 >>> 16 & 255, res[i2++] = len2 >>> 24 & 255, res[i2++] = 0, res[i2++] = 0, res[i2++] = 0, res[i2++] = 0;
        for (t2 = 8;t2 < this.padLength; t2++)
          res[i2++] = 0;
      }
      return res;
    };
  });
  require_common2 = __commonJS2((exports) => {
    var utils = require_utils3(), rotr32 = utils.rotr32;
    function ft_1(s, x, y, z) {
      if (s === 0)
        return ch32(x, y, z);
      if (s === 1 || s === 3)
        return p32(x, y, z);
      if (s === 2)
        return maj32(x, y, z);
    }
    exports.ft_1 = ft_1;
    function ch32(x, y, z) {
      return x & y ^ ~x & z;
    }
    exports.ch32 = ch32;
    function maj32(x, y, z) {
      return x & y ^ x & z ^ y & z;
    }
    exports.maj32 = maj32;
    function p32(x, y, z) {
      return x ^ y ^ z;
    }
    exports.p32 = p32;
    function s0_256(x) {
      return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
    }
    exports.s0_256 = s0_256;
    function s1_256(x) {
      return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
    }
    exports.s1_256 = s1_256;
    function g0_256(x) {
      return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
    }
    exports.g0_256 = g0_256;
    function g1_256(x) {
      return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
    }
    exports.g1_256 = g1_256;
  });
  require_1 = __commonJS2((exports, module) => {
    var utils = require_utils3(), common = require_common(), shaCommon = require_common2(), rotl32 = utils.rotl32, sum32 = utils.sum32, sum32_5 = utils.sum32_5, ft_1 = shaCommon.ft_1, BlockHash = common.BlockHash, sha1_K = [1518500249, 1859775393, 2400959708, 3395469782];
    function SHA1() {
      if (!(this instanceof SHA1))
        return new SHA1;
      BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
    }
    utils.inherits(SHA1, BlockHash);
    module.exports = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update = function _update(msg, start) {
      var W = this.W;
      for (var i2 = 0;i2 < 16; i2++)
        W[i2] = msg[start + i2];
      for (;i2 < W.length; i2++)
        W[i2] = rotl32(W[i2 - 3] ^ W[i2 - 8] ^ W[i2 - 14] ^ W[i2 - 16], 1);
      var a = this.h[0], b = this.h[1], c = this.h[2], d = this.h[3], e = this.h[4];
      for (i2 = 0;i2 < W.length; i2++) {
        var s = ~~(i2 / 20), t2 = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i2], sha1_K[s]);
        e = d, d = c, c = rotl32(b, 30), b = a, a = t2;
      }
      this.h[0] = sum32(this.h[0], a), this.h[1] = sum32(this.h[1], b), this.h[2] = sum32(this.h[2], c), this.h[3] = sum32(this.h[3], d), this.h[4] = sum32(this.h[4], e);
    };
    SHA1.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  });
  require_256 = __commonJS2((exports, module) => {
    var utils = require_utils3(), common = require_common(), shaCommon = require_common2(), assert = require_minimalistic_assert(), sum32 = utils.sum32, sum32_4 = utils.sum32_4, sum32_5 = utils.sum32_5, ch32 = shaCommon.ch32, maj32 = shaCommon.maj32, s0_256 = shaCommon.s0_256, s1_256 = shaCommon.s1_256, g0_256 = shaCommon.g0_256, g1_256 = shaCommon.g1_256, BlockHash = common.BlockHash, sha256_K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
    function SHA256() {
      if (!(this instanceof SHA256))
        return new SHA256;
      BlockHash.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = sha256_K, this.W = new Array(64);
    }
    utils.inherits(SHA256, BlockHash);
    module.exports = SHA256;
    SHA256.blockSize = 512;
    SHA256.outSize = 256;
    SHA256.hmacStrength = 192;
    SHA256.padLength = 64;
    SHA256.prototype._update = function _update(msg, start) {
      var W = this.W;
      for (var i2 = 0;i2 < 16; i2++)
        W[i2] = msg[start + i2];
      for (;i2 < W.length; i2++)
        W[i2] = sum32_4(g1_256(W[i2 - 2]), W[i2 - 7], g0_256(W[i2 - 15]), W[i2 - 16]);
      var a = this.h[0], b = this.h[1], c = this.h[2], d = this.h[3], e = this.h[4], f = this.h[5], g = this.h[6], h = this.h[7];
      assert(this.k.length === W.length);
      for (i2 = 0;i2 < W.length; i2++) {
        var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i2], W[i2]), T2 = sum32(s0_256(a), maj32(a, b, c));
        h = g, g = f, f = e, e = sum32(d, T1), d = c, c = b, b = a, a = sum32(T1, T2);
      }
      this.h[0] = sum32(this.h[0], a), this.h[1] = sum32(this.h[1], b), this.h[2] = sum32(this.h[2], c), this.h[3] = sum32(this.h[3], d), this.h[4] = sum32(this.h[4], e), this.h[5] = sum32(this.h[5], f), this.h[6] = sum32(this.h[6], g), this.h[7] = sum32(this.h[7], h);
    };
    SHA256.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  });
  require_224 = __commonJS2((exports, module) => {
    var utils = require_utils3(), SHA256 = require_256();
    function SHA224() {
      if (!(this instanceof SHA224))
        return new SHA224;
      SHA256.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
    }
    utils.inherits(SHA224, SHA256);
    module.exports = SHA224;
    SHA224.blockSize = 512;
    SHA224.outSize = 224;
    SHA224.hmacStrength = 192;
    SHA224.padLength = 64;
    SHA224.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 7), "big");
      else
        return utils.split32(this.h.slice(0, 7), "big");
    };
  });
  require_512 = __commonJS2((exports, module) => {
    var utils = require_utils3(), common = require_common(), assert = require_minimalistic_assert(), rotr64_hi = utils.rotr64_hi, rotr64_lo = utils.rotr64_lo, shr64_hi = utils.shr64_hi, shr64_lo = utils.shr64_lo, sum64 = utils.sum64, sum64_hi = utils.sum64_hi, sum64_lo = utils.sum64_lo, sum64_4_hi = utils.sum64_4_hi, sum64_4_lo = utils.sum64_4_lo, sum64_5_hi = utils.sum64_5_hi, sum64_5_lo = utils.sum64_5_lo, BlockHash = common.BlockHash, sha512_K = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
    function SHA512() {
      if (!(this instanceof SHA512))
        return new SHA512;
      BlockHash.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = sha512_K, this.W = new Array(160);
    }
    utils.inherits(SHA512, BlockHash);
    module.exports = SHA512;
    SHA512.blockSize = 1024;
    SHA512.outSize = 512;
    SHA512.hmacStrength = 192;
    SHA512.padLength = 128;
    SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
      var W = this.W;
      for (var i2 = 0;i2 < 32; i2++)
        W[i2] = msg[start + i2];
      for (;i2 < W.length; i2 += 2) {
        var c0_hi = g1_512_hi(W[i2 - 4], W[i2 - 3]), c0_lo = g1_512_lo(W[i2 - 4], W[i2 - 3]), c1_hi = W[i2 - 14], c1_lo = W[i2 - 13], c2_hi = g0_512_hi(W[i2 - 30], W[i2 - 29]), c2_lo = g0_512_lo(W[i2 - 30], W[i2 - 29]), c3_hi = W[i2 - 32], c3_lo = W[i2 - 31];
        W[i2] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo), W[i2 + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
      }
    };
    SHA512.prototype._update = function _update(msg, start) {
      this._prepareBlock(msg, start);
      var W = this.W, ah = this.h[0], al = this.h[1], bh = this.h[2], bl = this.h[3], ch = this.h[4], cl = this.h[5], dh = this.h[6], dl = this.h[7], eh = this.h[8], el = this.h[9], fh = this.h[10], fl = this.h[11], gh = this.h[12], gl = this.h[13], hh = this.h[14], hl = this.h[15];
      assert(this.k.length === W.length);
      for (var i2 = 0;i2 < W.length; i2 += 2) {
        var c0_hi = hh, c0_lo = hl, c1_hi = s1_512_hi(eh, el), c1_lo = s1_512_lo(eh, el), c2_hi = ch64_hi(eh, el, fh, fl, gh, gl), c2_lo = ch64_lo(eh, el, fh, fl, gh, gl), c3_hi = this.k[i2], c3_lo = this.k[i2 + 1], c4_hi = W[i2], c4_lo = W[i2 + 1], T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo), T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
        c0_hi = s0_512_hi(ah, al), c0_lo = s0_512_lo(ah, al), c1_hi = maj64_hi(ah, al, bh, bl, ch, cl), c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo), T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh, hl = gl, gh = fh, gl = fl, fh = eh, fl = el, eh = sum64_hi(dh, dl, T1_hi, T1_lo), el = sum64_lo(dl, dl, T1_hi, T1_lo), dh = ch, dl = cl, ch = bh, cl = bl, bh = ah, bl = al, ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo), al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
      }
      sum64(this.h, 0, ah, al), sum64(this.h, 2, bh, bl), sum64(this.h, 4, ch, cl), sum64(this.h, 6, dh, dl), sum64(this.h, 8, eh, el), sum64(this.h, 10, fh, fl), sum64(this.h, 12, gh, gl), sum64(this.h, 14, hh, hl);
    };
    SHA512.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
    function ch64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ ~xh & zh;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function ch64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ ~xl & zl;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function maj64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ xh & zh ^ yh & zh;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function maj64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ xl & zl ^ yl & zl;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 28), c1_hi = rotr64_hi(xl, xh, 2), c2_hi = rotr64_hi(xl, xh, 7), r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 28), c1_lo = rotr64_lo(xl, xh, 2), c2_lo = rotr64_lo(xl, xh, 7), r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 14), c1_hi = rotr64_hi(xh, xl, 18), c2_hi = rotr64_hi(xl, xh, 9), r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 14), c1_lo = rotr64_lo(xh, xl, 18), c2_lo = rotr64_lo(xl, xh, 9), r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 1), c1_hi = rotr64_hi(xh, xl, 8), c2_hi = shr64_hi(xh, xl, 7), r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 1), c1_lo = rotr64_lo(xh, xl, 8), c2_lo = shr64_lo(xh, xl, 7), r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 19), c1_hi = rotr64_hi(xl, xh, 29), c2_hi = shr64_hi(xh, xl, 6), r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 19), c1_lo = rotr64_lo(xl, xh, 29), c2_lo = shr64_lo(xh, xl, 6), r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
  });
  require_384 = __commonJS2((exports, module) => {
    var utils = require_utils3(), SHA512 = require_512();
    function SHA384() {
      if (!(this instanceof SHA384))
        return new SHA384;
      SHA512.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
    }
    utils.inherits(SHA384, SHA512);
    module.exports = SHA384;
    SHA384.blockSize = 1024;
    SHA384.outSize = 384;
    SHA384.hmacStrength = 192;
    SHA384.padLength = 128;
    SHA384.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 12), "big");
      else
        return utils.split32(this.h.slice(0, 12), "big");
    };
  });
  require_sha = __commonJS2((exports) => {
    exports.sha1 = require_1();
    exports.sha224 = require_224();
    exports.sha256 = require_256();
    exports.sha384 = require_384();
    exports.sha512 = require_512();
  });
  require_ripemd = __commonJS2((exports) => {
    var utils = require_utils3(), common = require_common(), rotl32 = utils.rotl32, sum32 = utils.sum32, sum32_3 = utils.sum32_3, sum32_4 = utils.sum32_4, BlockHash = common.BlockHash;
    function RIPEMD160() {
      if (!(this instanceof RIPEMD160))
        return new RIPEMD160;
      BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
    }
    utils.inherits(RIPEMD160, BlockHash);
    exports.ripemd160 = RIPEMD160;
    RIPEMD160.blockSize = 512;
    RIPEMD160.outSize = 160;
    RIPEMD160.hmacStrength = 192;
    RIPEMD160.padLength = 64;
    RIPEMD160.prototype._update = function update(msg, start) {
      var A = this.h[0], B = this.h[1], C = this.h[2], D = this.h[3], E2 = this.h[4], Ah = A, Bh = B, Ch = C, Dh = D, Eh = E2;
      for (var j = 0;j < 80; j++) {
        var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E2);
        A = E2, E2 = D, D = rotl32(C, 10), C = B, B = T, T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh), Ah = Eh, Eh = Dh, Dh = rotl32(Ch, 10), Ch = Bh, Bh = T;
      }
      T = sum32_3(this.h[1], C, Dh), this.h[1] = sum32_3(this.h[2], D, Eh), this.h[2] = sum32_3(this.h[3], E2, Ah), this.h[3] = sum32_3(this.h[4], A, Bh), this.h[4] = sum32_3(this.h[0], B, Ch), this.h[0] = T;
    };
    RIPEMD160.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "little");
      else
        return utils.split32(this.h, "little");
    };
    function f(j, x, y, z) {
      if (j <= 15)
        return x ^ y ^ z;
      else if (j <= 31)
        return x & y | ~x & z;
      else if (j <= 47)
        return (x | ~y) ^ z;
      else if (j <= 63)
        return x & z | y & ~z;
      else
        return x ^ (y | ~z);
    }
    function K(j) {
      if (j <= 15)
        return 0;
      else if (j <= 31)
        return 1518500249;
      else if (j <= 47)
        return 1859775393;
      else if (j <= 63)
        return 2400959708;
      else
        return 2840853838;
    }
    function Kh(j) {
      if (j <= 15)
        return 1352829926;
      else if (j <= 31)
        return 1548603684;
      else if (j <= 47)
        return 1836072691;
      else if (j <= 63)
        return 2053994217;
      else
        return 0;
    }
    var r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], rh = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], s = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], sh = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
  });
  require_hmac = __commonJS2((exports, module) => {
    var utils = require_utils3(), assert = require_minimalistic_assert();
    function Hmac(hash3, key, enc) {
      if (!(this instanceof Hmac))
        return new Hmac(hash3, key, enc);
      this.Hash = hash3, this.blockSize = hash3.blockSize / 8, this.outSize = hash3.outSize / 8, this.inner = null, this.outer = null, this._init(utils.toArray(key, enc));
    }
    module.exports = Hmac;
    Hmac.prototype._init = function init(key) {
      if (key.length > this.blockSize)
        key = new this.Hash().update(key).digest();
      assert(key.length <= this.blockSize);
      for (var i2 = key.length;i2 < this.blockSize; i2++)
        key.push(0);
      for (i2 = 0;i2 < key.length; i2++)
        key[i2] ^= 54;
      this.inner = new this.Hash().update(key);
      for (i2 = 0;i2 < key.length; i2++)
        key[i2] ^= 106;
      this.outer = new this.Hash().update(key);
    };
    Hmac.prototype.update = function update(msg, enc) {
      return this.inner.update(msg, enc), this;
    };
    Hmac.prototype.digest = function digest(enc) {
      return this.outer.update(this.inner.digest()), this.outer.digest(enc);
    };
  });
  require_hash = __commonJS2((exports) => {
    var hash3 = exports;
    hash3.utils = require_utils3();
    hash3.common = require_common();
    hash3.sha = require_sha();
    hash3.ripemd = require_ripemd();
    hash3.hmac = require_hmac();
    hash3.sha1 = hash3.sha.sha1;
    hash3.sha256 = hash3.sha.sha256;
    hash3.sha224 = hash3.sha.sha224;
    hash3.sha384 = hash3.sha.sha384;
    hash3.sha512 = hash3.sha.sha512;
    hash3.ripemd160 = hash3.ripemd.ripemd160;
  });
  require_secp256k1 = __commonJS2((exports, module) => {
    module.exports = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } };
  });
  require_curves = __commonJS2((exports) => {
    var curves = exports, hash3 = require_hash(), curve = require_curve(), utils = require_utils2(), assert = utils.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g, this.n = this.curve.n, this.hash = options.hash, assert(this.g.validate(), "Invalid curve"), assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name, options) {
      Object.defineProperty(curves, name, { configurable: true, enumerable: true, get: function() {
        var curve2 = new PresetCurve(options);
        return Object.defineProperty(curves, name, { configurable: true, enumerable: true, value: curve2 }), curve2;
      } });
    }
    defineCurve("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: hash3.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] });
    defineCurve("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: hash3.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] });
    defineCurve("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: hash3.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] });
    defineCurve("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: hash3.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] });
    defineCurve("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: hash3.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] });
    defineCurve("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: hash3.sha256, gRed: false, g: ["9"] });
    defineCurve("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: hash3.sha256, gRed: false, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
    var pre;
    try {
      pre = require_secp256k1();
    } catch (e) {
      pre = undefined;
    }
    defineCurve("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: hash3.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: false, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", pre] });
  });
  require_hmac_drbg = __commonJS2((exports, module) => {
    var hash3 = require_hash(), utils = require_utils(), assert = require_minimalistic_assert();
    function HmacDRBG(options) {
      if (!(this instanceof HmacDRBG))
        return new HmacDRBG(options);
      this.hash = options.hash, this.predResist = !!options.predResist, this.outLen = this.hash.outSize, this.minEntropy = options.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
      var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex"), nonce = utils.toArray(options.nonce, options.nonceEnc || "hex"), pers = utils.toArray(options.pers, options.persEnc || "hex");
      assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(entropy, nonce, pers);
    }
    module.exports = HmacDRBG;
    HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
      var seed = entropy.concat(nonce).concat(pers);
      this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
      for (var i2 = 0;i2 < this.V.length; i2++)
        this.K[i2] = 0, this.V[i2] = 1;
      this._update(seed), this._reseed = 1, this.reseedInterval = 281474976710656;
    };
    HmacDRBG.prototype._hmac = function hmac() {
      return new hash3.hmac(this.hash, this.K);
    };
    HmacDRBG.prototype._update = function update(seed) {
      var kmac = this._hmac().update(this.V).update([0]);
      if (seed)
        kmac = kmac.update(seed);
      if (this.K = kmac.digest(), this.V = this._hmac().update(this.V).digest(), !seed)
        return;
      this.K = this._hmac().update(this.V).update([1]).update(seed).digest(), this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
      if (typeof entropyEnc !== "string")
        addEnc = add, add = entropyEnc, entropyEnc = null;
      entropy = utils.toArray(entropy, entropyEnc), add = utils.toArray(add, addEnc), assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(entropy.concat(add || [])), this._reseed = 1;
    };
    HmacDRBG.prototype.generate = function generate(len2, enc, add, addEnc) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      if (typeof enc !== "string")
        addEnc = add, add = enc, enc = null;
      if (add)
        add = utils.toArray(add, addEnc || "hex"), this._update(add);
      var temp = [];
      while (temp.length < len2)
        this.V = this._hmac().update(this.V).digest(), temp = temp.concat(this.V);
      var res = temp.slice(0, len2);
      return this._update(add), this._reseed++, utils.encode(res, enc);
    };
  });
  require_key = __commonJS2((exports, module) => {
    var BN = require_bn(), utils = require_utils2(), assert = utils.assert;
    function KeyPair(ec, options) {
      if (this.ec = ec, this.priv = null, this.pub = null, options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    module.exports = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec, { pub, pubEnc: enc });
    };
    KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec, { priv, privEnc: enc });
    };
    KeyPair.prototype.validate = function validate() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string")
        enc = compact, compact = null;
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
      this.priv = new BN(key, enc || 16), this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key, enc) {
      if (key.x || key.y) {
        if (this.ec.curve.type === "mont")
          assert(key.x, "Need x coordinate");
        else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards")
          assert(key.x && key.y, "Need both x and y coordinate");
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
      if (!pub.validate())
        assert(pub.validate(), "public point not validated");
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify(msg, signature, options) {
      return this.ec.verify(msg, signature, this, undefined, options);
    };
    KeyPair.prototype.inspect = function inspect() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  });
  require_signature = __commonJS2((exports, module) => {
    var BN = require_bn(), utils = require_utils2(), assert = utils.assert;
    function Signature(options, enc) {
      if (options instanceof Signature)
        return options;
      if (this._importDER(options, enc))
        return;
      if (assert(options.r && options.s, "Signature without r or s"), this.r = new BN(options.r, 16), this.s = new BN(options.s, 16), options.recoveryParam === undefined)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    module.exports = Signature;
    function Position() {
      this.place = 0;
    }
    function getLength(buf, p) {
      var initial = buf[p.place++];
      if (!(initial & 128))
        return initial;
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4)
        return false;
      if (buf[p.place] === 0)
        return false;
      var val = 0;
      for (var i2 = 0, off = p.place;i2 < octetLen; i2++, off++)
        val <<= 8, val |= buf[off], val >>>= 0;
      if (val <= 127)
        return false;
      return p.place = off, val;
    }
    function rmPadding(buf) {
      var i2 = 0, len2 = buf.length - 1;
      while (!buf[i2] && !(buf[i2 + 1] & 128) && i2 < len2)
        i2++;
      if (i2 === 0)
        return buf;
      return buf.slice(i2);
    }
    Signature.prototype._importDER = function _importDER(data, enc) {
      data = utils.toArray(data, enc);
      var p = new Position;
      if (data[p.place++] !== 48)
        return false;
      var len2 = getLength(data, p);
      if (len2 === false)
        return false;
      if (len2 + p.place !== data.length)
        return false;
      if (data[p.place++] !== 2)
        return false;
      var rlen = getLength(data, p);
      if (rlen === false)
        return false;
      if ((data[p.place] & 128) !== 0)
        return false;
      var r = data.slice(p.place, rlen + p.place);
      if (p.place += rlen, data[p.place++] !== 2)
        return false;
      var slen = getLength(data, p);
      if (slen === false)
        return false;
      if (data.length !== slen + p.place)
        return false;
      if ((data[p.place] & 128) !== 0)
        return false;
      var s = data.slice(p.place, slen + p.place);
      if (r[0] === 0)
        if (r[1] & 128)
          r = r.slice(1);
        else
          return false;
      if (s[0] === 0)
        if (s[1] & 128)
          s = s.slice(1);
        else
          return false;
      return this.r = new BN(r), this.s = new BN(s), this.recoveryParam = null, true;
    };
    function constructLength(arr, len2) {
      if (len2 < 128) {
        arr.push(len2);
        return;
      }
      var octets = 1 + (Math.log(len2) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets)
        arr.push(len2 >>> (octets << 3) & 255);
      arr.push(len2);
    }
    Signature.prototype.toDER = function toDER(enc) {
      var r = this.r.toArray(), s = this.s.toArray();
      if (r[0] & 128)
        r = [0].concat(r);
      if (s[0] & 128)
        s = [0].concat(s);
      r = rmPadding(r), s = rmPadding(s);
      while (!s[0] && !(s[1] & 128))
        s = s.slice(1);
      var arr = [2];
      constructLength(arr, r.length), arr = arr.concat(r), arr.push(2), constructLength(arr, s.length);
      var backHalf = arr.concat(s), res = [48];
      return constructLength(res, backHalf.length), res = res.concat(backHalf), utils.encode(res, enc);
    };
  });
  require_ec = __commonJS2((exports, module) => {
    var BN = require_bn(), HmacDRBG = require_hmac_drbg(), utils = require_utils2(), curves = require_curves(), rand = require_brorand(), assert = utils.assert, KeyPair = require_key(), Signature = require_signature();
    function EC(options) {
      if (!(this instanceof EC))
        return new EC(options);
      if (typeof options === "string")
        assert(Object.prototype.hasOwnProperty.call(curves, options), "Unknown curve " + options), options = curves[options];
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = options.curve.g, this.g.precompute(options.curve.n.bitLength() + 1), this.hash = options.hash || options.curve.hash;
    }
    module.exports = EC;
    EC.prototype.keyPair = function keyPair(options) {
      return new KeyPair(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return KeyPair.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return KeyPair.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG({ hash: this.hash, pers: options.pers, persEnc: options.persEnc || "utf8", entropy: options.entropy || rand(this.hash.hmacStrength), entropyEnc: options.entropy && options.entropyEnc || "utf8", nonce: this.n.toArray() }), bytes = this.n.byteLength(), ns2 = this.n.sub(new BN(2));
      for (;; ) {
        var priv = new BN(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0)
          continue;
        return priv.iaddn(1), this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly, bitLength) {
      var byteLength2;
      if (BN.isBN(msg) || typeof msg === "number")
        msg = new BN(msg, 16), byteLength2 = msg.byteLength();
      else if (typeof msg === "object")
        byteLength2 = msg.length, msg = new BN(msg, 16);
      else {
        var str = msg.toString();
        byteLength2 = str.length + 1 >>> 1, msg = new BN(str, 16);
      }
      if (typeof bitLength !== "number")
        bitLength = byteLength2 * 8;
      var delta3 = bitLength - this.n.bitLength();
      if (delta3 > 0)
        msg = msg.ushrn(delta3);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign(msg, key, enc, options) {
      if (typeof enc === "object")
        options = enc, enc = null;
      if (!options)
        options = {};
      if (typeof msg !== "string" && typeof msg !== "number" && !BN.isBN(msg)) {
        assert(typeof msg === "object" && msg && typeof msg.length === "number", "Expected message to be an array-like, a hex string, or a BN instance"), assert(msg.length >>> 0 === msg.length);
        for (var i2 = 0;i2 < msg.length; i2++)
          assert((msg[i2] & 255) === msg[i2]);
      }
      key = this.keyFromPrivate(key, enc), msg = this._truncateToN(msg, false, options.msgBitLength), assert(!msg.isNeg(), "Can not sign a negative message");
      var bytes = this.n.byteLength(), bkey = key.getPrivate().toArray("be", bytes), nonce = msg.toArray("be", bytes);
      assert(new BN(nonce).eq(msg), "Can not sign message");
      var drbg = new HmacDRBG({ hash: this.hash, entropy: bkey, nonce, pers: options.pers, persEnc: options.persEnc || "utf8" }), ns1 = this.n.sub(new BN(1));
      for (var iter = 0;; iter++) {
        var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
        if (k = this._truncateToN(k, true), k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX(), r = kpX.umod(this.n);
        if (r.cmpn(0) === 0)
          continue;
        var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
        if (s = s.umod(this.n), s.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
        if (options.canonical && s.cmp(this.nh) > 0)
          s = this.n.sub(s), recoveryParam ^= 1;
        return new Signature({ r, s, recoveryParam });
      }
    };
    EC.prototype.verify = function verify(msg, signature, key, enc, options) {
      if (!options)
        options = {};
      msg = this._truncateToN(msg, false, options.msgBitLength), key = this.keyFromPublic(key, enc), signature = new Signature(signature, "hex");
      var { r, s } = signature;
      if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
        return false;
      if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
        return false;
      var sinv = s.invm(this.n), u1 = sinv.mul(msg).umod(this.n), u2 = sinv.mul(r).umod(this.n), p;
      if (!this.curve._maxwellTrick) {
        if (p = this.g.mulAdd(u1, key.getPublic(), u2), p.isInfinity())
          return false;
        return p.getX().umod(this.n).cmp(r) === 0;
      }
      if (p = this.g.jmulAdd(u1, key.getPublic(), u2), p.isInfinity())
        return false;
      return p.eqXToP(r);
    };
    EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
      assert((3 & j) === j, "The recovery param is more than two bits"), signature = new Signature(signature, enc);
      var n = this.n, e = new BN(msg), r = signature.r, s = signature.s, isYOdd = j & 1, isSecondKey = j >> 1;
      if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
      else
        r = this.curve.pointFromX(r, isYOdd);
      var rInv = signature.r.invm(n), s1 = n.sub(e).mul(rInv).umod(n), s2 = s.mul(rInv).umod(n);
      return this.g.mulAdd(s1, r, s2);
    };
    EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
      if (signature = new Signature(signature, enc), signature.recoveryParam !== null)
        return signature.recoveryParam;
      for (var i2 = 0;i2 < 4; i2++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e, signature, i2);
        } catch (e2) {
          continue;
        }
        if (Qprime.eq(Q))
          return i2;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  });
  require_key2 = __commonJS2((exports, module) => {
    var utils = require_utils2(), assert = utils.assert, parseBytes = utils.parseBytes, cachedProperty = utils.cachedProperty;
    function KeyPair(eddsa, params) {
      if (this.eddsa = eddsa, this._secret = parseBytes(params.secret), eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    KeyPair.fromPublic = function fromPublic(eddsa, pub) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(eddsa, { pub });
    };
    KeyPair.fromSecret = function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair)
        return secret;
      return new KeyPair(eddsa, { secret });
    };
    KeyPair.prototype.secret = function secret() {
      return this._secret;
    };
    cachedProperty(KeyPair, "pubBytes", function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair, "pub", function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair, "privBytes", function privBytes() {
      var eddsa = this.eddsa, hash3 = this.hash(), lastIx = eddsa.encodingLength - 1, a = hash3.slice(0, eddsa.encodingLength);
      return a[0] &= 248, a[lastIx] &= 127, a[lastIx] |= 64, a;
    });
    cachedProperty(KeyPair, "priv", function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair, "hash", function hash() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair.prototype.sign = function sign(message) {
      return assert(this._secret, "KeyPair can only verify"), this.eddsa.sign(message, this);
    };
    KeyPair.prototype.verify = function verify(message, sig) {
      return this.eddsa.verify(message, sig, this);
    };
    KeyPair.prototype.getSecret = function getSecret(enc) {
      return assert(this._secret, "KeyPair is public only"), utils.encode(this.secret(), enc);
    };
    KeyPair.prototype.getPublic = function getPublic(enc) {
      return utils.encode(this.pubBytes(), enc);
    };
    module.exports = KeyPair;
  });
  require_signature2 = __commonJS2((exports, module) => {
    var BN = require_bn(), utils = require_utils2(), assert = utils.assert, cachedProperty = utils.cachedProperty, parseBytes = utils.parseBytes;
    function Signature(eddsa, sig) {
      if (this.eddsa = eddsa, typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig))
        assert(sig.length === eddsa.encodingLength * 2, "Signature has invalid size"), sig = { R: sig.slice(0, eddsa.encodingLength), S: sig.slice(eddsa.encodingLength) };
      if (assert(sig.R && sig.S, "Signature without R or S"), eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded, this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature, "S", function S() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature, "R", function R() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature, "Rencoded", function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature, "Sencoded", function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    });
    Signature.prototype.toBytes = function toBytes() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Signature.prototype.toHex = function toHex() {
      return utils.encode(this.toBytes(), "hex").toUpperCase();
    };
    module.exports = Signature;
  });
  require_eddsa = __commonJS2((exports, module) => {
    var hash3 = require_hash(), curves = require_curves(), utils = require_utils2(), assert = utils.assert, parseBytes = utils.parseBytes, KeyPair = require_key2(), Signature = require_signature2();
    function EDDSA(curve) {
      if (assert(curve === "ed25519", "only tested with ed25519 so far"), !(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve, this.curve = curve, this.g = curve.g, this.g.precompute(curve.n.bitLength() + 1), this.pointClass = curve.point().constructor, this.encodingLength = Math.ceil(curve.n.bitLength() / 8), this.hash = hash3.sha512;
    }
    module.exports = EDDSA;
    EDDSA.prototype.sign = function sign(message, secret) {
      message = parseBytes(message);
      var key = this.keyFromSecret(secret), r = this.hashInt(key.messagePrefix(), message), R = this.g.mul(r), Rencoded = this.encodePoint(R), s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv()), S = r.add(s_).umod(this.curve.n);
      return this.makeSignature({ R, S, Rencoded });
    };
    EDDSA.prototype.verify = function verify(message, sig, pub) {
      if (message = parseBytes(message), sig = this.makeSignature(sig), sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg())
        return false;
      var key = this.keyFromPublic(pub), h = this.hashInt(sig.Rencoded(), key.pubBytes(), message), SG = this.g.mul(sig.S()), RplusAh = sig.R().add(key.pub().mul(h));
      return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
      var hash22 = this.hash();
      for (var i2 = 0;i2 < arguments.length; i2++)
        hash22.update(arguments[i2]);
      return utils.intFromLE(hash22.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
      return KeyPair.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
      return KeyPair.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
      if (sig instanceof Signature)
        return sig;
      return new Signature(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point) {
      var enc = point.getY().toArray("le", this.encodingLength);
      return enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0, enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes) {
      bytes = utils.parseBytes(bytes);
      var lastIx = bytes.length - 1, normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & -129), xIsOdd = (bytes[lastIx] & 128) !== 0, y = utils.intFromLE(normed);
      return this.curve.pointFromY(y, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes) {
      return utils.intFromLE(bytes);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
      return val instanceof this.pointClass;
    };
  });
  require_elliptic = __commonJS2((exports) => {
    var elliptic = exports;
    elliptic.version = require_package().version;
    elliptic.utils = require_utils2();
    elliptic.rand = require_brorand();
    elliptic.curve = require_curve();
    elliptic.curves = require_curves();
    elliptic.ec = require_ec();
    elliptic.eddsa = require_eddsa();
  });
  require_bn2 = __commonJS2((exports, module) => {
    (function(module2, exports2) {
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor, ctor.prototype.constructor = ctor;
      }
      function BN(number3, base, endian) {
        if (BN.isBN(number3))
          return number3;
        if (this.negative = 0, this.words = null, this.length = 0, this.red = null, number3 !== null) {
          if (base === "le" || base === "be")
            endian = base, base = 10;
          this._init(number3 || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object")
        module2.exports = BN;
      else
        exports2.BN = BN;
      BN.BN = BN, BN.wordSize = 26;
      var Buffer22;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined")
          Buffer22 = window.Buffer;
        else
          Buffer22 = (init_buffer(), __toCommonJS(exports_buffer2)).Buffer;
      } catch (e) {}
      BN.isBN = function isBN(num) {
        if (num instanceof BN)
          return true;
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      }, BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      }, BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      }, BN.prototype._init = function init(number3, base, endian) {
        if (typeof number3 === "number")
          return this._initNumber(number3, base, endian);
        if (typeof number3 === "object")
          return this._initArray(number3, base, endian);
        if (base === "hex")
          base = 16;
        assert(base === (base | 0) && base >= 2 && base <= 36), number3 = number3.toString().replace(/\s+/g, "");
        var start = 0;
        if (number3[0] === "-")
          start++, this.negative = 1;
        if (start < number3.length) {
          if (base === 16)
            this._parseHex(number3, start, endian);
          else if (this._parseBase(number3, base, start), endian === "le")
            this._initArray(this.toArray(), base, endian);
        }
      }, BN.prototype._initNumber = function _initNumber(number3, base, endian) {
        if (number3 < 0)
          this.negative = 1, number3 = -number3;
        if (number3 < 67108864)
          this.words = [number3 & 67108863], this.length = 1;
        else if (number3 < 4503599627370496)
          this.words = [number3 & 67108863, number3 / 67108864 & 67108863], this.length = 2;
        else
          assert(number3 < 9007199254740992), this.words = [number3 & 67108863, number3 / 67108864 & 67108863, 1], this.length = 3;
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      }, BN.prototype._initArray = function _initArray(number3, base, endian) {
        if (assert(typeof number3.length === "number"), number3.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(number3.length / 3), this.words = new Array(this.length);
        for (var i2 = 0;i2 < this.length; i2++)
          this.words[i2] = 0;
        var j, w, off = 0;
        if (endian === "be") {
          for (i2 = number3.length - 1, j = 0;i2 >= 0; i2 -= 3)
            if (w = number3[i2] | number3[i2 - 1] << 8 | number3[i2 - 2] << 16, this.words[j] |= w << off & 67108863, this.words[j + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26)
              off -= 26, j++;
        } else if (endian === "le") {
          for (i2 = 0, j = 0;i2 < number3.length; i2 += 3)
            if (w = number3[i2] | number3[i2 + 1] << 8 | number3[i2 + 2] << 16, this.words[j] |= w << off & 67108863, this.words[j + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26)
              off -= 26, j++;
        }
        return this.strip();
      };
      function parseHex4Bits(string3, index) {
        var c = string3.charCodeAt(index);
        if (c >= 65 && c <= 70)
          return c - 55;
        else if (c >= 97 && c <= 102)
          return c - 87;
        else
          return c - 48 & 15;
      }
      function parseHexByte(string3, lowerBound, index) {
        var r = parseHex4Bits(string3, index);
        if (index - 1 >= lowerBound)
          r |= parseHex4Bits(string3, index - 1) << 4;
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number3, start, endian) {
        this.length = Math.ceil((number3.length - start) / 6), this.words = new Array(this.length);
        for (var i2 = 0;i2 < this.length; i2++)
          this.words[i2] = 0;
        var off = 0, j = 0, w;
        if (endian === "be")
          for (i2 = number3.length - 1;i2 >= start; i2 -= 2)
            if (w = parseHexByte(number3, start, i2) << off, this.words[j] |= w & 67108863, off >= 18)
              off -= 18, j += 1, this.words[j] |= w >>> 26;
            else
              off += 8;
        else {
          var parseLength = number3.length - start;
          for (i2 = parseLength % 2 === 0 ? start + 1 : start;i2 < number3.length; i2 += 2)
            if (w = parseHexByte(number3, start, i2) << off, this.words[j] |= w & 67108863, off >= 18)
              off -= 18, j += 1, this.words[j] |= w >>> 26;
            else
              off += 8;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0, len2 = Math.min(str.length, end);
        for (var i2 = start;i2 < len2; i2++) {
          var c = str.charCodeAt(i2) - 48;
          if (r *= mul, c >= 49)
            r += c - 49 + 10;
          else if (c >= 17)
            r += c - 17 + 10;
          else
            r += c;
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number3, base, start) {
        this.words = [0], this.length = 1;
        for (var limbLen = 0, limbPow = 1;limbPow <= 67108863; limbPow *= base)
          limbLen++;
        limbLen--, limbPow = limbPow / base | 0;
        var total = number3.length - start, mod = total % limbLen, end = Math.min(total, total - mod) + start, word = 0;
        for (var i2 = start;i2 < end; i2 += limbLen)
          if (word = parseBase(number3, i2, i2 + limbLen, base), this.imuln(limbPow), this.words[0] + word < 67108864)
            this.words[0] += word;
          else
            this._iaddn(word);
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number3, i2, number3.length, base);
          for (i2 = 0;i2 < mod; i2++)
            pow *= base;
          if (this.imuln(pow), this.words[0] + word < 67108864)
            this.words[0] += word;
          else
            this._iaddn(word);
        }
        this.strip();
      }, BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i2 = 0;i2 < this.length; i2++)
          dest.words[i2] = this.words[i2];
        dest.length = this.length, dest.negative = this.negative, dest.red = this.red;
      }, BN.prototype.clone = function clone() {
        var r = new BN(null);
        return this.copy(r), r;
      }, BN.prototype._expand = function _expand(size) {
        while (this.length < size)
          this.words[this.length++] = 0;
        return this;
      }, BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0)
          this.length--;
        return this._normSign();
      }, BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0)
          this.negative = 0;
        return this;
      }, BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      if (BN.prototype.toString = function toString(base, padding) {
        base = base || 10, padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0, carry = 0;
          for (var i2 = 0;i2 < this.length; i2++) {
            var w = this.words[i2], word = ((w << off | carry) & 16777215).toString(16);
            if (carry = w >>> 24 - off & 16777215, off += 2, off >= 26)
              off -= 26, i2--;
            if (carry !== 0 || i2 !== this.length - 1)
              out = zeros[6 - word.length] + word + out;
            else
              out = word + out;
          }
          if (carry !== 0)
            out = carry.toString(16) + out;
          while (out.length % padding !== 0)
            out = "0" + out;
          if (this.negative !== 0)
            out = "-" + out;
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base], groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            if (c = c.idivn(groupBase), !c.isZero())
              out = zeros[groupSize - r.length] + r + out;
            else
              out = r + out;
          }
          if (this.isZero())
            out = "0" + out;
          while (out.length % padding !== 0)
            out = "0" + out;
          if (this.negative !== 0)
            out = "-" + out;
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      }, BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2)
          ret += this.words[1] * 67108864;
        else if (this.length === 3 && this.words[2] === 1)
          ret += 4503599627370496 + this.words[1] * 67108864;
        else if (this.length > 2)
          assert(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -ret : ret;
      }, BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      }, BN.prototype.toBuffer = function toBuffer(endian, length) {
        return assert(typeof Buffer22 !== "undefined"), this.toArrayLike(Buffer22, endian, length);
      }, BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      }, BN.prototype.toArrayLike = function toArrayLike(ArrayType7, endian, length) {
        var byteLength2 = this.byteLength(), reqLength = length || Math.max(1, byteLength2);
        assert(byteLength2 <= reqLength, "byte array longer than desired length"), assert(reqLength > 0, "Requested array length <= 0"), this.strip();
        var littleEndian = endian === "le", res = new ArrayType7(reqLength), b, i2, q = this.clone();
        if (!littleEndian) {
          for (i2 = 0;i2 < reqLength - byteLength2; i2++)
            res[i2] = 0;
          for (i2 = 0;!q.isZero(); i2++)
            b = q.andln(255), q.iushrn(8), res[reqLength - i2 - 1] = b;
        } else {
          for (i2 = 0;!q.isZero(); i2++)
            b = q.andln(255), q.iushrn(8), res[i2] = b;
          for (;i2 < reqLength; i2++)
            res[i2] = 0;
        }
        return res;
      }, Math.clz32)
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      else
        BN.prototype._countBits = function _countBits(w) {
          var t2 = w, r = 0;
          if (t2 >= 4096)
            r += 13, t2 >>>= 13;
          if (t2 >= 64)
            r += 7, t2 >>>= 7;
          if (t2 >= 8)
            r += 4, t2 >>>= 4;
          if (t2 >= 2)
            r += 2, t2 >>>= 2;
          return r + t2;
        };
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t2 = w, r = 0;
        if ((t2 & 8191) === 0)
          r += 13, t2 >>>= 13;
        if ((t2 & 127) === 0)
          r += 7, t2 >>>= 7;
        if ((t2 & 15) === 0)
          r += 4, t2 >>>= 4;
        if ((t2 & 3) === 0)
          r += 2, t2 >>>= 2;
        if ((t2 & 1) === 0)
          r++;
        return r;
      }, BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1], hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0;bit < w.length; bit++) {
          var off = bit / 26 | 0, wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i2 = 0;i2 < this.length; i2++) {
          var b = this._zeroBits(this.words[i2]);
          if (r += b, b !== 26)
            break;
        }
        return r;
      }, BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      }, BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0)
          return this.abs().inotn(width).iaddn(1);
        return this.clone();
      }, BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1))
          return this.notn(width).iaddn(1).ineg();
        return this.clone();
      }, BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      }, BN.prototype.neg = function neg() {
        return this.clone().ineg();
      }, BN.prototype.ineg = function ineg() {
        if (!this.isZero())
          this.negative ^= 1;
        return this;
      }, BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length)
          this.words[this.length++] = 0;
        for (var i2 = 0;i2 < num.length; i2++)
          this.words[i2] = this.words[i2] | num.words[i2];
        return this.strip();
      }, BN.prototype.ior = function ior(num) {
        return assert((this.negative | num.negative) === 0), this.iuor(num);
      }, BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      }, BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      }, BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length)
          b = num;
        else
          b = this;
        for (var i2 = 0;i2 < b.length; i2++)
          this.words[i2] = this.words[i2] & num.words[i2];
        return this.length = b.length, this.strip();
      }, BN.prototype.iand = function iand(num) {
        return assert((this.negative | num.negative) === 0), this.iuand(num);
      }, BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      }, BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      }, BN.prototype.iuxor = function iuxor(num) {
        var a, b;
        if (this.length > num.length)
          a = this, b = num;
        else
          a = num, b = this;
        for (var i2 = 0;i2 < b.length; i2++)
          this.words[i2] = a.words[i2] ^ b.words[i2];
        if (this !== a)
          for (;i2 < a.length; i2++)
            this.words[i2] = a.words[i2];
        return this.length = a.length, this.strip();
      }, BN.prototype.ixor = function ixor(num) {
        return assert((this.negative | num.negative) === 0), this.iuxor(num);
      }, BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      }, BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      }, BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0, bitsLeft = width % 26;
        if (this._expand(bytesNeeded), bitsLeft > 0)
          bytesNeeded--;
        for (var i2 = 0;i2 < bytesNeeded; i2++)
          this.words[i2] = ~this.words[i2] & 67108863;
        if (bitsLeft > 0)
          this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
        return this.strip();
      }, BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      }, BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0, wbit = bit % 26;
        if (this._expand(off + 1), val)
          this.words[off] = this.words[off] | 1 << wbit;
        else
          this.words[off] = this.words[off] & ~(1 << wbit);
        return this.strip();
      }, BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0)
          return this.negative = 0, r = this.isub(num), this.negative ^= 1, this._normSign();
        else if (this.negative === 0 && num.negative !== 0)
          return num.negative = 0, r = this.isub(num), num.negative = 1, r._normSign();
        var a, b;
        if (this.length > num.length)
          a = this, b = num;
        else
          a = num, b = this;
        var carry = 0;
        for (var i2 = 0;i2 < b.length; i2++)
          r = (a.words[i2] | 0) + (b.words[i2] | 0) + carry, this.words[i2] = r & 67108863, carry = r >>> 26;
        for (;carry !== 0 && i2 < a.length; i2++)
          r = (a.words[i2] | 0) + carry, this.words[i2] = r & 67108863, carry = r >>> 26;
        if (this.length = a.length, carry !== 0)
          this.words[this.length] = carry, this.length++;
        else if (a !== this)
          for (;i2 < a.length; i2++)
            this.words[i2] = a.words[i2];
        return this;
      }, BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0)
          return num.negative = 0, res = this.sub(num), num.negative ^= 1, res;
        else if (num.negative === 0 && this.negative !== 0)
          return this.negative = 0, res = num.sub(this), this.negative = 1, res;
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      }, BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          return num.negative = 1, r._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(num), this.negative = 1, this._normSign();
        var cmp = this.cmp(num);
        if (cmp === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var a, b;
        if (cmp > 0)
          a = this, b = num;
        else
          a = num, b = this;
        var carry = 0;
        for (var i2 = 0;i2 < b.length; i2++)
          r = (a.words[i2] | 0) - (b.words[i2] | 0) + carry, carry = r >> 26, this.words[i2] = r & 67108863;
        for (;carry !== 0 && i2 < a.length; i2++)
          r = (a.words[i2] | 0) + carry, carry = r >> 26, this.words[i2] = r & 67108863;
        if (carry === 0 && i2 < a.length && a !== this)
          for (;i2 < a.length; i2++)
            this.words[i2] = a.words[i2];
        if (this.length = Math.max(this.length, i2), a !== this)
          this.negative = 1;
        return this.strip();
      }, BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len2 = self2.length + num.length | 0;
        out.length = len2, len2 = len2 - 1 | 0;
        var a = self2.words[0] | 0, b = num.words[0] | 0, r = a * b, lo = r & 67108863, carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1;k < len2; k++) {
          var ncarry = carry >>> 26, rword = carry & 67108863, maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
            var i2 = k - j | 0;
            a = self2.words[i2] | 0, b = num.words[j] | 0, r = a * b + rword, ncarry += r / 67108864 | 0, rword = r & 67108863;
          }
          out.words[k] = rword | 0, carry = ncarry | 0;
        }
        if (carry !== 0)
          out.words[k] = carry | 0;
        else
          out.length--;
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo(self2, num, out) {
        var a = self2.words, b = num.words, o = out.words, c = 0, lo, mid, hi, a0 = a[0] | 0, al0 = a0 & 8191, ah0 = a0 >>> 13, a1 = a[1] | 0, al1 = a1 & 8191, ah1 = a1 >>> 13, a2 = a[2] | 0, al2 = a2 & 8191, ah2 = a2 >>> 13, a3 = a[3] | 0, al3 = a3 & 8191, ah3 = a3 >>> 13, a4 = a[4] | 0, al4 = a4 & 8191, ah4 = a4 >>> 13, a5 = a[5] | 0, al5 = a5 & 8191, ah5 = a5 >>> 13, a6 = a[6] | 0, al6 = a6 & 8191, ah6 = a6 >>> 13, a7 = a[7] | 0, al7 = a7 & 8191, ah7 = a7 >>> 13, a8 = a[8] | 0, al8 = a8 & 8191, ah8 = a8 >>> 13, a9 = a[9] | 0, al9 = a9 & 8191, ah9 = a9 >>> 13, b0 = b[0] | 0, bl0 = b0 & 8191, bh0 = b0 >>> 13, b1 = b[1] | 0, bl1 = b1 & 8191, bh1 = b1 >>> 13, b2 = b[2] | 0, bl2 = b2 & 8191, bh2 = b2 >>> 13, b3 = b[3] | 0, bl3 = b3 & 8191, bh3 = b3 >>> 13, b4 = b[4] | 0, bl4 = b4 & 8191, bh4 = b4 >>> 13, b5 = b[5] | 0, bl5 = b5 & 8191, bh5 = b5 >>> 13, b6 = b[6] | 0, bl6 = b6 & 8191, bh6 = b6 >>> 13, b7 = b[7] | 0, bl7 = b7 & 8191, bh7 = b7 >>> 13, b8 = b[8] | 0, bl8 = b8 & 8191, bh8 = b8 >>> 13, b9 = b[9] | 0, bl9 = b9 & 8191, bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative, out.length = 19, lo = Math.imul(al0, bl0), mid = Math.imul(al0, bh0), mid = mid + Math.imul(ah0, bl0) | 0, hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0, w0 &= 67108863, lo = Math.imul(al1, bl0), mid = Math.imul(al1, bh0), mid = mid + Math.imul(ah1, bl0) | 0, hi = Math.imul(ah1, bh0), lo = lo + Math.imul(al0, bl1) | 0, mid = mid + Math.imul(al0, bh1) | 0, mid = mid + Math.imul(ah0, bl1) | 0, hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0, w1 &= 67108863, lo = Math.imul(al2, bl0), mid = Math.imul(al2, bh0), mid = mid + Math.imul(ah2, bl0) | 0, hi = Math.imul(ah2, bh0), lo = lo + Math.imul(al1, bl1) | 0, mid = mid + Math.imul(al1, bh1) | 0, mid = mid + Math.imul(ah1, bl1) | 0, hi = hi + Math.imul(ah1, bh1) | 0, lo = lo + Math.imul(al0, bl2) | 0, mid = mid + Math.imul(al0, bh2) | 0, mid = mid + Math.imul(ah0, bl2) | 0, hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0, w2 &= 67108863, lo = Math.imul(al3, bl0), mid = Math.imul(al3, bh0), mid = mid + Math.imul(ah3, bl0) | 0, hi = Math.imul(ah3, bh0), lo = lo + Math.imul(al2, bl1) | 0, mid = mid + Math.imul(al2, bh1) | 0, mid = mid + Math.imul(ah2, bl1) | 0, hi = hi + Math.imul(ah2, bh1) | 0, lo = lo + Math.imul(al1, bl2) | 0, mid = mid + Math.imul(al1, bh2) | 0, mid = mid + Math.imul(ah1, bl2) | 0, hi = hi + Math.imul(ah1, bh2) | 0, lo = lo + Math.imul(al0, bl3) | 0, mid = mid + Math.imul(al0, bh3) | 0, mid = mid + Math.imul(ah0, bl3) | 0, hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0, w3 &= 67108863, lo = Math.imul(al4, bl0), mid = Math.imul(al4, bh0), mid = mid + Math.imul(ah4, bl0) | 0, hi = Math.imul(ah4, bh0), lo = lo + Math.imul(al3, bl1) | 0, mid = mid + Math.imul(al3, bh1) | 0, mid = mid + Math.imul(ah3, bl1) | 0, hi = hi + Math.imul(ah3, bh1) | 0, lo = lo + Math.imul(al2, bl2) | 0, mid = mid + Math.imul(al2, bh2) | 0, mid = mid + Math.imul(ah2, bl2) | 0, hi = hi + Math.imul(ah2, bh2) | 0, lo = lo + Math.imul(al1, bl3) | 0, mid = mid + Math.imul(al1, bh3) | 0, mid = mid + Math.imul(ah1, bl3) | 0, hi = hi + Math.imul(ah1, bh3) | 0, lo = lo + Math.imul(al0, bl4) | 0, mid = mid + Math.imul(al0, bh4) | 0, mid = mid + Math.imul(ah0, bl4) | 0, hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0, w4 &= 67108863, lo = Math.imul(al5, bl0), mid = Math.imul(al5, bh0), mid = mid + Math.imul(ah5, bl0) | 0, hi = Math.imul(ah5, bh0), lo = lo + Math.imul(al4, bl1) | 0, mid = mid + Math.imul(al4, bh1) | 0, mid = mid + Math.imul(ah4, bl1) | 0, hi = hi + Math.imul(ah4, bh1) | 0, lo = lo + Math.imul(al3, bl2) | 0, mid = mid + Math.imul(al3, bh2) | 0, mid = mid + Math.imul(ah3, bl2) | 0, hi = hi + Math.imul(ah3, bh2) | 0, lo = lo + Math.imul(al2, bl3) | 0, mid = mid + Math.imul(al2, bh3) | 0, mid = mid + Math.imul(ah2, bl3) | 0, hi = hi + Math.imul(ah2, bh3) | 0, lo = lo + Math.imul(al1, bl4) | 0, mid = mid + Math.imul(al1, bh4) | 0, mid = mid + Math.imul(ah1, bl4) | 0, hi = hi + Math.imul(ah1, bh4) | 0, lo = lo + Math.imul(al0, bl5) | 0, mid = mid + Math.imul(al0, bh5) | 0, mid = mid + Math.imul(ah0, bl5) | 0, hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0, w5 &= 67108863, lo = Math.imul(al6, bl0), mid = Math.imul(al6, bh0), mid = mid + Math.imul(ah6, bl0) | 0, hi = Math.imul(ah6, bh0), lo = lo + Math.imul(al5, bl1) | 0, mid = mid + Math.imul(al5, bh1) | 0, mid = mid + Math.imul(ah5, bl1) | 0, hi = hi + Math.imul(ah5, bh1) | 0, lo = lo + Math.imul(al4, bl2) | 0, mid = mid + Math.imul(al4, bh2) | 0, mid = mid + Math.imul(ah4, bl2) | 0, hi = hi + Math.imul(ah4, bh2) | 0, lo = lo + Math.imul(al3, bl3) | 0, mid = mid + Math.imul(al3, bh3) | 0, mid = mid + Math.imul(ah3, bl3) | 0, hi = hi + Math.imul(ah3, bh3) | 0, lo = lo + Math.imul(al2, bl4) | 0, mid = mid + Math.imul(al2, bh4) | 0, mid = mid + Math.imul(ah2, bl4) | 0, hi = hi + Math.imul(ah2, bh4) | 0, lo = lo + Math.imul(al1, bl5) | 0, mid = mid + Math.imul(al1, bh5) | 0, mid = mid + Math.imul(ah1, bl5) | 0, hi = hi + Math.imul(ah1, bh5) | 0, lo = lo + Math.imul(al0, bl6) | 0, mid = mid + Math.imul(al0, bh6) | 0, mid = mid + Math.imul(ah0, bl6) | 0, hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0, w6 &= 67108863, lo = Math.imul(al7, bl0), mid = Math.imul(al7, bh0), mid = mid + Math.imul(ah7, bl0) | 0, hi = Math.imul(ah7, bh0), lo = lo + Math.imul(al6, bl1) | 0, mid = mid + Math.imul(al6, bh1) | 0, mid = mid + Math.imul(ah6, bl1) | 0, hi = hi + Math.imul(ah6, bh1) | 0, lo = lo + Math.imul(al5, bl2) | 0, mid = mid + Math.imul(al5, bh2) | 0, mid = mid + Math.imul(ah5, bl2) | 0, hi = hi + Math.imul(ah5, bh2) | 0, lo = lo + Math.imul(al4, bl3) | 0, mid = mid + Math.imul(al4, bh3) | 0, mid = mid + Math.imul(ah4, bl3) | 0, hi = hi + Math.imul(ah4, bh3) | 0, lo = lo + Math.imul(al3, bl4) | 0, mid = mid + Math.imul(al3, bh4) | 0, mid = mid + Math.imul(ah3, bl4) | 0, hi = hi + Math.imul(ah3, bh4) | 0, lo = lo + Math.imul(al2, bl5) | 0, mid = mid + Math.imul(al2, bh5) | 0, mid = mid + Math.imul(ah2, bl5) | 0, hi = hi + Math.imul(ah2, bh5) | 0, lo = lo + Math.imul(al1, bl6) | 0, mid = mid + Math.imul(al1, bh6) | 0, mid = mid + Math.imul(ah1, bl6) | 0, hi = hi + Math.imul(ah1, bh6) | 0, lo = lo + Math.imul(al0, bl7) | 0, mid = mid + Math.imul(al0, bh7) | 0, mid = mid + Math.imul(ah0, bl7) | 0, hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0, w7 &= 67108863, lo = Math.imul(al8, bl0), mid = Math.imul(al8, bh0), mid = mid + Math.imul(ah8, bl0) | 0, hi = Math.imul(ah8, bh0), lo = lo + Math.imul(al7, bl1) | 0, mid = mid + Math.imul(al7, bh1) | 0, mid = mid + Math.imul(ah7, bl1) | 0, hi = hi + Math.imul(ah7, bh1) | 0, lo = lo + Math.imul(al6, bl2) | 0, mid = mid + Math.imul(al6, bh2) | 0, mid = mid + Math.imul(ah6, bl2) | 0, hi = hi + Math.imul(ah6, bh2) | 0, lo = lo + Math.imul(al5, bl3) | 0, mid = mid + Math.imul(al5, bh3) | 0, mid = mid + Math.imul(ah5, bl3) | 0, hi = hi + Math.imul(ah5, bh3) | 0, lo = lo + Math.imul(al4, bl4) | 0, mid = mid + Math.imul(al4, bh4) | 0, mid = mid + Math.imul(ah4, bl4) | 0, hi = hi + Math.imul(ah4, bh4) | 0, lo = lo + Math.imul(al3, bl5) | 0, mid = mid + Math.imul(al3, bh5) | 0, mid = mid + Math.imul(ah3, bl5) | 0, hi = hi + Math.imul(ah3, bh5) | 0, lo = lo + Math.imul(al2, bl6) | 0, mid = mid + Math.imul(al2, bh6) | 0, mid = mid + Math.imul(ah2, bl6) | 0, hi = hi + Math.imul(ah2, bh6) | 0, lo = lo + Math.imul(al1, bl7) | 0, mid = mid + Math.imul(al1, bh7) | 0, mid = mid + Math.imul(ah1, bl7) | 0, hi = hi + Math.imul(ah1, bh7) | 0, lo = lo + Math.imul(al0, bl8) | 0, mid = mid + Math.imul(al0, bh8) | 0, mid = mid + Math.imul(ah0, bl8) | 0, hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0, w8 &= 67108863, lo = Math.imul(al9, bl0), mid = Math.imul(al9, bh0), mid = mid + Math.imul(ah9, bl0) | 0, hi = Math.imul(ah9, bh0), lo = lo + Math.imul(al8, bl1) | 0, mid = mid + Math.imul(al8, bh1) | 0, mid = mid + Math.imul(ah8, bl1) | 0, hi = hi + Math.imul(ah8, bh1) | 0, lo = lo + Math.imul(al7, bl2) | 0, mid = mid + Math.imul(al7, bh2) | 0, mid = mid + Math.imul(ah7, bl2) | 0, hi = hi + Math.imul(ah7, bh2) | 0, lo = lo + Math.imul(al6, bl3) | 0, mid = mid + Math.imul(al6, bh3) | 0, mid = mid + Math.imul(ah6, bl3) | 0, hi = hi + Math.imul(ah6, bh3) | 0, lo = lo + Math.imul(al5, bl4) | 0, mid = mid + Math.imul(al5, bh4) | 0, mid = mid + Math.imul(ah5, bl4) | 0, hi = hi + Math.imul(ah5, bh4) | 0, lo = lo + Math.imul(al4, bl5) | 0, mid = mid + Math.imul(al4, bh5) | 0, mid = mid + Math.imul(ah4, bl5) | 0, hi = hi + Math.imul(ah4, bh5) | 0, lo = lo + Math.imul(al3, bl6) | 0, mid = mid + Math.imul(al3, bh6) | 0, mid = mid + Math.imul(ah3, bl6) | 0, hi = hi + Math.imul(ah3, bh6) | 0, lo = lo + Math.imul(al2, bl7) | 0, mid = mid + Math.imul(al2, bh7) | 0, mid = mid + Math.imul(ah2, bl7) | 0, hi = hi + Math.imul(ah2, bh7) | 0, lo = lo + Math.imul(al1, bl8) | 0, mid = mid + Math.imul(al1, bh8) | 0, mid = mid + Math.imul(ah1, bl8) | 0, hi = hi + Math.imul(ah1, bh8) | 0, lo = lo + Math.imul(al0, bl9) | 0, mid = mid + Math.imul(al0, bh9) | 0, mid = mid + Math.imul(ah0, bl9) | 0, hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0, w9 &= 67108863, lo = Math.imul(al9, bl1), mid = Math.imul(al9, bh1), mid = mid + Math.imul(ah9, bl1) | 0, hi = Math.imul(ah9, bh1), lo = lo + Math.imul(al8, bl2) | 0, mid = mid + Math.imul(al8, bh2) | 0, mid = mid + Math.imul(ah8, bl2) | 0, hi = hi + Math.imul(ah8, bh2) | 0, lo = lo + Math.imul(al7, bl3) | 0, mid = mid + Math.imul(al7, bh3) | 0, mid = mid + Math.imul(ah7, bl3) | 0, hi = hi + Math.imul(ah7, bh3) | 0, lo = lo + Math.imul(al6, bl4) | 0, mid = mid + Math.imul(al6, bh4) | 0, mid = mid + Math.imul(ah6, bl4) | 0, hi = hi + Math.imul(ah6, bh4) | 0, lo = lo + Math.imul(al5, bl5) | 0, mid = mid + Math.imul(al5, bh5) | 0, mid = mid + Math.imul(ah5, bl5) | 0, hi = hi + Math.imul(ah5, bh5) | 0, lo = lo + Math.imul(al4, bl6) | 0, mid = mid + Math.imul(al4, bh6) | 0, mid = mid + Math.imul(ah4, bl6) | 0, hi = hi + Math.imul(ah4, bh6) | 0, lo = lo + Math.imul(al3, bl7) | 0, mid = mid + Math.imul(al3, bh7) | 0, mid = mid + Math.imul(ah3, bl7) | 0, hi = hi + Math.imul(ah3, bh7) | 0, lo = lo + Math.imul(al2, bl8) | 0, mid = mid + Math.imul(al2, bh8) | 0, mid = mid + Math.imul(ah2, bl8) | 0, hi = hi + Math.imul(ah2, bh8) | 0, lo = lo + Math.imul(al1, bl9) | 0, mid = mid + Math.imul(al1, bh9) | 0, mid = mid + Math.imul(ah1, bl9) | 0, hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0, w10 &= 67108863, lo = Math.imul(al9, bl2), mid = Math.imul(al9, bh2), mid = mid + Math.imul(ah9, bl2) | 0, hi = Math.imul(ah9, bh2), lo = lo + Math.imul(al8, bl3) | 0, mid = mid + Math.imul(al8, bh3) | 0, mid = mid + Math.imul(ah8, bl3) | 0, hi = hi + Math.imul(ah8, bh3) | 0, lo = lo + Math.imul(al7, bl4) | 0, mid = mid + Math.imul(al7, bh4) | 0, mid = mid + Math.imul(ah7, bl4) | 0, hi = hi + Math.imul(ah7, bh4) | 0, lo = lo + Math.imul(al6, bl5) | 0, mid = mid + Math.imul(al6, bh5) | 0, mid = mid + Math.imul(ah6, bl5) | 0, hi = hi + Math.imul(ah6, bh5) | 0, lo = lo + Math.imul(al5, bl6) | 0, mid = mid + Math.imul(al5, bh6) | 0, mid = mid + Math.imul(ah5, bl6) | 0, hi = hi + Math.imul(ah5, bh6) | 0, lo = lo + Math.imul(al4, bl7) | 0, mid = mid + Math.imul(al4, bh7) | 0, mid = mid + Math.imul(ah4, bl7) | 0, hi = hi + Math.imul(ah4, bh7) | 0, lo = lo + Math.imul(al3, bl8) | 0, mid = mid + Math.imul(al3, bh8) | 0, mid = mid + Math.imul(ah3, bl8) | 0, hi = hi + Math.imul(ah3, bh8) | 0, lo = lo + Math.imul(al2, bl9) | 0, mid = mid + Math.imul(al2, bh9) | 0, mid = mid + Math.imul(ah2, bl9) | 0, hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0, w11 &= 67108863, lo = Math.imul(al9, bl3), mid = Math.imul(al9, bh3), mid = mid + Math.imul(ah9, bl3) | 0, hi = Math.imul(ah9, bh3), lo = lo + Math.imul(al8, bl4) | 0, mid = mid + Math.imul(al8, bh4) | 0, mid = mid + Math.imul(ah8, bl4) | 0, hi = hi + Math.imul(ah8, bh4) | 0, lo = lo + Math.imul(al7, bl5) | 0, mid = mid + Math.imul(al7, bh5) | 0, mid = mid + Math.imul(ah7, bl5) | 0, hi = hi + Math.imul(ah7, bh5) | 0, lo = lo + Math.imul(al6, bl6) | 0, mid = mid + Math.imul(al6, bh6) | 0, mid = mid + Math.imul(ah6, bl6) | 0, hi = hi + Math.imul(ah6, bh6) | 0, lo = lo + Math.imul(al5, bl7) | 0, mid = mid + Math.imul(al5, bh7) | 0, mid = mid + Math.imul(ah5, bl7) | 0, hi = hi + Math.imul(ah5, bh7) | 0, lo = lo + Math.imul(al4, bl8) | 0, mid = mid + Math.imul(al4, bh8) | 0, mid = mid + Math.imul(ah4, bl8) | 0, hi = hi + Math.imul(ah4, bh8) | 0, lo = lo + Math.imul(al3, bl9) | 0, mid = mid + Math.imul(al3, bh9) | 0, mid = mid + Math.imul(ah3, bl9) | 0, hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0, w12 &= 67108863, lo = Math.imul(al9, bl4), mid = Math.imul(al9, bh4), mid = mid + Math.imul(ah9, bl4) | 0, hi = Math.imul(ah9, bh4), lo = lo + Math.imul(al8, bl5) | 0, mid = mid + Math.imul(al8, bh5) | 0, mid = mid + Math.imul(ah8, bl5) | 0, hi = hi + Math.imul(ah8, bh5) | 0, lo = lo + Math.imul(al7, bl6) | 0, mid = mid + Math.imul(al7, bh6) | 0, mid = mid + Math.imul(ah7, bl6) | 0, hi = hi + Math.imul(ah7, bh6) | 0, lo = lo + Math.imul(al6, bl7) | 0, mid = mid + Math.imul(al6, bh7) | 0, mid = mid + Math.imul(ah6, bl7) | 0, hi = hi + Math.imul(ah6, bh7) | 0, lo = lo + Math.imul(al5, bl8) | 0, mid = mid + Math.imul(al5, bh8) | 0, mid = mid + Math.imul(ah5, bl8) | 0, hi = hi + Math.imul(ah5, bh8) | 0, lo = lo + Math.imul(al4, bl9) | 0, mid = mid + Math.imul(al4, bh9) | 0, mid = mid + Math.imul(ah4, bl9) | 0, hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0, w13 &= 67108863, lo = Math.imul(al9, bl5), mid = Math.imul(al9, bh5), mid = mid + Math.imul(ah9, bl5) | 0, hi = Math.imul(ah9, bh5), lo = lo + Math.imul(al8, bl6) | 0, mid = mid + Math.imul(al8, bh6) | 0, mid = mid + Math.imul(ah8, bl6) | 0, hi = hi + Math.imul(ah8, bh6) | 0, lo = lo + Math.imul(al7, bl7) | 0, mid = mid + Math.imul(al7, bh7) | 0, mid = mid + Math.imul(ah7, bl7) | 0, hi = hi + Math.imul(ah7, bh7) | 0, lo = lo + Math.imul(al6, bl8) | 0, mid = mid + Math.imul(al6, bh8) | 0, mid = mid + Math.imul(ah6, bl8) | 0, hi = hi + Math.imul(ah6, bh8) | 0, lo = lo + Math.imul(al5, bl9) | 0, mid = mid + Math.imul(al5, bh9) | 0, mid = mid + Math.imul(ah5, bl9) | 0, hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0, w14 &= 67108863, lo = Math.imul(al9, bl6), mid = Math.imul(al9, bh6), mid = mid + Math.imul(ah9, bl6) | 0, hi = Math.imul(ah9, bh6), lo = lo + Math.imul(al8, bl7) | 0, mid = mid + Math.imul(al8, bh7) | 0, mid = mid + Math.imul(ah8, bl7) | 0, hi = hi + Math.imul(ah8, bh7) | 0, lo = lo + Math.imul(al7, bl8) | 0, mid = mid + Math.imul(al7, bh8) | 0, mid = mid + Math.imul(ah7, bl8) | 0, hi = hi + Math.imul(ah7, bh8) | 0, lo = lo + Math.imul(al6, bl9) | 0, mid = mid + Math.imul(al6, bh9) | 0, mid = mid + Math.imul(ah6, bl9) | 0, hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0, w15 &= 67108863, lo = Math.imul(al9, bl7), mid = Math.imul(al9, bh7), mid = mid + Math.imul(ah9, bl7) | 0, hi = Math.imul(ah9, bh7), lo = lo + Math.imul(al8, bl8) | 0, mid = mid + Math.imul(al8, bh8) | 0, mid = mid + Math.imul(ah8, bl8) | 0, hi = hi + Math.imul(ah8, bh8) | 0, lo = lo + Math.imul(al7, bl9) | 0, mid = mid + Math.imul(al7, bh9) | 0, mid = mid + Math.imul(ah7, bl9) | 0, hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0, w16 &= 67108863, lo = Math.imul(al9, bl8), mid = Math.imul(al9, bh8), mid = mid + Math.imul(ah9, bl8) | 0, hi = Math.imul(ah9, bh8), lo = lo + Math.imul(al8, bl9) | 0, mid = mid + Math.imul(al8, bh9) | 0, mid = mid + Math.imul(ah8, bl9) | 0, hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0, w17 &= 67108863, lo = Math.imul(al9, bl9), mid = Math.imul(al9, bh9), mid = mid + Math.imul(ah9, bl9) | 0, hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        if (c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0, w18 &= 67108863, o[0] = w0, o[1] = w1, o[2] = w2, o[3] = w3, o[4] = w4, o[5] = w5, o[6] = w6, o[7] = w7, o[8] = w8, o[9] = w9, o[10] = w10, o[11] = w11, o[12] = w12, o[13] = w13, o[14] = w14, o[15] = w15, o[16] = w16, o[17] = w17, o[18] = w18, c !== 0)
          o[19] = c, out.length++;
        return out;
      };
      if (!Math.imul)
        comb10MulTo = smallMulTo;
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative, out.length = self2.length + num.length;
        var carry = 0, hncarry = 0;
        for (var k = 0;k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863, maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
            var i2 = k - j, a = self2.words[i2] | 0, b = num.words[j] | 0, r = a * b, lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0, lo = lo + rword | 0, rword = lo & 67108863, ncarry = ncarry + (lo >>> 26) | 0, hncarry += ncarry >>> 26, ncarry &= 67108863;
          }
          out.words[k] = rword, carry = ncarry, ncarry = hncarry;
        }
        if (carry !== 0)
          out.words[k] = carry;
        else
          out.length--;
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM;
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res, len2 = this.length + num.length;
        if (this.length === 10 && num.length === 10)
          res = comb10MulTo(this, num, out);
        else if (len2 < 63)
          res = smallMulTo(this, num, out);
        else if (len2 < 1024)
          res = bigMulTo(this, num, out);
        else
          res = jumboMulTo(this, num, out);
        return res;
      };
      function FFTM(x, y) {
        this.x = x, this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t2 = new Array(N), l = BN.prototype._countBits(N) - 1;
        for (var i2 = 0;i2 < N; i2++)
          t2[i2] = this.revBin(i2, l, N);
        return t2;
      }, FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i2 = 0;i2 < l; i2++)
          rb |= (x & 1) << l - i2 - 1, x >>= 1;
        return rb;
      }, FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i2 = 0;i2 < N; i2++)
          rtws[i2] = rws[rbt[i2]], itws[i2] = iws[rbt[i2]];
      }, FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1;s < N; s <<= 1) {
          var l = s << 1, rtwdf = Math.cos(2 * Math.PI / l), itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0;p < N; p += l) {
            var rtwdf_ = rtwdf, itwdf_ = itwdf;
            for (var j = 0;j < s; j++) {
              var re = rtws[p + j], ie = itws[p + j], ro = rtws[p + j + s], io = itws[p + j + s], rx = rtwdf_ * ro - itwdf_ * io;
              if (io = rtwdf_ * io + itwdf_ * ro, ro = rx, rtws[p + j] = re + ro, itws[p + j] = ie + io, rtws[p + j + s] = re - ro, itws[p + j + s] = ie - io, j !== l)
                rx = rtwdf * rtwdf_ - itwdf * itwdf_, itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_, rtwdf_ = rx;
            }
          }
        }
      }, FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1, odd = N & 1, i2 = 0;
        for (N = N / 2 | 0;N; N = N >>> 1)
          i2++;
        return 1 << i2 + 1 + odd;
      }, FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i2 = 0;i2 < N / 2; i2++) {
          var t2 = rws[i2];
          rws[i2] = rws[N - i2 - 1], rws[N - i2 - 1] = t2, t2 = iws[i2], iws[i2] = -iws[N - i2 - 1], iws[N - i2 - 1] = -t2;
        }
      }, FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i2 = 0;i2 < N / 2; i2++) {
          var w = Math.round(ws[2 * i2 + 1] / N) * 8192 + Math.round(ws[2 * i2] / N) + carry;
          if (ws[i2] = w & 67108863, w < 67108864)
            carry = 0;
          else
            carry = w / 67108864 | 0;
        }
        return ws;
      }, FFTM.prototype.convert13b = function convert13b(ws, len2, rws, N) {
        var carry = 0;
        for (var i2 = 0;i2 < len2; i2++)
          carry = carry + (ws[i2] | 0), rws[2 * i2] = carry & 8191, carry = carry >>> 13, rws[2 * i2 + 1] = carry & 8191, carry = carry >>> 13;
        for (i2 = 2 * len2;i2 < N; ++i2)
          rws[i2] = 0;
        assert(carry === 0), assert((carry & -8192) === 0);
      }, FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i2 = 0;i2 < N; i2++)
          ph[i2] = 0;
        return ph;
      }, FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length), rbt = this.makeRBT(N), _ = this.stub(N), rws = new Array(N), rwst = new Array(N), iwst = new Array(N), nrws = new Array(N), nrwst = new Array(N), niwst = new Array(N), rmws = out.words;
        rmws.length = N, this.convert13b(x.words, x.length, rws, N), this.convert13b(y.words, y.length, nrws, N), this.transform(rws, _, rwst, iwst, N, rbt), this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i2 = 0;i2 < N; i2++) {
          var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
          iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2], rwst[i2] = rx;
        }
        return this.conjugate(rwst, iwst, N), this.transform(rwst, iwst, rmws, _, N, rbt), this.conjugate(rmws, _, N), this.normalize13b(rmws, N), out.negative = x.negative ^ y.negative, out.length = x.length + y.length, out.strip();
      }, BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        return out.words = new Array(this.length + num.length), this.mulTo(num, out);
      }, BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        return out.words = new Array(this.length + num.length), jumboMulTo(this, num, out);
      }, BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      }, BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number"), assert(num < 67108864);
        var carry = 0;
        for (var i2 = 0;i2 < this.length; i2++) {
          var w = (this.words[i2] | 0) * num, lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26, carry += w / 67108864 | 0, carry += lo >>> 26, this.words[i2] = lo & 67108863;
        }
        if (carry !== 0)
          this.words[i2] = carry, this.length++;
        return this.length = num === 0 ? 1 : this.length, this;
      }, BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      }, BN.prototype.sqr = function sqr() {
        return this.mul(this);
      }, BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      }, BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i2 = 0;i2 < w.length; i2++, res = res.sqr())
          if (w[i2] !== 0)
            break;
        if (++i2 < w.length)
          for (var q = res.sqr();i2 < w.length; i2++, q = q.sqr()) {
            if (w[i2] === 0)
              continue;
            res = res.mul(q);
          }
        return res;
      }, BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26, s = (bits - r) / 26, carryMask = 67108863 >>> 26 - r << 26 - r, i2;
        if (r !== 0) {
          var carry = 0;
          for (i2 = 0;i2 < this.length; i2++) {
            var newCarry = this.words[i2] & carryMask, c = (this.words[i2] | 0) - newCarry << r;
            this.words[i2] = c | carry, carry = newCarry >>> 26 - r;
          }
          if (carry)
            this.words[i2] = carry, this.length++;
        }
        if (s !== 0) {
          for (i2 = this.length - 1;i2 >= 0; i2--)
            this.words[i2 + s] = this.words[i2];
          for (i2 = 0;i2 < s; i2++)
            this.words[i2] = 0;
          this.length += s;
        }
        return this.strip();
      }, BN.prototype.ishln = function ishln(bits) {
        return assert(this.negative === 0), this.iushln(bits);
      }, BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint)
          h = (hint - hint % 26) / 26;
        else
          h = 0;
        var r = bits % 26, s = Math.min((bits - r) / 26, this.length), mask = 67108863 ^ 67108863 >>> r << r, maskedWords = extended;
        if (h -= s, h = Math.max(0, h), maskedWords) {
          for (var i2 = 0;i2 < s; i2++)
            maskedWords.words[i2] = this.words[i2];
          maskedWords.length = s;
        }
        if (s === 0)
          ;
        else if (this.length > s) {
          this.length -= s;
          for (i2 = 0;i2 < this.length; i2++)
            this.words[i2] = this.words[i2 + s];
        } else
          this.words[0] = 0, this.length = 1;
        var carry = 0;
        for (i2 = this.length - 1;i2 >= 0 && (carry !== 0 || i2 >= h); i2--) {
          var word = this.words[i2] | 0;
          this.words[i2] = carry << 26 - r | word >>> r, carry = word & mask;
        }
        if (maskedWords && carry !== 0)
          maskedWords.words[maskedWords.length++] = carry;
        if (this.length === 0)
          this.words[0] = 0, this.length = 1;
        return this.strip();
      }, BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        return assert(this.negative === 0), this.iushrn(bits, hint, extended);
      }, BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      }, BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      }, BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      }, BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      }, BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26, s = (bit - r) / 26, q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      }, BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26, s = (bits - r) / 26;
        if (assert(this.negative === 0, "imaskn works only with positive numbers"), this.length <= s)
          return this;
        if (r !== 0)
          s++;
        if (this.length = Math.min(s, this.length), r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      }, BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      }, BN.prototype.iaddn = function iaddn(num) {
        if (assert(typeof num === "number"), assert(num < 67108864), num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num)
            return this.words[0] = num - (this.words[0] | 0), this.negative = 0, this;
          return this.negative = 0, this.isubn(num), this.negative = 1, this;
        }
        return this._iaddn(num);
      }, BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i2 = 0;i2 < this.length && this.words[i2] >= 67108864; i2++)
          if (this.words[i2] -= 67108864, i2 === this.length - 1)
            this.words[i2 + 1] = 1;
          else
            this.words[i2 + 1]++;
        return this.length = Math.max(this.length, i2 + 1), this;
      }, BN.prototype.isubn = function isubn(num) {
        if (assert(typeof num === "number"), assert(num < 67108864), num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(num), this.negative = 1, this;
        if (this.words[0] -= num, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var i2 = 0;i2 < this.length && this.words[i2] < 0; i2++)
            this.words[i2] += 67108864, this.words[i2 + 1] -= 1;
        return this.strip();
      }, BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      }, BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      }, BN.prototype.iabs = function iabs() {
        return this.negative = 0, this;
      }, BN.prototype.abs = function abs() {
        return this.clone().iabs();
      }, BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len2 = num.length + shift, i2;
        this._expand(len2);
        var w, carry = 0;
        for (i2 = 0;i2 < num.length; i2++) {
          w = (this.words[i2 + shift] | 0) + carry;
          var right = (num.words[i2] | 0) * mul;
          w -= right & 67108863, carry = (w >> 26) - (right / 67108864 | 0), this.words[i2 + shift] = w & 67108863;
        }
        for (;i2 < this.length - shift; i2++)
          w = (this.words[i2 + shift] | 0) + carry, carry = w >> 26, this.words[i2 + shift] = w & 67108863;
        if (carry === 0)
          return this.strip();
        assert(carry === -1), carry = 0;
        for (i2 = 0;i2 < this.length; i2++)
          w = -(this.words[i2] | 0) + carry, carry = w >> 26, this.words[i2] = w & 67108863;
        return this.negative = 1, this.strip();
      }, BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length, a = this.clone(), b = num, bhi = b.words[b.length - 1] | 0, bhiBits = this._countBits(bhi);
        if (shift = 26 - bhiBits, shift !== 0)
          b = b.ushln(shift), a.iushln(shift), bhi = b.words[b.length - 1] | 0;
        var m = a.length - b.length, q;
        if (mode !== "mod") {
          q = new BN(null), q.length = m + 1, q.words = new Array(q.length);
          for (var i2 = 0;i2 < q.length; i2++)
            q.words[i2] = 0;
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          if (a = diff, q)
            q.words[m] = 1;
        }
        for (var j = m - 1;j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863), a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0)
            if (qj--, a.negative = 0, a._ishlnsubmul(b, 1, j), !a.isZero())
              a.negative ^= 1;
          if (q)
            q.words[j] = qj;
        }
        if (q)
          q.strip();
        if (a.strip(), mode !== "div" && shift !== 0)
          a.iushrn(shift);
        return { div: q || null, mod: a };
      }, BN.prototype.divmod = function divmod(num, mode, positive) {
        if (assert(!num.isZero()), this.isZero())
          return { div: new BN(0), mod: new BN(0) };
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          if (res = this.neg().divmod(num, mode), mode !== "mod")
            div = res.div.neg();
          if (mode !== "div") {
            if (mod = res.mod.neg(), positive && mod.negative !== 0)
              mod.iadd(num);
          }
          return { div, mod };
        }
        if (this.negative === 0 && num.negative !== 0) {
          if (res = this.divmod(num.neg(), mode), mode !== "mod")
            div = res.div.neg();
          return { div, mod: res.mod };
        }
        if ((this.negative & num.negative) !== 0) {
          if (res = this.neg().divmod(num.neg(), mode), mode !== "div") {
            if (mod = res.mod.neg(), positive && mod.negative !== 0)
              mod.isub(num);
          }
          return { div: res.div, mod };
        }
        if (num.length > this.length || this.cmp(num) < 0)
          return { div: new BN(0), mod: this };
        if (num.length === 1) {
          if (mode === "div")
            return { div: this.divn(num.words[0]), mod: null };
          if (mode === "mod")
            return { div: null, mod: new BN(this.modn(num.words[0])) };
          return { div: this.divn(num.words[0]), mod: new BN(this.modn(num.words[0])) };
        }
        return this._wordDiv(num, mode);
      }, BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      }, BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      }, BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      }, BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod, half = num.ushrn(1), r2 = num.andln(1), cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      }, BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = 67108864 % num, acc = 0;
        for (var i2 = this.length - 1;i2 >= 0; i2--)
          acc = (p * acc + (this.words[i2] | 0)) % num;
        return acc;
      }, BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i2 = this.length - 1;i2 >= 0; i2--) {
          var w = (this.words[i2] | 0) + carry * 67108864;
          this.words[i2] = w / num | 0, carry = w % num;
        }
        return this.strip();
      }, BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      }, BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0), assert(!p.isZero());
        var x = this, y = p.clone();
        if (x.negative !== 0)
          x = x.umod(p);
        else
          x = x.clone();
        var A = new BN(1), B = new BN(0), C = new BN(0), D = new BN(1), g = 0;
        while (x.isEven() && y.isEven())
          x.iushrn(1), y.iushrn(1), ++g;
        var yp = y.clone(), xp = x.clone();
        while (!x.isZero()) {
          for (var i2 = 0, im = 1;(x.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            x.iushrn(i2);
            while (i2-- > 0) {
              if (A.isOdd() || B.isOdd())
                A.iadd(yp), B.isub(xp);
              A.iushrn(1), B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1;(y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd())
                C.iadd(yp), D.isub(xp);
              C.iushrn(1), D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0)
            x.isub(y), A.isub(C), B.isub(D);
          else
            y.isub(x), C.isub(A), D.isub(B);
        }
        return { a: C, b: D, gcd: y.iushln(g) };
      }, BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0), assert(!p.isZero());
        var a = this, b = p.clone();
        if (a.negative !== 0)
          a = a.umod(p);
        else
          a = a.clone();
        var x1 = new BN(1), x2 = new BN(0), delta3 = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i2 = 0, im = 1;(a.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            a.iushrn(i2);
            while (i2-- > 0) {
              if (x1.isOdd())
                x1.iadd(delta3);
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1;(b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd())
                x2.iadd(delta3);
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0)
            a.isub(b), x1.isub(x2);
          else
            b.isub(a), x2.isub(x1);
        }
        var res;
        if (a.cmpn(1) === 0)
          res = x1;
        else
          res = x2;
        if (res.cmpn(0) < 0)
          res.iadd(p);
        return res;
      }, BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone(), b = num.clone();
        a.negative = 0, b.negative = 0;
        for (var shift = 0;a.isEven() && b.isEven(); shift++)
          a.iushrn(1), b.iushrn(1);
        do {
          while (a.isEven())
            a.iushrn(1);
          while (b.isEven())
            b.iushrn(1);
          var r = a.cmp(b);
          if (r < 0) {
            var t2 = a;
            a = b, b = t2;
          } else if (r === 0 || b.cmpn(1) === 0)
            break;
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      }, BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      }, BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      }, BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      }, BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      }, BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26, s = (bit - r) / 26, q = 1 << r;
        if (this.length <= s)
          return this._expand(s + 1), this.words[s] |= q, this;
        var carry = q;
        for (var i2 = s;carry !== 0 && i2 < this.length; i2++) {
          var w = this.words[i2] | 0;
          w += carry, carry = w >>> 26, w &= 67108863, this.words[i2] = w;
        }
        if (carry !== 0)
          this.words[i2] = carry, this.length++;
        return this;
      }, BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      }, BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1)
          res = 1;
        else {
          if (negative)
            num = -num;
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      }, BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      }, BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i2 = this.length - 1;i2 >= 0; i2--) {
          var a = this.words[i2] | 0, b = num.words[i2] | 0;
          if (a === b)
            continue;
          if (a < b)
            res = -1;
          else if (a > b)
            res = 1;
          break;
        }
        return res;
      }, BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      }, BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      }, BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      }, BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      }, BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      }, BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      }, BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      }, BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      }, BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      }, BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      }, BN.red = function red(num) {
        return new Red(num);
      }, BN.prototype.toRed = function toRed(ctx) {
        return assert(!this.red, "Already a number in reduction context"), assert(this.negative === 0, "red works only with positives"), ctx.convertTo(this)._forceRed(ctx);
      }, BN.prototype.fromRed = function fromRed() {
        return assert(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, BN.prototype._forceRed = function _forceRed(ctx) {
        return this.red = ctx, this;
      }, BN.prototype.forceRed = function forceRed(ctx) {
        return assert(!this.red, "Already a number in reduction context"), this._forceRed(ctx);
      }, BN.prototype.redAdd = function redAdd(num) {
        return assert(this.red, "redAdd works only with red numbers"), this.red.add(this, num);
      }, BN.prototype.redIAdd = function redIAdd(num) {
        return assert(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, num);
      }, BN.prototype.redSub = function redSub(num) {
        return assert(this.red, "redSub works only with red numbers"), this.red.sub(this, num);
      }, BN.prototype.redISub = function redISub(num) {
        return assert(this.red, "redISub works only with red numbers"), this.red.isub(this, num);
      }, BN.prototype.redShl = function redShl(num) {
        return assert(this.red, "redShl works only with red numbers"), this.red.shl(this, num);
      }, BN.prototype.redMul = function redMul(num) {
        return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.mul(this, num);
      }, BN.prototype.redIMul = function redIMul(num) {
        return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.imul(this, num);
      }, BN.prototype.redSqr = function redSqr() {
        return assert(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, BN.prototype.redISqr = function redISqr() {
        return assert(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, BN.prototype.redSqrt = function redSqrt() {
        return assert(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, BN.prototype.redInvm = function redInvm() {
        return assert(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, BN.prototype.redNeg = function redNeg() {
        return assert(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, BN.prototype.redPow = function redPow(num) {
        return assert(this.red && !num.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, num);
      };
      var primes = { k256: null, p224: null, p192: null, p25519: null };
      function MPrime(name, p) {
        this.name = name, this.p = new BN(p, 16), this.n = this.p.bitLength(), this.k = new BN(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        return tmp.words = new Array(Math.ceil(this.n / 13)), tmp;
      }, MPrime.prototype.ireduce = function ireduce(num) {
        var r = num, rlen;
        do
          this.split(r, this.tmp), r = this.imulK(r), r = r.iadd(this.tmp), rlen = r.bitLength();
        while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0)
          r.words[0] = 0, r.length = 1;
        else if (cmp > 0)
          r.isub(this.p);
        else if (r.strip !== undefined)
          r.strip();
        else
          r._strip();
        return r;
      }, MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      }, MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      inherits2(K256, MPrime), K256.prototype.split = function split(input, output) {
        var mask = 4194303, outLen = Math.min(input.length, 9);
        for (var i2 = 0;i2 < outLen; i2++)
          output.words[i2] = input.words[i2];
        if (output.length = outLen, input.length <= 9) {
          input.words[0] = 0, input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i2 = 10;i2 < input.length; i2++) {
          var next = input.words[i2] | 0;
          input.words[i2 - 10] = (next & mask) << 4 | prev >>> 22, prev = next;
        }
        if (prev >>>= 22, input.words[i2 - 10] = prev, prev === 0 && input.length > 10)
          input.length -= 10;
        else
          input.length -= 9;
      }, K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0, num.words[num.length + 1] = 0, num.length += 2;
        var lo = 0;
        for (var i2 = 0;i2 < num.length; i2++) {
          var w = num.words[i2] | 0;
          lo += w * 977, num.words[i2] = lo & 67108863, lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          if (num.length--, num.words[num.length - 1] === 0)
            num.length--;
        }
        return num;
      };
      function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      inherits2(P25519, MPrime), P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i2 = 0;i2 < num.length; i2++) {
          var hi = (num.words[i2] | 0) * 19 + carry, lo = hi & 67108863;
          hi >>>= 26, num.words[i2] = lo, carry = hi;
        }
        if (carry !== 0)
          num.words[num.length++] = carry;
        return num;
      }, BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime;
        if (name === "k256")
          prime = new K256;
        else if (name === "p224")
          prime = new P224;
        else if (name === "p192")
          prime = new P192;
        else if (name === "p25519")
          prime = new P25519;
        else
          throw new Error("Unknown prime " + name);
        return primes[name] = prime, prime;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p, this.prime = prime;
        } else
          assert(m.gtn(1), "modulus must be greater than 1"), this.m = m, this.prime = null;
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives"), assert(a.red, "red works only with red numbers");
      }, Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives"), assert(a.red && a.red === b.red, "red works only with red numbers");
      }, Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      }, Red.prototype.neg = function neg(a) {
        if (a.isZero())
          return a.clone();
        return this.m.sub(a)._forceRed(this);
      }, Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0)
          res.isub(this.m);
        return res._forceRed(this);
      }, Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0)
          res.isub(this.m);
        return res;
      }, Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0)
          res.iadd(this.m);
        return res._forceRed(this);
      }, Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0)
          res.iadd(this.m);
        return res;
      }, Red.prototype.shl = function shl(a, num) {
        return this._verify1(a), this.imod(a.ushln(num));
      }, Red.prototype.imul = function imul(a, b) {
        return this._verify2(a, b), this.imod(a.imul(b));
      }, Red.prototype.mul = function mul(a, b) {
        return this._verify2(a, b), this.imod(a.mul(b));
      }, Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      }, Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      }, Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        if (assert(mod3 % 2 === 1), mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1), s = 0;
        while (!q.isZero() && q.andln(1) === 0)
          s++, q.iushrn(1);
        assert(!q.isZero());
        var one = new BN(1).toRed(this), nOne = one.redNeg(), lpow = this.m.subn(1).iushrn(1), z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0)
          z.redIAdd(nOne);
        var c = this.pow(z, q), r = this.pow(a, q.addn(1).iushrn(1)), t2 = this.pow(a, q), m = s;
        while (t2.cmp(one) !== 0) {
          var tmp = t2;
          for (var i2 = 0;tmp.cmp(one) !== 0; i2++)
            tmp = tmp.redSqr();
          assert(i2 < m);
          var b = this.pow(c, new BN(1).iushln(m - i2 - 1));
          r = r.redMul(b), c = b.redSqr(), t2 = t2.redMul(c), m = i2;
        }
        return r;
      }, Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0)
          return inv.negative = 0, this.imod(inv).redNeg();
        else
          return this.imod(inv);
      }, Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4, wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this), wnd[1] = a;
        for (var i2 = 2;i2 < wnd.length; i2++)
          wnd[i2] = this.mul(wnd[i2 - 1], a);
        var res = wnd[0], current = 0, currentLen = 0, start = num.bitLength() % 26;
        if (start === 0)
          start = 26;
        for (i2 = num.length - 1;i2 >= 0; i2--) {
          var word = num.words[i2];
          for (var j = start - 1;j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0])
              res = this.sqr(res);
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            if (current <<= 1, current |= bit, currentLen++, currentLen !== windowSize && (i2 !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]), currentLen = 0, current = 0;
          }
          start = 26;
        }
        return res;
      }, Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      }, Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        return res.red = null, res;
      }, BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        if (Red.call(this, m), this.shift = this.m.bitLength(), this.shift % 26 !== 0)
          this.shift += 26 - this.shift % 26;
        this.r = new BN(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red), Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      }, Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        return r.red = null, r;
      }, Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero())
          return a.words[0] = 0, a.length = 1, a;
        var t2 = a.imul(b), c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t2.isub(c).iushrn(this.shift), res = u;
        if (u.cmp(this.m) >= 0)
          res = u.isub(this.m);
        else if (u.cmpn(0) < 0)
          res = u.iadd(this.m);
        return res._forceRed(this);
      }, Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t2 = a.mul(b), c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t2.isub(c).iushrn(this.shift), res = u;
        if (u.cmp(this.m) >= 0)
          res = u.isub(this.m);
        else if (u.cmpn(0) < 0)
          res = u.iadd(this.m);
        return res._forceRed(this);
      }, Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  });
  require_browser = __commonJS2((exports, module) => {
    var elliptic = require_elliptic(), BN = require_bn2();
    module.exports = function createECDH(curve) {
      return new ECDH(curve);
    };
    var aliases = { secp256k1: { name: "secp256k1", byteLength: 32 }, secp224r1: { name: "p224", byteLength: 28 }, prime256v1: { name: "p256", byteLength: 32 }, prime192v1: { name: "p192", byteLength: 24 }, ed25519: { name: "ed25519", byteLength: 32 }, secp384r1: { name: "p384", byteLength: 48 }, secp521r1: { name: "p521", byteLength: 66 } };
    aliases.p224 = aliases.secp224r1;
    aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
    aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
    aliases.p384 = aliases.secp384r1;
    aliases.p521 = aliases.secp521r1;
    function ECDH(curve) {
      if (this.curveType = aliases[curve], !this.curveType)
        this.curveType = { name: curve };
      this.curve = new elliptic.ec(this.curveType.name), this.keys = undefined;
    }
    ECDH.prototype.generateKeys = function(enc, format2) {
      return this.keys = this.curve.genKeyPair(), this.getPublicKey(enc, format2);
    };
    ECDH.prototype.computeSecret = function(other, inenc, enc) {
      if (inenc = inenc || "utf8", !Buffer.isBuffer(other))
        other = new Buffer(other, inenc);
      var otherPub = this.curve.keyFromPublic(other).getPublic(), out = otherPub.mul(this.keys.getPrivate()).getX();
      return formatReturnValue(out, enc, this.curveType.byteLength);
    };
    ECDH.prototype.getPublicKey = function(enc, format2) {
      var key = this.keys.getPublic(format2 === "compressed", true);
      if (format2 === "hybrid")
        if (key[key.length - 1] % 2)
          key[0] = 7;
        else
          key[0] = 6;
      return formatReturnValue(key, enc);
    };
    ECDH.prototype.getPrivateKey = function(enc) {
      return formatReturnValue(this.keys.getPrivate(), enc);
    };
    ECDH.prototype.setPublicKey = function(pub, enc) {
      if (enc = enc || "utf8", !Buffer.isBuffer(pub))
        pub = new Buffer(pub, enc);
      return this.keys._importPublic(pub), this;
    };
    ECDH.prototype.setPrivateKey = function(priv, enc) {
      if (enc = enc || "utf8", !Buffer.isBuffer(priv))
        priv = new Buffer(priv, enc);
      var _priv = new BN(priv);
      return _priv = _priv.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(_priv), this;
    };
    function formatReturnValue(bn, enc, len2) {
      if (!Array.isArray(bn))
        bn = bn.toArray();
      var buf = new Buffer(bn);
      if (len2 && buf.length < len2) {
        var zeros = new Buffer(len2 - buf.length);
        zeros.fill(0), buf = Buffer.concat([zeros, buf]);
      }
      if (!enc)
        return buf;
      else
        return buf.toString(enc);
    }
  });
  require_create_ecdh = __commonJS2((exports, module) => {
    var createECDH = (init_crypto(), __toCommonJS(exports_crypto)).createECDH;
    module.exports = createECDH || require_browser();
  });
  require_bn3 = __commonJS2((exports, module) => {
    (function(module2, exports2) {
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor, ctor.prototype.constructor = ctor;
      }
      function BN(number3, base, endian) {
        if (BN.isBN(number3))
          return number3;
        if (this.negative = 0, this.words = null, this.length = 0, this.red = null, number3 !== null) {
          if (base === "le" || base === "be")
            endian = base, base = 10;
          this._init(number3 || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object")
        module2.exports = BN;
      else
        exports2.BN = BN;
      BN.BN = BN, BN.wordSize = 26;
      var Buffer22;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined")
          Buffer22 = window.Buffer;
        else
          Buffer22 = (init_buffer(), __toCommonJS(exports_buffer2)).Buffer;
      } catch (e) {}
      BN.isBN = function isBN(num) {
        if (num instanceof BN)
          return true;
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      }, BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      }, BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      }, BN.prototype._init = function init(number3, base, endian) {
        if (typeof number3 === "number")
          return this._initNumber(number3, base, endian);
        if (typeof number3 === "object")
          return this._initArray(number3, base, endian);
        if (base === "hex")
          base = 16;
        assert(base === (base | 0) && base >= 2 && base <= 36), number3 = number3.toString().replace(/\s+/g, "");
        var start = 0;
        if (number3[0] === "-")
          start++, this.negative = 1;
        if (start < number3.length) {
          if (base === 16)
            this._parseHex(number3, start, endian);
          else if (this._parseBase(number3, base, start), endian === "le")
            this._initArray(this.toArray(), base, endian);
        }
      }, BN.prototype._initNumber = function _initNumber(number3, base, endian) {
        if (number3 < 0)
          this.negative = 1, number3 = -number3;
        if (number3 < 67108864)
          this.words = [number3 & 67108863], this.length = 1;
        else if (number3 < 4503599627370496)
          this.words = [number3 & 67108863, number3 / 67108864 & 67108863], this.length = 2;
        else
          assert(number3 < 9007199254740992), this.words = [number3 & 67108863, number3 / 67108864 & 67108863, 1], this.length = 3;
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      }, BN.prototype._initArray = function _initArray(number3, base, endian) {
        if (assert(typeof number3.length === "number"), number3.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(number3.length / 3), this.words = new Array(this.length);
        for (var i2 = 0;i2 < this.length; i2++)
          this.words[i2] = 0;
        var j, w, off = 0;
        if (endian === "be") {
          for (i2 = number3.length - 1, j = 0;i2 >= 0; i2 -= 3)
            if (w = number3[i2] | number3[i2 - 1] << 8 | number3[i2 - 2] << 16, this.words[j] |= w << off & 67108863, this.words[j + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26)
              off -= 26, j++;
        } else if (endian === "le") {
          for (i2 = 0, j = 0;i2 < number3.length; i2 += 3)
            if (w = number3[i2] | number3[i2 + 1] << 8 | number3[i2 + 2] << 16, this.words[j] |= w << off & 67108863, this.words[j + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26)
              off -= 26, j++;
        }
        return this.strip();
      };
      function parseHex4Bits(string3, index) {
        var c = string3.charCodeAt(index);
        if (c >= 65 && c <= 70)
          return c - 55;
        else if (c >= 97 && c <= 102)
          return c - 87;
        else
          return c - 48 & 15;
      }
      function parseHexByte(string3, lowerBound, index) {
        var r = parseHex4Bits(string3, index);
        if (index - 1 >= lowerBound)
          r |= parseHex4Bits(string3, index - 1) << 4;
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number3, start, endian) {
        this.length = Math.ceil((number3.length - start) / 6), this.words = new Array(this.length);
        for (var i2 = 0;i2 < this.length; i2++)
          this.words[i2] = 0;
        var off = 0, j = 0, w;
        if (endian === "be")
          for (i2 = number3.length - 1;i2 >= start; i2 -= 2)
            if (w = parseHexByte(number3, start, i2) << off, this.words[j] |= w & 67108863, off >= 18)
              off -= 18, j += 1, this.words[j] |= w >>> 26;
            else
              off += 8;
        else {
          var parseLength = number3.length - start;
          for (i2 = parseLength % 2 === 0 ? start + 1 : start;i2 < number3.length; i2 += 2)
            if (w = parseHexByte(number3, start, i2) << off, this.words[j] |= w & 67108863, off >= 18)
              off -= 18, j += 1, this.words[j] |= w >>> 26;
            else
              off += 8;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0, len2 = Math.min(str.length, end);
        for (var i2 = start;i2 < len2; i2++) {
          var c = str.charCodeAt(i2) - 48;
          if (r *= mul, c >= 49)
            r += c - 49 + 10;
          else if (c >= 17)
            r += c - 17 + 10;
          else
            r += c;
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number3, base, start) {
        this.words = [0], this.length = 1;
        for (var limbLen = 0, limbPow = 1;limbPow <= 67108863; limbPow *= base)
          limbLen++;
        limbLen--, limbPow = limbPow / base | 0;
        var total = number3.length - start, mod = total % limbLen, end = Math.min(total, total - mod) + start, word = 0;
        for (var i2 = start;i2 < end; i2 += limbLen)
          if (word = parseBase(number3, i2, i2 + limbLen, base), this.imuln(limbPow), this.words[0] + word < 67108864)
            this.words[0] += word;
          else
            this._iaddn(word);
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number3, i2, number3.length, base);
          for (i2 = 0;i2 < mod; i2++)
            pow *= base;
          if (this.imuln(pow), this.words[0] + word < 67108864)
            this.words[0] += word;
          else
            this._iaddn(word);
        }
        this.strip();
      }, BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i2 = 0;i2 < this.length; i2++)
          dest.words[i2] = this.words[i2];
        dest.length = this.length, dest.negative = this.negative, dest.red = this.red;
      }, BN.prototype.clone = function clone() {
        var r = new BN(null);
        return this.copy(r), r;
      }, BN.prototype._expand = function _expand(size) {
        while (this.length < size)
          this.words[this.length++] = 0;
        return this;
      }, BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0)
          this.length--;
        return this._normSign();
      }, BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0)
          this.negative = 0;
        return this;
      }, BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      if (BN.prototype.toString = function toString(base, padding) {
        base = base || 10, padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0, carry = 0;
          for (var i2 = 0;i2 < this.length; i2++) {
            var w = this.words[i2], word = ((w << off | carry) & 16777215).toString(16);
            if (carry = w >>> 24 - off & 16777215, off += 2, off >= 26)
              off -= 26, i2--;
            if (carry !== 0 || i2 !== this.length - 1)
              out = zeros[6 - word.length] + word + out;
            else
              out = word + out;
          }
          if (carry !== 0)
            out = carry.toString(16) + out;
          while (out.length % padding !== 0)
            out = "0" + out;
          if (this.negative !== 0)
            out = "-" + out;
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base], groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            if (c = c.idivn(groupBase), !c.isZero())
              out = zeros[groupSize - r.length] + r + out;
            else
              out = r + out;
          }
          if (this.isZero())
            out = "0" + out;
          while (out.length % padding !== 0)
            out = "0" + out;
          if (this.negative !== 0)
            out = "-" + out;
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      }, BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2)
          ret += this.words[1] * 67108864;
        else if (this.length === 3 && this.words[2] === 1)
          ret += 4503599627370496 + this.words[1] * 67108864;
        else if (this.length > 2)
          assert(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -ret : ret;
      }, BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      }, BN.prototype.toBuffer = function toBuffer(endian, length) {
        return assert(typeof Buffer22 !== "undefined"), this.toArrayLike(Buffer22, endian, length);
      }, BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      }, BN.prototype.toArrayLike = function toArrayLike(ArrayType7, endian, length) {
        var byteLength2 = this.byteLength(), reqLength = length || Math.max(1, byteLength2);
        assert(byteLength2 <= reqLength, "byte array longer than desired length"), assert(reqLength > 0, "Requested array length <= 0"), this.strip();
        var littleEndian = endian === "le", res = new ArrayType7(reqLength), b, i2, q = this.clone();
        if (!littleEndian) {
          for (i2 = 0;i2 < reqLength - byteLength2; i2++)
            res[i2] = 0;
          for (i2 = 0;!q.isZero(); i2++)
            b = q.andln(255), q.iushrn(8), res[reqLength - i2 - 1] = b;
        } else {
          for (i2 = 0;!q.isZero(); i2++)
            b = q.andln(255), q.iushrn(8), res[i2] = b;
          for (;i2 < reqLength; i2++)
            res[i2] = 0;
        }
        return res;
      }, Math.clz32)
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      else
        BN.prototype._countBits = function _countBits(w) {
          var t2 = w, r = 0;
          if (t2 >= 4096)
            r += 13, t2 >>>= 13;
          if (t2 >= 64)
            r += 7, t2 >>>= 7;
          if (t2 >= 8)
            r += 4, t2 >>>= 4;
          if (t2 >= 2)
            r += 2, t2 >>>= 2;
          return r + t2;
        };
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t2 = w, r = 0;
        if ((t2 & 8191) === 0)
          r += 13, t2 >>>= 13;
        if ((t2 & 127) === 0)
          r += 7, t2 >>>= 7;
        if ((t2 & 15) === 0)
          r += 4, t2 >>>= 4;
        if ((t2 & 3) === 0)
          r += 2, t2 >>>= 2;
        if ((t2 & 1) === 0)
          r++;
        return r;
      }, BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1], hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0;bit < w.length; bit++) {
          var off = bit / 26 | 0, wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i2 = 0;i2 < this.length; i2++) {
          var b = this._zeroBits(this.words[i2]);
          if (r += b, b !== 26)
            break;
        }
        return r;
      }, BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      }, BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0)
          return this.abs().inotn(width).iaddn(1);
        return this.clone();
      }, BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1))
          return this.notn(width).iaddn(1).ineg();
        return this.clone();
      }, BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      }, BN.prototype.neg = function neg() {
        return this.clone().ineg();
      }, BN.prototype.ineg = function ineg() {
        if (!this.isZero())
          this.negative ^= 1;
        return this;
      }, BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length)
          this.words[this.length++] = 0;
        for (var i2 = 0;i2 < num.length; i2++)
          this.words[i2] = this.words[i2] | num.words[i2];
        return this.strip();
      }, BN.prototype.ior = function ior(num) {
        return assert((this.negative | num.negative) === 0), this.iuor(num);
      }, BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      }, BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      }, BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length)
          b = num;
        else
          b = this;
        for (var i2 = 0;i2 < b.length; i2++)
          this.words[i2] = this.words[i2] & num.words[i2];
        return this.length = b.length, this.strip();
      }, BN.prototype.iand = function iand(num) {
        return assert((this.negative | num.negative) === 0), this.iuand(num);
      }, BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      }, BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      }, BN.prototype.iuxor = function iuxor(num) {
        var a, b;
        if (this.length > num.length)
          a = this, b = num;
        else
          a = num, b = this;
        for (var i2 = 0;i2 < b.length; i2++)
          this.words[i2] = a.words[i2] ^ b.words[i2];
        if (this !== a)
          for (;i2 < a.length; i2++)
            this.words[i2] = a.words[i2];
        return this.length = a.length, this.strip();
      }, BN.prototype.ixor = function ixor(num) {
        return assert((this.negative | num.negative) === 0), this.iuxor(num);
      }, BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      }, BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      }, BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0, bitsLeft = width % 26;
        if (this._expand(bytesNeeded), bitsLeft > 0)
          bytesNeeded--;
        for (var i2 = 0;i2 < bytesNeeded; i2++)
          this.words[i2] = ~this.words[i2] & 67108863;
        if (bitsLeft > 0)
          this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
        return this.strip();
      }, BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      }, BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0, wbit = bit % 26;
        if (this._expand(off + 1), val)
          this.words[off] = this.words[off] | 1 << wbit;
        else
          this.words[off] = this.words[off] & ~(1 << wbit);
        return this.strip();
      }, BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0)
          return this.negative = 0, r = this.isub(num), this.negative ^= 1, this._normSign();
        else if (this.negative === 0 && num.negative !== 0)
          return num.negative = 0, r = this.isub(num), num.negative = 1, r._normSign();
        var a, b;
        if (this.length > num.length)
          a = this, b = num;
        else
          a = num, b = this;
        var carry = 0;
        for (var i2 = 0;i2 < b.length; i2++)
          r = (a.words[i2] | 0) + (b.words[i2] | 0) + carry, this.words[i2] = r & 67108863, carry = r >>> 26;
        for (;carry !== 0 && i2 < a.length; i2++)
          r = (a.words[i2] | 0) + carry, this.words[i2] = r & 67108863, carry = r >>> 26;
        if (this.length = a.length, carry !== 0)
          this.words[this.length] = carry, this.length++;
        else if (a !== this)
          for (;i2 < a.length; i2++)
            this.words[i2] = a.words[i2];
        return this;
      }, BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0)
          return num.negative = 0, res = this.sub(num), num.negative ^= 1, res;
        else if (num.negative === 0 && this.negative !== 0)
          return this.negative = 0, res = num.sub(this), this.negative = 1, res;
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      }, BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          return num.negative = 1, r._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(num), this.negative = 1, this._normSign();
        var cmp = this.cmp(num);
        if (cmp === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var a, b;
        if (cmp > 0)
          a = this, b = num;
        else
          a = num, b = this;
        var carry = 0;
        for (var i2 = 0;i2 < b.length; i2++)
          r = (a.words[i2] | 0) - (b.words[i2] | 0) + carry, carry = r >> 26, this.words[i2] = r & 67108863;
        for (;carry !== 0 && i2 < a.length; i2++)
          r = (a.words[i2] | 0) + carry, carry = r >> 26, this.words[i2] = r & 67108863;
        if (carry === 0 && i2 < a.length && a !== this)
          for (;i2 < a.length; i2++)
            this.words[i2] = a.words[i2];
        if (this.length = Math.max(this.length, i2), a !== this)
          this.negative = 1;
        return this.strip();
      }, BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len2 = self2.length + num.length | 0;
        out.length = len2, len2 = len2 - 1 | 0;
        var a = self2.words[0] | 0, b = num.words[0] | 0, r = a * b, lo = r & 67108863, carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1;k < len2; k++) {
          var ncarry = carry >>> 26, rword = carry & 67108863, maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
            var i2 = k - j | 0;
            a = self2.words[i2] | 0, b = num.words[j] | 0, r = a * b + rword, ncarry += r / 67108864 | 0, rword = r & 67108863;
          }
          out.words[k] = rword | 0, carry = ncarry | 0;
        }
        if (carry !== 0)
          out.words[k] = carry | 0;
        else
          out.length--;
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo(self2, num, out) {
        var a = self2.words, b = num.words, o = out.words, c = 0, lo, mid, hi, a0 = a[0] | 0, al0 = a0 & 8191, ah0 = a0 >>> 13, a1 = a[1] | 0, al1 = a1 & 8191, ah1 = a1 >>> 13, a2 = a[2] | 0, al2 = a2 & 8191, ah2 = a2 >>> 13, a3 = a[3] | 0, al3 = a3 & 8191, ah3 = a3 >>> 13, a4 = a[4] | 0, al4 = a4 & 8191, ah4 = a4 >>> 13, a5 = a[5] | 0, al5 = a5 & 8191, ah5 = a5 >>> 13, a6 = a[6] | 0, al6 = a6 & 8191, ah6 = a6 >>> 13, a7 = a[7] | 0, al7 = a7 & 8191, ah7 = a7 >>> 13, a8 = a[8] | 0, al8 = a8 & 8191, ah8 = a8 >>> 13, a9 = a[9] | 0, al9 = a9 & 8191, ah9 = a9 >>> 13, b0 = b[0] | 0, bl0 = b0 & 8191, bh0 = b0 >>> 13, b1 = b[1] | 0, bl1 = b1 & 8191, bh1 = b1 >>> 13, b2 = b[2] | 0, bl2 = b2 & 8191, bh2 = b2 >>> 13, b3 = b[3] | 0, bl3 = b3 & 8191, bh3 = b3 >>> 13, b4 = b[4] | 0, bl4 = b4 & 8191, bh4 = b4 >>> 13, b5 = b[5] | 0, bl5 = b5 & 8191, bh5 = b5 >>> 13, b6 = b[6] | 0, bl6 = b6 & 8191, bh6 = b6 >>> 13, b7 = b[7] | 0, bl7 = b7 & 8191, bh7 = b7 >>> 13, b8 = b[8] | 0, bl8 = b8 & 8191, bh8 = b8 >>> 13, b9 = b[9] | 0, bl9 = b9 & 8191, bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative, out.length = 19, lo = Math.imul(al0, bl0), mid = Math.imul(al0, bh0), mid = mid + Math.imul(ah0, bl0) | 0, hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0, w0 &= 67108863, lo = Math.imul(al1, bl0), mid = Math.imul(al1, bh0), mid = mid + Math.imul(ah1, bl0) | 0, hi = Math.imul(ah1, bh0), lo = lo + Math.imul(al0, bl1) | 0, mid = mid + Math.imul(al0, bh1) | 0, mid = mid + Math.imul(ah0, bl1) | 0, hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0, w1 &= 67108863, lo = Math.imul(al2, bl0), mid = Math.imul(al2, bh0), mid = mid + Math.imul(ah2, bl0) | 0, hi = Math.imul(ah2, bh0), lo = lo + Math.imul(al1, bl1) | 0, mid = mid + Math.imul(al1, bh1) | 0, mid = mid + Math.imul(ah1, bl1) | 0, hi = hi + Math.imul(ah1, bh1) | 0, lo = lo + Math.imul(al0, bl2) | 0, mid = mid + Math.imul(al0, bh2) | 0, mid = mid + Math.imul(ah0, bl2) | 0, hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0, w2 &= 67108863, lo = Math.imul(al3, bl0), mid = Math.imul(al3, bh0), mid = mid + Math.imul(ah3, bl0) | 0, hi = Math.imul(ah3, bh0), lo = lo + Math.imul(al2, bl1) | 0, mid = mid + Math.imul(al2, bh1) | 0, mid = mid + Math.imul(ah2, bl1) | 0, hi = hi + Math.imul(ah2, bh1) | 0, lo = lo + Math.imul(al1, bl2) | 0, mid = mid + Math.imul(al1, bh2) | 0, mid = mid + Math.imul(ah1, bl2) | 0, hi = hi + Math.imul(ah1, bh2) | 0, lo = lo + Math.imul(al0, bl3) | 0, mid = mid + Math.imul(al0, bh3) | 0, mid = mid + Math.imul(ah0, bl3) | 0, hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0, w3 &= 67108863, lo = Math.imul(al4, bl0), mid = Math.imul(al4, bh0), mid = mid + Math.imul(ah4, bl0) | 0, hi = Math.imul(ah4, bh0), lo = lo + Math.imul(al3, bl1) | 0, mid = mid + Math.imul(al3, bh1) | 0, mid = mid + Math.imul(ah3, bl1) | 0, hi = hi + Math.imul(ah3, bh1) | 0, lo = lo + Math.imul(al2, bl2) | 0, mid = mid + Math.imul(al2, bh2) | 0, mid = mid + Math.imul(ah2, bl2) | 0, hi = hi + Math.imul(ah2, bh2) | 0, lo = lo + Math.imul(al1, bl3) | 0, mid = mid + Math.imul(al1, bh3) | 0, mid = mid + Math.imul(ah1, bl3) | 0, hi = hi + Math.imul(ah1, bh3) | 0, lo = lo + Math.imul(al0, bl4) | 0, mid = mid + Math.imul(al0, bh4) | 0, mid = mid + Math.imul(ah0, bl4) | 0, hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0, w4 &= 67108863, lo = Math.imul(al5, bl0), mid = Math.imul(al5, bh0), mid = mid + Math.imul(ah5, bl0) | 0, hi = Math.imul(ah5, bh0), lo = lo + Math.imul(al4, bl1) | 0, mid = mid + Math.imul(al4, bh1) | 0, mid = mid + Math.imul(ah4, bl1) | 0, hi = hi + Math.imul(ah4, bh1) | 0, lo = lo + Math.imul(al3, bl2) | 0, mid = mid + Math.imul(al3, bh2) | 0, mid = mid + Math.imul(ah3, bl2) | 0, hi = hi + Math.imul(ah3, bh2) | 0, lo = lo + Math.imul(al2, bl3) | 0, mid = mid + Math.imul(al2, bh3) | 0, mid = mid + Math.imul(ah2, bl3) | 0, hi = hi + Math.imul(ah2, bh3) | 0, lo = lo + Math.imul(al1, bl4) | 0, mid = mid + Math.imul(al1, bh4) | 0, mid = mid + Math.imul(ah1, bl4) | 0, hi = hi + Math.imul(ah1, bh4) | 0, lo = lo + Math.imul(al0, bl5) | 0, mid = mid + Math.imul(al0, bh5) | 0, mid = mid + Math.imul(ah0, bl5) | 0, hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0, w5 &= 67108863, lo = Math.imul(al6, bl0), mid = Math.imul(al6, bh0), mid = mid + Math.imul(ah6, bl0) | 0, hi = Math.imul(ah6, bh0), lo = lo + Math.imul(al5, bl1) | 0, mid = mid + Math.imul(al5, bh1) | 0, mid = mid + Math.imul(ah5, bl1) | 0, hi = hi + Math.imul(ah5, bh1) | 0, lo = lo + Math.imul(al4, bl2) | 0, mid = mid + Math.imul(al4, bh2) | 0, mid = mid + Math.imul(ah4, bl2) | 0, hi = hi + Math.imul(ah4, bh2) | 0, lo = lo + Math.imul(al3, bl3) | 0, mid = mid + Math.imul(al3, bh3) | 0, mid = mid + Math.imul(ah3, bl3) | 0, hi = hi + Math.imul(ah3, bh3) | 0, lo = lo + Math.imul(al2, bl4) | 0, mid = mid + Math.imul(al2, bh4) | 0, mid = mid + Math.imul(ah2, bl4) | 0, hi = hi + Math.imul(ah2, bh4) | 0, lo = lo + Math.imul(al1, bl5) | 0, mid = mid + Math.imul(al1, bh5) | 0, mid = mid + Math.imul(ah1, bl5) | 0, hi = hi + Math.imul(ah1, bh5) | 0, lo = lo + Math.imul(al0, bl6) | 0, mid = mid + Math.imul(al0, bh6) | 0, mid = mid + Math.imul(ah0, bl6) | 0, hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0, w6 &= 67108863, lo = Math.imul(al7, bl0), mid = Math.imul(al7, bh0), mid = mid + Math.imul(ah7, bl0) | 0, hi = Math.imul(ah7, bh0), lo = lo + Math.imul(al6, bl1) | 0, mid = mid + Math.imul(al6, bh1) | 0, mid = mid + Math.imul(ah6, bl1) | 0, hi = hi + Math.imul(ah6, bh1) | 0, lo = lo + Math.imul(al5, bl2) | 0, mid = mid + Math.imul(al5, bh2) | 0, mid = mid + Math.imul(ah5, bl2) | 0, hi = hi + Math.imul(ah5, bh2) | 0, lo = lo + Math.imul(al4, bl3) | 0, mid = mid + Math.imul(al4, bh3) | 0, mid = mid + Math.imul(ah4, bl3) | 0, hi = hi + Math.imul(ah4, bh3) | 0, lo = lo + Math.imul(al3, bl4) | 0, mid = mid + Math.imul(al3, bh4) | 0, mid = mid + Math.imul(ah3, bl4) | 0, hi = hi + Math.imul(ah3, bh4) | 0, lo = lo + Math.imul(al2, bl5) | 0, mid = mid + Math.imul(al2, bh5) | 0, mid = mid + Math.imul(ah2, bl5) | 0, hi = hi + Math.imul(ah2, bh5) | 0, lo = lo + Math.imul(al1, bl6) | 0, mid = mid + Math.imul(al1, bh6) | 0, mid = mid + Math.imul(ah1, bl6) | 0, hi = hi + Math.imul(ah1, bh6) | 0, lo = lo + Math.imul(al0, bl7) | 0, mid = mid + Math.imul(al0, bh7) | 0, mid = mid + Math.imul(ah0, bl7) | 0, hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0, w7 &= 67108863, lo = Math.imul(al8, bl0), mid = Math.imul(al8, bh0), mid = mid + Math.imul(ah8, bl0) | 0, hi = Math.imul(ah8, bh0), lo = lo + Math.imul(al7, bl1) | 0, mid = mid + Math.imul(al7, bh1) | 0, mid = mid + Math.imul(ah7, bl1) | 0, hi = hi + Math.imul(ah7, bh1) | 0, lo = lo + Math.imul(al6, bl2) | 0, mid = mid + Math.imul(al6, bh2) | 0, mid = mid + Math.imul(ah6, bl2) | 0, hi = hi + Math.imul(ah6, bh2) | 0, lo = lo + Math.imul(al5, bl3) | 0, mid = mid + Math.imul(al5, bh3) | 0, mid = mid + Math.imul(ah5, bl3) | 0, hi = hi + Math.imul(ah5, bh3) | 0, lo = lo + Math.imul(al4, bl4) | 0, mid = mid + Math.imul(al4, bh4) | 0, mid = mid + Math.imul(ah4, bl4) | 0, hi = hi + Math.imul(ah4, bh4) | 0, lo = lo + Math.imul(al3, bl5) | 0, mid = mid + Math.imul(al3, bh5) | 0, mid = mid + Math.imul(ah3, bl5) | 0, hi = hi + Math.imul(ah3, bh5) | 0, lo = lo + Math.imul(al2, bl6) | 0, mid = mid + Math.imul(al2, bh6) | 0, mid = mid + Math.imul(ah2, bl6) | 0, hi = hi + Math.imul(ah2, bh6) | 0, lo = lo + Math.imul(al1, bl7) | 0, mid = mid + Math.imul(al1, bh7) | 0, mid = mid + Math.imul(ah1, bl7) | 0, hi = hi + Math.imul(ah1, bh7) | 0, lo = lo + Math.imul(al0, bl8) | 0, mid = mid + Math.imul(al0, bh8) | 0, mid = mid + Math.imul(ah0, bl8) | 0, hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0, w8 &= 67108863, lo = Math.imul(al9, bl0), mid = Math.imul(al9, bh0), mid = mid + Math.imul(ah9, bl0) | 0, hi = Math.imul(ah9, bh0), lo = lo + Math.imul(al8, bl1) | 0, mid = mid + Math.imul(al8, bh1) | 0, mid = mid + Math.imul(ah8, bl1) | 0, hi = hi + Math.imul(ah8, bh1) | 0, lo = lo + Math.imul(al7, bl2) | 0, mid = mid + Math.imul(al7, bh2) | 0, mid = mid + Math.imul(ah7, bl2) | 0, hi = hi + Math.imul(ah7, bh2) | 0, lo = lo + Math.imul(al6, bl3) | 0, mid = mid + Math.imul(al6, bh3) | 0, mid = mid + Math.imul(ah6, bl3) | 0, hi = hi + Math.imul(ah6, bh3) | 0, lo = lo + Math.imul(al5, bl4) | 0, mid = mid + Math.imul(al5, bh4) | 0, mid = mid + Math.imul(ah5, bl4) | 0, hi = hi + Math.imul(ah5, bh4) | 0, lo = lo + Math.imul(al4, bl5) | 0, mid = mid + Math.imul(al4, bh5) | 0, mid = mid + Math.imul(ah4, bl5) | 0, hi = hi + Math.imul(ah4, bh5) | 0, lo = lo + Math.imul(al3, bl6) | 0, mid = mid + Math.imul(al3, bh6) | 0, mid = mid + Math.imul(ah3, bl6) | 0, hi = hi + Math.imul(ah3, bh6) | 0, lo = lo + Math.imul(al2, bl7) | 0, mid = mid + Math.imul(al2, bh7) | 0, mid = mid + Math.imul(ah2, bl7) | 0, hi = hi + Math.imul(ah2, bh7) | 0, lo = lo + Math.imul(al1, bl8) | 0, mid = mid + Math.imul(al1, bh8) | 0, mid = mid + Math.imul(ah1, bl8) | 0, hi = hi + Math.imul(ah1, bh8) | 0, lo = lo + Math.imul(al0, bl9) | 0, mid = mid + Math.imul(al0, bh9) | 0, mid = mid + Math.imul(ah0, bl9) | 0, hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0, w9 &= 67108863, lo = Math.imul(al9, bl1), mid = Math.imul(al9, bh1), mid = mid + Math.imul(ah9, bl1) | 0, hi = Math.imul(ah9, bh1), lo = lo + Math.imul(al8, bl2) | 0, mid = mid + Math.imul(al8, bh2) | 0, mid = mid + Math.imul(ah8, bl2) | 0, hi = hi + Math.imul(ah8, bh2) | 0, lo = lo + Math.imul(al7, bl3) | 0, mid = mid + Math.imul(al7, bh3) | 0, mid = mid + Math.imul(ah7, bl3) | 0, hi = hi + Math.imul(ah7, bh3) | 0, lo = lo + Math.imul(al6, bl4) | 0, mid = mid + Math.imul(al6, bh4) | 0, mid = mid + Math.imul(ah6, bl4) | 0, hi = hi + Math.imul(ah6, bh4) | 0, lo = lo + Math.imul(al5, bl5) | 0, mid = mid + Math.imul(al5, bh5) | 0, mid = mid + Math.imul(ah5, bl5) | 0, hi = hi + Math.imul(ah5, bh5) | 0, lo = lo + Math.imul(al4, bl6) | 0, mid = mid + Math.imul(al4, bh6) | 0, mid = mid + Math.imul(ah4, bl6) | 0, hi = hi + Math.imul(ah4, bh6) | 0, lo = lo + Math.imul(al3, bl7) | 0, mid = mid + Math.imul(al3, bh7) | 0, mid = mid + Math.imul(ah3, bl7) | 0, hi = hi + Math.imul(ah3, bh7) | 0, lo = lo + Math.imul(al2, bl8) | 0, mid = mid + Math.imul(al2, bh8) | 0, mid = mid + Math.imul(ah2, bl8) | 0, hi = hi + Math.imul(ah2, bh8) | 0, lo = lo + Math.imul(al1, bl9) | 0, mid = mid + Math.imul(al1, bh9) | 0, mid = mid + Math.imul(ah1, bl9) | 0, hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0, w10 &= 67108863, lo = Math.imul(al9, bl2), mid = Math.imul(al9, bh2), mid = mid + Math.imul(ah9, bl2) | 0, hi = Math.imul(ah9, bh2), lo = lo + Math.imul(al8, bl3) | 0, mid = mid + Math.imul(al8, bh3) | 0, mid = mid + Math.imul(ah8, bl3) | 0, hi = hi + Math.imul(ah8, bh3) | 0, lo = lo + Math.imul(al7, bl4) | 0, mid = mid + Math.imul(al7, bh4) | 0, mid = mid + Math.imul(ah7, bl4) | 0, hi = hi + Math.imul(ah7, bh4) | 0, lo = lo + Math.imul(al6, bl5) | 0, mid = mid + Math.imul(al6, bh5) | 0, mid = mid + Math.imul(ah6, bl5) | 0, hi = hi + Math.imul(ah6, bh5) | 0, lo = lo + Math.imul(al5, bl6) | 0, mid = mid + Math.imul(al5, bh6) | 0, mid = mid + Math.imul(ah5, bl6) | 0, hi = hi + Math.imul(ah5, bh6) | 0, lo = lo + Math.imul(al4, bl7) | 0, mid = mid + Math.imul(al4, bh7) | 0, mid = mid + Math.imul(ah4, bl7) | 0, hi = hi + Math.imul(ah4, bh7) | 0, lo = lo + Math.imul(al3, bl8) | 0, mid = mid + Math.imul(al3, bh8) | 0, mid = mid + Math.imul(ah3, bl8) | 0, hi = hi + Math.imul(ah3, bh8) | 0, lo = lo + Math.imul(al2, bl9) | 0, mid = mid + Math.imul(al2, bh9) | 0, mid = mid + Math.imul(ah2, bl9) | 0, hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0, w11 &= 67108863, lo = Math.imul(al9, bl3), mid = Math.imul(al9, bh3), mid = mid + Math.imul(ah9, bl3) | 0, hi = Math.imul(ah9, bh3), lo = lo + Math.imul(al8, bl4) | 0, mid = mid + Math.imul(al8, bh4) | 0, mid = mid + Math.imul(ah8, bl4) | 0, hi = hi + Math.imul(ah8, bh4) | 0, lo = lo + Math.imul(al7, bl5) | 0, mid = mid + Math.imul(al7, bh5) | 0, mid = mid + Math.imul(ah7, bl5) | 0, hi = hi + Math.imul(ah7, bh5) | 0, lo = lo + Math.imul(al6, bl6) | 0, mid = mid + Math.imul(al6, bh6) | 0, mid = mid + Math.imul(ah6, bl6) | 0, hi = hi + Math.imul(ah6, bh6) | 0, lo = lo + Math.imul(al5, bl7) | 0, mid = mid + Math.imul(al5, bh7) | 0, mid = mid + Math.imul(ah5, bl7) | 0, hi = hi + Math.imul(ah5, bh7) | 0, lo = lo + Math.imul(al4, bl8) | 0, mid = mid + Math.imul(al4, bh8) | 0, mid = mid + Math.imul(ah4, bl8) | 0, hi = hi + Math.imul(ah4, bh8) | 0, lo = lo + Math.imul(al3, bl9) | 0, mid = mid + Math.imul(al3, bh9) | 0, mid = mid + Math.imul(ah3, bl9) | 0, hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0, w12 &= 67108863, lo = Math.imul(al9, bl4), mid = Math.imul(al9, bh4), mid = mid + Math.imul(ah9, bl4) | 0, hi = Math.imul(ah9, bh4), lo = lo + Math.imul(al8, bl5) | 0, mid = mid + Math.imul(al8, bh5) | 0, mid = mid + Math.imul(ah8, bl5) | 0, hi = hi + Math.imul(ah8, bh5) | 0, lo = lo + Math.imul(al7, bl6) | 0, mid = mid + Math.imul(al7, bh6) | 0, mid = mid + Math.imul(ah7, bl6) | 0, hi = hi + Math.imul(ah7, bh6) | 0, lo = lo + Math.imul(al6, bl7) | 0, mid = mid + Math.imul(al6, bh7) | 0, mid = mid + Math.imul(ah6, bl7) | 0, hi = hi + Math.imul(ah6, bh7) | 0, lo = lo + Math.imul(al5, bl8) | 0, mid = mid + Math.imul(al5, bh8) | 0, mid = mid + Math.imul(ah5, bl8) | 0, hi = hi + Math.imul(ah5, bh8) | 0, lo = lo + Math.imul(al4, bl9) | 0, mid = mid + Math.imul(al4, bh9) | 0, mid = mid + Math.imul(ah4, bl9) | 0, hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0, w13 &= 67108863, lo = Math.imul(al9, bl5), mid = Math.imul(al9, bh5), mid = mid + Math.imul(ah9, bl5) | 0, hi = Math.imul(ah9, bh5), lo = lo + Math.imul(al8, bl6) | 0, mid = mid + Math.imul(al8, bh6) | 0, mid = mid + Math.imul(ah8, bl6) | 0, hi = hi + Math.imul(ah8, bh6) | 0, lo = lo + Math.imul(al7, bl7) | 0, mid = mid + Math.imul(al7, bh7) | 0, mid = mid + Math.imul(ah7, bl7) | 0, hi = hi + Math.imul(ah7, bh7) | 0, lo = lo + Math.imul(al6, bl8) | 0, mid = mid + Math.imul(al6, bh8) | 0, mid = mid + Math.imul(ah6, bl8) | 0, hi = hi + Math.imul(ah6, bh8) | 0, lo = lo + Math.imul(al5, bl9) | 0, mid = mid + Math.imul(al5, bh9) | 0, mid = mid + Math.imul(ah5, bl9) | 0, hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0, w14 &= 67108863, lo = Math.imul(al9, bl6), mid = Math.imul(al9, bh6), mid = mid + Math.imul(ah9, bl6) | 0, hi = Math.imul(ah9, bh6), lo = lo + Math.imul(al8, bl7) | 0, mid = mid + Math.imul(al8, bh7) | 0, mid = mid + Math.imul(ah8, bl7) | 0, hi = hi + Math.imul(ah8, bh7) | 0, lo = lo + Math.imul(al7, bl8) | 0, mid = mid + Math.imul(al7, bh8) | 0, mid = mid + Math.imul(ah7, bl8) | 0, hi = hi + Math.imul(ah7, bh8) | 0, lo = lo + Math.imul(al6, bl9) | 0, mid = mid + Math.imul(al6, bh9) | 0, mid = mid + Math.imul(ah6, bl9) | 0, hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0, w15 &= 67108863, lo = Math.imul(al9, bl7), mid = Math.imul(al9, bh7), mid = mid + Math.imul(ah9, bl7) | 0, hi = Math.imul(ah9, bh7), lo = lo + Math.imul(al8, bl8) | 0, mid = mid + Math.imul(al8, bh8) | 0, mid = mid + Math.imul(ah8, bl8) | 0, hi = hi + Math.imul(ah8, bh8) | 0, lo = lo + Math.imul(al7, bl9) | 0, mid = mid + Math.imul(al7, bh9) | 0, mid = mid + Math.imul(ah7, bl9) | 0, hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0, w16 &= 67108863, lo = Math.imul(al9, bl8), mid = Math.imul(al9, bh8), mid = mid + Math.imul(ah9, bl8) | 0, hi = Math.imul(ah9, bh8), lo = lo + Math.imul(al8, bl9) | 0, mid = mid + Math.imul(al8, bh9) | 0, mid = mid + Math.imul(ah8, bl9) | 0, hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0, w17 &= 67108863, lo = Math.imul(al9, bl9), mid = Math.imul(al9, bh9), mid = mid + Math.imul(ah9, bl9) | 0, hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        if (c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0, w18 &= 67108863, o[0] = w0, o[1] = w1, o[2] = w2, o[3] = w3, o[4] = w4, o[5] = w5, o[6] = w6, o[7] = w7, o[8] = w8, o[9] = w9, o[10] = w10, o[11] = w11, o[12] = w12, o[13] = w13, o[14] = w14, o[15] = w15, o[16] = w16, o[17] = w17, o[18] = w18, c !== 0)
          o[19] = c, out.length++;
        return out;
      };
      if (!Math.imul)
        comb10MulTo = smallMulTo;
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative, out.length = self2.length + num.length;
        var carry = 0, hncarry = 0;
        for (var k = 0;k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863, maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
            var i2 = k - j, a = self2.words[i2] | 0, b = num.words[j] | 0, r = a * b, lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0, lo = lo + rword | 0, rword = lo & 67108863, ncarry = ncarry + (lo >>> 26) | 0, hncarry += ncarry >>> 26, ncarry &= 67108863;
          }
          out.words[k] = rword, carry = ncarry, ncarry = hncarry;
        }
        if (carry !== 0)
          out.words[k] = carry;
        else
          out.length--;
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM;
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res, len2 = this.length + num.length;
        if (this.length === 10 && num.length === 10)
          res = comb10MulTo(this, num, out);
        else if (len2 < 63)
          res = smallMulTo(this, num, out);
        else if (len2 < 1024)
          res = bigMulTo(this, num, out);
        else
          res = jumboMulTo(this, num, out);
        return res;
      };
      function FFTM(x, y) {
        this.x = x, this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t2 = new Array(N), l = BN.prototype._countBits(N) - 1;
        for (var i2 = 0;i2 < N; i2++)
          t2[i2] = this.revBin(i2, l, N);
        return t2;
      }, FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i2 = 0;i2 < l; i2++)
          rb |= (x & 1) << l - i2 - 1, x >>= 1;
        return rb;
      }, FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i2 = 0;i2 < N; i2++)
          rtws[i2] = rws[rbt[i2]], itws[i2] = iws[rbt[i2]];
      }, FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1;s < N; s <<= 1) {
          var l = s << 1, rtwdf = Math.cos(2 * Math.PI / l), itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0;p < N; p += l) {
            var rtwdf_ = rtwdf, itwdf_ = itwdf;
            for (var j = 0;j < s; j++) {
              var re = rtws[p + j], ie = itws[p + j], ro = rtws[p + j + s], io = itws[p + j + s], rx = rtwdf_ * ro - itwdf_ * io;
              if (io = rtwdf_ * io + itwdf_ * ro, ro = rx, rtws[p + j] = re + ro, itws[p + j] = ie + io, rtws[p + j + s] = re - ro, itws[p + j + s] = ie - io, j !== l)
                rx = rtwdf * rtwdf_ - itwdf * itwdf_, itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_, rtwdf_ = rx;
            }
          }
        }
      }, FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1, odd = N & 1, i2 = 0;
        for (N = N / 2 | 0;N; N = N >>> 1)
          i2++;
        return 1 << i2 + 1 + odd;
      }, FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i2 = 0;i2 < N / 2; i2++) {
          var t2 = rws[i2];
          rws[i2] = rws[N - i2 - 1], rws[N - i2 - 1] = t2, t2 = iws[i2], iws[i2] = -iws[N - i2 - 1], iws[N - i2 - 1] = -t2;
        }
      }, FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i2 = 0;i2 < N / 2; i2++) {
          var w = Math.round(ws[2 * i2 + 1] / N) * 8192 + Math.round(ws[2 * i2] / N) + carry;
          if (ws[i2] = w & 67108863, w < 67108864)
            carry = 0;
          else
            carry = w / 67108864 | 0;
        }
        return ws;
      }, FFTM.prototype.convert13b = function convert13b(ws, len2, rws, N) {
        var carry = 0;
        for (var i2 = 0;i2 < len2; i2++)
          carry = carry + (ws[i2] | 0), rws[2 * i2] = carry & 8191, carry = carry >>> 13, rws[2 * i2 + 1] = carry & 8191, carry = carry >>> 13;
        for (i2 = 2 * len2;i2 < N; ++i2)
          rws[i2] = 0;
        assert(carry === 0), assert((carry & -8192) === 0);
      }, FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i2 = 0;i2 < N; i2++)
          ph[i2] = 0;
        return ph;
      }, FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length), rbt = this.makeRBT(N), _ = this.stub(N), rws = new Array(N), rwst = new Array(N), iwst = new Array(N), nrws = new Array(N), nrwst = new Array(N), niwst = new Array(N), rmws = out.words;
        rmws.length = N, this.convert13b(x.words, x.length, rws, N), this.convert13b(y.words, y.length, nrws, N), this.transform(rws, _, rwst, iwst, N, rbt), this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i2 = 0;i2 < N; i2++) {
          var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
          iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2], rwst[i2] = rx;
        }
        return this.conjugate(rwst, iwst, N), this.transform(rwst, iwst, rmws, _, N, rbt), this.conjugate(rmws, _, N), this.normalize13b(rmws, N), out.negative = x.negative ^ y.negative, out.length = x.length + y.length, out.strip();
      }, BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        return out.words = new Array(this.length + num.length), this.mulTo(num, out);
      }, BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        return out.words = new Array(this.length + num.length), jumboMulTo(this, num, out);
      }, BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      }, BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number"), assert(num < 67108864);
        var carry = 0;
        for (var i2 = 0;i2 < this.length; i2++) {
          var w = (this.words[i2] | 0) * num, lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26, carry += w / 67108864 | 0, carry += lo >>> 26, this.words[i2] = lo & 67108863;
        }
        if (carry !== 0)
          this.words[i2] = carry, this.length++;
        return this.length = num === 0 ? 1 : this.length, this;
      }, BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      }, BN.prototype.sqr = function sqr() {
        return this.mul(this);
      }, BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      }, BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i2 = 0;i2 < w.length; i2++, res = res.sqr())
          if (w[i2] !== 0)
            break;
        if (++i2 < w.length)
          for (var q = res.sqr();i2 < w.length; i2++, q = q.sqr()) {
            if (w[i2] === 0)
              continue;
            res = res.mul(q);
          }
        return res;
      }, BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26, s = (bits - r) / 26, carryMask = 67108863 >>> 26 - r << 26 - r, i2;
        if (r !== 0) {
          var carry = 0;
          for (i2 = 0;i2 < this.length; i2++) {
            var newCarry = this.words[i2] & carryMask, c = (this.words[i2] | 0) - newCarry << r;
            this.words[i2] = c | carry, carry = newCarry >>> 26 - r;
          }
          if (carry)
            this.words[i2] = carry, this.length++;
        }
        if (s !== 0) {
          for (i2 = this.length - 1;i2 >= 0; i2--)
            this.words[i2 + s] = this.words[i2];
          for (i2 = 0;i2 < s; i2++)
            this.words[i2] = 0;
          this.length += s;
        }
        return this.strip();
      }, BN.prototype.ishln = function ishln(bits) {
        return assert(this.negative === 0), this.iushln(bits);
      }, BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint)
          h = (hint - hint % 26) / 26;
        else
          h = 0;
        var r = bits % 26, s = Math.min((bits - r) / 26, this.length), mask = 67108863 ^ 67108863 >>> r << r, maskedWords = extended;
        if (h -= s, h = Math.max(0, h), maskedWords) {
          for (var i2 = 0;i2 < s; i2++)
            maskedWords.words[i2] = this.words[i2];
          maskedWords.length = s;
        }
        if (s === 0)
          ;
        else if (this.length > s) {
          this.length -= s;
          for (i2 = 0;i2 < this.length; i2++)
            this.words[i2] = this.words[i2 + s];
        } else
          this.words[0] = 0, this.length = 1;
        var carry = 0;
        for (i2 = this.length - 1;i2 >= 0 && (carry !== 0 || i2 >= h); i2--) {
          var word = this.words[i2] | 0;
          this.words[i2] = carry << 26 - r | word >>> r, carry = word & mask;
        }
        if (maskedWords && carry !== 0)
          maskedWords.words[maskedWords.length++] = carry;
        if (this.length === 0)
          this.words[0] = 0, this.length = 1;
        return this.strip();
      }, BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        return assert(this.negative === 0), this.iushrn(bits, hint, extended);
      }, BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      }, BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      }, BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      }, BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      }, BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26, s = (bit - r) / 26, q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      }, BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26, s = (bits - r) / 26;
        if (assert(this.negative === 0, "imaskn works only with positive numbers"), this.length <= s)
          return this;
        if (r !== 0)
          s++;
        if (this.length = Math.min(s, this.length), r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      }, BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      }, BN.prototype.iaddn = function iaddn(num) {
        if (assert(typeof num === "number"), assert(num < 67108864), num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num)
            return this.words[0] = num - (this.words[0] | 0), this.negative = 0, this;
          return this.negative = 0, this.isubn(num), this.negative = 1, this;
        }
        return this._iaddn(num);
      }, BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i2 = 0;i2 < this.length && this.words[i2] >= 67108864; i2++)
          if (this.words[i2] -= 67108864, i2 === this.length - 1)
            this.words[i2 + 1] = 1;
          else
            this.words[i2 + 1]++;
        return this.length = Math.max(this.length, i2 + 1), this;
      }, BN.prototype.isubn = function isubn(num) {
        if (assert(typeof num === "number"), assert(num < 67108864), num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(num), this.negative = 1, this;
        if (this.words[0] -= num, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var i2 = 0;i2 < this.length && this.words[i2] < 0; i2++)
            this.words[i2] += 67108864, this.words[i2 + 1] -= 1;
        return this.strip();
      }, BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      }, BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      }, BN.prototype.iabs = function iabs() {
        return this.negative = 0, this;
      }, BN.prototype.abs = function abs() {
        return this.clone().iabs();
      }, BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len2 = num.length + shift, i2;
        this._expand(len2);
        var w, carry = 0;
        for (i2 = 0;i2 < num.length; i2++) {
          w = (this.words[i2 + shift] | 0) + carry;
          var right = (num.words[i2] | 0) * mul;
          w -= right & 67108863, carry = (w >> 26) - (right / 67108864 | 0), this.words[i2 + shift] = w & 67108863;
        }
        for (;i2 < this.length - shift; i2++)
          w = (this.words[i2 + shift] | 0) + carry, carry = w >> 26, this.words[i2 + shift] = w & 67108863;
        if (carry === 0)
          return this.strip();
        assert(carry === -1), carry = 0;
        for (i2 = 0;i2 < this.length; i2++)
          w = -(this.words[i2] | 0) + carry, carry = w >> 26, this.words[i2] = w & 67108863;
        return this.negative = 1, this.strip();
      }, BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length, a = this.clone(), b = num, bhi = b.words[b.length - 1] | 0, bhiBits = this._countBits(bhi);
        if (shift = 26 - bhiBits, shift !== 0)
          b = b.ushln(shift), a.iushln(shift), bhi = b.words[b.length - 1] | 0;
        var m = a.length - b.length, q;
        if (mode !== "mod") {
          q = new BN(null), q.length = m + 1, q.words = new Array(q.length);
          for (var i2 = 0;i2 < q.length; i2++)
            q.words[i2] = 0;
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          if (a = diff, q)
            q.words[m] = 1;
        }
        for (var j = m - 1;j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863), a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0)
            if (qj--, a.negative = 0, a._ishlnsubmul(b, 1, j), !a.isZero())
              a.negative ^= 1;
          if (q)
            q.words[j] = qj;
        }
        if (q)
          q.strip();
        if (a.strip(), mode !== "div" && shift !== 0)
          a.iushrn(shift);
        return { div: q || null, mod: a };
      }, BN.prototype.divmod = function divmod(num, mode, positive) {
        if (assert(!num.isZero()), this.isZero())
          return { div: new BN(0), mod: new BN(0) };
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          if (res = this.neg().divmod(num, mode), mode !== "mod")
            div = res.div.neg();
          if (mode !== "div") {
            if (mod = res.mod.neg(), positive && mod.negative !== 0)
              mod.iadd(num);
          }
          return { div, mod };
        }
        if (this.negative === 0 && num.negative !== 0) {
          if (res = this.divmod(num.neg(), mode), mode !== "mod")
            div = res.div.neg();
          return { div, mod: res.mod };
        }
        if ((this.negative & num.negative) !== 0) {
          if (res = this.neg().divmod(num.neg(), mode), mode !== "div") {
            if (mod = res.mod.neg(), positive && mod.negative !== 0)
              mod.isub(num);
          }
          return { div: res.div, mod };
        }
        if (num.length > this.length || this.cmp(num) < 0)
          return { div: new BN(0), mod: this };
        if (num.length === 1) {
          if (mode === "div")
            return { div: this.divn(num.words[0]), mod: null };
          if (mode === "mod")
            return { div: null, mod: new BN(this.modn(num.words[0])) };
          return { div: this.divn(num.words[0]), mod: new BN(this.modn(num.words[0])) };
        }
        return this._wordDiv(num, mode);
      }, BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      }, BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      }, BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      }, BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod, half = num.ushrn(1), r2 = num.andln(1), cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      }, BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = 67108864 % num, acc = 0;
        for (var i2 = this.length - 1;i2 >= 0; i2--)
          acc = (p * acc + (this.words[i2] | 0)) % num;
        return acc;
      }, BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i2 = this.length - 1;i2 >= 0; i2--) {
          var w = (this.words[i2] | 0) + carry * 67108864;
          this.words[i2] = w / num | 0, carry = w % num;
        }
        return this.strip();
      }, BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      }, BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0), assert(!p.isZero());
        var x = this, y = p.clone();
        if (x.negative !== 0)
          x = x.umod(p);
        else
          x = x.clone();
        var A = new BN(1), B = new BN(0), C = new BN(0), D = new BN(1), g = 0;
        while (x.isEven() && y.isEven())
          x.iushrn(1), y.iushrn(1), ++g;
        var yp = y.clone(), xp = x.clone();
        while (!x.isZero()) {
          for (var i2 = 0, im = 1;(x.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            x.iushrn(i2);
            while (i2-- > 0) {
              if (A.isOdd() || B.isOdd())
                A.iadd(yp), B.isub(xp);
              A.iushrn(1), B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1;(y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd())
                C.iadd(yp), D.isub(xp);
              C.iushrn(1), D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0)
            x.isub(y), A.isub(C), B.isub(D);
          else
            y.isub(x), C.isub(A), D.isub(B);
        }
        return { a: C, b: D, gcd: y.iushln(g) };
      }, BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0), assert(!p.isZero());
        var a = this, b = p.clone();
        if (a.negative !== 0)
          a = a.umod(p);
        else
          a = a.clone();
        var x1 = new BN(1), x2 = new BN(0), delta3 = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i2 = 0, im = 1;(a.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            a.iushrn(i2);
            while (i2-- > 0) {
              if (x1.isOdd())
                x1.iadd(delta3);
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1;(b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd())
                x2.iadd(delta3);
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0)
            a.isub(b), x1.isub(x2);
          else
            b.isub(a), x2.isub(x1);
        }
        var res;
        if (a.cmpn(1) === 0)
          res = x1;
        else
          res = x2;
        if (res.cmpn(0) < 0)
          res.iadd(p);
        return res;
      }, BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone(), b = num.clone();
        a.negative = 0, b.negative = 0;
        for (var shift = 0;a.isEven() && b.isEven(); shift++)
          a.iushrn(1), b.iushrn(1);
        do {
          while (a.isEven())
            a.iushrn(1);
          while (b.isEven())
            b.iushrn(1);
          var r = a.cmp(b);
          if (r < 0) {
            var t2 = a;
            a = b, b = t2;
          } else if (r === 0 || b.cmpn(1) === 0)
            break;
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      }, BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      }, BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      }, BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      }, BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      }, BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26, s = (bit - r) / 26, q = 1 << r;
        if (this.length <= s)
          return this._expand(s + 1), this.words[s] |= q, this;
        var carry = q;
        for (var i2 = s;carry !== 0 && i2 < this.length; i2++) {
          var w = this.words[i2] | 0;
          w += carry, carry = w >>> 26, w &= 67108863, this.words[i2] = w;
        }
        if (carry !== 0)
          this.words[i2] = carry, this.length++;
        return this;
      }, BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      }, BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1)
          res = 1;
        else {
          if (negative)
            num = -num;
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      }, BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      }, BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i2 = this.length - 1;i2 >= 0; i2--) {
          var a = this.words[i2] | 0, b = num.words[i2] | 0;
          if (a === b)
            continue;
          if (a < b)
            res = -1;
          else if (a > b)
            res = 1;
          break;
        }
        return res;
      }, BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      }, BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      }, BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      }, BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      }, BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      }, BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      }, BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      }, BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      }, BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      }, BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      }, BN.red = function red(num) {
        return new Red(num);
      }, BN.prototype.toRed = function toRed(ctx) {
        return assert(!this.red, "Already a number in reduction context"), assert(this.negative === 0, "red works only with positives"), ctx.convertTo(this)._forceRed(ctx);
      }, BN.prototype.fromRed = function fromRed() {
        return assert(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, BN.prototype._forceRed = function _forceRed(ctx) {
        return this.red = ctx, this;
      }, BN.prototype.forceRed = function forceRed(ctx) {
        return assert(!this.red, "Already a number in reduction context"), this._forceRed(ctx);
      }, BN.prototype.redAdd = function redAdd(num) {
        return assert(this.red, "redAdd works only with red numbers"), this.red.add(this, num);
      }, BN.prototype.redIAdd = function redIAdd(num) {
        return assert(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, num);
      }, BN.prototype.redSub = function redSub(num) {
        return assert(this.red, "redSub works only with red numbers"), this.red.sub(this, num);
      }, BN.prototype.redISub = function redISub(num) {
        return assert(this.red, "redISub works only with red numbers"), this.red.isub(this, num);
      }, BN.prototype.redShl = function redShl(num) {
        return assert(this.red, "redShl works only with red numbers"), this.red.shl(this, num);
      }, BN.prototype.redMul = function redMul(num) {
        return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.mul(this, num);
      }, BN.prototype.redIMul = function redIMul(num) {
        return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.imul(this, num);
      }, BN.prototype.redSqr = function redSqr() {
        return assert(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, BN.prototype.redISqr = function redISqr() {
        return assert(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, BN.prototype.redSqrt = function redSqrt() {
        return assert(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, BN.prototype.redInvm = function redInvm() {
        return assert(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, BN.prototype.redNeg = function redNeg() {
        return assert(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, BN.prototype.redPow = function redPow(num) {
        return assert(this.red && !num.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, num);
      };
      var primes = { k256: null, p224: null, p192: null, p25519: null };
      function MPrime(name, p) {
        this.name = name, this.p = new BN(p, 16), this.n = this.p.bitLength(), this.k = new BN(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        return tmp.words = new Array(Math.ceil(this.n / 13)), tmp;
      }, MPrime.prototype.ireduce = function ireduce(num) {
        var r = num, rlen;
        do
          this.split(r, this.tmp), r = this.imulK(r), r = r.iadd(this.tmp), rlen = r.bitLength();
        while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0)
          r.words[0] = 0, r.length = 1;
        else if (cmp > 0)
          r.isub(this.p);
        else if (r.strip !== undefined)
          r.strip();
        else
          r._strip();
        return r;
      }, MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      }, MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      inherits2(K256, MPrime), K256.prototype.split = function split(input, output) {
        var mask = 4194303, outLen = Math.min(input.length, 9);
        for (var i2 = 0;i2 < outLen; i2++)
          output.words[i2] = input.words[i2];
        if (output.length = outLen, input.length <= 9) {
          input.words[0] = 0, input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i2 = 10;i2 < input.length; i2++) {
          var next = input.words[i2] | 0;
          input.words[i2 - 10] = (next & mask) << 4 | prev >>> 22, prev = next;
        }
        if (prev >>>= 22, input.words[i2 - 10] = prev, prev === 0 && input.length > 10)
          input.length -= 10;
        else
          input.length -= 9;
      }, K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0, num.words[num.length + 1] = 0, num.length += 2;
        var lo = 0;
        for (var i2 = 0;i2 < num.length; i2++) {
          var w = num.words[i2] | 0;
          lo += w * 977, num.words[i2] = lo & 67108863, lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          if (num.length--, num.words[num.length - 1] === 0)
            num.length--;
        }
        return num;
      };
      function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      inherits2(P25519, MPrime), P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i2 = 0;i2 < num.length; i2++) {
          var hi = (num.words[i2] | 0) * 19 + carry, lo = hi & 67108863;
          hi >>>= 26, num.words[i2] = lo, carry = hi;
        }
        if (carry !== 0)
          num.words[num.length++] = carry;
        return num;
      }, BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime;
        if (name === "k256")
          prime = new K256;
        else if (name === "p224")
          prime = new P224;
        else if (name === "p192")
          prime = new P192;
        else if (name === "p25519")
          prime = new P25519;
        else
          throw new Error("Unknown prime " + name);
        return primes[name] = prime, prime;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p, this.prime = prime;
        } else
          assert(m.gtn(1), "modulus must be greater than 1"), this.m = m, this.prime = null;
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives"), assert(a.red, "red works only with red numbers");
      }, Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives"), assert(a.red && a.red === b.red, "red works only with red numbers");
      }, Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      }, Red.prototype.neg = function neg(a) {
        if (a.isZero())
          return a.clone();
        return this.m.sub(a)._forceRed(this);
      }, Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0)
          res.isub(this.m);
        return res._forceRed(this);
      }, Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0)
          res.isub(this.m);
        return res;
      }, Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0)
          res.iadd(this.m);
        return res._forceRed(this);
      }, Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0)
          res.iadd(this.m);
        return res;
      }, Red.prototype.shl = function shl(a, num) {
        return this._verify1(a), this.imod(a.ushln(num));
      }, Red.prototype.imul = function imul(a, b) {
        return this._verify2(a, b), this.imod(a.imul(b));
      }, Red.prototype.mul = function mul(a, b) {
        return this._verify2(a, b), this.imod(a.mul(b));
      }, Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      }, Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      }, Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        if (assert(mod3 % 2 === 1), mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1), s = 0;
        while (!q.isZero() && q.andln(1) === 0)
          s++, q.iushrn(1);
        assert(!q.isZero());
        var one = new BN(1).toRed(this), nOne = one.redNeg(), lpow = this.m.subn(1).iushrn(1), z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0)
          z.redIAdd(nOne);
        var c = this.pow(z, q), r = this.pow(a, q.addn(1).iushrn(1)), t2 = this.pow(a, q), m = s;
        while (t2.cmp(one) !== 0) {
          var tmp = t2;
          for (var i2 = 0;tmp.cmp(one) !== 0; i2++)
            tmp = tmp.redSqr();
          assert(i2 < m);
          var b = this.pow(c, new BN(1).iushln(m - i2 - 1));
          r = r.redMul(b), c = b.redSqr(), t2 = t2.redMul(c), m = i2;
        }
        return r;
      }, Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0)
          return inv.negative = 0, this.imod(inv).redNeg();
        else
          return this.imod(inv);
      }, Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4, wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this), wnd[1] = a;
        for (var i2 = 2;i2 < wnd.length; i2++)
          wnd[i2] = this.mul(wnd[i2 - 1], a);
        var res = wnd[0], current = 0, currentLen = 0, start = num.bitLength() % 26;
        if (start === 0)
          start = 26;
        for (i2 = num.length - 1;i2 >= 0; i2--) {
          var word = num.words[i2];
          for (var j = start - 1;j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0])
              res = this.sqr(res);
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            if (current <<= 1, current |= bit, currentLen++, currentLen !== windowSize && (i2 !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]), currentLen = 0, current = 0;
          }
          start = 26;
        }
        return res;
      }, Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      }, Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        return res.red = null, res;
      }, BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        if (Red.call(this, m), this.shift = this.m.bitLength(), this.shift % 26 !== 0)
          this.shift += 26 - this.shift % 26;
        this.r = new BN(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red), Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      }, Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        return r.red = null, r;
      }, Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero())
          return a.words[0] = 0, a.length = 1, a;
        var t2 = a.imul(b), c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t2.isub(c).iushrn(this.shift), res = u;
        if (u.cmp(this.m) >= 0)
          res = u.isub(this.m);
        else if (u.cmpn(0) < 0)
          res = u.iadd(this.m);
        return res._forceRed(this);
      }, Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t2 = a.mul(b), c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t2.isub(c).iushrn(this.shift), res = u;
        if (u.cmp(this.m) >= 0)
          res = u.isub(this.m);
        else if (u.cmpn(0) < 0)
          res = u.iadd(this.m);
        return res._forceRed(this);
      }, Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  });
  require_api = __commonJS2((exports) => {
    var asn1 = require_asn1(), inherits2 = require_inherits(), api = exports;
    api.define = function define(name, body) {
      return new Entity(name, body);
    };
    function Entity(name, body) {
      this.name = name, this.body = body, this.decoders = {}, this.encoders = {};
    }
    Entity.prototype._createNamed = function createNamed(base) {
      var named;
      try {
        named = (()=>{throw new Error("Cannot require module "+"vm");})().runInThisContext("(function " + this.name + `(entity) {
  this._initNamed(entity);
})`);
      } catch (e) {
        named = function(entity) {
          this._initNamed(entity);
        };
      }
      return inherits2(named, base), named.prototype._initNamed = function initnamed(entity) {
        base.call(this, entity);
      }, new named(this);
    };
    Entity.prototype._getDecoder = function _getDecoder(enc) {
      if (enc = enc || "der", !this.decoders.hasOwnProperty(enc))
        this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
      return this.decoders[enc];
    };
    Entity.prototype.decode = function decode(data, enc, options) {
      return this._getDecoder(enc).decode(data, options);
    };
    Entity.prototype._getEncoder = function _getEncoder(enc) {
      if (enc = enc || "der", !this.encoders.hasOwnProperty(enc))
        this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
      return this.encoders[enc];
    };
    Entity.prototype.encode = function encode(data, enc, reporter) {
      return this._getEncoder(enc).encode(data, reporter);
    };
  });
  require_reporter = __commonJS2((exports) => {
    var inherits2 = require_inherits();
    function Reporter(options) {
      this._reporterState = { obj: null, path: [], options: options || {}, errors: [] };
    }
    exports.Reporter = Reporter;
    Reporter.prototype.isError = function isError(obj) {
      return obj instanceof ReporterError;
    };
    Reporter.prototype.save = function save() {
      var state = this._reporterState;
      return { obj: state.obj, pathLen: state.path.length };
    };
    Reporter.prototype.restore = function restore(data) {
      var state = this._reporterState;
      state.obj = data.obj, state.path = state.path.slice(0, data.pathLen);
    };
    Reporter.prototype.enterKey = function enterKey(key) {
      return this._reporterState.path.push(key);
    };
    Reporter.prototype.exitKey = function exitKey(index) {
      var state = this._reporterState;
      state.path = state.path.slice(0, index - 1);
    };
    Reporter.prototype.leaveKey = function leaveKey(index, key, value2) {
      var state = this._reporterState;
      if (this.exitKey(index), state.obj !== null)
        state.obj[key] = value2;
    };
    Reporter.prototype.path = function path() {
      return this._reporterState.path.join("/");
    };
    Reporter.prototype.enterObject = function enterObject() {
      var state = this._reporterState, prev = state.obj;
      return state.obj = {}, prev;
    };
    Reporter.prototype.leaveObject = function leaveObject(prev) {
      var state = this._reporterState, now = state.obj;
      return state.obj = prev, now;
    };
    Reporter.prototype.error = function error(msg) {
      var err, state = this._reporterState, inherited = msg instanceof ReporterError;
      if (inherited)
        err = msg;
      else
        err = new ReporterError(state.path.map(function(elem) {
          return "[" + JSON.stringify(elem) + "]";
        }).join(""), msg.message || msg, msg.stack);
      if (!state.options.partial)
        throw err;
      if (!inherited)
        state.errors.push(err);
      return err;
    };
    Reporter.prototype.wrapResult = function wrapResult(result) {
      var state = this._reporterState;
      if (!state.options.partial)
        return result;
      return { result: this.isError(result) ? null : result, errors: state.errors };
    };
    function ReporterError(path, msg) {
      this.path = path, this.rethrow(msg);
    }
    inherits2(ReporterError, Error);
    ReporterError.prototype.rethrow = function rethrow(msg) {
      if (this.message = msg + " at: " + (this.path || "(shallow)"), Error.captureStackTrace)
        Error.captureStackTrace(this, ReporterError);
      if (!this.stack)
        try {
          throw new Error(this.message);
        } catch (e) {
          this.stack = e.stack;
        }
      return this;
    };
  });
  require_buffer = __commonJS2((exports) => {
    var inherits2 = require_inherits(), Reporter = require_base2().Reporter, Buffer22 = (init_buffer(), __toCommonJS(exports_buffer2)).Buffer;
    function DecoderBuffer(base, options) {
      if (Reporter.call(this, options), !Buffer22.isBuffer(base)) {
        this.error("Input not Buffer");
        return;
      }
      this.base = base, this.offset = 0, this.length = base.length;
    }
    inherits2(DecoderBuffer, Reporter);
    exports.DecoderBuffer = DecoderBuffer;
    DecoderBuffer.prototype.save = function save() {
      return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
    };
    DecoderBuffer.prototype.restore = function restore(save) {
      var res = new DecoderBuffer(this.base);
      return res.offset = save.offset, res.length = this.offset, this.offset = save.offset, Reporter.prototype.restore.call(this, save.reporter), res;
    };
    DecoderBuffer.prototype.isEmpty = function isEmpty() {
      return this.offset === this.length;
    };
    DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
      if (this.offset + 1 <= this.length)
        return this.base.readUInt8(this.offset++, true);
      else
        return this.error(fail || "DecoderBuffer overrun");
    };
    DecoderBuffer.prototype.skip = function skip(bytes, fail) {
      if (!(this.offset + bytes <= this.length))
        return this.error(fail || "DecoderBuffer overrun");
      var res = new DecoderBuffer(this.base);
      return res._reporterState = this._reporterState, res.offset = this.offset, res.length = this.offset + bytes, this.offset += bytes, res;
    };
    DecoderBuffer.prototype.raw = function raw(save) {
      return this.base.slice(save ? save.offset : this.offset, this.length);
    };
    function EncoderBuffer(value2, reporter) {
      if (Array.isArray(value2))
        this.length = 0, this.value = value2.map(function(item) {
          if (!(item instanceof EncoderBuffer))
            item = new EncoderBuffer(item, reporter);
          return this.length += item.length, item;
        }, this);
      else if (typeof value2 === "number") {
        if (!(0 <= value2 && value2 <= 255))
          return reporter.error("non-byte EncoderBuffer value");
        this.value = value2, this.length = 1;
      } else if (typeof value2 === "string")
        this.value = value2, this.length = Buffer22.byteLength(value2);
      else if (Buffer22.isBuffer(value2))
        this.value = value2, this.length = value2.length;
      else
        return reporter.error("Unsupported type: " + typeof value2);
    }
    exports.EncoderBuffer = EncoderBuffer;
    EncoderBuffer.prototype.join = function join(out, offset) {
      if (!out)
        out = new Buffer22(this.length);
      if (!offset)
        offset = 0;
      if (this.length === 0)
        return out;
      if (Array.isArray(this.value))
        this.value.forEach(function(item) {
          item.join(out, offset), offset += item.length;
        });
      else {
        if (typeof this.value === "number")
          out[offset] = this.value;
        else if (typeof this.value === "string")
          out.write(this.value, offset);
        else if (Buffer22.isBuffer(this.value))
          this.value.copy(out, offset);
        offset += this.length;
      }
      return out;
    };
  });
  require_node = __commonJS2((exports, module) => {
    var Reporter = require_base2().Reporter, EncoderBuffer = require_base2().EncoderBuffer, DecoderBuffer = require_base2().DecoderBuffer, assert = require_minimalistic_assert(), tags = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], methods = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(tags), overrided = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
    function Node(enc, parent) {
      var state = {};
      if (this._baseState = state, state.enc = enc, state.parent = parent || null, state.children = null, state.tag = null, state.args = null, state.reverseArgs = null, state.choice = null, state.optional = false, state.any = false, state.obj = false, state.use = null, state.useDecoder = null, state.key = null, state.default = null, state.explicit = null, state.implicit = null, state.contains = null, !state.parent)
        state.children = [], this._wrap();
    }
    module.exports = Node;
    var stateProps = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
    Node.prototype.clone = function clone() {
      var state = this._baseState, cstate = {};
      stateProps.forEach(function(prop) {
        cstate[prop] = state[prop];
      });
      var res = new this.constructor(cstate.parent);
      return res._baseState = cstate, res;
    };
    Node.prototype._wrap = function wrap() {
      var state = this._baseState;
      methods.forEach(function(method) {
        this[method] = function _wrappedMethod() {
          var clone4 = new this.constructor(this);
          return state.children.push(clone4), clone4[method].apply(clone4, arguments);
        };
      }, this);
    };
    Node.prototype._init = function init(body) {
      var state = this._baseState;
      assert(state.parent === null), body.call(this), state.children = state.children.filter(function(child) {
        return child._baseState.parent === this;
      }, this), assert.equal(state.children.length, 1, "Root node can have only one child");
    };
    Node.prototype._useArgs = function useArgs(args) {
      var state = this._baseState, children = args.filter(function(arg) {
        return arg instanceof this.constructor;
      }, this);
      if (args = args.filter(function(arg) {
        return !(arg instanceof this.constructor);
      }, this), children.length !== 0)
        assert(state.children === null), state.children = children, children.forEach(function(child) {
          child._baseState.parent = this;
        }, this);
      if (args.length !== 0)
        assert(state.args === null), state.args = args, state.reverseArgs = args.map(function(arg) {
          if (typeof arg !== "object" || arg.constructor !== Object)
            return arg;
          var res = {};
          return Object.keys(arg).forEach(function(key) {
            if (key == (key | 0))
              key |= 0;
            var value2 = arg[key];
            res[value2] = key;
          }), res;
        });
    };
    overrided.forEach(function(method) {
      Node.prototype[method] = function _overrided() {
        var state = this._baseState;
        throw new Error(method + " not implemented for encoding: " + state.enc);
      };
    });
    tags.forEach(function(tag) {
      Node.prototype[tag] = function _tagMethod() {
        var state = this._baseState, args = Array.prototype.slice.call(arguments);
        return assert(state.tag === null), state.tag = tag, this._useArgs(args), this;
      };
    });
    Node.prototype.use = function use(item) {
      assert(item);
      var state = this._baseState;
      return assert(state.use === null), state.use = item, this;
    };
    Node.prototype.optional = function optional() {
      var state = this._baseState;
      return state.optional = true, this;
    };
    Node.prototype.def = function def(val) {
      var state = this._baseState;
      return assert(state.default === null), state.default = val, state.optional = true, this;
    };
    Node.prototype.explicit = function explicit(num) {
      var state = this._baseState;
      return assert(state.explicit === null && state.implicit === null), state.explicit = num, this;
    };
    Node.prototype.implicit = function implicit(num) {
      var state = this._baseState;
      return assert(state.explicit === null && state.implicit === null), state.implicit = num, this;
    };
    Node.prototype.obj = function obj() {
      var state = this._baseState, args = Array.prototype.slice.call(arguments);
      if (state.obj = true, args.length !== 0)
        this._useArgs(args);
      return this;
    };
    Node.prototype.key = function key(newKey) {
      var state = this._baseState;
      return assert(state.key === null), state.key = newKey, this;
    };
    Node.prototype.any = function any() {
      var state = this._baseState;
      return state.any = true, this;
    };
    Node.prototype.choice = function choice(obj) {
      var state = this._baseState;
      return assert(state.choice === null), state.choice = obj, this._useArgs(Object.keys(obj).map(function(key) {
        return obj[key];
      })), this;
    };
    Node.prototype.contains = function contains(item) {
      var state = this._baseState;
      return assert(state.use === null), state.contains = item, this;
    };
    Node.prototype._decode = function decode(input, options) {
      var state = this._baseState;
      if (state.parent === null)
        return input.wrapResult(state.children[0]._decode(input, options));
      var result = state.default, present = true, prevKey = null;
      if (state.key !== null)
        prevKey = input.enterKey(state.key);
      if (state.optional) {
        var tag = null;
        if (state.explicit !== null)
          tag = state.explicit;
        else if (state.implicit !== null)
          tag = state.implicit;
        else if (state.tag !== null)
          tag = state.tag;
        if (tag === null && !state.any) {
          var save = input.save();
          try {
            if (state.choice === null)
              this._decodeGeneric(state.tag, input, options);
            else
              this._decodeChoice(input, options);
            present = true;
          } catch (e) {
            present = false;
          }
          input.restore(save);
        } else if (present = this._peekTag(input, tag, state.any), input.isError(present))
          return present;
      }
      var prevObj;
      if (state.obj && present)
        prevObj = input.enterObject();
      if (present) {
        if (state.explicit !== null) {
          var explicit = this._decodeTag(input, state.explicit);
          if (input.isError(explicit))
            return explicit;
          input = explicit;
        }
        var start = input.offset;
        if (state.use === null && state.choice === null) {
          if (state.any)
            var save = input.save();
          var body = this._decodeTag(input, state.implicit !== null ? state.implicit : state.tag, state.any);
          if (input.isError(body))
            return body;
          if (state.any)
            result = input.raw(save);
          else
            input = body;
        }
        if (options && options.track && state.tag !== null)
          options.track(input.path(), start, input.length, "tagged");
        if (options && options.track && state.tag !== null)
          options.track(input.path(), input.offset, input.length, "content");
        if (state.any)
          result = result;
        else if (state.choice === null)
          result = this._decodeGeneric(state.tag, input, options);
        else
          result = this._decodeChoice(input, options);
        if (input.isError(result))
          return result;
        if (!state.any && state.choice === null && state.children !== null)
          state.children.forEach(function decodeChildren(child) {
            child._decode(input, options);
          });
        if (state.contains && (state.tag === "octstr" || state.tag === "bitstr")) {
          var data = new DecoderBuffer(result);
          result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);
        }
      }
      if (state.obj && present)
        result = input.leaveObject(prevObj);
      if (state.key !== null && (result !== null || present === true))
        input.leaveKey(prevKey, state.key, result);
      else if (prevKey !== null)
        input.exitKey(prevKey);
      return result;
    };
    Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
      var state = this._baseState;
      if (tag === "seq" || tag === "set")
        return null;
      if (tag === "seqof" || tag === "setof")
        return this._decodeList(input, tag, state.args[0], options);
      else if (/str$/.test(tag))
        return this._decodeStr(input, tag, options);
      else if (tag === "objid" && state.args)
        return this._decodeObjid(input, state.args[0], state.args[1], options);
      else if (tag === "objid")
        return this._decodeObjid(input, null, null, options);
      else if (tag === "gentime" || tag === "utctime")
        return this._decodeTime(input, tag, options);
      else if (tag === "null_")
        return this._decodeNull(input, options);
      else if (tag === "bool")
        return this._decodeBool(input, options);
      else if (tag === "objDesc")
        return this._decodeStr(input, tag, options);
      else if (tag === "int" || tag === "enum")
        return this._decodeInt(input, state.args && state.args[0], options);
      if (state.use !== null)
        return this._getUse(state.use, input._reporterState.obj)._decode(input, options);
      else
        return input.error("unknown tag: " + tag);
    };
    Node.prototype._getUse = function _getUse(entity, obj) {
      var state = this._baseState;
      if (state.useDecoder = this._use(entity, obj), assert(state.useDecoder._baseState.parent === null), state.useDecoder = state.useDecoder._baseState.children[0], state.implicit !== state.useDecoder._baseState.implicit)
        state.useDecoder = state.useDecoder.clone(), state.useDecoder._baseState.implicit = state.implicit;
      return state.useDecoder;
    };
    Node.prototype._decodeChoice = function decodeChoice(input, options) {
      var state = this._baseState, result = null, match = false;
      if (Object.keys(state.choice).some(function(key) {
        var save = input.save(), node = state.choice[key];
        try {
          var value2 = node._decode(input, options);
          if (input.isError(value2))
            return false;
          result = { type: key, value: value2 }, match = true;
        } catch (e) {
          return input.restore(save), false;
        }
        return true;
      }, this), !match)
        return input.error("Choice not matched");
      return result;
    };
    Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
      return new EncoderBuffer(data, this.reporter);
    };
    Node.prototype._encode = function encode(data, reporter, parent) {
      var state = this._baseState;
      if (state.default !== null && state.default === data)
        return;
      var result = this._encodeValue(data, reporter, parent);
      if (result === undefined)
        return;
      if (this._skipDefault(result, reporter, parent))
        return;
      return result;
    };
    Node.prototype._encodeValue = function encode(data, reporter, parent) {
      var state = this._baseState;
      if (state.parent === null)
        return state.children[0]._encode(data, reporter || new Reporter);
      var result = null;
      if (this.reporter = reporter, state.optional && data === undefined)
        if (state.default !== null)
          data = state.default;
        else
          return;
      var content = null, primitive = false;
      if (state.any)
        result = this._createEncoderBuffer(data);
      else if (state.choice)
        result = this._encodeChoice(data, reporter);
      else if (state.contains)
        content = this._getUse(state.contains, parent)._encode(data, reporter), primitive = true;
      else if (state.children)
        content = state.children.map(function(child2) {
          if (child2._baseState.tag === "null_")
            return child2._encode(null, reporter, data);
          if (child2._baseState.key === null)
            return reporter.error("Child should have a key");
          var prevKey = reporter.enterKey(child2._baseState.key);
          if (typeof data !== "object")
            return reporter.error("Child expected, but input is not object");
          var res = child2._encode(data[child2._baseState.key], reporter, data);
          return reporter.leaveKey(prevKey), res;
        }, this).filter(function(child2) {
          return child2;
        }), content = this._createEncoderBuffer(content);
      else if (state.tag === "seqof" || state.tag === "setof") {
        if (!(state.args && state.args.length === 1))
          return reporter.error("Too many args for : " + state.tag);
        if (!Array.isArray(data))
          return reporter.error("seqof/setof, but data is not Array");
        var child = this.clone();
        child._baseState.implicit = null, content = this._createEncoderBuffer(data.map(function(item) {
          var state2 = this._baseState;
          return this._getUse(state2.args[0], data)._encode(item, reporter);
        }, child));
      } else if (state.use !== null)
        result = this._getUse(state.use, parent)._encode(data, reporter);
      else
        content = this._encodePrimitive(state.tag, data), primitive = true;
      var result;
      if (!state.any && state.choice === null) {
        var tag = state.implicit !== null ? state.implicit : state.tag, cls = state.implicit === null ? "universal" : "context";
        if (tag === null) {
          if (state.use === null)
            reporter.error("Tag could be omitted only for .use()");
        } else if (state.use === null)
          result = this._encodeComposite(tag, primitive, cls, content);
      }
      if (state.explicit !== null)
        result = this._encodeComposite(state.explicit, false, "context", result);
      return result;
    };
    Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
      var state = this._baseState, node = state.choice[data.type];
      if (!node)
        assert(false, data.type + " not found in " + JSON.stringify(Object.keys(state.choice)));
      return node._encode(data.value, reporter);
    };
    Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
      var state = this._baseState;
      if (/str$/.test(tag))
        return this._encodeStr(data, tag);
      else if (tag === "objid" && state.args)
        return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
      else if (tag === "objid")
        return this._encodeObjid(data, null, null);
      else if (tag === "gentime" || tag === "utctime")
        return this._encodeTime(data, tag);
      else if (tag === "null_")
        return this._encodeNull();
      else if (tag === "int" || tag === "enum")
        return this._encodeInt(data, state.args && state.reverseArgs[0]);
      else if (tag === "bool")
        return this._encodeBool(data);
      else if (tag === "objDesc")
        return this._encodeStr(data, tag);
      else
        throw new Error("Unsupported tag: " + tag);
    };
    Node.prototype._isNumstr = function isNumstr(str) {
      return /^[0-9 ]*$/.test(str);
    };
    Node.prototype._isPrintstr = function isPrintstr(str) {
      return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
    };
  });
  require_base2 = __commonJS2((exports) => {
    var base = exports;
    base.Reporter = require_reporter().Reporter;
    base.DecoderBuffer = require_buffer().DecoderBuffer;
    base.EncoderBuffer = require_buffer().EncoderBuffer;
    base.Node = require_node();
  });
  require_der = __commonJS2((exports) => {
    var constants2 = require_constants();
    exports.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" };
    exports.tagClassByName = constants2._reverse(exports.tagClass);
    exports.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" };
    exports.tagByName = constants2._reverse(exports.tag);
  });
  require_constants = __commonJS2((exports) => {
    var constants2 = exports;
    constants2._reverse = function reverse(map3) {
      var res = {};
      return Object.keys(map3).forEach(function(key) {
        if ((key | 0) == key)
          key = key | 0;
        var value2 = map3[key];
        res[value2] = key;
      }), res;
    };
    constants2.der = require_der();
  });
  require_der2 = __commonJS2((exports, module) => {
    var inherits2 = require_inherits(), asn1 = require_asn1(), base = asn1.base, bignum = asn1.bignum, der = asn1.constants.der;
    function DERDecoder(entity) {
      this.enc = "der", this.name = entity.name, this.entity = entity, this.tree = new DERNode, this.tree._init(entity.body);
    }
    module.exports = DERDecoder;
    DERDecoder.prototype.decode = function decode(data, options) {
      if (!(data instanceof base.DecoderBuffer))
        data = new base.DecoderBuffer(data, options);
      return this.tree._decode(data, options);
    };
    function DERNode(parent) {
      base.Node.call(this, "der", parent);
    }
    inherits2(DERNode, base.Node);
    DERNode.prototype._peekTag = function peekTag(buffer, tag, any3) {
      if (buffer.isEmpty())
        return false;
      var state = buffer.save(), decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
      if (buffer.isError(decodedTag))
        return decodedTag;
      return buffer.restore(state), decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + "of" === tag || any3;
    };
    DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any3) {
      var decodedTag = derDecodeTag(buffer, 'Failed to decode tag of "' + tag + '"');
      if (buffer.isError(decodedTag))
        return decodedTag;
      var len2 = derDecodeLen(buffer, decodedTag.primitive, 'Failed to get length of "' + tag + '"');
      if (buffer.isError(len2))
        return len2;
      if (!any3 && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + "of" !== tag)
        return buffer.error('Failed to match tag: "' + tag + '"');
      if (decodedTag.primitive || len2 !== null)
        return buffer.skip(len2, 'Failed to match body of: "' + tag + '"');
      var state = buffer.save(), res = this._skipUntilEnd(buffer, 'Failed to skip indefinite length body: "' + this.tag + '"');
      if (buffer.isError(res))
        return res;
      return len2 = buffer.offset - state.offset, buffer.restore(state), buffer.skip(len2, 'Failed to match body of: "' + tag + '"');
    };
    DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
      while (true) {
        var tag = derDecodeTag(buffer, fail);
        if (buffer.isError(tag))
          return tag;
        var len2 = derDecodeLen(buffer, tag.primitive, fail);
        if (buffer.isError(len2))
          return len2;
        var res;
        if (tag.primitive || len2 !== null)
          res = buffer.skip(len2);
        else
          res = this._skipUntilEnd(buffer, fail);
        if (buffer.isError(res))
          return res;
        if (tag.tagStr === "end")
          break;
      }
    };
    DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder, options) {
      var result = [];
      while (!buffer.isEmpty()) {
        var possibleEnd = this._peekTag(buffer, "end");
        if (buffer.isError(possibleEnd))
          return possibleEnd;
        var res = decoder.decode(buffer, "der", options);
        if (buffer.isError(res) && possibleEnd)
          break;
        result.push(res);
      }
      return result;
    };
    DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
      if (tag === "bitstr") {
        var unused = buffer.readUInt8();
        if (buffer.isError(unused))
          return unused;
        return { unused, data: buffer.raw() };
      } else if (tag === "bmpstr") {
        var raw = buffer.raw();
        if (raw.length % 2 === 1)
          return buffer.error("Decoding of string type: bmpstr length mismatch");
        var str = "";
        for (var i2 = 0;i2 < raw.length / 2; i2++)
          str += String.fromCharCode(raw.readUInt16BE(i2 * 2));
        return str;
      } else if (tag === "numstr") {
        var numstr = buffer.raw().toString("ascii");
        if (!this._isNumstr(numstr))
          return buffer.error("Decoding of string type: numstr unsupported characters");
        return numstr;
      } else if (tag === "octstr")
        return buffer.raw();
      else if (tag === "objDesc")
        return buffer.raw();
      else if (tag === "printstr") {
        var printstr = buffer.raw().toString("ascii");
        if (!this._isPrintstr(printstr))
          return buffer.error("Decoding of string type: printstr unsupported characters");
        return printstr;
      } else if (/str$/.test(tag))
        return buffer.raw().toString();
      else
        return buffer.error("Decoding of string type: " + tag + " unsupported");
    };
    DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
      var result, identifiers = [], ident = 0;
      while (!buffer.isEmpty()) {
        var subident = buffer.readUInt8();
        if (ident <<= 7, ident |= subident & 127, (subident & 128) === 0)
          identifiers.push(ident), ident = 0;
      }
      if (subident & 128)
        identifiers.push(ident);
      var first = identifiers[0] / 40 | 0, second = identifiers[0] % 40;
      if (relative)
        result = identifiers;
      else
        result = [first, second].concat(identifiers.slice(1));
      if (values) {
        var tmp = values[result.join(" ")];
        if (tmp === undefined)
          tmp = values[result.join(".")];
        if (tmp !== undefined)
          result = tmp;
      }
      return result;
    };
    DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
      var str = buffer.raw().toString();
      if (tag === "gentime")
        var year = str.slice(0, 4) | 0, mon = str.slice(4, 6) | 0, day = str.slice(6, 8) | 0, hour = str.slice(8, 10) | 0, min = str.slice(10, 12) | 0, sec = str.slice(12, 14) | 0;
      else if (tag === "utctime") {
        var year = str.slice(0, 2) | 0, mon = str.slice(2, 4) | 0, day = str.slice(4, 6) | 0, hour = str.slice(6, 8) | 0, min = str.slice(8, 10) | 0, sec = str.slice(10, 12) | 0;
        if (year < 70)
          year = 2000 + year;
        else
          year = 1900 + year;
      } else
        return buffer.error("Decoding " + tag + " time is not supported yet");
      return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
    };
    DERNode.prototype._decodeNull = function decodeNull(buffer) {
      return null;
    };
    DERNode.prototype._decodeBool = function decodeBool(buffer) {
      var res = buffer.readUInt8();
      if (buffer.isError(res))
        return res;
      else
        return res !== 0;
    };
    DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
      var raw = buffer.raw(), res = new bignum(raw);
      if (values)
        res = values[res.toString(10)] || res;
      return res;
    };
    DERNode.prototype._use = function use(entity, obj) {
      if (typeof entity === "function")
        entity = entity(obj);
      return entity._getDecoder("der").tree;
    };
    function derDecodeTag(buf, fail) {
      var tag = buf.readUInt8(fail);
      if (buf.isError(tag))
        return tag;
      var cls = der.tagClass[tag >> 6], primitive = (tag & 32) === 0;
      if ((tag & 31) === 31) {
        var oct = tag;
        tag = 0;
        while ((oct & 128) === 128) {
          if (oct = buf.readUInt8(fail), buf.isError(oct))
            return oct;
          tag <<= 7, tag |= oct & 127;
        }
      } else
        tag &= 31;
      var tagStr = der.tag[tag];
      return { cls, primitive, tag, tagStr };
    }
    function derDecodeLen(buf, primitive, fail) {
      var len2 = buf.readUInt8(fail);
      if (buf.isError(len2))
        return len2;
      if (!primitive && len2 === 128)
        return null;
      if ((len2 & 128) === 0)
        return len2;
      var num = len2 & 127;
      if (num > 4)
        return buf.error("length octect is too long");
      len2 = 0;
      for (var i2 = 0;i2 < num; i2++) {
        len2 <<= 8;
        var j = buf.readUInt8(fail);
        if (buf.isError(j))
          return j;
        len2 |= j;
      }
      return len2;
    }
  });
  require_pem = __commonJS2((exports, module) => {
    var inherits2 = require_inherits(), Buffer22 = (init_buffer(), __toCommonJS(exports_buffer2)).Buffer, DERDecoder = require_der2();
    function PEMDecoder(entity) {
      DERDecoder.call(this, entity), this.enc = "pem";
    }
    inherits2(PEMDecoder, DERDecoder);
    module.exports = PEMDecoder;
    PEMDecoder.prototype.decode = function decode(data, options) {
      var lines = data.toString().split(/[\r\n]+/g), label = options.label.toUpperCase(), re = /^-----(BEGIN|END) ([^-]+)-----$/, start = -1, end = -1;
      for (var i2 = 0;i2 < lines.length; i2++) {
        var match = lines[i2].match(re);
        if (match === null)
          continue;
        if (match[2] !== label)
          continue;
        if (start === -1) {
          if (match[1] !== "BEGIN")
            break;
          start = i2;
        } else {
          if (match[1] !== "END")
            break;
          end = i2;
          break;
        }
      }
      if (start === -1 || end === -1)
        throw new Error("PEM section not found for: " + label);
      var base64 = lines.slice(start + 1, end).join("");
      base64.replace(/[^a-z0-9\+\/=]+/gi, "");
      var input = new Buffer22(base64, "base64");
      return DERDecoder.prototype.decode.call(this, input, options);
    };
  });
  require_decoders = __commonJS2((exports) => {
    var decoders = exports;
    decoders.der = require_der2();
    decoders.pem = require_pem();
  });
  require_der3 = __commonJS2((exports, module) => {
    var inherits2 = require_inherits(), Buffer22 = (init_buffer(), __toCommonJS(exports_buffer2)).Buffer, asn1 = require_asn1(), base = asn1.base, der = asn1.constants.der;
    function DEREncoder(entity) {
      this.enc = "der", this.name = entity.name, this.entity = entity, this.tree = new DERNode, this.tree._init(entity.body);
    }
    module.exports = DEREncoder;
    DEREncoder.prototype.encode = function encode(data, reporter) {
      return this.tree._encode(data, reporter).join();
    };
    function DERNode(parent) {
      base.Node.call(this, "der", parent);
    }
    inherits2(DERNode, base.Node);
    DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
      var encodedTag = encodeTag(tag, primitive, cls, this.reporter);
      if (content.length < 128) {
        var header = new Buffer22(2);
        return header[0] = encodedTag, header[1] = content.length, this._createEncoderBuffer([header, content]);
      }
      var lenOctets = 1;
      for (var i2 = content.length;i2 >= 256; i2 >>= 8)
        lenOctets++;
      var header = new Buffer22(2 + lenOctets);
      header[0] = encodedTag, header[1] = 128 | lenOctets;
      for (var i2 = 1 + lenOctets, j = content.length;j > 0; i2--, j >>= 8)
        header[i2] = j & 255;
      return this._createEncoderBuffer([header, content]);
    };
    DERNode.prototype._encodeStr = function encodeStr(str, tag) {
      if (tag === "bitstr")
        return this._createEncoderBuffer([str.unused | 0, str.data]);
      else if (tag === "bmpstr") {
        var buf = new Buffer22(str.length * 2);
        for (var i2 = 0;i2 < str.length; i2++)
          buf.writeUInt16BE(str.charCodeAt(i2), i2 * 2);
        return this._createEncoderBuffer(buf);
      } else if (tag === "numstr") {
        if (!this._isNumstr(str))
          return this.reporter.error("Encoding of string type: numstr supports only digits and space");
        return this._createEncoderBuffer(str);
      } else if (tag === "printstr") {
        if (!this._isPrintstr(str))
          return this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark");
        return this._createEncoderBuffer(str);
      } else if (/str$/.test(tag))
        return this._createEncoderBuffer(str);
      else if (tag === "objDesc")
        return this._createEncoderBuffer(str);
      else
        return this.reporter.error("Encoding of string type: " + tag + " unsupported");
    };
    DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
      if (typeof id === "string") {
        if (!values)
          return this.reporter.error("string objid given, but no values map found");
        if (!values.hasOwnProperty(id))
          return this.reporter.error("objid not found in values map");
        id = values[id].split(/[\s\.]+/g);
        for (var i2 = 0;i2 < id.length; i2++)
          id[i2] |= 0;
      } else if (Array.isArray(id)) {
        id = id.slice();
        for (var i2 = 0;i2 < id.length; i2++)
          id[i2] |= 0;
      }
      if (!Array.isArray(id))
        return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(id));
      if (!relative) {
        if (id[1] >= 40)
          return this.reporter.error("Second objid identifier OOB");
        id.splice(0, 2, id[0] * 40 + id[1]);
      }
      var size = 0;
      for (var i2 = 0;i2 < id.length; i2++) {
        var ident = id[i2];
        for (size++;ident >= 128; ident >>= 7)
          size++;
      }
      var objid = new Buffer22(size), offset = objid.length - 1;
      for (var i2 = id.length - 1;i2 >= 0; i2--) {
        var ident = id[i2];
        objid[offset--] = ident & 127;
        while ((ident >>= 7) > 0)
          objid[offset--] = 128 | ident & 127;
      }
      return this._createEncoderBuffer(objid);
    };
    function two(num) {
      if (num < 10)
        return "0" + num;
      else
        return num;
    }
    DERNode.prototype._encodeTime = function encodeTime(time, tag) {
      var str, date3 = new Date(time);
      if (tag === "gentime")
        str = [two(date3.getFullYear()), two(date3.getUTCMonth() + 1), two(date3.getUTCDate()), two(date3.getUTCHours()), two(date3.getUTCMinutes()), two(date3.getUTCSeconds()), "Z"].join("");
      else if (tag === "utctime")
        str = [two(date3.getFullYear() % 100), two(date3.getUTCMonth() + 1), two(date3.getUTCDate()), two(date3.getUTCHours()), two(date3.getUTCMinutes()), two(date3.getUTCSeconds()), "Z"].join("");
      else
        this.reporter.error("Encoding " + tag + " time is not supported yet");
      return this._encodeStr(str, "octstr");
    };
    DERNode.prototype._encodeNull = function encodeNull() {
      return this._createEncoderBuffer("");
    };
    DERNode.prototype._encodeInt = function encodeInt(num, values) {
      if (typeof num === "string") {
        if (!values)
          return this.reporter.error("String int or enum given, but no values map");
        if (!values.hasOwnProperty(num))
          return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num));
        num = values[num];
      }
      if (typeof num !== "number" && !Buffer22.isBuffer(num)) {
        var numArray = num.toArray();
        if (!num.sign && numArray[0] & 128)
          numArray.unshift(0);
        num = new Buffer22(numArray);
      }
      if (Buffer22.isBuffer(num)) {
        var size = num.length;
        if (num.length === 0)
          size++;
        var out = new Buffer22(size);
        if (num.copy(out), num.length === 0)
          out[0] = 0;
        return this._createEncoderBuffer(out);
      }
      if (num < 128)
        return this._createEncoderBuffer(num);
      if (num < 256)
        return this._createEncoderBuffer([0, num]);
      var size = 1;
      for (var i2 = num;i2 >= 256; i2 >>= 8)
        size++;
      var out = new Array(size);
      for (var i2 = out.length - 1;i2 >= 0; i2--)
        out[i2] = num & 255, num >>= 8;
      if (out[0] & 128)
        out.unshift(0);
      return this._createEncoderBuffer(new Buffer22(out));
    };
    DERNode.prototype._encodeBool = function encodeBool(value2) {
      return this._createEncoderBuffer(value2 ? 255 : 0);
    };
    DERNode.prototype._use = function use(entity, obj) {
      if (typeof entity === "function")
        entity = entity(obj);
      return entity._getEncoder("der").tree;
    };
    DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
      var state = this._baseState, i2;
      if (state.default === null)
        return false;
      var data = dataBuffer.join();
      if (state.defaultBuffer === undefined)
        state.defaultBuffer = this._encodeValue(state.default, reporter, parent).join();
      if (data.length !== state.defaultBuffer.length)
        return false;
      for (i2 = 0;i2 < data.length; i2++)
        if (data[i2] !== state.defaultBuffer[i2])
          return false;
      return true;
    };
    function encodeTag(tag, primitive, cls, reporter) {
      var res;
      if (tag === "seqof")
        tag = "seq";
      else if (tag === "setof")
        tag = "set";
      if (der.tagByName.hasOwnProperty(tag))
        res = der.tagByName[tag];
      else if (typeof tag === "number" && (tag | 0) === tag)
        res = tag;
      else
        return reporter.error("Unknown tag: " + tag);
      if (res >= 31)
        return reporter.error("Multi-octet tag encoding unsupported");
      if (!primitive)
        res |= 32;
      return res |= der.tagClassByName[cls || "universal"] << 6, res;
    }
  });
  require_pem2 = __commonJS2((exports, module) => {
    var inherits2 = require_inherits(), DEREncoder = require_der3();
    function PEMEncoder(entity) {
      DEREncoder.call(this, entity), this.enc = "pem";
    }
    inherits2(PEMEncoder, DEREncoder);
    module.exports = PEMEncoder;
    PEMEncoder.prototype.encode = function encode(data, options) {
      var buf = DEREncoder.prototype.encode.call(this, data), p = buf.toString("base64"), out = ["-----BEGIN " + options.label + "-----"];
      for (var i2 = 0;i2 < p.length; i2 += 64)
        out.push(p.slice(i2, i2 + 64));
      return out.push("-----END " + options.label + "-----"), out.join(`
`);
    };
  });
  require_encoders = __commonJS2((exports) => {
    var encoders = exports;
    encoders.der = require_der3();
    encoders.pem = require_pem2();
  });
  require_asn1 = __commonJS2((exports) => {
    var asn1 = exports;
    asn1.bignum = require_bn3();
    asn1.define = require_api().define;
    asn1.base = require_base2();
    asn1.constants = require_constants();
    asn1.decoders = require_decoders();
    asn1.encoders = require_encoders();
  });
  require_certificate = __commonJS2((exports, module) => {
    var asn = require_asn1(), Time = asn.define("Time", function() {
      this.choice({ utcTime: this.utctime(), generalTime: this.gentime() });
    }), AttributeTypeValue = asn.define("AttributeTypeValue", function() {
      this.seq().obj(this.key("type").objid(), this.key("value").any());
    }), AlgorithmIdentifier = asn.define("AlgorithmIdentifier", function() {
      this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
    }), SubjectPublicKeyInfo = asn.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPublicKey").bitstr());
    }), RelativeDistinguishedName = asn.define("RelativeDistinguishedName", function() {
      this.setof(AttributeTypeValue);
    }), RDNSequence = asn.define("RDNSequence", function() {
      this.seqof(RelativeDistinguishedName);
    }), Name = asn.define("Name", function() {
      this.choice({ rdnSequence: this.use(RDNSequence) });
    }), Validity = asn.define("Validity", function() {
      this.seq().obj(this.key("notBefore").use(Time), this.key("notAfter").use(Time));
    }), Extension = asn.define("Extension", function() {
      this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
    }), TBSCertificate = asn.define("TBSCertificate", function() {
      this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(AlgorithmIdentifier), this.key("issuer").use(Name), this.key("validity").use(Validity), this.key("subject").use(Name), this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(Extension).optional());
    }), X509Certificate = asn.define("X509Certificate", function() {
      this.seq().obj(this.key("tbsCertificate").use(TBSCertificate), this.key("signatureAlgorithm").use(AlgorithmIdentifier), this.key("signatureValue").bitstr());
    });
    module.exports = X509Certificate;
  });
  require_asn12 = __commonJS2((exports) => {
    var asn1 = require_asn1();
    exports.certificate = require_certificate();
    var RSAPrivateKey = asn1.define("RSAPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
    });
    exports.RSAPrivateKey = RSAPrivateKey;
    var RSAPublicKey = asn1.define("RSAPublicKey", function() {
      this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
    });
    exports.RSAPublicKey = RSAPublicKey;
    var AlgorithmIdentifier = asn1.define("AlgorithmIdentifier", function() {
      this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
    }), PublicKey = asn1.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPublicKey").bitstr());
    });
    exports.PublicKey = PublicKey;
    var PrivateKeyInfo = asn1.define("PrivateKeyInfo", function() {
      this.seq().obj(this.key("version").int(), this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPrivateKey").octstr());
    });
    exports.PrivateKey = PrivateKeyInfo;
    var EncryptedPrivateKeyInfo = asn1.define("EncryptedPrivateKeyInfo", function() {
      this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
    });
    exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
    var DSAPrivateKey = asn1.define("DSAPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
    });
    exports.DSAPrivateKey = DSAPrivateKey;
    exports.DSAparam = asn1.define("DSAparam", function() {
      this.int();
    });
    var ECParameters = asn1.define("ECParameters", function() {
      this.choice({ namedCurve: this.objid() });
    }), ECPrivateKey = asn1.define("ECPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(ECParameters), this.key("publicKey").optional().explicit(1).bitstr());
    });
    exports.ECPrivateKey = ECPrivateKey;
    exports.signature = asn1.define("signature", function() {
      this.seq().obj(this.key("r").int(), this.key("s").int());
    });
  });
  require_aesid = __commonJS2((exports, module) => {
    module.exports = { "2.16.840.1.101.3.4.1.1": "aes-128-ecb", "2.16.840.1.101.3.4.1.2": "aes-128-cbc", "2.16.840.1.101.3.4.1.3": "aes-128-ofb", "2.16.840.1.101.3.4.1.4": "aes-128-cfb", "2.16.840.1.101.3.4.1.21": "aes-192-ecb", "2.16.840.1.101.3.4.1.22": "aes-192-cbc", "2.16.840.1.101.3.4.1.23": "aes-192-ofb", "2.16.840.1.101.3.4.1.24": "aes-192-cfb", "2.16.840.1.101.3.4.1.41": "aes-256-ecb", "2.16.840.1.101.3.4.1.42": "aes-256-cbc", "2.16.840.1.101.3.4.1.43": "aes-256-ofb", "2.16.840.1.101.3.4.1.44": "aes-256-cfb" };
  });
  require_hash_base = __commonJS2((exports, module) => {
    var Buffer22 = require_safe_buffer().Buffer, Transform2 = require_stream().Transform, inherits2 = require_inherits();
    function HashBase(blockSize) {
      Transform2.call(this), this._block = Buffer22.allocUnsafe(blockSize), this._blockSize = blockSize, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = false;
    }
    inherits2(HashBase, Transform2);
    HashBase.prototype._transform = function(chunk, encoding, callback) {
      var error3 = null;
      try {
        this.update(chunk, encoding);
      } catch (err) {
        error3 = err;
      }
      callback(error3);
    };
    HashBase.prototype._flush = function(callback) {
      var error3 = null;
      try {
        this.push(this.digest());
      } catch (err) {
        error3 = err;
      }
      callback(error3);
    };
    var useUint8Array = typeof Uint8Array !== "undefined", useArrayBuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && ArrayBuffer.isView && (Buffer22.prototype instanceof Uint8Array || Buffer22.TYPED_ARRAY_SUPPORT);
    function toBuffer(data, encoding) {
      if (data instanceof Buffer22)
        return data;
      if (typeof data === "string")
        return Buffer22.from(data, encoding);
      if (useArrayBuffer && ArrayBuffer.isView(data)) {
        if (data.byteLength === 0)
          return Buffer22.alloc(0);
        var res = Buffer22.from(data.buffer, data.byteOffset, data.byteLength);
        if (res.byteLength === data.byteLength)
          return res;
      }
      if (useUint8Array && data instanceof Uint8Array)
        return Buffer22.from(data);
      if (Buffer22.isBuffer(data) && data.constructor && typeof data.constructor.isBuffer === "function" && data.constructor.isBuffer(data))
        return Buffer22.from(data);
      throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
    }
    HashBase.prototype.update = function(data, encoding) {
      if (this._finalized)
        throw new Error("Digest already called");
      data = toBuffer(data, encoding);
      var block = this._block, offset = 0;
      while (this._blockOffset + data.length - offset >= this._blockSize) {
        for (var i2 = this._blockOffset;i2 < this._blockSize; )
          block[i2++] = data[offset++];
        this._update(), this._blockOffset = 0;
      }
      while (offset < data.length)
        block[this._blockOffset++] = data[offset++];
      for (var j = 0, carry = data.length * 8;carry > 0; ++j)
        if (this._length[j] += carry, carry = this._length[j] / 4294967296 | 0, carry > 0)
          this._length[j] -= 4294967296 * carry;
      return this;
    };
    HashBase.prototype._update = function() {
      throw new Error("_update is not implemented");
    };
    HashBase.prototype.digest = function(encoding) {
      if (this._finalized)
        throw new Error("Digest already called");
      this._finalized = true;
      var digest = this._digest();
      if (encoding !== undefined)
        digest = digest.toString(encoding);
      this._block.fill(0), this._blockOffset = 0;
      for (var i2 = 0;i2 < 4; ++i2)
        this._length[i2] = 0;
      return digest;
    };
    HashBase.prototype._digest = function() {
      throw new Error("_digest is not implemented");
    };
    module.exports = HashBase;
  });
  require_md5 = __commonJS2((exports, module) => {
    var inherits2 = require_inherits(), HashBase = require_hash_base(), Buffer22 = require_safe_buffer().Buffer, ARRAY16 = new Array(16);
    function MD5() {
      HashBase.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
    }
    inherits2(MD5, HashBase);
    MD5.prototype._update = function() {
      var M = ARRAY16;
      for (var i2 = 0;i2 < 16; ++i2)
        M[i2] = this._block.readInt32LE(i2 * 4);
      var a = this._a, b = this._b, c = this._c, d = this._d;
      a = fnF(a, b, c, d, M[0], 3614090360, 7), d = fnF(d, a, b, c, M[1], 3905402710, 12), c = fnF(c, d, a, b, M[2], 606105819, 17), b = fnF(b, c, d, a, M[3], 3250441966, 22), a = fnF(a, b, c, d, M[4], 4118548399, 7), d = fnF(d, a, b, c, M[5], 1200080426, 12), c = fnF(c, d, a, b, M[6], 2821735955, 17), b = fnF(b, c, d, a, M[7], 4249261313, 22), a = fnF(a, b, c, d, M[8], 1770035416, 7), d = fnF(d, a, b, c, M[9], 2336552879, 12), c = fnF(c, d, a, b, M[10], 4294925233, 17), b = fnF(b, c, d, a, M[11], 2304563134, 22), a = fnF(a, b, c, d, M[12], 1804603682, 7), d = fnF(d, a, b, c, M[13], 4254626195, 12), c = fnF(c, d, a, b, M[14], 2792965006, 17), b = fnF(b, c, d, a, M[15], 1236535329, 22), a = fnG(a, b, c, d, M[1], 4129170786, 5), d = fnG(d, a, b, c, M[6], 3225465664, 9), c = fnG(c, d, a, b, M[11], 643717713, 14), b = fnG(b, c, d, a, M[0], 3921069994, 20), a = fnG(a, b, c, d, M[5], 3593408605, 5), d = fnG(d, a, b, c, M[10], 38016083, 9), c = fnG(c, d, a, b, M[15], 3634488961, 14), b = fnG(b, c, d, a, M[4], 3889429448, 20), a = fnG(a, b, c, d, M[9], 568446438, 5), d = fnG(d, a, b, c, M[14], 3275163606, 9), c = fnG(c, d, a, b, M[3], 4107603335, 14), b = fnG(b, c, d, a, M[8], 1163531501, 20), a = fnG(a, b, c, d, M[13], 2850285829, 5), d = fnG(d, a, b, c, M[2], 4243563512, 9), c = fnG(c, d, a, b, M[7], 1735328473, 14), b = fnG(b, c, d, a, M[12], 2368359562, 20), a = fnH(a, b, c, d, M[5], 4294588738, 4), d = fnH(d, a, b, c, M[8], 2272392833, 11), c = fnH(c, d, a, b, M[11], 1839030562, 16), b = fnH(b, c, d, a, M[14], 4259657740, 23), a = fnH(a, b, c, d, M[1], 2763975236, 4), d = fnH(d, a, b, c, M[4], 1272893353, 11), c = fnH(c, d, a, b, M[7], 4139469664, 16), b = fnH(b, c, d, a, M[10], 3200236656, 23), a = fnH(a, b, c, d, M[13], 681279174, 4), d = fnH(d, a, b, c, M[0], 3936430074, 11), c = fnH(c, d, a, b, M[3], 3572445317, 16), b = fnH(b, c, d, a, M[6], 76029189, 23), a = fnH(a, b, c, d, M[9], 3654602809, 4), d = fnH(d, a, b, c, M[12], 3873151461, 11), c = fnH(c, d, a, b, M[15], 530742520, 16), b = fnH(b, c, d, a, M[2], 3299628645, 23), a = fnI(a, b, c, d, M[0], 4096336452, 6), d = fnI(d, a, b, c, M[7], 1126891415, 10), c = fnI(c, d, a, b, M[14], 2878612391, 15), b = fnI(b, c, d, a, M[5], 4237533241, 21), a = fnI(a, b, c, d, M[12], 1700485571, 6), d = fnI(d, a, b, c, M[3], 2399980690, 10), c = fnI(c, d, a, b, M[10], 4293915773, 15), b = fnI(b, c, d, a, M[1], 2240044497, 21), a = fnI(a, b, c, d, M[8], 1873313359, 6), d = fnI(d, a, b, c, M[15], 4264355552, 10), c = fnI(c, d, a, b, M[6], 2734768916, 15), b = fnI(b, c, d, a, M[13], 1309151649, 21), a = fnI(a, b, c, d, M[4], 4149444226, 6), d = fnI(d, a, b, c, M[11], 3174756917, 10), c = fnI(c, d, a, b, M[2], 718787259, 15), b = fnI(b, c, d, a, M[9], 3951481745, 21), this._a = this._a + a | 0, this._b = this._b + b | 0, this._c = this._c + c | 0, this._d = this._d + d | 0;
    };
    MD5.prototype._digest = function() {
      if (this._block[this._blockOffset++] = 128, this._blockOffset > 56)
        this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0;
      this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
      var buffer = Buffer22.allocUnsafe(16);
      return buffer.writeInt32LE(this._a, 0), buffer.writeInt32LE(this._b, 4), buffer.writeInt32LE(this._c, 8), buffer.writeInt32LE(this._d, 12), buffer;
    };
    function rotl(x, n) {
      return x << n | x >>> 32 - n;
    }
    function fnF(a, b, c, d, m, k, s) {
      return rotl(a + (b & c | ~b & d) + m + k | 0, s) + b | 0;
    }
    function fnG(a, b, c, d, m, k, s) {
      return rotl(a + (b & d | c & ~d) + m + k | 0, s) + b | 0;
    }
    function fnH(a, b, c, d, m, k, s) {
      return rotl(a + (b ^ c ^ d) + m + k | 0, s) + b | 0;
    }
    function fnI(a, b, c, d, m, k, s) {
      return rotl(a + (c ^ (b | ~d)) + m + k | 0, s) + b | 0;
    }
    module.exports = MD5;
  });
  require_evp_bytestokey = __commonJS2((exports, module) => {
    var Buffer22 = require_safe_buffer().Buffer, MD5 = require_md5();
    function EVP_BytesToKey(password, salt, keyBits, ivLen) {
      if (!Buffer22.isBuffer(password))
        password = Buffer22.from(password, "binary");
      if (salt) {
        if (!Buffer22.isBuffer(salt))
          salt = Buffer22.from(salt, "binary");
        if (salt.length !== 8)
          throw new RangeError("salt should be Buffer with 8 byte length");
      }
      var keyLen = keyBits / 8, key = Buffer22.alloc(keyLen), iv = Buffer22.alloc(ivLen || 0), tmp = Buffer22.alloc(0);
      while (keyLen > 0 || ivLen > 0) {
        var hash3 = new MD5;
        if (hash3.update(tmp), hash3.update(password), salt)
          hash3.update(salt);
        tmp = hash3.digest();
        var used = 0;
        if (keyLen > 0) {
          var keyStart = key.length - keyLen;
          used = Math.min(keyLen, tmp.length), tmp.copy(key, keyStart, 0, used), keyLen -= used;
        }
        if (used < tmp.length && ivLen > 0) {
          var ivStart = iv.length - ivLen, length = Math.min(ivLen, tmp.length - used);
          tmp.copy(iv, ivStart, used, used + length), ivLen -= length;
        }
      }
      return tmp.fill(0), { key, iv };
    }
    module.exports = EVP_BytesToKey;
  });
  require_browserify_aes = __commonJS2((exports) => {
    var crypto2 = (init_crypto(), __toCommonJS(exports_crypto));
    exports.createCipher = exports.Cipher = crypto2.createCipher;
    exports.createCipheriv = exports.Cipheriv = crypto2.createCipheriv;
    exports.createDecipher = exports.Decipher = crypto2.createDecipher;
    exports.createDecipheriv = exports.Decipheriv = crypto2.createDecipheriv;
    exports.listCiphers = exports.getCiphers = crypto2.getCiphers;
  });
  require_fixProc = __commonJS2((exports, module) => {
    var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, evp = require_evp_bytestokey(), ciphers = require_browserify_aes(), Buffer22 = require_safe_buffer().Buffer;
    module.exports = function(okey, password) {
      var key = okey.toString(), match = key.match(findProc), decrypted;
      if (!match) {
        var match2 = key.match(fullRegex);
        decrypted = Buffer22.from(match2[2].replace(/[\r\n]/g, ""), "base64");
      } else {
        var suite = "aes" + match[1], iv = Buffer22.from(match[2], "hex"), cipherText = Buffer22.from(match[3].replace(/[\r\n]/g, ""), "base64"), cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key, out = [], cipher = ciphers.createDecipheriv(suite, cipherKey, iv);
        out.push(cipher.update(cipherText)), out.push(cipher.final()), decrypted = Buffer22.concat(out);
      }
      var tag = key.match(startRegex)[1];
      return { tag, data: decrypted };
    };
  });
  require_parse_asn1 = __commonJS2((exports, module) => {
    var asn1 = require_asn12(), aesid = require_aesid(), fixProc = require_fixProc(), ciphers = require_browserify_aes(), compat = require_pbkdf2(), Buffer22 = require_safe_buffer().Buffer;
    function decrypt(data, password) {
      var salt = data.algorithm.decrypt.kde.kdeparams.salt, iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), algo = aesid[data.algorithm.decrypt.cipher.algo.join(".")], iv = data.algorithm.decrypt.cipher.iv, cipherText = data.subjectPrivateKey, keylen = parseInt(algo.split("-")[1], 10) / 8, key = compat.pbkdf2Sync(password, salt, iters, keylen, "sha1"), cipher = ciphers.createDecipheriv(algo, key, iv), out = [];
      return out.push(cipher.update(cipherText)), out.push(cipher.final()), Buffer22.concat(out);
    }
    function parseKeys(buffer) {
      var password;
      if (typeof buffer === "object" && !Buffer22.isBuffer(buffer))
        password = buffer.passphrase, buffer = buffer.key;
      if (typeof buffer === "string")
        buffer = Buffer22.from(buffer);
      var stripped = fixProc(buffer, password), type3 = stripped.tag, data = stripped.data, subtype, ndata;
      switch (type3) {
        case "CERTIFICATE":
          ndata = asn1.certificate.decode(data, "der").tbsCertificate.subjectPublicKeyInfo;
        case "PUBLIC KEY":
          if (!ndata)
            ndata = asn1.PublicKey.decode(data, "der");
          switch (subtype = ndata.algorithm.algorithm.join("."), subtype) {
            case "1.2.840.113549.1.1.1":
              return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, "der");
            case "1.2.840.10045.2.1":
              return ndata.subjectPrivateKey = ndata.subjectPublicKey, { type: "ec", data: ndata };
            case "1.2.840.10040.4.1":
              return ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, "der"), { type: "dsa", data: ndata.algorithm.params };
            default:
              throw new Error("unknown key id " + subtype);
          }
        case "ENCRYPTED PRIVATE KEY":
          data = asn1.EncryptedPrivateKey.decode(data, "der"), data = decrypt(data, password);
        case "PRIVATE KEY":
          switch (ndata = asn1.PrivateKey.decode(data, "der"), subtype = ndata.algorithm.algorithm.join("."), subtype) {
            case "1.2.840.113549.1.1.1":
              return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, "der");
            case "1.2.840.10045.2.1":
              return { curve: ndata.algorithm.curve, privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, "der").privateKey };
            case "1.2.840.10040.4.1":
              return ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, "der"), { type: "dsa", params: ndata.algorithm.params };
            default:
              throw new Error("unknown key id " + subtype);
          }
        case "RSA PUBLIC KEY":
          return asn1.RSAPublicKey.decode(data, "der");
        case "RSA PRIVATE KEY":
          return asn1.RSAPrivateKey.decode(data, "der");
        case "DSA PRIVATE KEY":
          return { type: "dsa", params: asn1.DSAPrivateKey.decode(data, "der") };
        case "EC PRIVATE KEY":
          return data = asn1.ECPrivateKey.decode(data, "der"), { curve: data.parameters.value, privateKey: data.privateKey };
        default:
          throw new Error("unknown key type " + type3);
      }
    }
    parseKeys.signature = asn1.signature;
    module.exports = parseKeys;
  });
  require_mgf = __commonJS2((exports, module) => {
    var createHash = require_create_hash(), Buffer22 = require_safe_buffer().Buffer;
    module.exports = function(seed, len2) {
      var t2 = Buffer22.alloc(0), i2 = 0, c;
      while (t2.length < len2)
        c = i2ops(i2++), t2 = Buffer22.concat([t2, createHash("sha1").update(seed).update(c).digest()]);
      return t2.slice(0, len2);
    };
    function i2ops(c) {
      var out = Buffer22.allocUnsafe(4);
      return out.writeUInt32BE(c, 0), out;
    }
  });
  require_xor = __commonJS2((exports, module) => {
    module.exports = function xor(a, b) {
      var len2 = a.length, i2 = -1;
      while (++i2 < len2)
        a[i2] ^= b[i2];
      return a;
    };
  });
  require_bn4 = __commonJS2((exports, module) => {
    (function(module2, exports2) {
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor, ctor.prototype.constructor = ctor;
      }
      function BN(number3, base, endian) {
        if (BN.isBN(number3))
          return number3;
        if (this.negative = 0, this.words = null, this.length = 0, this.red = null, number3 !== null) {
          if (base === "le" || base === "be")
            endian = base, base = 10;
          this._init(number3 || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object")
        module2.exports = BN;
      else
        exports2.BN = BN;
      BN.BN = BN, BN.wordSize = 26;
      var Buffer22;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined")
          Buffer22 = window.Buffer;
        else
          Buffer22 = (init_buffer(), __toCommonJS(exports_buffer2)).Buffer;
      } catch (e) {}
      BN.isBN = function isBN(num) {
        if (num instanceof BN)
          return true;
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      }, BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      }, BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      }, BN.prototype._init = function init(number3, base, endian) {
        if (typeof number3 === "number")
          return this._initNumber(number3, base, endian);
        if (typeof number3 === "object")
          return this._initArray(number3, base, endian);
        if (base === "hex")
          base = 16;
        assert(base === (base | 0) && base >= 2 && base <= 36), number3 = number3.toString().replace(/\s+/g, "");
        var start = 0;
        if (number3[0] === "-")
          start++, this.negative = 1;
        if (start < number3.length) {
          if (base === 16)
            this._parseHex(number3, start, endian);
          else if (this._parseBase(number3, base, start), endian === "le")
            this._initArray(this.toArray(), base, endian);
        }
      }, BN.prototype._initNumber = function _initNumber(number3, base, endian) {
        if (number3 < 0)
          this.negative = 1, number3 = -number3;
        if (number3 < 67108864)
          this.words = [number3 & 67108863], this.length = 1;
        else if (number3 < 4503599627370496)
          this.words = [number3 & 67108863, number3 / 67108864 & 67108863], this.length = 2;
        else
          assert(number3 < 9007199254740992), this.words = [number3 & 67108863, number3 / 67108864 & 67108863, 1], this.length = 3;
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      }, BN.prototype._initArray = function _initArray(number3, base, endian) {
        if (assert(typeof number3.length === "number"), number3.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(number3.length / 3), this.words = new Array(this.length);
        for (var i2 = 0;i2 < this.length; i2++)
          this.words[i2] = 0;
        var j, w, off = 0;
        if (endian === "be") {
          for (i2 = number3.length - 1, j = 0;i2 >= 0; i2 -= 3)
            if (w = number3[i2] | number3[i2 - 1] << 8 | number3[i2 - 2] << 16, this.words[j] |= w << off & 67108863, this.words[j + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26)
              off -= 26, j++;
        } else if (endian === "le") {
          for (i2 = 0, j = 0;i2 < number3.length; i2 += 3)
            if (w = number3[i2] | number3[i2 + 1] << 8 | number3[i2 + 2] << 16, this.words[j] |= w << off & 67108863, this.words[j + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26)
              off -= 26, j++;
        }
        return this.strip();
      };
      function parseHex4Bits(string3, index) {
        var c = string3.charCodeAt(index);
        if (c >= 65 && c <= 70)
          return c - 55;
        else if (c >= 97 && c <= 102)
          return c - 87;
        else
          return c - 48 & 15;
      }
      function parseHexByte(string3, lowerBound, index) {
        var r = parseHex4Bits(string3, index);
        if (index - 1 >= lowerBound)
          r |= parseHex4Bits(string3, index - 1) << 4;
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number3, start, endian) {
        this.length = Math.ceil((number3.length - start) / 6), this.words = new Array(this.length);
        for (var i2 = 0;i2 < this.length; i2++)
          this.words[i2] = 0;
        var off = 0, j = 0, w;
        if (endian === "be")
          for (i2 = number3.length - 1;i2 >= start; i2 -= 2)
            if (w = parseHexByte(number3, start, i2) << off, this.words[j] |= w & 67108863, off >= 18)
              off -= 18, j += 1, this.words[j] |= w >>> 26;
            else
              off += 8;
        else {
          var parseLength = number3.length - start;
          for (i2 = parseLength % 2 === 0 ? start + 1 : start;i2 < number3.length; i2 += 2)
            if (w = parseHexByte(number3, start, i2) << off, this.words[j] |= w & 67108863, off >= 18)
              off -= 18, j += 1, this.words[j] |= w >>> 26;
            else
              off += 8;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0, len2 = Math.min(str.length, end);
        for (var i2 = start;i2 < len2; i2++) {
          var c = str.charCodeAt(i2) - 48;
          if (r *= mul, c >= 49)
            r += c - 49 + 10;
          else if (c >= 17)
            r += c - 17 + 10;
          else
            r += c;
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number3, base, start) {
        this.words = [0], this.length = 1;
        for (var limbLen = 0, limbPow = 1;limbPow <= 67108863; limbPow *= base)
          limbLen++;
        limbLen--, limbPow = limbPow / base | 0;
        var total = number3.length - start, mod = total % limbLen, end = Math.min(total, total - mod) + start, word = 0;
        for (var i2 = start;i2 < end; i2 += limbLen)
          if (word = parseBase(number3, i2, i2 + limbLen, base), this.imuln(limbPow), this.words[0] + word < 67108864)
            this.words[0] += word;
          else
            this._iaddn(word);
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number3, i2, number3.length, base);
          for (i2 = 0;i2 < mod; i2++)
            pow *= base;
          if (this.imuln(pow), this.words[0] + word < 67108864)
            this.words[0] += word;
          else
            this._iaddn(word);
        }
        this.strip();
      }, BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i2 = 0;i2 < this.length; i2++)
          dest.words[i2] = this.words[i2];
        dest.length = this.length, dest.negative = this.negative, dest.red = this.red;
      }, BN.prototype.clone = function clone() {
        var r = new BN(null);
        return this.copy(r), r;
      }, BN.prototype._expand = function _expand(size) {
        while (this.length < size)
          this.words[this.length++] = 0;
        return this;
      }, BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0)
          this.length--;
        return this._normSign();
      }, BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0)
          this.negative = 0;
        return this;
      }, BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      if (BN.prototype.toString = function toString(base, padding) {
        base = base || 10, padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0, carry = 0;
          for (var i2 = 0;i2 < this.length; i2++) {
            var w = this.words[i2], word = ((w << off | carry) & 16777215).toString(16);
            if (carry = w >>> 24 - off & 16777215, off += 2, off >= 26)
              off -= 26, i2--;
            if (carry !== 0 || i2 !== this.length - 1)
              out = zeros[6 - word.length] + word + out;
            else
              out = word + out;
          }
          if (carry !== 0)
            out = carry.toString(16) + out;
          while (out.length % padding !== 0)
            out = "0" + out;
          if (this.negative !== 0)
            out = "-" + out;
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base], groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            if (c = c.idivn(groupBase), !c.isZero())
              out = zeros[groupSize - r.length] + r + out;
            else
              out = r + out;
          }
          if (this.isZero())
            out = "0" + out;
          while (out.length % padding !== 0)
            out = "0" + out;
          if (this.negative !== 0)
            out = "-" + out;
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      }, BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2)
          ret += this.words[1] * 67108864;
        else if (this.length === 3 && this.words[2] === 1)
          ret += 4503599627370496 + this.words[1] * 67108864;
        else if (this.length > 2)
          assert(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -ret : ret;
      }, BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      }, BN.prototype.toBuffer = function toBuffer(endian, length) {
        return assert(typeof Buffer22 !== "undefined"), this.toArrayLike(Buffer22, endian, length);
      }, BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      }, BN.prototype.toArrayLike = function toArrayLike(ArrayType7, endian, length) {
        var byteLength2 = this.byteLength(), reqLength = length || Math.max(1, byteLength2);
        assert(byteLength2 <= reqLength, "byte array longer than desired length"), assert(reqLength > 0, "Requested array length <= 0"), this.strip();
        var littleEndian = endian === "le", res = new ArrayType7(reqLength), b, i2, q = this.clone();
        if (!littleEndian) {
          for (i2 = 0;i2 < reqLength - byteLength2; i2++)
            res[i2] = 0;
          for (i2 = 0;!q.isZero(); i2++)
            b = q.andln(255), q.iushrn(8), res[reqLength - i2 - 1] = b;
        } else {
          for (i2 = 0;!q.isZero(); i2++)
            b = q.andln(255), q.iushrn(8), res[i2] = b;
          for (;i2 < reqLength; i2++)
            res[i2] = 0;
        }
        return res;
      }, Math.clz32)
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      else
        BN.prototype._countBits = function _countBits(w) {
          var t2 = w, r = 0;
          if (t2 >= 4096)
            r += 13, t2 >>>= 13;
          if (t2 >= 64)
            r += 7, t2 >>>= 7;
          if (t2 >= 8)
            r += 4, t2 >>>= 4;
          if (t2 >= 2)
            r += 2, t2 >>>= 2;
          return r + t2;
        };
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t2 = w, r = 0;
        if ((t2 & 8191) === 0)
          r += 13, t2 >>>= 13;
        if ((t2 & 127) === 0)
          r += 7, t2 >>>= 7;
        if ((t2 & 15) === 0)
          r += 4, t2 >>>= 4;
        if ((t2 & 3) === 0)
          r += 2, t2 >>>= 2;
        if ((t2 & 1) === 0)
          r++;
        return r;
      }, BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1], hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0;bit < w.length; bit++) {
          var off = bit / 26 | 0, wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i2 = 0;i2 < this.length; i2++) {
          var b = this._zeroBits(this.words[i2]);
          if (r += b, b !== 26)
            break;
        }
        return r;
      }, BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      }, BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0)
          return this.abs().inotn(width).iaddn(1);
        return this.clone();
      }, BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1))
          return this.notn(width).iaddn(1).ineg();
        return this.clone();
      }, BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      }, BN.prototype.neg = function neg() {
        return this.clone().ineg();
      }, BN.prototype.ineg = function ineg() {
        if (!this.isZero())
          this.negative ^= 1;
        return this;
      }, BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length)
          this.words[this.length++] = 0;
        for (var i2 = 0;i2 < num.length; i2++)
          this.words[i2] = this.words[i2] | num.words[i2];
        return this.strip();
      }, BN.prototype.ior = function ior(num) {
        return assert((this.negative | num.negative) === 0), this.iuor(num);
      }, BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      }, BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      }, BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length)
          b = num;
        else
          b = this;
        for (var i2 = 0;i2 < b.length; i2++)
          this.words[i2] = this.words[i2] & num.words[i2];
        return this.length = b.length, this.strip();
      }, BN.prototype.iand = function iand(num) {
        return assert((this.negative | num.negative) === 0), this.iuand(num);
      }, BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      }, BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      }, BN.prototype.iuxor = function iuxor(num) {
        var a, b;
        if (this.length > num.length)
          a = this, b = num;
        else
          a = num, b = this;
        for (var i2 = 0;i2 < b.length; i2++)
          this.words[i2] = a.words[i2] ^ b.words[i2];
        if (this !== a)
          for (;i2 < a.length; i2++)
            this.words[i2] = a.words[i2];
        return this.length = a.length, this.strip();
      }, BN.prototype.ixor = function ixor(num) {
        return assert((this.negative | num.negative) === 0), this.iuxor(num);
      }, BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      }, BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      }, BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0, bitsLeft = width % 26;
        if (this._expand(bytesNeeded), bitsLeft > 0)
          bytesNeeded--;
        for (var i2 = 0;i2 < bytesNeeded; i2++)
          this.words[i2] = ~this.words[i2] & 67108863;
        if (bitsLeft > 0)
          this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
        return this.strip();
      }, BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      }, BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0, wbit = bit % 26;
        if (this._expand(off + 1), val)
          this.words[off] = this.words[off] | 1 << wbit;
        else
          this.words[off] = this.words[off] & ~(1 << wbit);
        return this.strip();
      }, BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0)
          return this.negative = 0, r = this.isub(num), this.negative ^= 1, this._normSign();
        else if (this.negative === 0 && num.negative !== 0)
          return num.negative = 0, r = this.isub(num), num.negative = 1, r._normSign();
        var a, b;
        if (this.length > num.length)
          a = this, b = num;
        else
          a = num, b = this;
        var carry = 0;
        for (var i2 = 0;i2 < b.length; i2++)
          r = (a.words[i2] | 0) + (b.words[i2] | 0) + carry, this.words[i2] = r & 67108863, carry = r >>> 26;
        for (;carry !== 0 && i2 < a.length; i2++)
          r = (a.words[i2] | 0) + carry, this.words[i2] = r & 67108863, carry = r >>> 26;
        if (this.length = a.length, carry !== 0)
          this.words[this.length] = carry, this.length++;
        else if (a !== this)
          for (;i2 < a.length; i2++)
            this.words[i2] = a.words[i2];
        return this;
      }, BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0)
          return num.negative = 0, res = this.sub(num), num.negative ^= 1, res;
        else if (num.negative === 0 && this.negative !== 0)
          return this.negative = 0, res = num.sub(this), this.negative = 1, res;
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      }, BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          return num.negative = 1, r._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(num), this.negative = 1, this._normSign();
        var cmp = this.cmp(num);
        if (cmp === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var a, b;
        if (cmp > 0)
          a = this, b = num;
        else
          a = num, b = this;
        var carry = 0;
        for (var i2 = 0;i2 < b.length; i2++)
          r = (a.words[i2] | 0) - (b.words[i2] | 0) + carry, carry = r >> 26, this.words[i2] = r & 67108863;
        for (;carry !== 0 && i2 < a.length; i2++)
          r = (a.words[i2] | 0) + carry, carry = r >> 26, this.words[i2] = r & 67108863;
        if (carry === 0 && i2 < a.length && a !== this)
          for (;i2 < a.length; i2++)
            this.words[i2] = a.words[i2];
        if (this.length = Math.max(this.length, i2), a !== this)
          this.negative = 1;
        return this.strip();
      }, BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len2 = self2.length + num.length | 0;
        out.length = len2, len2 = len2 - 1 | 0;
        var a = self2.words[0] | 0, b = num.words[0] | 0, r = a * b, lo = r & 67108863, carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1;k < len2; k++) {
          var ncarry = carry >>> 26, rword = carry & 67108863, maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
            var i2 = k - j | 0;
            a = self2.words[i2] | 0, b = num.words[j] | 0, r = a * b + rword, ncarry += r / 67108864 | 0, rword = r & 67108863;
          }
          out.words[k] = rword | 0, carry = ncarry | 0;
        }
        if (carry !== 0)
          out.words[k] = carry | 0;
        else
          out.length--;
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo(self2, num, out) {
        var a = self2.words, b = num.words, o = out.words, c = 0, lo, mid, hi, a0 = a[0] | 0, al0 = a0 & 8191, ah0 = a0 >>> 13, a1 = a[1] | 0, al1 = a1 & 8191, ah1 = a1 >>> 13, a2 = a[2] | 0, al2 = a2 & 8191, ah2 = a2 >>> 13, a3 = a[3] | 0, al3 = a3 & 8191, ah3 = a3 >>> 13, a4 = a[4] | 0, al4 = a4 & 8191, ah4 = a4 >>> 13, a5 = a[5] | 0, al5 = a5 & 8191, ah5 = a5 >>> 13, a6 = a[6] | 0, al6 = a6 & 8191, ah6 = a6 >>> 13, a7 = a[7] | 0, al7 = a7 & 8191, ah7 = a7 >>> 13, a8 = a[8] | 0, al8 = a8 & 8191, ah8 = a8 >>> 13, a9 = a[9] | 0, al9 = a9 & 8191, ah9 = a9 >>> 13, b0 = b[0] | 0, bl0 = b0 & 8191, bh0 = b0 >>> 13, b1 = b[1] | 0, bl1 = b1 & 8191, bh1 = b1 >>> 13, b2 = b[2] | 0, bl2 = b2 & 8191, bh2 = b2 >>> 13, b3 = b[3] | 0, bl3 = b3 & 8191, bh3 = b3 >>> 13, b4 = b[4] | 0, bl4 = b4 & 8191, bh4 = b4 >>> 13, b5 = b[5] | 0, bl5 = b5 & 8191, bh5 = b5 >>> 13, b6 = b[6] | 0, bl6 = b6 & 8191, bh6 = b6 >>> 13, b7 = b[7] | 0, bl7 = b7 & 8191, bh7 = b7 >>> 13, b8 = b[8] | 0, bl8 = b8 & 8191, bh8 = b8 >>> 13, b9 = b[9] | 0, bl9 = b9 & 8191, bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative, out.length = 19, lo = Math.imul(al0, bl0), mid = Math.imul(al0, bh0), mid = mid + Math.imul(ah0, bl0) | 0, hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0, w0 &= 67108863, lo = Math.imul(al1, bl0), mid = Math.imul(al1, bh0), mid = mid + Math.imul(ah1, bl0) | 0, hi = Math.imul(ah1, bh0), lo = lo + Math.imul(al0, bl1) | 0, mid = mid + Math.imul(al0, bh1) | 0, mid = mid + Math.imul(ah0, bl1) | 0, hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0, w1 &= 67108863, lo = Math.imul(al2, bl0), mid = Math.imul(al2, bh0), mid = mid + Math.imul(ah2, bl0) | 0, hi = Math.imul(ah2, bh0), lo = lo + Math.imul(al1, bl1) | 0, mid = mid + Math.imul(al1, bh1) | 0, mid = mid + Math.imul(ah1, bl1) | 0, hi = hi + Math.imul(ah1, bh1) | 0, lo = lo + Math.imul(al0, bl2) | 0, mid = mid + Math.imul(al0, bh2) | 0, mid = mid + Math.imul(ah0, bl2) | 0, hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0, w2 &= 67108863, lo = Math.imul(al3, bl0), mid = Math.imul(al3, bh0), mid = mid + Math.imul(ah3, bl0) | 0, hi = Math.imul(ah3, bh0), lo = lo + Math.imul(al2, bl1) | 0, mid = mid + Math.imul(al2, bh1) | 0, mid = mid + Math.imul(ah2, bl1) | 0, hi = hi + Math.imul(ah2, bh1) | 0, lo = lo + Math.imul(al1, bl2) | 0, mid = mid + Math.imul(al1, bh2) | 0, mid = mid + Math.imul(ah1, bl2) | 0, hi = hi + Math.imul(ah1, bh2) | 0, lo = lo + Math.imul(al0, bl3) | 0, mid = mid + Math.imul(al0, bh3) | 0, mid = mid + Math.imul(ah0, bl3) | 0, hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0, w3 &= 67108863, lo = Math.imul(al4, bl0), mid = Math.imul(al4, bh0), mid = mid + Math.imul(ah4, bl0) | 0, hi = Math.imul(ah4, bh0), lo = lo + Math.imul(al3, bl1) | 0, mid = mid + Math.imul(al3, bh1) | 0, mid = mid + Math.imul(ah3, bl1) | 0, hi = hi + Math.imul(ah3, bh1) | 0, lo = lo + Math.imul(al2, bl2) | 0, mid = mid + Math.imul(al2, bh2) | 0, mid = mid + Math.imul(ah2, bl2) | 0, hi = hi + Math.imul(ah2, bh2) | 0, lo = lo + Math.imul(al1, bl3) | 0, mid = mid + Math.imul(al1, bh3) | 0, mid = mid + Math.imul(ah1, bl3) | 0, hi = hi + Math.imul(ah1, bh3) | 0, lo = lo + Math.imul(al0, bl4) | 0, mid = mid + Math.imul(al0, bh4) | 0, mid = mid + Math.imul(ah0, bl4) | 0, hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0, w4 &= 67108863, lo = Math.imul(al5, bl0), mid = Math.imul(al5, bh0), mid = mid + Math.imul(ah5, bl0) | 0, hi = Math.imul(ah5, bh0), lo = lo + Math.imul(al4, bl1) | 0, mid = mid + Math.imul(al4, bh1) | 0, mid = mid + Math.imul(ah4, bl1) | 0, hi = hi + Math.imul(ah4, bh1) | 0, lo = lo + Math.imul(al3, bl2) | 0, mid = mid + Math.imul(al3, bh2) | 0, mid = mid + Math.imul(ah3, bl2) | 0, hi = hi + Math.imul(ah3, bh2) | 0, lo = lo + Math.imul(al2, bl3) | 0, mid = mid + Math.imul(al2, bh3) | 0, mid = mid + Math.imul(ah2, bl3) | 0, hi = hi + Math.imul(ah2, bh3) | 0, lo = lo + Math.imul(al1, bl4) | 0, mid = mid + Math.imul(al1, bh4) | 0, mid = mid + Math.imul(ah1, bl4) | 0, hi = hi + Math.imul(ah1, bh4) | 0, lo = lo + Math.imul(al0, bl5) | 0, mid = mid + Math.imul(al0, bh5) | 0, mid = mid + Math.imul(ah0, bl5) | 0, hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0, w5 &= 67108863, lo = Math.imul(al6, bl0), mid = Math.imul(al6, bh0), mid = mid + Math.imul(ah6, bl0) | 0, hi = Math.imul(ah6, bh0), lo = lo + Math.imul(al5, bl1) | 0, mid = mid + Math.imul(al5, bh1) | 0, mid = mid + Math.imul(ah5, bl1) | 0, hi = hi + Math.imul(ah5, bh1) | 0, lo = lo + Math.imul(al4, bl2) | 0, mid = mid + Math.imul(al4, bh2) | 0, mid = mid + Math.imul(ah4, bl2) | 0, hi = hi + Math.imul(ah4, bh2) | 0, lo = lo + Math.imul(al3, bl3) | 0, mid = mid + Math.imul(al3, bh3) | 0, mid = mid + Math.imul(ah3, bl3) | 0, hi = hi + Math.imul(ah3, bh3) | 0, lo = lo + Math.imul(al2, bl4) | 0, mid = mid + Math.imul(al2, bh4) | 0, mid = mid + Math.imul(ah2, bl4) | 0, hi = hi + Math.imul(ah2, bh4) | 0, lo = lo + Math.imul(al1, bl5) | 0, mid = mid + Math.imul(al1, bh5) | 0, mid = mid + Math.imul(ah1, bl5) | 0, hi = hi + Math.imul(ah1, bh5) | 0, lo = lo + Math.imul(al0, bl6) | 0, mid = mid + Math.imul(al0, bh6) | 0, mid = mid + Math.imul(ah0, bl6) | 0, hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0, w6 &= 67108863, lo = Math.imul(al7, bl0), mid = Math.imul(al7, bh0), mid = mid + Math.imul(ah7, bl0) | 0, hi = Math.imul(ah7, bh0), lo = lo + Math.imul(al6, bl1) | 0, mid = mid + Math.imul(al6, bh1) | 0, mid = mid + Math.imul(ah6, bl1) | 0, hi = hi + Math.imul(ah6, bh1) | 0, lo = lo + Math.imul(al5, bl2) | 0, mid = mid + Math.imul(al5, bh2) | 0, mid = mid + Math.imul(ah5, bl2) | 0, hi = hi + Math.imul(ah5, bh2) | 0, lo = lo + Math.imul(al4, bl3) | 0, mid = mid + Math.imul(al4, bh3) | 0, mid = mid + Math.imul(ah4, bl3) | 0, hi = hi + Math.imul(ah4, bh3) | 0, lo = lo + Math.imul(al3, bl4) | 0, mid = mid + Math.imul(al3, bh4) | 0, mid = mid + Math.imul(ah3, bl4) | 0, hi = hi + Math.imul(ah3, bh4) | 0, lo = lo + Math.imul(al2, bl5) | 0, mid = mid + Math.imul(al2, bh5) | 0, mid = mid + Math.imul(ah2, bl5) | 0, hi = hi + Math.imul(ah2, bh5) | 0, lo = lo + Math.imul(al1, bl6) | 0, mid = mid + Math.imul(al1, bh6) | 0, mid = mid + Math.imul(ah1, bl6) | 0, hi = hi + Math.imul(ah1, bh6) | 0, lo = lo + Math.imul(al0, bl7) | 0, mid = mid + Math.imul(al0, bh7) | 0, mid = mid + Math.imul(ah0, bl7) | 0, hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0, w7 &= 67108863, lo = Math.imul(al8, bl0), mid = Math.imul(al8, bh0), mid = mid + Math.imul(ah8, bl0) | 0, hi = Math.imul(ah8, bh0), lo = lo + Math.imul(al7, bl1) | 0, mid = mid + Math.imul(al7, bh1) | 0, mid = mid + Math.imul(ah7, bl1) | 0, hi = hi + Math.imul(ah7, bh1) | 0, lo = lo + Math.imul(al6, bl2) | 0, mid = mid + Math.imul(al6, bh2) | 0, mid = mid + Math.imul(ah6, bl2) | 0, hi = hi + Math.imul(ah6, bh2) | 0, lo = lo + Math.imul(al5, bl3) | 0, mid = mid + Math.imul(al5, bh3) | 0, mid = mid + Math.imul(ah5, bl3) | 0, hi = hi + Math.imul(ah5, bh3) | 0, lo = lo + Math.imul(al4, bl4) | 0, mid = mid + Math.imul(al4, bh4) | 0, mid = mid + Math.imul(ah4, bl4) | 0, hi = hi + Math.imul(ah4, bh4) | 0, lo = lo + Math.imul(al3, bl5) | 0, mid = mid + Math.imul(al3, bh5) | 0, mid = mid + Math.imul(ah3, bl5) | 0, hi = hi + Math.imul(ah3, bh5) | 0, lo = lo + Math.imul(al2, bl6) | 0, mid = mid + Math.imul(al2, bh6) | 0, mid = mid + Math.imul(ah2, bl6) | 0, hi = hi + Math.imul(ah2, bh6) | 0, lo = lo + Math.imul(al1, bl7) | 0, mid = mid + Math.imul(al1, bh7) | 0, mid = mid + Math.imul(ah1, bl7) | 0, hi = hi + Math.imul(ah1, bh7) | 0, lo = lo + Math.imul(al0, bl8) | 0, mid = mid + Math.imul(al0, bh8) | 0, mid = mid + Math.imul(ah0, bl8) | 0, hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0, w8 &= 67108863, lo = Math.imul(al9, bl0), mid = Math.imul(al9, bh0), mid = mid + Math.imul(ah9, bl0) | 0, hi = Math.imul(ah9, bh0), lo = lo + Math.imul(al8, bl1) | 0, mid = mid + Math.imul(al8, bh1) | 0, mid = mid + Math.imul(ah8, bl1) | 0, hi = hi + Math.imul(ah8, bh1) | 0, lo = lo + Math.imul(al7, bl2) | 0, mid = mid + Math.imul(al7, bh2) | 0, mid = mid + Math.imul(ah7, bl2) | 0, hi = hi + Math.imul(ah7, bh2) | 0, lo = lo + Math.imul(al6, bl3) | 0, mid = mid + Math.imul(al6, bh3) | 0, mid = mid + Math.imul(ah6, bl3) | 0, hi = hi + Math.imul(ah6, bh3) | 0, lo = lo + Math.imul(al5, bl4) | 0, mid = mid + Math.imul(al5, bh4) | 0, mid = mid + Math.imul(ah5, bl4) | 0, hi = hi + Math.imul(ah5, bh4) | 0, lo = lo + Math.imul(al4, bl5) | 0, mid = mid + Math.imul(al4, bh5) | 0, mid = mid + Math.imul(ah4, bl5) | 0, hi = hi + Math.imul(ah4, bh5) | 0, lo = lo + Math.imul(al3, bl6) | 0, mid = mid + Math.imul(al3, bh6) | 0, mid = mid + Math.imul(ah3, bl6) | 0, hi = hi + Math.imul(ah3, bh6) | 0, lo = lo + Math.imul(al2, bl7) | 0, mid = mid + Math.imul(al2, bh7) | 0, mid = mid + Math.imul(ah2, bl7) | 0, hi = hi + Math.imul(ah2, bh7) | 0, lo = lo + Math.imul(al1, bl8) | 0, mid = mid + Math.imul(al1, bh8) | 0, mid = mid + Math.imul(ah1, bl8) | 0, hi = hi + Math.imul(ah1, bh8) | 0, lo = lo + Math.imul(al0, bl9) | 0, mid = mid + Math.imul(al0, bh9) | 0, mid = mid + Math.imul(ah0, bl9) | 0, hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0, w9 &= 67108863, lo = Math.imul(al9, bl1), mid = Math.imul(al9, bh1), mid = mid + Math.imul(ah9, bl1) | 0, hi = Math.imul(ah9, bh1), lo = lo + Math.imul(al8, bl2) | 0, mid = mid + Math.imul(al8, bh2) | 0, mid = mid + Math.imul(ah8, bl2) | 0, hi = hi + Math.imul(ah8, bh2) | 0, lo = lo + Math.imul(al7, bl3) | 0, mid = mid + Math.imul(al7, bh3) | 0, mid = mid + Math.imul(ah7, bl3) | 0, hi = hi + Math.imul(ah7, bh3) | 0, lo = lo + Math.imul(al6, bl4) | 0, mid = mid + Math.imul(al6, bh4) | 0, mid = mid + Math.imul(ah6, bl4) | 0, hi = hi + Math.imul(ah6, bh4) | 0, lo = lo + Math.imul(al5, bl5) | 0, mid = mid + Math.imul(al5, bh5) | 0, mid = mid + Math.imul(ah5, bl5) | 0, hi = hi + Math.imul(ah5, bh5) | 0, lo = lo + Math.imul(al4, bl6) | 0, mid = mid + Math.imul(al4, bh6) | 0, mid = mid + Math.imul(ah4, bl6) | 0, hi = hi + Math.imul(ah4, bh6) | 0, lo = lo + Math.imul(al3, bl7) | 0, mid = mid + Math.imul(al3, bh7) | 0, mid = mid + Math.imul(ah3, bl7) | 0, hi = hi + Math.imul(ah3, bh7) | 0, lo = lo + Math.imul(al2, bl8) | 0, mid = mid + Math.imul(al2, bh8) | 0, mid = mid + Math.imul(ah2, bl8) | 0, hi = hi + Math.imul(ah2, bh8) | 0, lo = lo + Math.imul(al1, bl9) | 0, mid = mid + Math.imul(al1, bh9) | 0, mid = mid + Math.imul(ah1, bl9) | 0, hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0, w10 &= 67108863, lo = Math.imul(al9, bl2), mid = Math.imul(al9, bh2), mid = mid + Math.imul(ah9, bl2) | 0, hi = Math.imul(ah9, bh2), lo = lo + Math.imul(al8, bl3) | 0, mid = mid + Math.imul(al8, bh3) | 0, mid = mid + Math.imul(ah8, bl3) | 0, hi = hi + Math.imul(ah8, bh3) | 0, lo = lo + Math.imul(al7, bl4) | 0, mid = mid + Math.imul(al7, bh4) | 0, mid = mid + Math.imul(ah7, bl4) | 0, hi = hi + Math.imul(ah7, bh4) | 0, lo = lo + Math.imul(al6, bl5) | 0, mid = mid + Math.imul(al6, bh5) | 0, mid = mid + Math.imul(ah6, bl5) | 0, hi = hi + Math.imul(ah6, bh5) | 0, lo = lo + Math.imul(al5, bl6) | 0, mid = mid + Math.imul(al5, bh6) | 0, mid = mid + Math.imul(ah5, bl6) | 0, hi = hi + Math.imul(ah5, bh6) | 0, lo = lo + Math.imul(al4, bl7) | 0, mid = mid + Math.imul(al4, bh7) | 0, mid = mid + Math.imul(ah4, bl7) | 0, hi = hi + Math.imul(ah4, bh7) | 0, lo = lo + Math.imul(al3, bl8) | 0, mid = mid + Math.imul(al3, bh8) | 0, mid = mid + Math.imul(ah3, bl8) | 0, hi = hi + Math.imul(ah3, bh8) | 0, lo = lo + Math.imul(al2, bl9) | 0, mid = mid + Math.imul(al2, bh9) | 0, mid = mid + Math.imul(ah2, bl9) | 0, hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0, w11 &= 67108863, lo = Math.imul(al9, bl3), mid = Math.imul(al9, bh3), mid = mid + Math.imul(ah9, bl3) | 0, hi = Math.imul(ah9, bh3), lo = lo + Math.imul(al8, bl4) | 0, mid = mid + Math.imul(al8, bh4) | 0, mid = mid + Math.imul(ah8, bl4) | 0, hi = hi + Math.imul(ah8, bh4) | 0, lo = lo + Math.imul(al7, bl5) | 0, mid = mid + Math.imul(al7, bh5) | 0, mid = mid + Math.imul(ah7, bl5) | 0, hi = hi + Math.imul(ah7, bh5) | 0, lo = lo + Math.imul(al6, bl6) | 0, mid = mid + Math.imul(al6, bh6) | 0, mid = mid + Math.imul(ah6, bl6) | 0, hi = hi + Math.imul(ah6, bh6) | 0, lo = lo + Math.imul(al5, bl7) | 0, mid = mid + Math.imul(al5, bh7) | 0, mid = mid + Math.imul(ah5, bl7) | 0, hi = hi + Math.imul(ah5, bh7) | 0, lo = lo + Math.imul(al4, bl8) | 0, mid = mid + Math.imul(al4, bh8) | 0, mid = mid + Math.imul(ah4, bl8) | 0, hi = hi + Math.imul(ah4, bh8) | 0, lo = lo + Math.imul(al3, bl9) | 0, mid = mid + Math.imul(al3, bh9) | 0, mid = mid + Math.imul(ah3, bl9) | 0, hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0, w12 &= 67108863, lo = Math.imul(al9, bl4), mid = Math.imul(al9, bh4), mid = mid + Math.imul(ah9, bl4) | 0, hi = Math.imul(ah9, bh4), lo = lo + Math.imul(al8, bl5) | 0, mid = mid + Math.imul(al8, bh5) | 0, mid = mid + Math.imul(ah8, bl5) | 0, hi = hi + Math.imul(ah8, bh5) | 0, lo = lo + Math.imul(al7, bl6) | 0, mid = mid + Math.imul(al7, bh6) | 0, mid = mid + Math.imul(ah7, bl6) | 0, hi = hi + Math.imul(ah7, bh6) | 0, lo = lo + Math.imul(al6, bl7) | 0, mid = mid + Math.imul(al6, bh7) | 0, mid = mid + Math.imul(ah6, bl7) | 0, hi = hi + Math.imul(ah6, bh7) | 0, lo = lo + Math.imul(al5, bl8) | 0, mid = mid + Math.imul(al5, bh8) | 0, mid = mid + Math.imul(ah5, bl8) | 0, hi = hi + Math.imul(ah5, bh8) | 0, lo = lo + Math.imul(al4, bl9) | 0, mid = mid + Math.imul(al4, bh9) | 0, mid = mid + Math.imul(ah4, bl9) | 0, hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0, w13 &= 67108863, lo = Math.imul(al9, bl5), mid = Math.imul(al9, bh5), mid = mid + Math.imul(ah9, bl5) | 0, hi = Math.imul(ah9, bh5), lo = lo + Math.imul(al8, bl6) | 0, mid = mid + Math.imul(al8, bh6) | 0, mid = mid + Math.imul(ah8, bl6) | 0, hi = hi + Math.imul(ah8, bh6) | 0, lo = lo + Math.imul(al7, bl7) | 0, mid = mid + Math.imul(al7, bh7) | 0, mid = mid + Math.imul(ah7, bl7) | 0, hi = hi + Math.imul(ah7, bh7) | 0, lo = lo + Math.imul(al6, bl8) | 0, mid = mid + Math.imul(al6, bh8) | 0, mid = mid + Math.imul(ah6, bl8) | 0, hi = hi + Math.imul(ah6, bh8) | 0, lo = lo + Math.imul(al5, bl9) | 0, mid = mid + Math.imul(al5, bh9) | 0, mid = mid + Math.imul(ah5, bl9) | 0, hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0, w14 &= 67108863, lo = Math.imul(al9, bl6), mid = Math.imul(al9, bh6), mid = mid + Math.imul(ah9, bl6) | 0, hi = Math.imul(ah9, bh6), lo = lo + Math.imul(al8, bl7) | 0, mid = mid + Math.imul(al8, bh7) | 0, mid = mid + Math.imul(ah8, bl7) | 0, hi = hi + Math.imul(ah8, bh7) | 0, lo = lo + Math.imul(al7, bl8) | 0, mid = mid + Math.imul(al7, bh8) | 0, mid = mid + Math.imul(ah7, bl8) | 0, hi = hi + Math.imul(ah7, bh8) | 0, lo = lo + Math.imul(al6, bl9) | 0, mid = mid + Math.imul(al6, bh9) | 0, mid = mid + Math.imul(ah6, bl9) | 0, hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0, w15 &= 67108863, lo = Math.imul(al9, bl7), mid = Math.imul(al9, bh7), mid = mid + Math.imul(ah9, bl7) | 0, hi = Math.imul(ah9, bh7), lo = lo + Math.imul(al8, bl8) | 0, mid = mid + Math.imul(al8, bh8) | 0, mid = mid + Math.imul(ah8, bl8) | 0, hi = hi + Math.imul(ah8, bh8) | 0, lo = lo + Math.imul(al7, bl9) | 0, mid = mid + Math.imul(al7, bh9) | 0, mid = mid + Math.imul(ah7, bl9) | 0, hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0, w16 &= 67108863, lo = Math.imul(al9, bl8), mid = Math.imul(al9, bh8), mid = mid + Math.imul(ah9, bl8) | 0, hi = Math.imul(ah9, bh8), lo = lo + Math.imul(al8, bl9) | 0, mid = mid + Math.imul(al8, bh9) | 0, mid = mid + Math.imul(ah8, bl9) | 0, hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0, w17 &= 67108863, lo = Math.imul(al9, bl9), mid = Math.imul(al9, bh9), mid = mid + Math.imul(ah9, bl9) | 0, hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        if (c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0, w18 &= 67108863, o[0] = w0, o[1] = w1, o[2] = w2, o[3] = w3, o[4] = w4, o[5] = w5, o[6] = w6, o[7] = w7, o[8] = w8, o[9] = w9, o[10] = w10, o[11] = w11, o[12] = w12, o[13] = w13, o[14] = w14, o[15] = w15, o[16] = w16, o[17] = w17, o[18] = w18, c !== 0)
          o[19] = c, out.length++;
        return out;
      };
      if (!Math.imul)
        comb10MulTo = smallMulTo;
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative, out.length = self2.length + num.length;
        var carry = 0, hncarry = 0;
        for (var k = 0;k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863, maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
            var i2 = k - j, a = self2.words[i2] | 0, b = num.words[j] | 0, r = a * b, lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0, lo = lo + rword | 0, rword = lo & 67108863, ncarry = ncarry + (lo >>> 26) | 0, hncarry += ncarry >>> 26, ncarry &= 67108863;
          }
          out.words[k] = rword, carry = ncarry, ncarry = hncarry;
        }
        if (carry !== 0)
          out.words[k] = carry;
        else
          out.length--;
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM;
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res, len2 = this.length + num.length;
        if (this.length === 10 && num.length === 10)
          res = comb10MulTo(this, num, out);
        else if (len2 < 63)
          res = smallMulTo(this, num, out);
        else if (len2 < 1024)
          res = bigMulTo(this, num, out);
        else
          res = jumboMulTo(this, num, out);
        return res;
      };
      function FFTM(x, y) {
        this.x = x, this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t2 = new Array(N), l = BN.prototype._countBits(N) - 1;
        for (var i2 = 0;i2 < N; i2++)
          t2[i2] = this.revBin(i2, l, N);
        return t2;
      }, FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i2 = 0;i2 < l; i2++)
          rb |= (x & 1) << l - i2 - 1, x >>= 1;
        return rb;
      }, FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i2 = 0;i2 < N; i2++)
          rtws[i2] = rws[rbt[i2]], itws[i2] = iws[rbt[i2]];
      }, FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1;s < N; s <<= 1) {
          var l = s << 1, rtwdf = Math.cos(2 * Math.PI / l), itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0;p < N; p += l) {
            var rtwdf_ = rtwdf, itwdf_ = itwdf;
            for (var j = 0;j < s; j++) {
              var re = rtws[p + j], ie = itws[p + j], ro = rtws[p + j + s], io = itws[p + j + s], rx = rtwdf_ * ro - itwdf_ * io;
              if (io = rtwdf_ * io + itwdf_ * ro, ro = rx, rtws[p + j] = re + ro, itws[p + j] = ie + io, rtws[p + j + s] = re - ro, itws[p + j + s] = ie - io, j !== l)
                rx = rtwdf * rtwdf_ - itwdf * itwdf_, itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_, rtwdf_ = rx;
            }
          }
        }
      }, FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1, odd = N & 1, i2 = 0;
        for (N = N / 2 | 0;N; N = N >>> 1)
          i2++;
        return 1 << i2 + 1 + odd;
      }, FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i2 = 0;i2 < N / 2; i2++) {
          var t2 = rws[i2];
          rws[i2] = rws[N - i2 - 1], rws[N - i2 - 1] = t2, t2 = iws[i2], iws[i2] = -iws[N - i2 - 1], iws[N - i2 - 1] = -t2;
        }
      }, FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i2 = 0;i2 < N / 2; i2++) {
          var w = Math.round(ws[2 * i2 + 1] / N) * 8192 + Math.round(ws[2 * i2] / N) + carry;
          if (ws[i2] = w & 67108863, w < 67108864)
            carry = 0;
          else
            carry = w / 67108864 | 0;
        }
        return ws;
      }, FFTM.prototype.convert13b = function convert13b(ws, len2, rws, N) {
        var carry = 0;
        for (var i2 = 0;i2 < len2; i2++)
          carry = carry + (ws[i2] | 0), rws[2 * i2] = carry & 8191, carry = carry >>> 13, rws[2 * i2 + 1] = carry & 8191, carry = carry >>> 13;
        for (i2 = 2 * len2;i2 < N; ++i2)
          rws[i2] = 0;
        assert(carry === 0), assert((carry & -8192) === 0);
      }, FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i2 = 0;i2 < N; i2++)
          ph[i2] = 0;
        return ph;
      }, FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length), rbt = this.makeRBT(N), _ = this.stub(N), rws = new Array(N), rwst = new Array(N), iwst = new Array(N), nrws = new Array(N), nrwst = new Array(N), niwst = new Array(N), rmws = out.words;
        rmws.length = N, this.convert13b(x.words, x.length, rws, N), this.convert13b(y.words, y.length, nrws, N), this.transform(rws, _, rwst, iwst, N, rbt), this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i2 = 0;i2 < N; i2++) {
          var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
          iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2], rwst[i2] = rx;
        }
        return this.conjugate(rwst, iwst, N), this.transform(rwst, iwst, rmws, _, N, rbt), this.conjugate(rmws, _, N), this.normalize13b(rmws, N), out.negative = x.negative ^ y.negative, out.length = x.length + y.length, out.strip();
      }, BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        return out.words = new Array(this.length + num.length), this.mulTo(num, out);
      }, BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        return out.words = new Array(this.length + num.length), jumboMulTo(this, num, out);
      }, BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      }, BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number"), assert(num < 67108864);
        var carry = 0;
        for (var i2 = 0;i2 < this.length; i2++) {
          var w = (this.words[i2] | 0) * num, lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26, carry += w / 67108864 | 0, carry += lo >>> 26, this.words[i2] = lo & 67108863;
        }
        if (carry !== 0)
          this.words[i2] = carry, this.length++;
        return this.length = num === 0 ? 1 : this.length, this;
      }, BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      }, BN.prototype.sqr = function sqr() {
        return this.mul(this);
      }, BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      }, BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i2 = 0;i2 < w.length; i2++, res = res.sqr())
          if (w[i2] !== 0)
            break;
        if (++i2 < w.length)
          for (var q = res.sqr();i2 < w.length; i2++, q = q.sqr()) {
            if (w[i2] === 0)
              continue;
            res = res.mul(q);
          }
        return res;
      }, BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26, s = (bits - r) / 26, carryMask = 67108863 >>> 26 - r << 26 - r, i2;
        if (r !== 0) {
          var carry = 0;
          for (i2 = 0;i2 < this.length; i2++) {
            var newCarry = this.words[i2] & carryMask, c = (this.words[i2] | 0) - newCarry << r;
            this.words[i2] = c | carry, carry = newCarry >>> 26 - r;
          }
          if (carry)
            this.words[i2] = carry, this.length++;
        }
        if (s !== 0) {
          for (i2 = this.length - 1;i2 >= 0; i2--)
            this.words[i2 + s] = this.words[i2];
          for (i2 = 0;i2 < s; i2++)
            this.words[i2] = 0;
          this.length += s;
        }
        return this.strip();
      }, BN.prototype.ishln = function ishln(bits) {
        return assert(this.negative === 0), this.iushln(bits);
      }, BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint)
          h = (hint - hint % 26) / 26;
        else
          h = 0;
        var r = bits % 26, s = Math.min((bits - r) / 26, this.length), mask = 67108863 ^ 67108863 >>> r << r, maskedWords = extended;
        if (h -= s, h = Math.max(0, h), maskedWords) {
          for (var i2 = 0;i2 < s; i2++)
            maskedWords.words[i2] = this.words[i2];
          maskedWords.length = s;
        }
        if (s === 0)
          ;
        else if (this.length > s) {
          this.length -= s;
          for (i2 = 0;i2 < this.length; i2++)
            this.words[i2] = this.words[i2 + s];
        } else
          this.words[0] = 0, this.length = 1;
        var carry = 0;
        for (i2 = this.length - 1;i2 >= 0 && (carry !== 0 || i2 >= h); i2--) {
          var word = this.words[i2] | 0;
          this.words[i2] = carry << 26 - r | word >>> r, carry = word & mask;
        }
        if (maskedWords && carry !== 0)
          maskedWords.words[maskedWords.length++] = carry;
        if (this.length === 0)
          this.words[0] = 0, this.length = 1;
        return this.strip();
      }, BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        return assert(this.negative === 0), this.iushrn(bits, hint, extended);
      }, BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      }, BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      }, BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      }, BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      }, BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26, s = (bit - r) / 26, q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      }, BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26, s = (bits - r) / 26;
        if (assert(this.negative === 0, "imaskn works only with positive numbers"), this.length <= s)
          return this;
        if (r !== 0)
          s++;
        if (this.length = Math.min(s, this.length), r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      }, BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      }, BN.prototype.iaddn = function iaddn(num) {
        if (assert(typeof num === "number"), assert(num < 67108864), num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num)
            return this.words[0] = num - (this.words[0] | 0), this.negative = 0, this;
          return this.negative = 0, this.isubn(num), this.negative = 1, this;
        }
        return this._iaddn(num);
      }, BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i2 = 0;i2 < this.length && this.words[i2] >= 67108864; i2++)
          if (this.words[i2] -= 67108864, i2 === this.length - 1)
            this.words[i2 + 1] = 1;
          else
            this.words[i2 + 1]++;
        return this.length = Math.max(this.length, i2 + 1), this;
      }, BN.prototype.isubn = function isubn(num) {
        if (assert(typeof num === "number"), assert(num < 67108864), num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(num), this.negative = 1, this;
        if (this.words[0] -= num, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var i2 = 0;i2 < this.length && this.words[i2] < 0; i2++)
            this.words[i2] += 67108864, this.words[i2 + 1] -= 1;
        return this.strip();
      }, BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      }, BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      }, BN.prototype.iabs = function iabs() {
        return this.negative = 0, this;
      }, BN.prototype.abs = function abs() {
        return this.clone().iabs();
      }, BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len2 = num.length + shift, i2;
        this._expand(len2);
        var w, carry = 0;
        for (i2 = 0;i2 < num.length; i2++) {
          w = (this.words[i2 + shift] | 0) + carry;
          var right = (num.words[i2] | 0) * mul;
          w -= right & 67108863, carry = (w >> 26) - (right / 67108864 | 0), this.words[i2 + shift] = w & 67108863;
        }
        for (;i2 < this.length - shift; i2++)
          w = (this.words[i2 + shift] | 0) + carry, carry = w >> 26, this.words[i2 + shift] = w & 67108863;
        if (carry === 0)
          return this.strip();
        assert(carry === -1), carry = 0;
        for (i2 = 0;i2 < this.length; i2++)
          w = -(this.words[i2] | 0) + carry, carry = w >> 26, this.words[i2] = w & 67108863;
        return this.negative = 1, this.strip();
      }, BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length, a = this.clone(), b = num, bhi = b.words[b.length - 1] | 0, bhiBits = this._countBits(bhi);
        if (shift = 26 - bhiBits, shift !== 0)
          b = b.ushln(shift), a.iushln(shift), bhi = b.words[b.length - 1] | 0;
        var m = a.length - b.length, q;
        if (mode !== "mod") {
          q = new BN(null), q.length = m + 1, q.words = new Array(q.length);
          for (var i2 = 0;i2 < q.length; i2++)
            q.words[i2] = 0;
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          if (a = diff, q)
            q.words[m] = 1;
        }
        for (var j = m - 1;j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863), a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0)
            if (qj--, a.negative = 0, a._ishlnsubmul(b, 1, j), !a.isZero())
              a.negative ^= 1;
          if (q)
            q.words[j] = qj;
        }
        if (q)
          q.strip();
        if (a.strip(), mode !== "div" && shift !== 0)
          a.iushrn(shift);
        return { div: q || null, mod: a };
      }, BN.prototype.divmod = function divmod(num, mode, positive) {
        if (assert(!num.isZero()), this.isZero())
          return { div: new BN(0), mod: new BN(0) };
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          if (res = this.neg().divmod(num, mode), mode !== "mod")
            div = res.div.neg();
          if (mode !== "div") {
            if (mod = res.mod.neg(), positive && mod.negative !== 0)
              mod.iadd(num);
          }
          return { div, mod };
        }
        if (this.negative === 0 && num.negative !== 0) {
          if (res = this.divmod(num.neg(), mode), mode !== "mod")
            div = res.div.neg();
          return { div, mod: res.mod };
        }
        if ((this.negative & num.negative) !== 0) {
          if (res = this.neg().divmod(num.neg(), mode), mode !== "div") {
            if (mod = res.mod.neg(), positive && mod.negative !== 0)
              mod.isub(num);
          }
          return { div: res.div, mod };
        }
        if (num.length > this.length || this.cmp(num) < 0)
          return { div: new BN(0), mod: this };
        if (num.length === 1) {
          if (mode === "div")
            return { div: this.divn(num.words[0]), mod: null };
          if (mode === "mod")
            return { div: null, mod: new BN(this.modn(num.words[0])) };
          return { div: this.divn(num.words[0]), mod: new BN(this.modn(num.words[0])) };
        }
        return this._wordDiv(num, mode);
      }, BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      }, BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      }, BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      }, BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod, half = num.ushrn(1), r2 = num.andln(1), cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      }, BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = 67108864 % num, acc = 0;
        for (var i2 = this.length - 1;i2 >= 0; i2--)
          acc = (p * acc + (this.words[i2] | 0)) % num;
        return acc;
      }, BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i2 = this.length - 1;i2 >= 0; i2--) {
          var w = (this.words[i2] | 0) + carry * 67108864;
          this.words[i2] = w / num | 0, carry = w % num;
        }
        return this.strip();
      }, BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      }, BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0), assert(!p.isZero());
        var x = this, y = p.clone();
        if (x.negative !== 0)
          x = x.umod(p);
        else
          x = x.clone();
        var A = new BN(1), B = new BN(0), C = new BN(0), D = new BN(1), g = 0;
        while (x.isEven() && y.isEven())
          x.iushrn(1), y.iushrn(1), ++g;
        var yp = y.clone(), xp = x.clone();
        while (!x.isZero()) {
          for (var i2 = 0, im = 1;(x.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            x.iushrn(i2);
            while (i2-- > 0) {
              if (A.isOdd() || B.isOdd())
                A.iadd(yp), B.isub(xp);
              A.iushrn(1), B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1;(y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd())
                C.iadd(yp), D.isub(xp);
              C.iushrn(1), D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0)
            x.isub(y), A.isub(C), B.isub(D);
          else
            y.isub(x), C.isub(A), D.isub(B);
        }
        return { a: C, b: D, gcd: y.iushln(g) };
      }, BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0), assert(!p.isZero());
        var a = this, b = p.clone();
        if (a.negative !== 0)
          a = a.umod(p);
        else
          a = a.clone();
        var x1 = new BN(1), x2 = new BN(0), delta3 = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i2 = 0, im = 1;(a.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            a.iushrn(i2);
            while (i2-- > 0) {
              if (x1.isOdd())
                x1.iadd(delta3);
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1;(b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd())
                x2.iadd(delta3);
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0)
            a.isub(b), x1.isub(x2);
          else
            b.isub(a), x2.isub(x1);
        }
        var res;
        if (a.cmpn(1) === 0)
          res = x1;
        else
          res = x2;
        if (res.cmpn(0) < 0)
          res.iadd(p);
        return res;
      }, BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone(), b = num.clone();
        a.negative = 0, b.negative = 0;
        for (var shift = 0;a.isEven() && b.isEven(); shift++)
          a.iushrn(1), b.iushrn(1);
        do {
          while (a.isEven())
            a.iushrn(1);
          while (b.isEven())
            b.iushrn(1);
          var r = a.cmp(b);
          if (r < 0) {
            var t2 = a;
            a = b, b = t2;
          } else if (r === 0 || b.cmpn(1) === 0)
            break;
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      }, BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      }, BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      }, BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      }, BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      }, BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26, s = (bit - r) / 26, q = 1 << r;
        if (this.length <= s)
          return this._expand(s + 1), this.words[s] |= q, this;
        var carry = q;
        for (var i2 = s;carry !== 0 && i2 < this.length; i2++) {
          var w = this.words[i2] | 0;
          w += carry, carry = w >>> 26, w &= 67108863, this.words[i2] = w;
        }
        if (carry !== 0)
          this.words[i2] = carry, this.length++;
        return this;
      }, BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      }, BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1)
          res = 1;
        else {
          if (negative)
            num = -num;
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      }, BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      }, BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i2 = this.length - 1;i2 >= 0; i2--) {
          var a = this.words[i2] | 0, b = num.words[i2] | 0;
          if (a === b)
            continue;
          if (a < b)
            res = -1;
          else if (a > b)
            res = 1;
          break;
        }
        return res;
      }, BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      }, BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      }, BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      }, BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      }, BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      }, BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      }, BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      }, BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      }, BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      }, BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      }, BN.red = function red(num) {
        return new Red(num);
      }, BN.prototype.toRed = function toRed(ctx) {
        return assert(!this.red, "Already a number in reduction context"), assert(this.negative === 0, "red works only with positives"), ctx.convertTo(this)._forceRed(ctx);
      }, BN.prototype.fromRed = function fromRed() {
        return assert(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, BN.prototype._forceRed = function _forceRed(ctx) {
        return this.red = ctx, this;
      }, BN.prototype.forceRed = function forceRed(ctx) {
        return assert(!this.red, "Already a number in reduction context"), this._forceRed(ctx);
      }, BN.prototype.redAdd = function redAdd(num) {
        return assert(this.red, "redAdd works only with red numbers"), this.red.add(this, num);
      }, BN.prototype.redIAdd = function redIAdd(num) {
        return assert(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, num);
      }, BN.prototype.redSub = function redSub(num) {
        return assert(this.red, "redSub works only with red numbers"), this.red.sub(this, num);
      }, BN.prototype.redISub = function redISub(num) {
        return assert(this.red, "redISub works only with red numbers"), this.red.isub(this, num);
      }, BN.prototype.redShl = function redShl(num) {
        return assert(this.red, "redShl works only with red numbers"), this.red.shl(this, num);
      }, BN.prototype.redMul = function redMul(num) {
        return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.mul(this, num);
      }, BN.prototype.redIMul = function redIMul(num) {
        return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.imul(this, num);
      }, BN.prototype.redSqr = function redSqr() {
        return assert(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, BN.prototype.redISqr = function redISqr() {
        return assert(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, BN.prototype.redSqrt = function redSqrt() {
        return assert(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, BN.prototype.redInvm = function redInvm() {
        return assert(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, BN.prototype.redNeg = function redNeg() {
        return assert(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, BN.prototype.redPow = function redPow(num) {
        return assert(this.red && !num.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, num);
      };
      var primes = { k256: null, p224: null, p192: null, p25519: null };
      function MPrime(name, p) {
        this.name = name, this.p = new BN(p, 16), this.n = this.p.bitLength(), this.k = new BN(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        return tmp.words = new Array(Math.ceil(this.n / 13)), tmp;
      }, MPrime.prototype.ireduce = function ireduce(num) {
        var r = num, rlen;
        do
          this.split(r, this.tmp), r = this.imulK(r), r = r.iadd(this.tmp), rlen = r.bitLength();
        while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0)
          r.words[0] = 0, r.length = 1;
        else if (cmp > 0)
          r.isub(this.p);
        else if (r.strip !== undefined)
          r.strip();
        else
          r._strip();
        return r;
      }, MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      }, MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      inherits2(K256, MPrime), K256.prototype.split = function split(input, output) {
        var mask = 4194303, outLen = Math.min(input.length, 9);
        for (var i2 = 0;i2 < outLen; i2++)
          output.words[i2] = input.words[i2];
        if (output.length = outLen, input.length <= 9) {
          input.words[0] = 0, input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i2 = 10;i2 < input.length; i2++) {
          var next = input.words[i2] | 0;
          input.words[i2 - 10] = (next & mask) << 4 | prev >>> 22, prev = next;
        }
        if (prev >>>= 22, input.words[i2 - 10] = prev, prev === 0 && input.length > 10)
          input.length -= 10;
        else
          input.length -= 9;
      }, K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0, num.words[num.length + 1] = 0, num.length += 2;
        var lo = 0;
        for (var i2 = 0;i2 < num.length; i2++) {
          var w = num.words[i2] | 0;
          lo += w * 977, num.words[i2] = lo & 67108863, lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          if (num.length--, num.words[num.length - 1] === 0)
            num.length--;
        }
        return num;
      };
      function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      inherits2(P25519, MPrime), P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i2 = 0;i2 < num.length; i2++) {
          var hi = (num.words[i2] | 0) * 19 + carry, lo = hi & 67108863;
          hi >>>= 26, num.words[i2] = lo, carry = hi;
        }
        if (carry !== 0)
          num.words[num.length++] = carry;
        return num;
      }, BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime;
        if (name === "k256")
          prime = new K256;
        else if (name === "p224")
          prime = new P224;
        else if (name === "p192")
          prime = new P192;
        else if (name === "p25519")
          prime = new P25519;
        else
          throw new Error("Unknown prime " + name);
        return primes[name] = prime, prime;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p, this.prime = prime;
        } else
          assert(m.gtn(1), "modulus must be greater than 1"), this.m = m, this.prime = null;
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives"), assert(a.red, "red works only with red numbers");
      }, Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives"), assert(a.red && a.red === b.red, "red works only with red numbers");
      }, Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      }, Red.prototype.neg = function neg(a) {
        if (a.isZero())
          return a.clone();
        return this.m.sub(a)._forceRed(this);
      }, Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0)
          res.isub(this.m);
        return res._forceRed(this);
      }, Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0)
          res.isub(this.m);
        return res;
      }, Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0)
          res.iadd(this.m);
        return res._forceRed(this);
      }, Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0)
          res.iadd(this.m);
        return res;
      }, Red.prototype.shl = function shl(a, num) {
        return this._verify1(a), this.imod(a.ushln(num));
      }, Red.prototype.imul = function imul(a, b) {
        return this._verify2(a, b), this.imod(a.imul(b));
      }, Red.prototype.mul = function mul(a, b) {
        return this._verify2(a, b), this.imod(a.mul(b));
      }, Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      }, Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      }, Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        if (assert(mod3 % 2 === 1), mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1), s = 0;
        while (!q.isZero() && q.andln(1) === 0)
          s++, q.iushrn(1);
        assert(!q.isZero());
        var one = new BN(1).toRed(this), nOne = one.redNeg(), lpow = this.m.subn(1).iushrn(1), z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0)
          z.redIAdd(nOne);
        var c = this.pow(z, q), r = this.pow(a, q.addn(1).iushrn(1)), t2 = this.pow(a, q), m = s;
        while (t2.cmp(one) !== 0) {
          var tmp = t2;
          for (var i2 = 0;tmp.cmp(one) !== 0; i2++)
            tmp = tmp.redSqr();
          assert(i2 < m);
          var b = this.pow(c, new BN(1).iushln(m - i2 - 1));
          r = r.redMul(b), c = b.redSqr(), t2 = t2.redMul(c), m = i2;
        }
        return r;
      }, Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0)
          return inv.negative = 0, this.imod(inv).redNeg();
        else
          return this.imod(inv);
      }, Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4, wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this), wnd[1] = a;
        for (var i2 = 2;i2 < wnd.length; i2++)
          wnd[i2] = this.mul(wnd[i2 - 1], a);
        var res = wnd[0], current = 0, currentLen = 0, start = num.bitLength() % 26;
        if (start === 0)
          start = 26;
        for (i2 = num.length - 1;i2 >= 0; i2--) {
          var word = num.words[i2];
          for (var j = start - 1;j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0])
              res = this.sqr(res);
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            if (current <<= 1, current |= bit, currentLen++, currentLen !== windowSize && (i2 !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]), currentLen = 0, current = 0;
          }
          start = 26;
        }
        return res;
      }, Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      }, Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        return res.red = null, res;
      }, BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        if (Red.call(this, m), this.shift = this.m.bitLength(), this.shift % 26 !== 0)
          this.shift += 26 - this.shift % 26;
        this.r = new BN(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red), Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      }, Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        return r.red = null, r;
      }, Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero())
          return a.words[0] = 0, a.length = 1, a;
        var t2 = a.imul(b), c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t2.isub(c).iushrn(this.shift), res = u;
        if (u.cmp(this.m) >= 0)
          res = u.isub(this.m);
        else if (u.cmpn(0) < 0)
          res = u.iadd(this.m);
        return res._forceRed(this);
      }, Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t2 = a.mul(b), c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t2.isub(c).iushrn(this.shift), res = u;
        if (u.cmp(this.m) >= 0)
          res = u.isub(this.m);
        else if (u.cmpn(0) < 0)
          res = u.iadd(this.m);
        return res._forceRed(this);
      }, Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  });
  require_withPublic = __commonJS2((exports, module) => {
    var BN = require_bn4(), Buffer22 = require_safe_buffer().Buffer;
    function withPublic(paddedMsg, key) {
      return Buffer22.from(paddedMsg.toRed(BN.mont(key.modulus)).redPow(new BN(key.publicExponent)).fromRed().toArray());
    }
    module.exports = withPublic;
  });
  require_bn5 = __commonJS2((exports, module) => {
    (function(module2, exports2) {
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor, ctor.prototype.constructor = ctor;
      }
      function BN(number3, base, endian) {
        if (BN.isBN(number3))
          return number3;
        if (this.negative = 0, this.words = null, this.length = 0, this.red = null, number3 !== null) {
          if (base === "le" || base === "be")
            endian = base, base = 10;
          this._init(number3 || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object")
        module2.exports = BN;
      else
        exports2.BN = BN;
      BN.BN = BN, BN.wordSize = 26;
      var Buffer22;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined")
          Buffer22 = window.Buffer;
        else
          Buffer22 = (init_buffer(), __toCommonJS(exports_buffer2)).Buffer;
      } catch (e) {}
      BN.isBN = function isBN(num) {
        if (num instanceof BN)
          return true;
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      }, BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      }, BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      }, BN.prototype._init = function init(number3, base, endian) {
        if (typeof number3 === "number")
          return this._initNumber(number3, base, endian);
        if (typeof number3 === "object")
          return this._initArray(number3, base, endian);
        if (base === "hex")
          base = 16;
        assert(base === (base | 0) && base >= 2 && base <= 36), number3 = number3.toString().replace(/\s+/g, "");
        var start = 0;
        if (number3[0] === "-")
          start++, this.negative = 1;
        if (start < number3.length) {
          if (base === 16)
            this._parseHex(number3, start, endian);
          else if (this._parseBase(number3, base, start), endian === "le")
            this._initArray(this.toArray(), base, endian);
        }
      }, BN.prototype._initNumber = function _initNumber(number3, base, endian) {
        if (number3 < 0)
          this.negative = 1, number3 = -number3;
        if (number3 < 67108864)
          this.words = [number3 & 67108863], this.length = 1;
        else if (number3 < 4503599627370496)
          this.words = [number3 & 67108863, number3 / 67108864 & 67108863], this.length = 2;
        else
          assert(number3 < 9007199254740992), this.words = [number3 & 67108863, number3 / 67108864 & 67108863, 1], this.length = 3;
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      }, BN.prototype._initArray = function _initArray(number3, base, endian) {
        if (assert(typeof number3.length === "number"), number3.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(number3.length / 3), this.words = new Array(this.length);
        for (var i2 = 0;i2 < this.length; i2++)
          this.words[i2] = 0;
        var j, w, off = 0;
        if (endian === "be") {
          for (i2 = number3.length - 1, j = 0;i2 >= 0; i2 -= 3)
            if (w = number3[i2] | number3[i2 - 1] << 8 | number3[i2 - 2] << 16, this.words[j] |= w << off & 67108863, this.words[j + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26)
              off -= 26, j++;
        } else if (endian === "le") {
          for (i2 = 0, j = 0;i2 < number3.length; i2 += 3)
            if (w = number3[i2] | number3[i2 + 1] << 8 | number3[i2 + 2] << 16, this.words[j] |= w << off & 67108863, this.words[j + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26)
              off -= 26, j++;
        }
        return this._strip();
      };
      function parseHex4Bits(string3, index) {
        var c = string3.charCodeAt(index);
        if (c >= 48 && c <= 57)
          return c - 48;
        else if (c >= 65 && c <= 70)
          return c - 55;
        else if (c >= 97 && c <= 102)
          return c - 87;
        else
          assert(false, "Invalid character in " + string3);
      }
      function parseHexByte(string3, lowerBound, index) {
        var r = parseHex4Bits(string3, index);
        if (index - 1 >= lowerBound)
          r |= parseHex4Bits(string3, index - 1) << 4;
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number3, start, endian) {
        this.length = Math.ceil((number3.length - start) / 6), this.words = new Array(this.length);
        for (var i2 = 0;i2 < this.length; i2++)
          this.words[i2] = 0;
        var off = 0, j = 0, w;
        if (endian === "be")
          for (i2 = number3.length - 1;i2 >= start; i2 -= 2)
            if (w = parseHexByte(number3, start, i2) << off, this.words[j] |= w & 67108863, off >= 18)
              off -= 18, j += 1, this.words[j] |= w >>> 26;
            else
              off += 8;
        else {
          var parseLength = number3.length - start;
          for (i2 = parseLength % 2 === 0 ? start + 1 : start;i2 < number3.length; i2 += 2)
            if (w = parseHexByte(number3, start, i2) << off, this.words[j] |= w & 67108863, off >= 18)
              off -= 18, j += 1, this.words[j] |= w >>> 26;
            else
              off += 8;
        }
        this._strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0, b = 0, len2 = Math.min(str.length, end);
        for (var i2 = start;i2 < len2; i2++) {
          var c = str.charCodeAt(i2) - 48;
          if (r *= mul, c >= 49)
            b = c - 49 + 10;
          else if (c >= 17)
            b = c - 17 + 10;
          else
            b = c;
          assert(c >= 0 && b < mul, "Invalid character"), r += b;
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number3, base, start) {
        this.words = [0], this.length = 1;
        for (var limbLen = 0, limbPow = 1;limbPow <= 67108863; limbPow *= base)
          limbLen++;
        limbLen--, limbPow = limbPow / base | 0;
        var total = number3.length - start, mod = total % limbLen, end = Math.min(total, total - mod) + start, word = 0;
        for (var i2 = start;i2 < end; i2 += limbLen)
          if (word = parseBase(number3, i2, i2 + limbLen, base), this.imuln(limbPow), this.words[0] + word < 67108864)
            this.words[0] += word;
          else
            this._iaddn(word);
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number3, i2, number3.length, base);
          for (i2 = 0;i2 < mod; i2++)
            pow *= base;
          if (this.imuln(pow), this.words[0] + word < 67108864)
            this.words[0] += word;
          else
            this._iaddn(word);
        }
        this._strip();
      }, BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i2 = 0;i2 < this.length; i2++)
          dest.words[i2] = this.words[i2];
        dest.length = this.length, dest.negative = this.negative, dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words, dest.length = src.length, dest.negative = src.negative, dest.red = src.red;
      }
      if (BN.prototype._move = function _move(dest) {
        move(dest, this);
      }, BN.prototype.clone = function clone() {
        var r = new BN(null);
        return this.copy(r), r;
      }, BN.prototype._expand = function _expand(size) {
        while (this.length < size)
          this.words[this.length++] = 0;
        return this;
      }, BN.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0)
          this.length--;
        return this._normSign();
      }, BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0)
          this.negative = 0;
        return this;
      }, typeof Symbol !== "undefined" && typeof Symbol.for === "function")
        try {
          BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect3;
        } catch (e) {
          BN.prototype.inspect = inspect3;
        }
      else
        BN.prototype.inspect = inspect3;
      function inspect3() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      if (BN.prototype.toString = function toString(base, padding) {
        base = base || 10, padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0, carry = 0;
          for (var i2 = 0;i2 < this.length; i2++) {
            var w = this.words[i2], word = ((w << off | carry) & 16777215).toString(16);
            if (carry = w >>> 24 - off & 16777215, off += 2, off >= 26)
              off -= 26, i2--;
            if (carry !== 0 || i2 !== this.length - 1)
              out = zeros[6 - word.length] + word + out;
            else
              out = word + out;
          }
          if (carry !== 0)
            out = carry.toString(16) + out;
          while (out.length % padding !== 0)
            out = "0" + out;
          if (this.negative !== 0)
            out = "-" + out;
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base], groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modrn(groupBase).toString(base);
            if (c = c.idivn(groupBase), !c.isZero())
              out = zeros[groupSize - r.length] + r + out;
            else
              out = r + out;
          }
          if (this.isZero())
            out = "0" + out;
          while (out.length % padding !== 0)
            out = "0" + out;
          if (this.negative !== 0)
            out = "-" + out;
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      }, BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2)
          ret += this.words[1] * 67108864;
        else if (this.length === 3 && this.words[2] === 1)
          ret += 4503599627370496 + this.words[1] * 67108864;
        else if (this.length > 2)
          assert(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -ret : ret;
      }, BN.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      }, Buffer22)
        BN.prototype.toBuffer = function toBuffer(endian, length) {
          return this.toArrayLike(Buffer22, endian, length);
        };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate(ArrayType7, size) {
        if (ArrayType7.allocUnsafe)
          return ArrayType7.allocUnsafe(size);
        return new ArrayType7(size);
      };
      if (BN.prototype.toArrayLike = function toArrayLike(ArrayType7, endian, length) {
        this._strip();
        var byteLength2 = this.byteLength(), reqLength = length || Math.max(1, byteLength2);
        assert(byteLength2 <= reqLength, "byte array longer than desired length"), assert(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType7, reqLength), postfix = endian === "le" ? "LE" : "BE";
        return this["_toArrayLike" + postfix](res, byteLength2), res;
      }, BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength2) {
        var position = 0, carry = 0;
        for (var i2 = 0, shift = 0;i2 < this.length; i2++) {
          var word = this.words[i2] << shift | carry;
          if (res[position++] = word & 255, position < res.length)
            res[position++] = word >> 8 & 255;
          if (position < res.length)
            res[position++] = word >> 16 & 255;
          if (shift === 6) {
            if (position < res.length)
              res[position++] = word >> 24 & 255;
            carry = 0, shift = 0;
          } else
            carry = word >>> 24, shift += 2;
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length)
            res[position++] = 0;
        }
      }, BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength2) {
        var position = res.length - 1, carry = 0;
        for (var i2 = 0, shift = 0;i2 < this.length; i2++) {
          var word = this.words[i2] << shift | carry;
          if (res[position--] = word & 255, position >= 0)
            res[position--] = word >> 8 & 255;
          if (position >= 0)
            res[position--] = word >> 16 & 255;
          if (shift === 6) {
            if (position >= 0)
              res[position--] = word >> 24 & 255;
            carry = 0, shift = 0;
          } else
            carry = word >>> 24, shift += 2;
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0)
            res[position--] = 0;
        }
      }, Math.clz32)
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      else
        BN.prototype._countBits = function _countBits(w) {
          var t2 = w, r = 0;
          if (t2 >= 4096)
            r += 13, t2 >>>= 13;
          if (t2 >= 64)
            r += 7, t2 >>>= 7;
          if (t2 >= 8)
            r += 4, t2 >>>= 4;
          if (t2 >= 2)
            r += 2, t2 >>>= 2;
          return r + t2;
        };
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t2 = w, r = 0;
        if ((t2 & 8191) === 0)
          r += 13, t2 >>>= 13;
        if ((t2 & 127) === 0)
          r += 7, t2 >>>= 7;
        if ((t2 & 15) === 0)
          r += 4, t2 >>>= 4;
        if ((t2 & 3) === 0)
          r += 2, t2 >>>= 2;
        if ((t2 & 1) === 0)
          r++;
        return r;
      }, BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1], hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0;bit < w.length; bit++) {
          var off = bit / 26 | 0, wbit = bit % 26;
          w[bit] = num.words[off] >>> wbit & 1;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i2 = 0;i2 < this.length; i2++) {
          var b = this._zeroBits(this.words[i2]);
          if (r += b, b !== 26)
            break;
        }
        return r;
      }, BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      }, BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0)
          return this.abs().inotn(width).iaddn(1);
        return this.clone();
      }, BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1))
          return this.notn(width).iaddn(1).ineg();
        return this.clone();
      }, BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      }, BN.prototype.neg = function neg() {
        return this.clone().ineg();
      }, BN.prototype.ineg = function ineg() {
        if (!this.isZero())
          this.negative ^= 1;
        return this;
      }, BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length)
          this.words[this.length++] = 0;
        for (var i2 = 0;i2 < num.length; i2++)
          this.words[i2] = this.words[i2] | num.words[i2];
        return this._strip();
      }, BN.prototype.ior = function ior(num) {
        return assert((this.negative | num.negative) === 0), this.iuor(num);
      }, BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      }, BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      }, BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length)
          b = num;
        else
          b = this;
        for (var i2 = 0;i2 < b.length; i2++)
          this.words[i2] = this.words[i2] & num.words[i2];
        return this.length = b.length, this._strip();
      }, BN.prototype.iand = function iand(num) {
        return assert((this.negative | num.negative) === 0), this.iuand(num);
      }, BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      }, BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      }, BN.prototype.iuxor = function iuxor(num) {
        var a, b;
        if (this.length > num.length)
          a = this, b = num;
        else
          a = num, b = this;
        for (var i2 = 0;i2 < b.length; i2++)
          this.words[i2] = a.words[i2] ^ b.words[i2];
        if (this !== a)
          for (;i2 < a.length; i2++)
            this.words[i2] = a.words[i2];
        return this.length = a.length, this._strip();
      }, BN.prototype.ixor = function ixor(num) {
        return assert((this.negative | num.negative) === 0), this.iuxor(num);
      }, BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      }, BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      }, BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0, bitsLeft = width % 26;
        if (this._expand(bytesNeeded), bitsLeft > 0)
          bytesNeeded--;
        for (var i2 = 0;i2 < bytesNeeded; i2++)
          this.words[i2] = ~this.words[i2] & 67108863;
        if (bitsLeft > 0)
          this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
        return this._strip();
      }, BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      }, BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0, wbit = bit % 26;
        if (this._expand(off + 1), val)
          this.words[off] = this.words[off] | 1 << wbit;
        else
          this.words[off] = this.words[off] & ~(1 << wbit);
        return this._strip();
      }, BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0)
          return this.negative = 0, r = this.isub(num), this.negative ^= 1, this._normSign();
        else if (this.negative === 0 && num.negative !== 0)
          return num.negative = 0, r = this.isub(num), num.negative = 1, r._normSign();
        var a, b;
        if (this.length > num.length)
          a = this, b = num;
        else
          a = num, b = this;
        var carry = 0;
        for (var i2 = 0;i2 < b.length; i2++)
          r = (a.words[i2] | 0) + (b.words[i2] | 0) + carry, this.words[i2] = r & 67108863, carry = r >>> 26;
        for (;carry !== 0 && i2 < a.length; i2++)
          r = (a.words[i2] | 0) + carry, this.words[i2] = r & 67108863, carry = r >>> 26;
        if (this.length = a.length, carry !== 0)
          this.words[this.length] = carry, this.length++;
        else if (a !== this)
          for (;i2 < a.length; i2++)
            this.words[i2] = a.words[i2];
        return this;
      }, BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0)
          return num.negative = 0, res = this.sub(num), num.negative ^= 1, res;
        else if (num.negative === 0 && this.negative !== 0)
          return this.negative = 0, res = num.sub(this), this.negative = 1, res;
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      }, BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          return num.negative = 1, r._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(num), this.negative = 1, this._normSign();
        var cmp = this.cmp(num);
        if (cmp === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var a, b;
        if (cmp > 0)
          a = this, b = num;
        else
          a = num, b = this;
        var carry = 0;
        for (var i2 = 0;i2 < b.length; i2++)
          r = (a.words[i2] | 0) - (b.words[i2] | 0) + carry, carry = r >> 26, this.words[i2] = r & 67108863;
        for (;carry !== 0 && i2 < a.length; i2++)
          r = (a.words[i2] | 0) + carry, carry = r >> 26, this.words[i2] = r & 67108863;
        if (carry === 0 && i2 < a.length && a !== this)
          for (;i2 < a.length; i2++)
            this.words[i2] = a.words[i2];
        if (this.length = Math.max(this.length, i2), a !== this)
          this.negative = 1;
        return this._strip();
      }, BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len2 = self2.length + num.length | 0;
        out.length = len2, len2 = len2 - 1 | 0;
        var a = self2.words[0] | 0, b = num.words[0] | 0, r = a * b, lo = r & 67108863, carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1;k < len2; k++) {
          var ncarry = carry >>> 26, rword = carry & 67108863, maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
            var i2 = k - j | 0;
            a = self2.words[i2] | 0, b = num.words[j] | 0, r = a * b + rword, ncarry += r / 67108864 | 0, rword = r & 67108863;
          }
          out.words[k] = rword | 0, carry = ncarry | 0;
        }
        if (carry !== 0)
          out.words[k] = carry | 0;
        else
          out.length--;
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo(self2, num, out) {
        var a = self2.words, b = num.words, o = out.words, c = 0, lo, mid, hi, a0 = a[0] | 0, al0 = a0 & 8191, ah0 = a0 >>> 13, a1 = a[1] | 0, al1 = a1 & 8191, ah1 = a1 >>> 13, a2 = a[2] | 0, al2 = a2 & 8191, ah2 = a2 >>> 13, a3 = a[3] | 0, al3 = a3 & 8191, ah3 = a3 >>> 13, a4 = a[4] | 0, al4 = a4 & 8191, ah4 = a4 >>> 13, a5 = a[5] | 0, al5 = a5 & 8191, ah5 = a5 >>> 13, a6 = a[6] | 0, al6 = a6 & 8191, ah6 = a6 >>> 13, a7 = a[7] | 0, al7 = a7 & 8191, ah7 = a7 >>> 13, a8 = a[8] | 0, al8 = a8 & 8191, ah8 = a8 >>> 13, a9 = a[9] | 0, al9 = a9 & 8191, ah9 = a9 >>> 13, b0 = b[0] | 0, bl0 = b0 & 8191, bh0 = b0 >>> 13, b1 = b[1] | 0, bl1 = b1 & 8191, bh1 = b1 >>> 13, b2 = b[2] | 0, bl2 = b2 & 8191, bh2 = b2 >>> 13, b3 = b[3] | 0, bl3 = b3 & 8191, bh3 = b3 >>> 13, b4 = b[4] | 0, bl4 = b4 & 8191, bh4 = b4 >>> 13, b5 = b[5] | 0, bl5 = b5 & 8191, bh5 = b5 >>> 13, b6 = b[6] | 0, bl6 = b6 & 8191, bh6 = b6 >>> 13, b7 = b[7] | 0, bl7 = b7 & 8191, bh7 = b7 >>> 13, b8 = b[8] | 0, bl8 = b8 & 8191, bh8 = b8 >>> 13, b9 = b[9] | 0, bl9 = b9 & 8191, bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative, out.length = 19, lo = Math.imul(al0, bl0), mid = Math.imul(al0, bh0), mid = mid + Math.imul(ah0, bl0) | 0, hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0, w0 &= 67108863, lo = Math.imul(al1, bl0), mid = Math.imul(al1, bh0), mid = mid + Math.imul(ah1, bl0) | 0, hi = Math.imul(ah1, bh0), lo = lo + Math.imul(al0, bl1) | 0, mid = mid + Math.imul(al0, bh1) | 0, mid = mid + Math.imul(ah0, bl1) | 0, hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0, w1 &= 67108863, lo = Math.imul(al2, bl0), mid = Math.imul(al2, bh0), mid = mid + Math.imul(ah2, bl0) | 0, hi = Math.imul(ah2, bh0), lo = lo + Math.imul(al1, bl1) | 0, mid = mid + Math.imul(al1, bh1) | 0, mid = mid + Math.imul(ah1, bl1) | 0, hi = hi + Math.imul(ah1, bh1) | 0, lo = lo + Math.imul(al0, bl2) | 0, mid = mid + Math.imul(al0, bh2) | 0, mid = mid + Math.imul(ah0, bl2) | 0, hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0, w2 &= 67108863, lo = Math.imul(al3, bl0), mid = Math.imul(al3, bh0), mid = mid + Math.imul(ah3, bl0) | 0, hi = Math.imul(ah3, bh0), lo = lo + Math.imul(al2, bl1) | 0, mid = mid + Math.imul(al2, bh1) | 0, mid = mid + Math.imul(ah2, bl1) | 0, hi = hi + Math.imul(ah2, bh1) | 0, lo = lo + Math.imul(al1, bl2) | 0, mid = mid + Math.imul(al1, bh2) | 0, mid = mid + Math.imul(ah1, bl2) | 0, hi = hi + Math.imul(ah1, bh2) | 0, lo = lo + Math.imul(al0, bl3) | 0, mid = mid + Math.imul(al0, bh3) | 0, mid = mid + Math.imul(ah0, bl3) | 0, hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0, w3 &= 67108863, lo = Math.imul(al4, bl0), mid = Math.imul(al4, bh0), mid = mid + Math.imul(ah4, bl0) | 0, hi = Math.imul(ah4, bh0), lo = lo + Math.imul(al3, bl1) | 0, mid = mid + Math.imul(al3, bh1) | 0, mid = mid + Math.imul(ah3, bl1) | 0, hi = hi + Math.imul(ah3, bh1) | 0, lo = lo + Math.imul(al2, bl2) | 0, mid = mid + Math.imul(al2, bh2) | 0, mid = mid + Math.imul(ah2, bl2) | 0, hi = hi + Math.imul(ah2, bh2) | 0, lo = lo + Math.imul(al1, bl3) | 0, mid = mid + Math.imul(al1, bh3) | 0, mid = mid + Math.imul(ah1, bl3) | 0, hi = hi + Math.imul(ah1, bh3) | 0, lo = lo + Math.imul(al0, bl4) | 0, mid = mid + Math.imul(al0, bh4) | 0, mid = mid + Math.imul(ah0, bl4) | 0, hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0, w4 &= 67108863, lo = Math.imul(al5, bl0), mid = Math.imul(al5, bh0), mid = mid + Math.imul(ah5, bl0) | 0, hi = Math.imul(ah5, bh0), lo = lo + Math.imul(al4, bl1) | 0, mid = mid + Math.imul(al4, bh1) | 0, mid = mid + Math.imul(ah4, bl1) | 0, hi = hi + Math.imul(ah4, bh1) | 0, lo = lo + Math.imul(al3, bl2) | 0, mid = mid + Math.imul(al3, bh2) | 0, mid = mid + Math.imul(ah3, bl2) | 0, hi = hi + Math.imul(ah3, bh2) | 0, lo = lo + Math.imul(al2, bl3) | 0, mid = mid + Math.imul(al2, bh3) | 0, mid = mid + Math.imul(ah2, bl3) | 0, hi = hi + Math.imul(ah2, bh3) | 0, lo = lo + Math.imul(al1, bl4) | 0, mid = mid + Math.imul(al1, bh4) | 0, mid = mid + Math.imul(ah1, bl4) | 0, hi = hi + Math.imul(ah1, bh4) | 0, lo = lo + Math.imul(al0, bl5) | 0, mid = mid + Math.imul(al0, bh5) | 0, mid = mid + Math.imul(ah0, bl5) | 0, hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0, w5 &= 67108863, lo = Math.imul(al6, bl0), mid = Math.imul(al6, bh0), mid = mid + Math.imul(ah6, bl0) | 0, hi = Math.imul(ah6, bh0), lo = lo + Math.imul(al5, bl1) | 0, mid = mid + Math.imul(al5, bh1) | 0, mid = mid + Math.imul(ah5, bl1) | 0, hi = hi + Math.imul(ah5, bh1) | 0, lo = lo + Math.imul(al4, bl2) | 0, mid = mid + Math.imul(al4, bh2) | 0, mid = mid + Math.imul(ah4, bl2) | 0, hi = hi + Math.imul(ah4, bh2) | 0, lo = lo + Math.imul(al3, bl3) | 0, mid = mid + Math.imul(al3, bh3) | 0, mid = mid + Math.imul(ah3, bl3) | 0, hi = hi + Math.imul(ah3, bh3) | 0, lo = lo + Math.imul(al2, bl4) | 0, mid = mid + Math.imul(al2, bh4) | 0, mid = mid + Math.imul(ah2, bl4) | 0, hi = hi + Math.imul(ah2, bh4) | 0, lo = lo + Math.imul(al1, bl5) | 0, mid = mid + Math.imul(al1, bh5) | 0, mid = mid + Math.imul(ah1, bl5) | 0, hi = hi + Math.imul(ah1, bh5) | 0, lo = lo + Math.imul(al0, bl6) | 0, mid = mid + Math.imul(al0, bh6) | 0, mid = mid + Math.imul(ah0, bl6) | 0, hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0, w6 &= 67108863, lo = Math.imul(al7, bl0), mid = Math.imul(al7, bh0), mid = mid + Math.imul(ah7, bl0) | 0, hi = Math.imul(ah7, bh0), lo = lo + Math.imul(al6, bl1) | 0, mid = mid + Math.imul(al6, bh1) | 0, mid = mid + Math.imul(ah6, bl1) | 0, hi = hi + Math.imul(ah6, bh1) | 0, lo = lo + Math.imul(al5, bl2) | 0, mid = mid + Math.imul(al5, bh2) | 0, mid = mid + Math.imul(ah5, bl2) | 0, hi = hi + Math.imul(ah5, bh2) | 0, lo = lo + Math.imul(al4, bl3) | 0, mid = mid + Math.imul(al4, bh3) | 0, mid = mid + Math.imul(ah4, bl3) | 0, hi = hi + Math.imul(ah4, bh3) | 0, lo = lo + Math.imul(al3, bl4) | 0, mid = mid + Math.imul(al3, bh4) | 0, mid = mid + Math.imul(ah3, bl4) | 0, hi = hi + Math.imul(ah3, bh4) | 0, lo = lo + Math.imul(al2, bl5) | 0, mid = mid + Math.imul(al2, bh5) | 0, mid = mid + Math.imul(ah2, bl5) | 0, hi = hi + Math.imul(ah2, bh5) | 0, lo = lo + Math.imul(al1, bl6) | 0, mid = mid + Math.imul(al1, bh6) | 0, mid = mid + Math.imul(ah1, bl6) | 0, hi = hi + Math.imul(ah1, bh6) | 0, lo = lo + Math.imul(al0, bl7) | 0, mid = mid + Math.imul(al0, bh7) | 0, mid = mid + Math.imul(ah0, bl7) | 0, hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0, w7 &= 67108863, lo = Math.imul(al8, bl0), mid = Math.imul(al8, bh0), mid = mid + Math.imul(ah8, bl0) | 0, hi = Math.imul(ah8, bh0), lo = lo + Math.imul(al7, bl1) | 0, mid = mid + Math.imul(al7, bh1) | 0, mid = mid + Math.imul(ah7, bl1) | 0, hi = hi + Math.imul(ah7, bh1) | 0, lo = lo + Math.imul(al6, bl2) | 0, mid = mid + Math.imul(al6, bh2) | 0, mid = mid + Math.imul(ah6, bl2) | 0, hi = hi + Math.imul(ah6, bh2) | 0, lo = lo + Math.imul(al5, bl3) | 0, mid = mid + Math.imul(al5, bh3) | 0, mid = mid + Math.imul(ah5, bl3) | 0, hi = hi + Math.imul(ah5, bh3) | 0, lo = lo + Math.imul(al4, bl4) | 0, mid = mid + Math.imul(al4, bh4) | 0, mid = mid + Math.imul(ah4, bl4) | 0, hi = hi + Math.imul(ah4, bh4) | 0, lo = lo + Math.imul(al3, bl5) | 0, mid = mid + Math.imul(al3, bh5) | 0, mid = mid + Math.imul(ah3, bl5) | 0, hi = hi + Math.imul(ah3, bh5) | 0, lo = lo + Math.imul(al2, bl6) | 0, mid = mid + Math.imul(al2, bh6) | 0, mid = mid + Math.imul(ah2, bl6) | 0, hi = hi + Math.imul(ah2, bh6) | 0, lo = lo + Math.imul(al1, bl7) | 0, mid = mid + Math.imul(al1, bh7) | 0, mid = mid + Math.imul(ah1, bl7) | 0, hi = hi + Math.imul(ah1, bh7) | 0, lo = lo + Math.imul(al0, bl8) | 0, mid = mid + Math.imul(al0, bh8) | 0, mid = mid + Math.imul(ah0, bl8) | 0, hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0, w8 &= 67108863, lo = Math.imul(al9, bl0), mid = Math.imul(al9, bh0), mid = mid + Math.imul(ah9, bl0) | 0, hi = Math.imul(ah9, bh0), lo = lo + Math.imul(al8, bl1) | 0, mid = mid + Math.imul(al8, bh1) | 0, mid = mid + Math.imul(ah8, bl1) | 0, hi = hi + Math.imul(ah8, bh1) | 0, lo = lo + Math.imul(al7, bl2) | 0, mid = mid + Math.imul(al7, bh2) | 0, mid = mid + Math.imul(ah7, bl2) | 0, hi = hi + Math.imul(ah7, bh2) | 0, lo = lo + Math.imul(al6, bl3) | 0, mid = mid + Math.imul(al6, bh3) | 0, mid = mid + Math.imul(ah6, bl3) | 0, hi = hi + Math.imul(ah6, bh3) | 0, lo = lo + Math.imul(al5, bl4) | 0, mid = mid + Math.imul(al5, bh4) | 0, mid = mid + Math.imul(ah5, bl4) | 0, hi = hi + Math.imul(ah5, bh4) | 0, lo = lo + Math.imul(al4, bl5) | 0, mid = mid + Math.imul(al4, bh5) | 0, mid = mid + Math.imul(ah4, bl5) | 0, hi = hi + Math.imul(ah4, bh5) | 0, lo = lo + Math.imul(al3, bl6) | 0, mid = mid + Math.imul(al3, bh6) | 0, mid = mid + Math.imul(ah3, bl6) | 0, hi = hi + Math.imul(ah3, bh6) | 0, lo = lo + Math.imul(al2, bl7) | 0, mid = mid + Math.imul(al2, bh7) | 0, mid = mid + Math.imul(ah2, bl7) | 0, hi = hi + Math.imul(ah2, bh7) | 0, lo = lo + Math.imul(al1, bl8) | 0, mid = mid + Math.imul(al1, bh8) | 0, mid = mid + Math.imul(ah1, bl8) | 0, hi = hi + Math.imul(ah1, bh8) | 0, lo = lo + Math.imul(al0, bl9) | 0, mid = mid + Math.imul(al0, bh9) | 0, mid = mid + Math.imul(ah0, bl9) | 0, hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0, w9 &= 67108863, lo = Math.imul(al9, bl1), mid = Math.imul(al9, bh1), mid = mid + Math.imul(ah9, bl1) | 0, hi = Math.imul(ah9, bh1), lo = lo + Math.imul(al8, bl2) | 0, mid = mid + Math.imul(al8, bh2) | 0, mid = mid + Math.imul(ah8, bl2) | 0, hi = hi + Math.imul(ah8, bh2) | 0, lo = lo + Math.imul(al7, bl3) | 0, mid = mid + Math.imul(al7, bh3) | 0, mid = mid + Math.imul(ah7, bl3) | 0, hi = hi + Math.imul(ah7, bh3) | 0, lo = lo + Math.imul(al6, bl4) | 0, mid = mid + Math.imul(al6, bh4) | 0, mid = mid + Math.imul(ah6, bl4) | 0, hi = hi + Math.imul(ah6, bh4) | 0, lo = lo + Math.imul(al5, bl5) | 0, mid = mid + Math.imul(al5, bh5) | 0, mid = mid + Math.imul(ah5, bl5) | 0, hi = hi + Math.imul(ah5, bh5) | 0, lo = lo + Math.imul(al4, bl6) | 0, mid = mid + Math.imul(al4, bh6) | 0, mid = mid + Math.imul(ah4, bl6) | 0, hi = hi + Math.imul(ah4, bh6) | 0, lo = lo + Math.imul(al3, bl7) | 0, mid = mid + Math.imul(al3, bh7) | 0, mid = mid + Math.imul(ah3, bl7) | 0, hi = hi + Math.imul(ah3, bh7) | 0, lo = lo + Math.imul(al2, bl8) | 0, mid = mid + Math.imul(al2, bh8) | 0, mid = mid + Math.imul(ah2, bl8) | 0, hi = hi + Math.imul(ah2, bh8) | 0, lo = lo + Math.imul(al1, bl9) | 0, mid = mid + Math.imul(al1, bh9) | 0, mid = mid + Math.imul(ah1, bl9) | 0, hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0, w10 &= 67108863, lo = Math.imul(al9, bl2), mid = Math.imul(al9, bh2), mid = mid + Math.imul(ah9, bl2) | 0, hi = Math.imul(ah9, bh2), lo = lo + Math.imul(al8, bl3) | 0, mid = mid + Math.imul(al8, bh3) | 0, mid = mid + Math.imul(ah8, bl3) | 0, hi = hi + Math.imul(ah8, bh3) | 0, lo = lo + Math.imul(al7, bl4) | 0, mid = mid + Math.imul(al7, bh4) | 0, mid = mid + Math.imul(ah7, bl4) | 0, hi = hi + Math.imul(ah7, bh4) | 0, lo = lo + Math.imul(al6, bl5) | 0, mid = mid + Math.imul(al6, bh5) | 0, mid = mid + Math.imul(ah6, bl5) | 0, hi = hi + Math.imul(ah6, bh5) | 0, lo = lo + Math.imul(al5, bl6) | 0, mid = mid + Math.imul(al5, bh6) | 0, mid = mid + Math.imul(ah5, bl6) | 0, hi = hi + Math.imul(ah5, bh6) | 0, lo = lo + Math.imul(al4, bl7) | 0, mid = mid + Math.imul(al4, bh7) | 0, mid = mid + Math.imul(ah4, bl7) | 0, hi = hi + Math.imul(ah4, bh7) | 0, lo = lo + Math.imul(al3, bl8) | 0, mid = mid + Math.imul(al3, bh8) | 0, mid = mid + Math.imul(ah3, bl8) | 0, hi = hi + Math.imul(ah3, bh8) | 0, lo = lo + Math.imul(al2, bl9) | 0, mid = mid + Math.imul(al2, bh9) | 0, mid = mid + Math.imul(ah2, bl9) | 0, hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0, w11 &= 67108863, lo = Math.imul(al9, bl3), mid = Math.imul(al9, bh3), mid = mid + Math.imul(ah9, bl3) | 0, hi = Math.imul(ah9, bh3), lo = lo + Math.imul(al8, bl4) | 0, mid = mid + Math.imul(al8, bh4) | 0, mid = mid + Math.imul(ah8, bl4) | 0, hi = hi + Math.imul(ah8, bh4) | 0, lo = lo + Math.imul(al7, bl5) | 0, mid = mid + Math.imul(al7, bh5) | 0, mid = mid + Math.imul(ah7, bl5) | 0, hi = hi + Math.imul(ah7, bh5) | 0, lo = lo + Math.imul(al6, bl6) | 0, mid = mid + Math.imul(al6, bh6) | 0, mid = mid + Math.imul(ah6, bl6) | 0, hi = hi + Math.imul(ah6, bh6) | 0, lo = lo + Math.imul(al5, bl7) | 0, mid = mid + Math.imul(al5, bh7) | 0, mid = mid + Math.imul(ah5, bl7) | 0, hi = hi + Math.imul(ah5, bh7) | 0, lo = lo + Math.imul(al4, bl8) | 0, mid = mid + Math.imul(al4, bh8) | 0, mid = mid + Math.imul(ah4, bl8) | 0, hi = hi + Math.imul(ah4, bh8) | 0, lo = lo + Math.imul(al3, bl9) | 0, mid = mid + Math.imul(al3, bh9) | 0, mid = mid + Math.imul(ah3, bl9) | 0, hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0, w12 &= 67108863, lo = Math.imul(al9, bl4), mid = Math.imul(al9, bh4), mid = mid + Math.imul(ah9, bl4) | 0, hi = Math.imul(ah9, bh4), lo = lo + Math.imul(al8, bl5) | 0, mid = mid + Math.imul(al8, bh5) | 0, mid = mid + Math.imul(ah8, bl5) | 0, hi = hi + Math.imul(ah8, bh5) | 0, lo = lo + Math.imul(al7, bl6) | 0, mid = mid + Math.imul(al7, bh6) | 0, mid = mid + Math.imul(ah7, bl6) | 0, hi = hi + Math.imul(ah7, bh6) | 0, lo = lo + Math.imul(al6, bl7) | 0, mid = mid + Math.imul(al6, bh7) | 0, mid = mid + Math.imul(ah6, bl7) | 0, hi = hi + Math.imul(ah6, bh7) | 0, lo = lo + Math.imul(al5, bl8) | 0, mid = mid + Math.imul(al5, bh8) | 0, mid = mid + Math.imul(ah5, bl8) | 0, hi = hi + Math.imul(ah5, bh8) | 0, lo = lo + Math.imul(al4, bl9) | 0, mid = mid + Math.imul(al4, bh9) | 0, mid = mid + Math.imul(ah4, bl9) | 0, hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0, w13 &= 67108863, lo = Math.imul(al9, bl5), mid = Math.imul(al9, bh5), mid = mid + Math.imul(ah9, bl5) | 0, hi = Math.imul(ah9, bh5), lo = lo + Math.imul(al8, bl6) | 0, mid = mid + Math.imul(al8, bh6) | 0, mid = mid + Math.imul(ah8, bl6) | 0, hi = hi + Math.imul(ah8, bh6) | 0, lo = lo + Math.imul(al7, bl7) | 0, mid = mid + Math.imul(al7, bh7) | 0, mid = mid + Math.imul(ah7, bl7) | 0, hi = hi + Math.imul(ah7, bh7) | 0, lo = lo + Math.imul(al6, bl8) | 0, mid = mid + Math.imul(al6, bh8) | 0, mid = mid + Math.imul(ah6, bl8) | 0, hi = hi + Math.imul(ah6, bh8) | 0, lo = lo + Math.imul(al5, bl9) | 0, mid = mid + Math.imul(al5, bh9) | 0, mid = mid + Math.imul(ah5, bl9) | 0, hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0, w14 &= 67108863, lo = Math.imul(al9, bl6), mid = Math.imul(al9, bh6), mid = mid + Math.imul(ah9, bl6) | 0, hi = Math.imul(ah9, bh6), lo = lo + Math.imul(al8, bl7) | 0, mid = mid + Math.imul(al8, bh7) | 0, mid = mid + Math.imul(ah8, bl7) | 0, hi = hi + Math.imul(ah8, bh7) | 0, lo = lo + Math.imul(al7, bl8) | 0, mid = mid + Math.imul(al7, bh8) | 0, mid = mid + Math.imul(ah7, bl8) | 0, hi = hi + Math.imul(ah7, bh8) | 0, lo = lo + Math.imul(al6, bl9) | 0, mid = mid + Math.imul(al6, bh9) | 0, mid = mid + Math.imul(ah6, bl9) | 0, hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0, w15 &= 67108863, lo = Math.imul(al9, bl7), mid = Math.imul(al9, bh7), mid = mid + Math.imul(ah9, bl7) | 0, hi = Math.imul(ah9, bh7), lo = lo + Math.imul(al8, bl8) | 0, mid = mid + Math.imul(al8, bh8) | 0, mid = mid + Math.imul(ah8, bl8) | 0, hi = hi + Math.imul(ah8, bh8) | 0, lo = lo + Math.imul(al7, bl9) | 0, mid = mid + Math.imul(al7, bh9) | 0, mid = mid + Math.imul(ah7, bl9) | 0, hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0, w16 &= 67108863, lo = Math.imul(al9, bl8), mid = Math.imul(al9, bh8), mid = mid + Math.imul(ah9, bl8) | 0, hi = Math.imul(ah9, bh8), lo = lo + Math.imul(al8, bl9) | 0, mid = mid + Math.imul(al8, bh9) | 0, mid = mid + Math.imul(ah8, bl9) | 0, hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0, w17 &= 67108863, lo = Math.imul(al9, bl9), mid = Math.imul(al9, bh9), mid = mid + Math.imul(ah9, bl9) | 0, hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        if (c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0, w18 &= 67108863, o[0] = w0, o[1] = w1, o[2] = w2, o[3] = w3, o[4] = w4, o[5] = w5, o[6] = w6, o[7] = w7, o[8] = w8, o[9] = w9, o[10] = w10, o[11] = w11, o[12] = w12, o[13] = w13, o[14] = w14, o[15] = w15, o[16] = w16, o[17] = w17, o[18] = w18, c !== 0)
          o[19] = c, out.length++;
        return out;
      };
      if (!Math.imul)
        comb10MulTo = smallMulTo;
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative, out.length = self2.length + num.length;
        var carry = 0, hncarry = 0;
        for (var k = 0;k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863, maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
            var i2 = k - j, a = self2.words[i2] | 0, b = num.words[j] | 0, r = a * b, lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0, lo = lo + rword | 0, rword = lo & 67108863, ncarry = ncarry + (lo >>> 26) | 0, hncarry += ncarry >>> 26, ncarry &= 67108863;
          }
          out.words[k] = rword, carry = ncarry, ncarry = hncarry;
        }
        if (carry !== 0)
          out.words[k] = carry;
        else
          out.length--;
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res, len2 = this.length + num.length;
        if (this.length === 10 && num.length === 10)
          res = comb10MulTo(this, num, out);
        else if (len2 < 63)
          res = smallMulTo(this, num, out);
        else if (len2 < 1024)
          res = bigMulTo(this, num, out);
        else
          res = jumboMulTo(this, num, out);
        return res;
      };
      function FFTM(x, y) {
        this.x = x, this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t2 = new Array(N), l = BN.prototype._countBits(N) - 1;
        for (var i2 = 0;i2 < N; i2++)
          t2[i2] = this.revBin(i2, l, N);
        return t2;
      }, FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i2 = 0;i2 < l; i2++)
          rb |= (x & 1) << l - i2 - 1, x >>= 1;
        return rb;
      }, FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i2 = 0;i2 < N; i2++)
          rtws[i2] = rws[rbt[i2]], itws[i2] = iws[rbt[i2]];
      }, FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1;s < N; s <<= 1) {
          var l = s << 1, rtwdf = Math.cos(2 * Math.PI / l), itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0;p < N; p += l) {
            var rtwdf_ = rtwdf, itwdf_ = itwdf;
            for (var j = 0;j < s; j++) {
              var re = rtws[p + j], ie = itws[p + j], ro = rtws[p + j + s], io = itws[p + j + s], rx = rtwdf_ * ro - itwdf_ * io;
              if (io = rtwdf_ * io + itwdf_ * ro, ro = rx, rtws[p + j] = re + ro, itws[p + j] = ie + io, rtws[p + j + s] = re - ro, itws[p + j + s] = ie - io, j !== l)
                rx = rtwdf * rtwdf_ - itwdf * itwdf_, itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_, rtwdf_ = rx;
            }
          }
        }
      }, FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1, odd = N & 1, i2 = 0;
        for (N = N / 2 | 0;N; N = N >>> 1)
          i2++;
        return 1 << i2 + 1 + odd;
      }, FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i2 = 0;i2 < N / 2; i2++) {
          var t2 = rws[i2];
          rws[i2] = rws[N - i2 - 1], rws[N - i2 - 1] = t2, t2 = iws[i2], iws[i2] = -iws[N - i2 - 1], iws[N - i2 - 1] = -t2;
        }
      }, FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i2 = 0;i2 < N / 2; i2++) {
          var w = Math.round(ws[2 * i2 + 1] / N) * 8192 + Math.round(ws[2 * i2] / N) + carry;
          if (ws[i2] = w & 67108863, w < 67108864)
            carry = 0;
          else
            carry = w / 67108864 | 0;
        }
        return ws;
      }, FFTM.prototype.convert13b = function convert13b(ws, len2, rws, N) {
        var carry = 0;
        for (var i2 = 0;i2 < len2; i2++)
          carry = carry + (ws[i2] | 0), rws[2 * i2] = carry & 8191, carry = carry >>> 13, rws[2 * i2 + 1] = carry & 8191, carry = carry >>> 13;
        for (i2 = 2 * len2;i2 < N; ++i2)
          rws[i2] = 0;
        assert(carry === 0), assert((carry & -8192) === 0);
      }, FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i2 = 0;i2 < N; i2++)
          ph[i2] = 0;
        return ph;
      }, FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length), rbt = this.makeRBT(N), _ = this.stub(N), rws = new Array(N), rwst = new Array(N), iwst = new Array(N), nrws = new Array(N), nrwst = new Array(N), niwst = new Array(N), rmws = out.words;
        rmws.length = N, this.convert13b(x.words, x.length, rws, N), this.convert13b(y.words, y.length, nrws, N), this.transform(rws, _, rwst, iwst, N, rbt), this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i2 = 0;i2 < N; i2++) {
          var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
          iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2], rwst[i2] = rx;
        }
        return this.conjugate(rwst, iwst, N), this.transform(rwst, iwst, rmws, _, N, rbt), this.conjugate(rmws, _, N), this.normalize13b(rmws, N), out.negative = x.negative ^ y.negative, out.length = x.length + y.length, out._strip();
      }, BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        return out.words = new Array(this.length + num.length), this.mulTo(num, out);
      }, BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        return out.words = new Array(this.length + num.length), jumboMulTo(this, num, out);
      }, BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      }, BN.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(typeof num === "number"), assert(num < 67108864);
        var carry = 0;
        for (var i2 = 0;i2 < this.length; i2++) {
          var w = (this.words[i2] | 0) * num, lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26, carry += w / 67108864 | 0, carry += lo >>> 26, this.words[i2] = lo & 67108863;
        }
        if (carry !== 0)
          this.words[i2] = carry, this.length++;
        return this.length = num === 0 ? 1 : this.length, isNegNum ? this.ineg() : this;
      }, BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      }, BN.prototype.sqr = function sqr() {
        return this.mul(this);
      }, BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      }, BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i2 = 0;i2 < w.length; i2++, res = res.sqr())
          if (w[i2] !== 0)
            break;
        if (++i2 < w.length)
          for (var q = res.sqr();i2 < w.length; i2++, q = q.sqr()) {
            if (w[i2] === 0)
              continue;
            res = res.mul(q);
          }
        return res;
      }, BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26, s = (bits - r) / 26, carryMask = 67108863 >>> 26 - r << 26 - r, i2;
        if (r !== 0) {
          var carry = 0;
          for (i2 = 0;i2 < this.length; i2++) {
            var newCarry = this.words[i2] & carryMask, c = (this.words[i2] | 0) - newCarry << r;
            this.words[i2] = c | carry, carry = newCarry >>> 26 - r;
          }
          if (carry)
            this.words[i2] = carry, this.length++;
        }
        if (s !== 0) {
          for (i2 = this.length - 1;i2 >= 0; i2--)
            this.words[i2 + s] = this.words[i2];
          for (i2 = 0;i2 < s; i2++)
            this.words[i2] = 0;
          this.length += s;
        }
        return this._strip();
      }, BN.prototype.ishln = function ishln(bits) {
        return assert(this.negative === 0), this.iushln(bits);
      }, BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint)
          h = (hint - hint % 26) / 26;
        else
          h = 0;
        var r = bits % 26, s = Math.min((bits - r) / 26, this.length), mask = 67108863 ^ 67108863 >>> r << r, maskedWords = extended;
        if (h -= s, h = Math.max(0, h), maskedWords) {
          for (var i2 = 0;i2 < s; i2++)
            maskedWords.words[i2] = this.words[i2];
          maskedWords.length = s;
        }
        if (s === 0)
          ;
        else if (this.length > s) {
          this.length -= s;
          for (i2 = 0;i2 < this.length; i2++)
            this.words[i2] = this.words[i2 + s];
        } else
          this.words[0] = 0, this.length = 1;
        var carry = 0;
        for (i2 = this.length - 1;i2 >= 0 && (carry !== 0 || i2 >= h); i2--) {
          var word = this.words[i2] | 0;
          this.words[i2] = carry << 26 - r | word >>> r, carry = word & mask;
        }
        if (maskedWords && carry !== 0)
          maskedWords.words[maskedWords.length++] = carry;
        if (this.length === 0)
          this.words[0] = 0, this.length = 1;
        return this._strip();
      }, BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        return assert(this.negative === 0), this.iushrn(bits, hint, extended);
      }, BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      }, BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      }, BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      }, BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      }, BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26, s = (bit - r) / 26, q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      }, BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26, s = (bits - r) / 26;
        if (assert(this.negative === 0, "imaskn works only with positive numbers"), this.length <= s)
          return this;
        if (r !== 0)
          s++;
        if (this.length = Math.min(s, this.length), r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      }, BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      }, BN.prototype.iaddn = function iaddn(num) {
        if (assert(typeof num === "number"), assert(num < 67108864), num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num)
            return this.words[0] = num - (this.words[0] | 0), this.negative = 0, this;
          return this.negative = 0, this.isubn(num), this.negative = 1, this;
        }
        return this._iaddn(num);
      }, BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i2 = 0;i2 < this.length && this.words[i2] >= 67108864; i2++)
          if (this.words[i2] -= 67108864, i2 === this.length - 1)
            this.words[i2 + 1] = 1;
          else
            this.words[i2 + 1]++;
        return this.length = Math.max(this.length, i2 + 1), this;
      }, BN.prototype.isubn = function isubn(num) {
        if (assert(typeof num === "number"), assert(num < 67108864), num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(num), this.negative = 1, this;
        if (this.words[0] -= num, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var i2 = 0;i2 < this.length && this.words[i2] < 0; i2++)
            this.words[i2] += 67108864, this.words[i2 + 1] -= 1;
        return this._strip();
      }, BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      }, BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      }, BN.prototype.iabs = function iabs() {
        return this.negative = 0, this;
      }, BN.prototype.abs = function abs() {
        return this.clone().iabs();
      }, BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len2 = num.length + shift, i2;
        this._expand(len2);
        var w, carry = 0;
        for (i2 = 0;i2 < num.length; i2++) {
          w = (this.words[i2 + shift] | 0) + carry;
          var right = (num.words[i2] | 0) * mul;
          w -= right & 67108863, carry = (w >> 26) - (right / 67108864 | 0), this.words[i2 + shift] = w & 67108863;
        }
        for (;i2 < this.length - shift; i2++)
          w = (this.words[i2 + shift] | 0) + carry, carry = w >> 26, this.words[i2 + shift] = w & 67108863;
        if (carry === 0)
          return this._strip();
        assert(carry === -1), carry = 0;
        for (i2 = 0;i2 < this.length; i2++)
          w = -(this.words[i2] | 0) + carry, carry = w >> 26, this.words[i2] = w & 67108863;
        return this.negative = 1, this._strip();
      }, BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length, a = this.clone(), b = num, bhi = b.words[b.length - 1] | 0, bhiBits = this._countBits(bhi);
        if (shift = 26 - bhiBits, shift !== 0)
          b = b.ushln(shift), a.iushln(shift), bhi = b.words[b.length - 1] | 0;
        var m = a.length - b.length, q;
        if (mode !== "mod") {
          q = new BN(null), q.length = m + 1, q.words = new Array(q.length);
          for (var i2 = 0;i2 < q.length; i2++)
            q.words[i2] = 0;
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          if (a = diff, q)
            q.words[m] = 1;
        }
        for (var j = m - 1;j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863), a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0)
            if (qj--, a.negative = 0, a._ishlnsubmul(b, 1, j), !a.isZero())
              a.negative ^= 1;
          if (q)
            q.words[j] = qj;
        }
        if (q)
          q._strip();
        if (a._strip(), mode !== "div" && shift !== 0)
          a.iushrn(shift);
        return { div: q || null, mod: a };
      }, BN.prototype.divmod = function divmod(num, mode, positive) {
        if (assert(!num.isZero()), this.isZero())
          return { div: new BN(0), mod: new BN(0) };
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          if (res = this.neg().divmod(num, mode), mode !== "mod")
            div = res.div.neg();
          if (mode !== "div") {
            if (mod = res.mod.neg(), positive && mod.negative !== 0)
              mod.iadd(num);
          }
          return { div, mod };
        }
        if (this.negative === 0 && num.negative !== 0) {
          if (res = this.divmod(num.neg(), mode), mode !== "mod")
            div = res.div.neg();
          return { div, mod: res.mod };
        }
        if ((this.negative & num.negative) !== 0) {
          if (res = this.neg().divmod(num.neg(), mode), mode !== "div") {
            if (mod = res.mod.neg(), positive && mod.negative !== 0)
              mod.isub(num);
          }
          return { div: res.div, mod };
        }
        if (num.length > this.length || this.cmp(num) < 0)
          return { div: new BN(0), mod: this };
        if (num.length === 1) {
          if (mode === "div")
            return { div: this.divn(num.words[0]), mod: null };
          if (mode === "mod")
            return { div: null, mod: new BN(this.modrn(num.words[0])) };
          return { div: this.divn(num.words[0]), mod: new BN(this.modrn(num.words[0])) };
        }
        return this._wordDiv(num, mode);
      }, BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      }, BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      }, BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      }, BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod, half = num.ushrn(1), r2 = num.andln(1), cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      }, BN.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(num <= 67108863);
        var p = 67108864 % num, acc = 0;
        for (var i2 = this.length - 1;i2 >= 0; i2--)
          acc = (p * acc + (this.words[i2] | 0)) % num;
        return isNegNum ? -acc : acc;
      }, BN.prototype.modn = function modn(num) {
        return this.modrn(num);
      }, BN.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(num <= 67108863);
        var carry = 0;
        for (var i2 = this.length - 1;i2 >= 0; i2--) {
          var w = (this.words[i2] | 0) + carry * 67108864;
          this.words[i2] = w / num | 0, carry = w % num;
        }
        return this._strip(), isNegNum ? this.ineg() : this;
      }, BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      }, BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0), assert(!p.isZero());
        var x = this, y = p.clone();
        if (x.negative !== 0)
          x = x.umod(p);
        else
          x = x.clone();
        var A = new BN(1), B = new BN(0), C = new BN(0), D = new BN(1), g = 0;
        while (x.isEven() && y.isEven())
          x.iushrn(1), y.iushrn(1), ++g;
        var yp = y.clone(), xp = x.clone();
        while (!x.isZero()) {
          for (var i2 = 0, im = 1;(x.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            x.iushrn(i2);
            while (i2-- > 0) {
              if (A.isOdd() || B.isOdd())
                A.iadd(yp), B.isub(xp);
              A.iushrn(1), B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1;(y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd())
                C.iadd(yp), D.isub(xp);
              C.iushrn(1), D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0)
            x.isub(y), A.isub(C), B.isub(D);
          else
            y.isub(x), C.isub(A), D.isub(B);
        }
        return { a: C, b: D, gcd: y.iushln(g) };
      }, BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0), assert(!p.isZero());
        var a = this, b = p.clone();
        if (a.negative !== 0)
          a = a.umod(p);
        else
          a = a.clone();
        var x1 = new BN(1), x2 = new BN(0), delta3 = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i2 = 0, im = 1;(a.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            a.iushrn(i2);
            while (i2-- > 0) {
              if (x1.isOdd())
                x1.iadd(delta3);
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1;(b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd())
                x2.iadd(delta3);
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0)
            a.isub(b), x1.isub(x2);
          else
            b.isub(a), x2.isub(x1);
        }
        var res;
        if (a.cmpn(1) === 0)
          res = x1;
        else
          res = x2;
        if (res.cmpn(0) < 0)
          res.iadd(p);
        return res;
      }, BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone(), b = num.clone();
        a.negative = 0, b.negative = 0;
        for (var shift = 0;a.isEven() && b.isEven(); shift++)
          a.iushrn(1), b.iushrn(1);
        do {
          while (a.isEven())
            a.iushrn(1);
          while (b.isEven())
            b.iushrn(1);
          var r = a.cmp(b);
          if (r < 0) {
            var t2 = a;
            a = b, b = t2;
          } else if (r === 0 || b.cmpn(1) === 0)
            break;
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      }, BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      }, BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      }, BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      }, BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      }, BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26, s = (bit - r) / 26, q = 1 << r;
        if (this.length <= s)
          return this._expand(s + 1), this.words[s] |= q, this;
        var carry = q;
        for (var i2 = s;carry !== 0 && i2 < this.length; i2++) {
          var w = this.words[i2] | 0;
          w += carry, carry = w >>> 26, w &= 67108863, this.words[i2] = w;
        }
        if (carry !== 0)
          this.words[i2] = carry, this.length++;
        return this;
      }, BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      }, BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1)
          res = 1;
        else {
          if (negative)
            num = -num;
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      }, BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      }, BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i2 = this.length - 1;i2 >= 0; i2--) {
          var a = this.words[i2] | 0, b = num.words[i2] | 0;
          if (a === b)
            continue;
          if (a < b)
            res = -1;
          else if (a > b)
            res = 1;
          break;
        }
        return res;
      }, BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      }, BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      }, BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      }, BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      }, BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      }, BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      }, BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      }, BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      }, BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      }, BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      }, BN.red = function red(num) {
        return new Red(num);
      }, BN.prototype.toRed = function toRed(ctx) {
        return assert(!this.red, "Already a number in reduction context"), assert(this.negative === 0, "red works only with positives"), ctx.convertTo(this)._forceRed(ctx);
      }, BN.prototype.fromRed = function fromRed() {
        return assert(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, BN.prototype._forceRed = function _forceRed(ctx) {
        return this.red = ctx, this;
      }, BN.prototype.forceRed = function forceRed(ctx) {
        return assert(!this.red, "Already a number in reduction context"), this._forceRed(ctx);
      }, BN.prototype.redAdd = function redAdd(num) {
        return assert(this.red, "redAdd works only with red numbers"), this.red.add(this, num);
      }, BN.prototype.redIAdd = function redIAdd(num) {
        return assert(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, num);
      }, BN.prototype.redSub = function redSub(num) {
        return assert(this.red, "redSub works only with red numbers"), this.red.sub(this, num);
      }, BN.prototype.redISub = function redISub(num) {
        return assert(this.red, "redISub works only with red numbers"), this.red.isub(this, num);
      }, BN.prototype.redShl = function redShl(num) {
        return assert(this.red, "redShl works only with red numbers"), this.red.shl(this, num);
      }, BN.prototype.redMul = function redMul(num) {
        return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.mul(this, num);
      }, BN.prototype.redIMul = function redIMul(num) {
        return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.imul(this, num);
      }, BN.prototype.redSqr = function redSqr() {
        return assert(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, BN.prototype.redISqr = function redISqr() {
        return assert(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, BN.prototype.redSqrt = function redSqrt() {
        return assert(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, BN.prototype.redInvm = function redInvm() {
        return assert(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, BN.prototype.redNeg = function redNeg() {
        return assert(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, BN.prototype.redPow = function redPow(num) {
        return assert(this.red && !num.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, num);
      };
      var primes = { k256: null, p224: null, p192: null, p25519: null };
      function MPrime(name, p) {
        this.name = name, this.p = new BN(p, 16), this.n = this.p.bitLength(), this.k = new BN(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        return tmp.words = new Array(Math.ceil(this.n / 13)), tmp;
      }, MPrime.prototype.ireduce = function ireduce(num) {
        var r = num, rlen;
        do
          this.split(r, this.tmp), r = this.imulK(r), r = r.iadd(this.tmp), rlen = r.bitLength();
        while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0)
          r.words[0] = 0, r.length = 1;
        else if (cmp > 0)
          r.isub(this.p);
        else if (r.strip !== undefined)
          r.strip();
        else
          r._strip();
        return r;
      }, MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      }, MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      inherits2(K256, MPrime), K256.prototype.split = function split(input, output) {
        var mask = 4194303, outLen = Math.min(input.length, 9);
        for (var i2 = 0;i2 < outLen; i2++)
          output.words[i2] = input.words[i2];
        if (output.length = outLen, input.length <= 9) {
          input.words[0] = 0, input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i2 = 10;i2 < input.length; i2++) {
          var next = input.words[i2] | 0;
          input.words[i2 - 10] = (next & mask) << 4 | prev >>> 22, prev = next;
        }
        if (prev >>>= 22, input.words[i2 - 10] = prev, prev === 0 && input.length > 10)
          input.length -= 10;
        else
          input.length -= 9;
      }, K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0, num.words[num.length + 1] = 0, num.length += 2;
        var lo = 0;
        for (var i2 = 0;i2 < num.length; i2++) {
          var w = num.words[i2] | 0;
          lo += w * 977, num.words[i2] = lo & 67108863, lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          if (num.length--, num.words[num.length - 1] === 0)
            num.length--;
        }
        return num;
      };
      function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      inherits2(P25519, MPrime), P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i2 = 0;i2 < num.length; i2++) {
          var hi = (num.words[i2] | 0) * 19 + carry, lo = hi & 67108863;
          hi >>>= 26, num.words[i2] = lo, carry = hi;
        }
        if (carry !== 0)
          num.words[num.length++] = carry;
        return num;
      }, BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime;
        if (name === "k256")
          prime = new K256;
        else if (name === "p224")
          prime = new P224;
        else if (name === "p192")
          prime = new P192;
        else if (name === "p25519")
          prime = new P25519;
        else
          throw new Error("Unknown prime " + name);
        return primes[name] = prime, prime;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p, this.prime = prime;
        } else
          assert(m.gtn(1), "modulus must be greater than 1"), this.m = m, this.prime = null;
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives"), assert(a.red, "red works only with red numbers");
      }, Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives"), assert(a.red && a.red === b.red, "red works only with red numbers");
      }, Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return move(a, a.umod(this.m)._forceRed(this)), a;
      }, Red.prototype.neg = function neg(a) {
        if (a.isZero())
          return a.clone();
        return this.m.sub(a)._forceRed(this);
      }, Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0)
          res.isub(this.m);
        return res._forceRed(this);
      }, Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0)
          res.isub(this.m);
        return res;
      }, Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0)
          res.iadd(this.m);
        return res._forceRed(this);
      }, Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0)
          res.iadd(this.m);
        return res;
      }, Red.prototype.shl = function shl(a, num) {
        return this._verify1(a), this.imod(a.ushln(num));
      }, Red.prototype.imul = function imul(a, b) {
        return this._verify2(a, b), this.imod(a.imul(b));
      }, Red.prototype.mul = function mul(a, b) {
        return this._verify2(a, b), this.imod(a.mul(b));
      }, Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      }, Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      }, Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        if (assert(mod3 % 2 === 1), mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1), s = 0;
        while (!q.isZero() && q.andln(1) === 0)
          s++, q.iushrn(1);
        assert(!q.isZero());
        var one = new BN(1).toRed(this), nOne = one.redNeg(), lpow = this.m.subn(1).iushrn(1), z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0)
          z.redIAdd(nOne);
        var c = this.pow(z, q), r = this.pow(a, q.addn(1).iushrn(1)), t2 = this.pow(a, q), m = s;
        while (t2.cmp(one) !== 0) {
          var tmp = t2;
          for (var i2 = 0;tmp.cmp(one) !== 0; i2++)
            tmp = tmp.redSqr();
          assert(i2 < m);
          var b = this.pow(c, new BN(1).iushln(m - i2 - 1));
          r = r.redMul(b), c = b.redSqr(), t2 = t2.redMul(c), m = i2;
        }
        return r;
      }, Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0)
          return inv.negative = 0, this.imod(inv).redNeg();
        else
          return this.imod(inv);
      }, Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4, wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this), wnd[1] = a;
        for (var i2 = 2;i2 < wnd.length; i2++)
          wnd[i2] = this.mul(wnd[i2 - 1], a);
        var res = wnd[0], current = 0, currentLen = 0, start = num.bitLength() % 26;
        if (start === 0)
          start = 26;
        for (i2 = num.length - 1;i2 >= 0; i2--) {
          var word = num.words[i2];
          for (var j = start - 1;j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0])
              res = this.sqr(res);
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            if (current <<= 1, current |= bit, currentLen++, currentLen !== windowSize && (i2 !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]), currentLen = 0, current = 0;
          }
          start = 26;
        }
        return res;
      }, Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      }, Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        return res.red = null, res;
      }, BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        if (Red.call(this, m), this.shift = this.m.bitLength(), this.shift % 26 !== 0)
          this.shift += 26 - this.shift % 26;
        this.r = new BN(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red), Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      }, Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        return r.red = null, r;
      }, Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero())
          return a.words[0] = 0, a.length = 1, a;
        var t2 = a.imul(b), c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t2.isub(c).iushrn(this.shift), res = u;
        if (u.cmp(this.m) >= 0)
          res = u.isub(this.m);
        else if (u.cmpn(0) < 0)
          res = u.iadd(this.m);
        return res._forceRed(this);
      }, Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t2 = a.mul(b), c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t2.isub(c).iushrn(this.shift), res = u;
        if (u.cmp(this.m) >= 0)
          res = u.isub(this.m);
        else if (u.cmpn(0) < 0)
          res = u.iadd(this.m);
        return res._forceRed(this);
      }, Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  });
  require_browserify_rsa = __commonJS2((exports, module) => {
    var BN = require_bn5(), randomBytes = require_randombytes(), Buffer22 = require_safe_buffer().Buffer;
    function getr(priv) {
      var len2 = priv.modulus.byteLength(), r;
      do
        r = new BN(randomBytes(len2));
      while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2));
      return r;
    }
    function blind(priv) {
      var r = getr(priv), blinder = r.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed();
      return { blinder, unblinder: r.invm(priv.modulus) };
    }
    function crt(msg, priv) {
      var blinds = blind(priv), len2 = priv.modulus.byteLength(), blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus), c1 = blinded.toRed(BN.mont(priv.prime1)), c2 = blinded.toRed(BN.mont(priv.prime2)), qinv = priv.coefficient, p = priv.prime1, q = priv.prime2, m1 = c1.redPow(priv.exponent1).fromRed(), m2 = c2.redPow(priv.exponent2).fromRed(), h = m1.isub(m2).imul(qinv).umod(p).imul(q);
      return m2.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer22, "be", len2);
    }
    crt.getr = getr;
    module.exports = crt;
  });
  require_publicEncrypt = __commonJS2((exports, module) => {
    var parseKeys = require_parse_asn1(), randomBytes = require_randombytes(), createHash = require_create_hash(), mgf = require_mgf(), xor = require_xor(), BN = require_bn4(), withPublic = require_withPublic(), crt = require_browserify_rsa(), Buffer22 = require_safe_buffer().Buffer;
    module.exports = function publicEncrypt(publicKey, msg, reverse) {
      var padding;
      if (publicKey.padding)
        padding = publicKey.padding;
      else if (reverse)
        padding = 1;
      else
        padding = 4;
      var key = parseKeys(publicKey), paddedMsg;
      if (padding === 4)
        paddedMsg = oaep(key, msg);
      else if (padding === 1)
        paddedMsg = pkcs1(key, msg, reverse);
      else if (padding === 3) {
        if (paddedMsg = new BN(msg), paddedMsg.cmp(key.modulus) >= 0)
          throw new Error("data too long for modulus");
      } else
        throw new Error("unknown padding");
      if (reverse)
        return crt(paddedMsg, key);
      else
        return withPublic(paddedMsg, key);
    };
    function oaep(key, msg) {
      var k = key.modulus.byteLength(), mLen = msg.length, iHash = createHash("sha1").update(Buffer22.alloc(0)).digest(), hLen = iHash.length, hLen2 = 2 * hLen;
      if (mLen > k - hLen2 - 2)
        throw new Error("message too long");
      var ps = Buffer22.alloc(k - mLen - hLen2 - 2), dblen = k - hLen - 1, seed = randomBytes(hLen), maskedDb = xor(Buffer22.concat([iHash, ps, Buffer22.alloc(1, 1), msg], dblen), mgf(seed, dblen)), maskedSeed = xor(seed, mgf(maskedDb, hLen));
      return new BN(Buffer22.concat([Buffer22.alloc(1), maskedSeed, maskedDb], k));
    }
    function pkcs1(key, msg, reverse) {
      var mLen = msg.length, k = key.modulus.byteLength();
      if (mLen > k - 11)
        throw new Error("message too long");
      var ps;
      if (reverse)
        ps = Buffer22.alloc(k - mLen - 3, 255);
      else
        ps = nonZero(k - mLen - 3);
      return new BN(Buffer22.concat([Buffer22.from([0, reverse ? 1 : 2]), ps, Buffer22.alloc(1), msg], k));
    }
    function nonZero(len2) {
      var out = Buffer22.allocUnsafe(len2), i2 = 0, cache = randomBytes(len2 * 2), cur = 0, num;
      while (i2 < len2) {
        if (cur === cache.length)
          cache = randomBytes(len2 * 2), cur = 0;
        if (num = cache[cur++], num)
          out[i2++] = num;
      }
      return out;
    }
  });
  require_privateDecrypt = __commonJS2((exports, module) => {
    var parseKeys = require_parse_asn1(), mgf = require_mgf(), xor = require_xor(), BN = require_bn4(), crt = require_browserify_rsa(), createHash = require_create_hash(), withPublic = require_withPublic(), Buffer22 = require_safe_buffer().Buffer;
    module.exports = function privateDecrypt(privateKey, enc, reverse) {
      var padding;
      if (privateKey.padding)
        padding = privateKey.padding;
      else if (reverse)
        padding = 1;
      else
        padding = 4;
      var key = parseKeys(privateKey), k = key.modulus.byteLength();
      if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0)
        throw new Error("decryption error");
      var msg;
      if (reverse)
        msg = withPublic(new BN(enc), key);
      else
        msg = crt(enc, key);
      var zBuffer = Buffer22.alloc(k - msg.length);
      if (msg = Buffer22.concat([zBuffer, msg], k), padding === 4)
        return oaep(key, msg);
      else if (padding === 1)
        return pkcs1(key, msg, reverse);
      else if (padding === 3)
        return msg;
      else
        throw new Error("unknown padding");
    };
    function oaep(key, msg) {
      var k = key.modulus.byteLength(), iHash = createHash("sha1").update(Buffer22.alloc(0)).digest(), hLen = iHash.length;
      if (msg[0] !== 0)
        throw new Error("decryption error");
      var maskedSeed = msg.slice(1, hLen + 1), maskedDb = msg.slice(hLen + 1), seed = xor(maskedSeed, mgf(maskedDb, hLen)), db = xor(maskedDb, mgf(seed, k - hLen - 1));
      if (compare3(iHash, db.slice(0, hLen)))
        throw new Error("decryption error");
      var i2 = hLen;
      while (db[i2] === 0)
        i2++;
      if (db[i2++] !== 1)
        throw new Error("decryption error");
      return db.slice(i2);
    }
    function pkcs1(key, msg, reverse) {
      var p1 = msg.slice(0, 2), i2 = 2, status = 0;
      while (msg[i2++] !== 0)
        if (i2 >= msg.length) {
          status++;
          break;
        }
      var ps = msg.slice(2, i2 - 1);
      if (p1.toString("hex") !== "0002" && !reverse || p1.toString("hex") !== "0001" && reverse)
        status++;
      if (ps.length < 8)
        status++;
      if (status)
        throw new Error("decryption error");
      return msg.slice(i2);
    }
    function compare3(a, b) {
      a = Buffer22.from(a), b = Buffer22.from(b);
      var dif = 0, len2 = a.length;
      if (a.length !== b.length)
        dif++, len2 = Math.min(a.length, b.length);
      var i2 = -1;
      while (++i2 < len2)
        dif += a[i2] ^ b[i2];
      return dif;
    }
  });
  require_browser2 = __commonJS2((exports) => {
    exports.publicEncrypt = require_publicEncrypt();
    exports.privateDecrypt = require_privateDecrypt();
    exports.privateEncrypt = function privateEncrypt(key, buf) {
      return exports.publicEncrypt(key, buf, true);
    };
    exports.publicDecrypt = function publicDecrypt(key, buf) {
      return exports.privateDecrypt(key, buf, true);
    };
  });
  require_public_encrypt = __commonJS2((exports) => {
    var crypto2 = (init_crypto(), __toCommonJS(exports_crypto));
    if (typeof crypto2.publicEncrypt !== "function")
      crypto2 = require_browser2();
    exports.publicEncrypt = crypto2.publicEncrypt;
    exports.privateDecrypt = crypto2.privateDecrypt;
    if (typeof crypto2.privateEncrypt !== "function")
      exports.privateEncrypt = require_browser2().privateEncrypt;
    else
      exports.privateEncrypt = crypto2.privateEncrypt;
    if (typeof crypto2.publicDecrypt !== "function")
      exports.publicDecrypt = require_browser2().publicDecrypt;
    else
      exports.publicDecrypt = crypto2.publicDecrypt;
  });
  require_browser3 = __commonJS2((exports) => {
    var safeBuffer = require_safe_buffer(), randombytes = require_randombytes(), Buffer22 = safeBuffer.Buffer, kBufferMaxLength = safeBuffer.kMaxLength, crypto2 = globalThis.crypto || globalThis.msCrypto, kMaxUint32 = Math.pow(2, 32) - 1;
    function assertOffset(offset, length) {
      if (typeof offset !== "number" || offset !== offset)
        throw new TypeError("offset must be a number");
      if (offset > kMaxUint32 || offset < 0)
        throw new TypeError("offset must be a uint32");
      if (offset > kBufferMaxLength || offset > length)
        throw new RangeError("offset out of range");
    }
    function assertSize2(size, offset, length) {
      if (typeof size !== "number" || size !== size)
        throw new TypeError("size must be a number");
      if (size > kMaxUint32 || size < 0)
        throw new TypeError("size must be a uint32");
      if (size + offset > length || size > kBufferMaxLength)
        throw new RangeError("buffer too small");
    }
    crypto2 && crypto2.getRandomValues, exports.randomFill = randomFill, exports.randomFillSync = randomFillSync;
    function randomFill(buf, offset, size, cb) {
      if (!Buffer22.isBuffer(buf) && !(buf instanceof globalThis.Uint8Array))
        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
      if (typeof offset === "function")
        cb = offset, offset = 0, size = buf.length;
      else if (typeof size === "function")
        cb = size, size = buf.length - offset;
      else if (typeof cb !== "function")
        throw new TypeError('"cb" argument must be a function');
      return assertOffset(offset, buf.length), assertSize2(size, offset, buf.length), actualFill(buf, offset, size, cb);
    }
    function actualFill(buf, offset, size, cb) {
      if (false)
        var ourBuf, uint;
      if (cb) {
        randombytes(size, function(err, bytes2) {
          if (err)
            return cb(err);
          bytes2.copy(buf, offset), cb(null, buf);
        });
        return;
      }
      var bytes = randombytes(size);
      return bytes.copy(buf, offset), buf;
    }
    function randomFillSync(buf, offset, size) {
      if (typeof offset === "undefined")
        offset = 0;
      if (!Buffer22.isBuffer(buf) && !(buf instanceof globalThis.Uint8Array))
        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
      if (assertOffset(offset, buf.length), size === undefined)
        size = buf.length - offset;
      return assertSize2(size, offset, buf.length), actualFill(buf, offset, size);
    }
  });
  require_randomfill = __commonJS2((exports, module) => {
    var crypto2 = (init_crypto(), __toCommonJS(exports_crypto));
    if (typeof crypto2.randomFill === "function" && typeof crypto2.randomFillSync === "function")
      exports.randomFill = crypto2.randomFill, exports.randomFillSync = crypto2.randomFillSync;
    else
      module.exports = require_browser3();
  });
  require_crypto_browserify = __commonJS2((exports) => {
    exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require_randombytes();
    exports.createHash = exports.Hash = require_create_hash();
    exports.createHmac = exports.Hmac = require_create_hmac();
    var algos = require_algorithms(), algoKeys = Object.keys(algos), hashes = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(algoKeys);
    exports.getHashes = function() {
      return hashes;
    };
    var p = require_pbkdf2();
    exports.pbkdf2 = p.pbkdf2;
    exports.pbkdf2Sync = p.pbkdf2Sync;
    var aes = require_browserify_cipher();
    exports.Cipher = aes.Cipher;
    exports.createCipher = aes.createCipher;
    exports.Cipheriv = aes.Cipheriv;
    exports.createCipheriv = aes.createCipheriv;
    exports.Decipher = aes.Decipher;
    exports.createDecipher = aes.createDecipher;
    exports.Decipheriv = aes.Decipheriv;
    exports.createDecipheriv = aes.createDecipheriv;
    exports.getCiphers = aes.getCiphers;
    exports.listCiphers = aes.listCiphers;
    var dh = require_diffie_hellman();
    exports.DiffieHellmanGroup = dh.DiffieHellmanGroup;
    exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup;
    exports.getDiffieHellman = dh.getDiffieHellman;
    exports.createDiffieHellman = dh.createDiffieHellman;
    exports.DiffieHellman = dh.DiffieHellman;
    var sign = require_browserify_sign();
    exports.createSign = sign.createSign;
    exports.Sign = sign.Sign;
    exports.createVerify = sign.createVerify;
    exports.Verify = sign.Verify;
    exports.createECDH = require_create_ecdh();
    var publicEncrypt = require_public_encrypt();
    exports.publicEncrypt = publicEncrypt.publicEncrypt;
    exports.privateEncrypt = publicEncrypt.privateEncrypt;
    exports.publicDecrypt = publicEncrypt.publicDecrypt;
    exports.privateDecrypt = publicEncrypt.privateDecrypt;
    var rf = require_randomfill();
    exports.randomFill = rf.randomFill;
    exports.randomFillSync = rf.randomFillSync;
    exports.createCredentials = function() {
      throw new Error(`sorry, createCredentials is not implemented yet
we accept pull requests
https://github.com/browserify/crypto-browserify`);
    };
    exports.constants = { DH_CHECK_P_NOT_SAFE_PRIME: 2, DH_CHECK_P_NOT_PRIME: 1, DH_UNABLE_TO_CHECK_GENERATOR: 4, DH_NOT_SUITABLE_GENERATOR: 8, NPN_ENABLED: 1, ALPN_ENABLED: 1, RSA_PKCS1_PADDING: 1, RSA_SSLV23_PADDING: 2, RSA_NO_PADDING: 3, RSA_PKCS1_OAEP_PADDING: 4, RSA_X931_PADDING: 5, RSA_PKCS1_PSS_PADDING: 6, POINT_CONVERSION_COMPRESSED: 2, POINT_CONVERSION_UNCOMPRESSED: 4, POINT_CONVERSION_HYBRID: 6 };
  });
  cryptoBrowserify = __toESM2(require_crypto_browserify(), 1);
  prng2 = cryptoBrowserify.prng;
  pseudoRandomBytes2 = cryptoBrowserify.pseudoRandomBytes;
  rng2 = cryptoBrowserify.rng;
  randomBytes2 = cryptoBrowserify.randomBytes;
  Hash22 = cryptoBrowserify.Hash;
  createHash2 = cryptoBrowserify.createHash;
  Hmac2 = cryptoBrowserify.Hmac;
  createHmac2 = cryptoBrowserify.createHmac;
  getHashes2 = cryptoBrowserify.getHashes;
  pbkdf22 = cryptoBrowserify.pbkdf2;
  pbkdf2Sync2 = cryptoBrowserify.pbkdf2Sync;
  Cipher2 = cryptoBrowserify.Cipher;
  createCipher2 = cryptoBrowserify.createCipher;
  Cipheriv2 = cryptoBrowserify.Cipheriv;
  createCipheriv2 = cryptoBrowserify.createCipheriv;
  Decipher2 = cryptoBrowserify.Decipher;
  createDecipher2 = cryptoBrowserify.createDecipher;
  Decipheriv2 = cryptoBrowserify.Decipheriv;
  createDecipheriv2 = cryptoBrowserify.createDecipheriv;
  getCiphers2 = cryptoBrowserify.getCiphers;
  listCiphers2 = cryptoBrowserify.listCiphers;
  DiffieHellmanGroup2 = cryptoBrowserify.DiffieHellmanGroup;
  createDiffieHellmanGroup2 = cryptoBrowserify.createDiffieHellmanGroup;
  getDiffieHellman2 = cryptoBrowserify.getDiffieHellman;
  createDiffieHellman2 = cryptoBrowserify.createDiffieHellman;
  DiffieHellman2 = cryptoBrowserify.DiffieHellman;
  createSign2 = cryptoBrowserify.createSign;
  Sign2 = cryptoBrowserify.Sign;
  createVerify2 = cryptoBrowserify.createVerify;
  Verify2 = cryptoBrowserify.Verify;
  createECDH2 = cryptoBrowserify.createECDH;
  publicEncrypt2 = cryptoBrowserify.publicEncrypt;
  privateEncrypt2 = cryptoBrowserify.privateEncrypt;
  publicDecrypt2 = cryptoBrowserify.publicDecrypt;
  privateDecrypt2 = cryptoBrowserify.privateDecrypt;
  randomFill2 = cryptoBrowserify.randomFill;
  randomFillSync2 = cryptoBrowserify.randomFillSync;
  createCredentials2 = cryptoBrowserify.createCredentials;
  constants2 = cryptoBrowserify.constants;
  hardcoded_curves = ["p192", "p224", "p256", "p384", "p521", "curve25519", "ed25519", "secp256k1", "secp224r1", "prime256v1", "prime192v1", "ed25519", "secp384r1", "secp521r1"];
  webcrypto = crypto;
  crypto_default = crypto;
});

// node_modules/bcryptjs/dist/bcrypt.js
var require_bcrypt = __commonJS((exports, module) => {
  (function(global2, factory) {
    if (typeof define === "function" && define["amd"])
      define([], factory);
    else if (typeof module === "object" && module && module.exports)
      module["exports"] = factory();
    else
      (global2["dcodeIO"] = global2["dcodeIO"] || {})["bcrypt"] = factory();
  })(exports, function() {
    var bcrypt = {};
    var randomFallback = null;
    function random(len2) {
      if (typeof module !== "undefined" && module && module["exports"])
        try {
          return (init_crypto(), __toCommonJS(exports_crypto))["randomBytes"](len2);
        } catch (e) {}
      try {
        var a;
        (self["crypto"] || self["msCrypto"])["getRandomValues"](a = new Uint32Array(len2));
        return Array.prototype.slice.call(a);
      } catch (e) {}
      if (!randomFallback)
        throw Error("Neither WebCryptoAPI nor a crypto module is available. Use bcrypt.setRandomFallback to set an alternative");
      return randomFallback(len2);
    }
    var randomAvailable = false;
    try {
      random(1);
      randomAvailable = true;
    } catch (e) {}
    randomFallback = null;
    bcrypt.setRandomFallback = function(random2) {
      randomFallback = random2;
    };
    bcrypt.genSaltSync = function(rounds, seed_length) {
      rounds = rounds || GENSALT_DEFAULT_LOG2_ROUNDS;
      if (typeof rounds !== "number")
        throw Error("Illegal arguments: " + typeof rounds + ", " + typeof seed_length);
      if (rounds < 4)
        rounds = 4;
      else if (rounds > 31)
        rounds = 31;
      var salt = [];
      salt.push("$2a$");
      if (rounds < 10)
        salt.push("0");
      salt.push(rounds.toString());
      salt.push("$");
      salt.push(base64_encode(random(BCRYPT_SALT_LEN), BCRYPT_SALT_LEN));
      return salt.join("");
    };
    bcrypt.genSalt = function(rounds, seed_length, callback) {
      if (typeof seed_length === "function")
        callback = seed_length, seed_length = undefined;
      if (typeof rounds === "function")
        callback = rounds, rounds = undefined;
      if (typeof rounds === "undefined")
        rounds = GENSALT_DEFAULT_LOG2_ROUNDS;
      else if (typeof rounds !== "number")
        throw Error("illegal arguments: " + typeof rounds);
      function _async(callback2) {
        nextTick(function() {
          try {
            callback2(null, bcrypt.genSaltSync(rounds));
          } catch (err) {
            callback2(err);
          }
        });
      }
      if (callback) {
        if (typeof callback !== "function")
          throw Error("Illegal callback: " + typeof callback);
        _async(callback);
      } else
        return new Promise(function(resolve, reject) {
          _async(function(err, res) {
            if (err) {
              reject(err);
              return;
            }
            resolve(res);
          });
        });
    };
    bcrypt.hashSync = function(s, salt) {
      if (typeof salt === "undefined")
        salt = GENSALT_DEFAULT_LOG2_ROUNDS;
      if (typeof salt === "number")
        salt = bcrypt.genSaltSync(salt);
      if (typeof s !== "string" || typeof salt !== "string")
        throw Error("Illegal arguments: " + typeof s + ", " + typeof salt);
      return _hash(s, salt);
    };
    bcrypt.hash = function(s, salt, callback, progressCallback) {
      function _async(callback2) {
        if (typeof s === "string" && typeof salt === "number")
          bcrypt.genSalt(salt, function(err, salt2) {
            _hash(s, salt2, callback2, progressCallback);
          });
        else if (typeof s === "string" && typeof salt === "string")
          _hash(s, salt, callback2, progressCallback);
        else
          nextTick(callback2.bind(this, Error("Illegal arguments: " + typeof s + ", " + typeof salt)));
      }
      if (callback) {
        if (typeof callback !== "function")
          throw Error("Illegal callback: " + typeof callback);
        _async(callback);
      } else
        return new Promise(function(resolve, reject) {
          _async(function(err, res) {
            if (err) {
              reject(err);
              return;
            }
            resolve(res);
          });
        });
    };
    function safeStringCompare(known, unknown3) {
      var right = 0, wrong = 0;
      for (var i2 = 0, k = known.length;i2 < k; ++i2) {
        if (known.charCodeAt(i2) === unknown3.charCodeAt(i2))
          ++right;
        else
          ++wrong;
      }
      if (right < 0)
        return false;
      return wrong === 0;
    }
    bcrypt.compareSync = function(s, hash3) {
      if (typeof s !== "string" || typeof hash3 !== "string")
        throw Error("Illegal arguments: " + typeof s + ", " + typeof hash3);
      if (hash3.length !== 60)
        return false;
      return safeStringCompare(bcrypt.hashSync(s, hash3.substr(0, hash3.length - 31)), hash3);
    };
    bcrypt.compare = function(s, hash3, callback, progressCallback) {
      function _async(callback2) {
        if (typeof s !== "string" || typeof hash3 !== "string") {
          nextTick(callback2.bind(this, Error("Illegal arguments: " + typeof s + ", " + typeof hash3)));
          return;
        }
        if (hash3.length !== 60) {
          nextTick(callback2.bind(this, null, false));
          return;
        }
        bcrypt.hash(s, hash3.substr(0, 29), function(err, comp) {
          if (err)
            callback2(err);
          else
            callback2(null, safeStringCompare(comp, hash3));
        }, progressCallback);
      }
      if (callback) {
        if (typeof callback !== "function")
          throw Error("Illegal callback: " + typeof callback);
        _async(callback);
      } else
        return new Promise(function(resolve, reject) {
          _async(function(err, res) {
            if (err) {
              reject(err);
              return;
            }
            resolve(res);
          });
        });
    };
    bcrypt.getRounds = function(hash3) {
      if (typeof hash3 !== "string")
        throw Error("Illegal arguments: " + typeof hash3);
      return parseInt(hash3.split("$")[2], 10);
    };
    bcrypt.getSalt = function(hash3) {
      if (typeof hash3 !== "string")
        throw Error("Illegal arguments: " + typeof hash3);
      if (hash3.length !== 60)
        throw Error("Illegal hash length: " + hash3.length + " != 60");
      return hash3.substring(0, 29);
    };
    var nextTick = typeof process !== "undefined" && process && typeof process.nextTick === "function" ? typeof setImmediate === "function" ? setImmediate : process.nextTick : setTimeout;
    function stringToBytes(str) {
      var out = [], i2 = 0;
      utfx.encodeUTF16toUTF8(function() {
        if (i2 >= str.length)
          return null;
        return str.charCodeAt(i2++);
      }, function(b) {
        out.push(b);
      });
      return out;
    }
    var BASE64_CODE = "./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split("");
    var BASE64_INDEX = [
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      0,
      1,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      -1,
      -1,
      -1,
      -1,
      -1
    ];
    var stringFromCharCode = String.fromCharCode;
    function base64_encode(b, len2) {
      var off = 0, rs = [], c1, c2;
      if (len2 <= 0 || len2 > b.length)
        throw Error("Illegal len: " + len2);
      while (off < len2) {
        c1 = b[off++] & 255;
        rs.push(BASE64_CODE[c1 >> 2 & 63]);
        c1 = (c1 & 3) << 4;
        if (off >= len2) {
          rs.push(BASE64_CODE[c1 & 63]);
          break;
        }
        c2 = b[off++] & 255;
        c1 |= c2 >> 4 & 15;
        rs.push(BASE64_CODE[c1 & 63]);
        c1 = (c2 & 15) << 2;
        if (off >= len2) {
          rs.push(BASE64_CODE[c1 & 63]);
          break;
        }
        c2 = b[off++] & 255;
        c1 |= c2 >> 6 & 3;
        rs.push(BASE64_CODE[c1 & 63]);
        rs.push(BASE64_CODE[c2 & 63]);
      }
      return rs.join("");
    }
    function base64_decode(s, len2) {
      var off = 0, slen = s.length, olen = 0, rs = [], c1, c2, c3, c4, o, code2;
      if (len2 <= 0)
        throw Error("Illegal len: " + len2);
      while (off < slen - 1 && olen < len2) {
        code2 = s.charCodeAt(off++);
        c1 = code2 < BASE64_INDEX.length ? BASE64_INDEX[code2] : -1;
        code2 = s.charCodeAt(off++);
        c2 = code2 < BASE64_INDEX.length ? BASE64_INDEX[code2] : -1;
        if (c1 == -1 || c2 == -1)
          break;
        o = c1 << 2 >>> 0;
        o |= (c2 & 48) >> 4;
        rs.push(stringFromCharCode(o));
        if (++olen >= len2 || off >= slen)
          break;
        code2 = s.charCodeAt(off++);
        c3 = code2 < BASE64_INDEX.length ? BASE64_INDEX[code2] : -1;
        if (c3 == -1)
          break;
        o = (c2 & 15) << 4 >>> 0;
        o |= (c3 & 60) >> 2;
        rs.push(stringFromCharCode(o));
        if (++olen >= len2 || off >= slen)
          break;
        code2 = s.charCodeAt(off++);
        c4 = code2 < BASE64_INDEX.length ? BASE64_INDEX[code2] : -1;
        o = (c3 & 3) << 6 >>> 0;
        o |= c4;
        rs.push(stringFromCharCode(o));
        ++olen;
      }
      var res = [];
      for (off = 0;off < olen; off++)
        res.push(rs[off].charCodeAt(0));
      return res;
    }
    var utfx = function() {
      var utfx2 = {};
      utfx2.MAX_CODEPOINT = 1114111;
      utfx2.encodeUTF8 = function(src, dst) {
        var cp = null;
        if (typeof src === "number")
          cp = src, src = function() {
            return null;
          };
        while (cp !== null || (cp = src()) !== null) {
          if (cp < 128)
            dst(cp & 127);
          else if (cp < 2048)
            dst(cp >> 6 & 31 | 192), dst(cp & 63 | 128);
          else if (cp < 65536)
            dst(cp >> 12 & 15 | 224), dst(cp >> 6 & 63 | 128), dst(cp & 63 | 128);
          else
            dst(cp >> 18 & 7 | 240), dst(cp >> 12 & 63 | 128), dst(cp >> 6 & 63 | 128), dst(cp & 63 | 128);
          cp = null;
        }
      };
      utfx2.decodeUTF8 = function(src, dst) {
        var a, b, c, d, fail = function(b2) {
          b2 = b2.slice(0, b2.indexOf(null));
          var err = Error(b2.toString());
          err.name = "TruncatedError";
          err["bytes"] = b2;
          throw err;
        };
        while ((a = src()) !== null) {
          if ((a & 128) === 0)
            dst(a);
          else if ((a & 224) === 192)
            (b = src()) === null && fail([a, b]), dst((a & 31) << 6 | b & 63);
          else if ((a & 240) === 224)
            ((b = src()) === null || (c = src()) === null) && fail([a, b, c]), dst((a & 15) << 12 | (b & 63) << 6 | c & 63);
          else if ((a & 248) === 240)
            ((b = src()) === null || (c = src()) === null || (d = src()) === null) && fail([a, b, c, d]), dst((a & 7) << 18 | (b & 63) << 12 | (c & 63) << 6 | d & 63);
          else
            throw RangeError("Illegal starting byte: " + a);
        }
      };
      utfx2.UTF16toUTF8 = function(src, dst) {
        var c1, c2 = null;
        while (true) {
          if ((c1 = c2 !== null ? c2 : src()) === null)
            break;
          if (c1 >= 55296 && c1 <= 57343) {
            if ((c2 = src()) !== null) {
              if (c2 >= 56320 && c2 <= 57343) {
                dst((c1 - 55296) * 1024 + c2 - 56320 + 65536);
                c2 = null;
                continue;
              }
            }
          }
          dst(c1);
        }
        if (c2 !== null)
          dst(c2);
      };
      utfx2.UTF8toUTF16 = function(src, dst) {
        var cp = null;
        if (typeof src === "number")
          cp = src, src = function() {
            return null;
          };
        while (cp !== null || (cp = src()) !== null) {
          if (cp <= 65535)
            dst(cp);
          else
            cp -= 65536, dst((cp >> 10) + 55296), dst(cp % 1024 + 56320);
          cp = null;
        }
      };
      utfx2.encodeUTF16toUTF8 = function(src, dst) {
        utfx2.UTF16toUTF8(src, function(cp) {
          utfx2.encodeUTF8(cp, dst);
        });
      };
      utfx2.decodeUTF8toUTF16 = function(src, dst) {
        utfx2.decodeUTF8(src, function(cp) {
          utfx2.UTF8toUTF16(cp, dst);
        });
      };
      utfx2.calculateCodePoint = function(cp) {
        return cp < 128 ? 1 : cp < 2048 ? 2 : cp < 65536 ? 3 : 4;
      };
      utfx2.calculateUTF8 = function(src) {
        var cp, l = 0;
        while ((cp = src()) !== null)
          l += utfx2.calculateCodePoint(cp);
        return l;
      };
      utfx2.calculateUTF16asUTF8 = function(src) {
        var n = 0, l = 0;
        utfx2.UTF16toUTF8(src, function(cp) {
          ++n;
          l += utfx2.calculateCodePoint(cp);
        });
        return [n, l];
      };
      return utfx2;
    }();
    Date.now = Date.now || function() {
      return +new Date;
    };
    var BCRYPT_SALT_LEN = 16;
    var GENSALT_DEFAULT_LOG2_ROUNDS = 10;
    var BLOWFISH_NUM_ROUNDS = 16;
    var MAX_EXECUTION_TIME = 100;
    var P_ORIG = [
      608135816,
      2242054355,
      320440878,
      57701188,
      2752067618,
      698298832,
      137296536,
      3964562569,
      1160258022,
      953160567,
      3193202383,
      887688300,
      3232508343,
      3380367581,
      1065670069,
      3041331479,
      2450970073,
      2306472731
    ];
    var S_ORIG = [
      3509652390,
      2564797868,
      805139163,
      3491422135,
      3101798381,
      1780907670,
      3128725573,
      4046225305,
      614570311,
      3012652279,
      134345442,
      2240740374,
      1667834072,
      1901547113,
      2757295779,
      4103290238,
      227898511,
      1921955416,
      1904987480,
      2182433518,
      2069144605,
      3260701109,
      2620446009,
      720527379,
      3318853667,
      677414384,
      3393288472,
      3101374703,
      2390351024,
      1614419982,
      1822297739,
      2954791486,
      3608508353,
      3174124327,
      2024746970,
      1432378464,
      3864339955,
      2857741204,
      1464375394,
      1676153920,
      1439316330,
      715854006,
      3033291828,
      289532110,
      2706671279,
      2087905683,
      3018724369,
      1668267050,
      732546397,
      1947742710,
      3462151702,
      2609353502,
      2950085171,
      1814351708,
      2050118529,
      680887927,
      999245976,
      1800124847,
      3300911131,
      1713906067,
      1641548236,
      4213287313,
      1216130144,
      1575780402,
      4018429277,
      3917837745,
      3693486850,
      3949271944,
      596196993,
      3549867205,
      258830323,
      2213823033,
      772490370,
      2760122372,
      1774776394,
      2652871518,
      566650946,
      4142492826,
      1728879713,
      2882767088,
      1783734482,
      3629395816,
      2517608232,
      2874225571,
      1861159788,
      326777828,
      3124490320,
      2130389656,
      2716951837,
      967770486,
      1724537150,
      2185432712,
      2364442137,
      1164943284,
      2105845187,
      998989502,
      3765401048,
      2244026483,
      1075463327,
      1455516326,
      1322494562,
      910128902,
      469688178,
      1117454909,
      936433444,
      3490320968,
      3675253459,
      1240580251,
      122909385,
      2157517691,
      634681816,
      4142456567,
      3825094682,
      3061402683,
      2540495037,
      79693498,
      3249098678,
      1084186820,
      1583128258,
      426386531,
      1761308591,
      1047286709,
      322548459,
      995290223,
      1845252383,
      2603652396,
      3431023940,
      2942221577,
      3202600964,
      3727903485,
      1712269319,
      422464435,
      3234572375,
      1170764815,
      3523960633,
      3117677531,
      1434042557,
      442511882,
      3600875718,
      1076654713,
      1738483198,
      4213154764,
      2393238008,
      3677496056,
      1014306527,
      4251020053,
      793779912,
      2902807211,
      842905082,
      4246964064,
      1395751752,
      1040244610,
      2656851899,
      3396308128,
      445077038,
      3742853595,
      3577915638,
      679411651,
      2892444358,
      2354009459,
      1767581616,
      3150600392,
      3791627101,
      3102740896,
      284835224,
      4246832056,
      1258075500,
      768725851,
      2589189241,
      3069724005,
      3532540348,
      1274779536,
      3789419226,
      2764799539,
      1660621633,
      3471099624,
      4011903706,
      913787905,
      3497959166,
      737222580,
      2514213453,
      2928710040,
      3937242737,
      1804850592,
      3499020752,
      2949064160,
      2386320175,
      2390070455,
      2415321851,
      4061277028,
      2290661394,
      2416832540,
      1336762016,
      1754252060,
      3520065937,
      3014181293,
      791618072,
      3188594551,
      3933548030,
      2332172193,
      3852520463,
      3043980520,
      413987798,
      3465142937,
      3030929376,
      4245938359,
      2093235073,
      3534596313,
      375366246,
      2157278981,
      2479649556,
      555357303,
      3870105701,
      2008414854,
      3344188149,
      4221384143,
      3956125452,
      2067696032,
      3594591187,
      2921233993,
      2428461,
      544322398,
      577241275,
      1471733935,
      610547355,
      4027169054,
      1432588573,
      1507829418,
      2025931657,
      3646575487,
      545086370,
      48609733,
      2200306550,
      1653985193,
      298326376,
      1316178497,
      3007786442,
      2064951626,
      458293330,
      2589141269,
      3591329599,
      3164325604,
      727753846,
      2179363840,
      146436021,
      1461446943,
      4069977195,
      705550613,
      3059967265,
      3887724982,
      4281599278,
      3313849956,
      1404054877,
      2845806497,
      146425753,
      1854211946,
      1266315497,
      3048417604,
      3681880366,
      3289982499,
      2909710000,
      1235738493,
      2632868024,
      2414719590,
      3970600049,
      1771706367,
      1449415276,
      3266420449,
      422970021,
      1963543593,
      2690192192,
      3826793022,
      1062508698,
      1531092325,
      1804592342,
      2583117782,
      2714934279,
      4024971509,
      1294809318,
      4028980673,
      1289560198,
      2221992742,
      1669523910,
      35572830,
      157838143,
      1052438473,
      1016535060,
      1802137761,
      1753167236,
      1386275462,
      3080475397,
      2857371447,
      1040679964,
      2145300060,
      2390574316,
      1461121720,
      2956646967,
      4031777805,
      4028374788,
      33600511,
      2920084762,
      1018524850,
      629373528,
      3691585981,
      3515945977,
      2091462646,
      2486323059,
      586499841,
      988145025,
      935516892,
      3367335476,
      2599673255,
      2839830854,
      265290510,
      3972581182,
      2759138881,
      3795373465,
      1005194799,
      847297441,
      406762289,
      1314163512,
      1332590856,
      1866599683,
      4127851711,
      750260880,
      613907577,
      1450815602,
      3165620655,
      3734664991,
      3650291728,
      3012275730,
      3704569646,
      1427272223,
      778793252,
      1343938022,
      2676280711,
      2052605720,
      1946737175,
      3164576444,
      3914038668,
      3967478842,
      3682934266,
      1661551462,
      3294938066,
      4011595847,
      840292616,
      3712170807,
      616741398,
      312560963,
      711312465,
      1351876610,
      322626781,
      1910503582,
      271666773,
      2175563734,
      1594956187,
      70604529,
      3617834859,
      1007753275,
      1495573769,
      4069517037,
      2549218298,
      2663038764,
      504708206,
      2263041392,
      3941167025,
      2249088522,
      1514023603,
      1998579484,
      1312622330,
      694541497,
      2582060303,
      2151582166,
      1382467621,
      776784248,
      2618340202,
      3323268794,
      2497899128,
      2784771155,
      503983604,
      4076293799,
      907881277,
      423175695,
      432175456,
      1378068232,
      4145222326,
      3954048622,
      3938656102,
      3820766613,
      2793130115,
      2977904593,
      26017576,
      3274890735,
      3194772133,
      1700274565,
      1756076034,
      4006520079,
      3677328699,
      720338349,
      1533947780,
      354530856,
      688349552,
      3973924725,
      1637815568,
      332179504,
      3949051286,
      53804574,
      2852348879,
      3044236432,
      1282449977,
      3583942155,
      3416972820,
      4006381244,
      1617046695,
      2628476075,
      3002303598,
      1686838959,
      431878346,
      2686675385,
      1700445008,
      1080580658,
      1009431731,
      832498133,
      3223435511,
      2605976345,
      2271191193,
      2516031870,
      1648197032,
      4164389018,
      2548247927,
      300782431,
      375919233,
      238389289,
      3353747414,
      2531188641,
      2019080857,
      1475708069,
      455242339,
      2609103871,
      448939670,
      3451063019,
      1395535956,
      2413381860,
      1841049896,
      1491858159,
      885456874,
      4264095073,
      4001119347,
      1565136089,
      3898914787,
      1108368660,
      540939232,
      1173283510,
      2745871338,
      3681308437,
      4207628240,
      3343053890,
      4016749493,
      1699691293,
      1103962373,
      3625875870,
      2256883143,
      3830138730,
      1031889488,
      3479347698,
      1535977030,
      4236805024,
      3251091107,
      2132092099,
      1774941330,
      1199868427,
      1452454533,
      157007616,
      2904115357,
      342012276,
      595725824,
      1480756522,
      206960106,
      497939518,
      591360097,
      863170706,
      2375253569,
      3596610801,
      1814182875,
      2094937945,
      3421402208,
      1082520231,
      3463918190,
      2785509508,
      435703966,
      3908032597,
      1641649973,
      2842273706,
      3305899714,
      1510255612,
      2148256476,
      2655287854,
      3276092548,
      4258621189,
      236887753,
      3681803219,
      274041037,
      1734335097,
      3815195456,
      3317970021,
      1899903192,
      1026095262,
      4050517792,
      356393447,
      2410691914,
      3873677099,
      3682840055,
      3913112168,
      2491498743,
      4132185628,
      2489919796,
      1091903735,
      1979897079,
      3170134830,
      3567386728,
      3557303409,
      857797738,
      1136121015,
      1342202287,
      507115054,
      2535736646,
      337727348,
      3213592640,
      1301675037,
      2528481711,
      1895095763,
      1721773893,
      3216771564,
      62756741,
      2142006736,
      835421444,
      2531993523,
      1442658625,
      3659876326,
      2882144922,
      676362277,
      1392781812,
      170690266,
      3921047035,
      1759253602,
      3611846912,
      1745797284,
      664899054,
      1329594018,
      3901205900,
      3045908486,
      2062866102,
      2865634940,
      3543621612,
      3464012697,
      1080764994,
      553557557,
      3656615353,
      3996768171,
      991055499,
      499776247,
      1265440854,
      648242737,
      3940784050,
      980351604,
      3713745714,
      1749149687,
      3396870395,
      4211799374,
      3640570775,
      1161844396,
      3125318951,
      1431517754,
      545492359,
      4268468663,
      3499529547,
      1437099964,
      2702547544,
      3433638243,
      2581715763,
      2787789398,
      1060185593,
      1593081372,
      2418618748,
      4260947970,
      69676912,
      2159744348,
      86519011,
      2512459080,
      3838209314,
      1220612927,
      3339683548,
      133810670,
      1090789135,
      1078426020,
      1569222167,
      845107691,
      3583754449,
      4072456591,
      1091646820,
      628848692,
      1613405280,
      3757631651,
      526609435,
      236106946,
      48312990,
      2942717905,
      3402727701,
      1797494240,
      859738849,
      992217954,
      4005476642,
      2243076622,
      3870952857,
      3732016268,
      765654824,
      3490871365,
      2511836413,
      1685915746,
      3888969200,
      1414112111,
      2273134842,
      3281911079,
      4080962846,
      172450625,
      2569994100,
      980381355,
      4109958455,
      2819808352,
      2716589560,
      2568741196,
      3681446669,
      3329971472,
      1835478071,
      660984891,
      3704678404,
      4045999559,
      3422617507,
      3040415634,
      1762651403,
      1719377915,
      3470491036,
      2693910283,
      3642056355,
      3138596744,
      1364962596,
      2073328063,
      1983633131,
      926494387,
      3423689081,
      2150032023,
      4096667949,
      1749200295,
      3328846651,
      309677260,
      2016342300,
      1779581495,
      3079819751,
      111262694,
      1274766160,
      443224088,
      298511866,
      1025883608,
      3806446537,
      1145181785,
      168956806,
      3641502830,
      3584813610,
      1689216846,
      3666258015,
      3200248200,
      1692713982,
      2646376535,
      4042768518,
      1618508792,
      1610833997,
      3523052358,
      4130873264,
      2001055236,
      3610705100,
      2202168115,
      4028541809,
      2961195399,
      1006657119,
      2006996926,
      3186142756,
      1430667929,
      3210227297,
      1314452623,
      4074634658,
      4101304120,
      2273951170,
      1399257539,
      3367210612,
      3027628629,
      1190975929,
      2062231137,
      2333990788,
      2221543033,
      2438960610,
      1181637006,
      548689776,
      2362791313,
      3372408396,
      3104550113,
      3145860560,
      296247880,
      1970579870,
      3078560182,
      3769228297,
      1714227617,
      3291629107,
      3898220290,
      166772364,
      1251581989,
      493813264,
      448347421,
      195405023,
      2709975567,
      677966185,
      3703036547,
      1463355134,
      2715995803,
      1338867538,
      1343315457,
      2802222074,
      2684532164,
      233230375,
      2599980071,
      2000651841,
      3277868038,
      1638401717,
      4028070440,
      3237316320,
      6314154,
      819756386,
      300326615,
      590932579,
      1405279636,
      3267499572,
      3150704214,
      2428286686,
      3959192993,
      3461946742,
      1862657033,
      1266418056,
      963775037,
      2089974820,
      2263052895,
      1917689273,
      448879540,
      3550394620,
      3981727096,
      150775221,
      3627908307,
      1303187396,
      508620638,
      2975983352,
      2726630617,
      1817252668,
      1876281319,
      1457606340,
      908771278,
      3720792119,
      3617206836,
      2455994898,
      1729034894,
      1080033504,
      976866871,
      3556439503,
      2881648439,
      1522871579,
      1555064734,
      1336096578,
      3548522304,
      2579274686,
      3574697629,
      3205460757,
      3593280638,
      3338716283,
      3079412587,
      564236357,
      2993598910,
      1781952180,
      1464380207,
      3163844217,
      3332601554,
      1699332808,
      1393555694,
      1183702653,
      3581086237,
      1288719814,
      691649499,
      2847557200,
      2895455976,
      3193889540,
      2717570544,
      1781354906,
      1676643554,
      2592534050,
      3230253752,
      1126444790,
      2770207658,
      2633158820,
      2210423226,
      2615765581,
      2414155088,
      3127139286,
      673620729,
      2805611233,
      1269405062,
      4015350505,
      3341807571,
      4149409754,
      1057255273,
      2012875353,
      2162469141,
      2276492801,
      2601117357,
      993977747,
      3918593370,
      2654263191,
      753973209,
      36408145,
      2530585658,
      25011837,
      3520020182,
      2088578344,
      530523599,
      2918365339,
      1524020338,
      1518925132,
      3760827505,
      3759777254,
      1202760957,
      3985898139,
      3906192525,
      674977740,
      4174734889,
      2031300136,
      2019492241,
      3983892565,
      4153806404,
      3822280332,
      352677332,
      2297720250,
      60907813,
      90501309,
      3286998549,
      1016092578,
      2535922412,
      2839152426,
      457141659,
      509813237,
      4120667899,
      652014361,
      1966332200,
      2975202805,
      55981186,
      2327461051,
      676427537,
      3255491064,
      2882294119,
      3433927263,
      1307055953,
      942726286,
      933058658,
      2468411793,
      3933900994,
      4215176142,
      1361170020,
      2001714738,
      2830558078,
      3274259782,
      1222529897,
      1679025792,
      2729314320,
      3714953764,
      1770335741,
      151462246,
      3013232138,
      1682292957,
      1483529935,
      471910574,
      1539241949,
      458788160,
      3436315007,
      1807016891,
      3718408830,
      978976581,
      1043663428,
      3165965781,
      1927990952,
      4200891579,
      2372276910,
      3208408903,
      3533431907,
      1412390302,
      2931980059,
      4132332400,
      1947078029,
      3881505623,
      4168226417,
      2941484381,
      1077988104,
      1320477388,
      886195818,
      18198404,
      3786409000,
      2509781533,
      112762804,
      3463356488,
      1866414978,
      891333506,
      18488651,
      661792760,
      1628790961,
      3885187036,
      3141171499,
      876946877,
      2693282273,
      1372485963,
      791857591,
      2686433993,
      3759982718,
      3167212022,
      3472953795,
      2716379847,
      445679433,
      3561995674,
      3504004811,
      3574258232,
      54117162,
      3331405415,
      2381918588,
      3769707343,
      4154350007,
      1140177722,
      4074052095,
      668550556,
      3214352940,
      367459370,
      261225585,
      2610173221,
      4209349473,
      3468074219,
      3265815641,
      314222801,
      3066103646,
      3808782860,
      282218597,
      3406013506,
      3773591054,
      379116347,
      1285071038,
      846784868,
      2669647154,
      3771962079,
      3550491691,
      2305946142,
      453669953,
      1268987020,
      3317592352,
      3279303384,
      3744833421,
      2610507566,
      3859509063,
      266596637,
      3847019092,
      517658769,
      3462560207,
      3443424879,
      370717030,
      4247526661,
      2224018117,
      4143653529,
      4112773975,
      2788324899,
      2477274417,
      1456262402,
      2901442914,
      1517677493,
      1846949527,
      2295493580,
      3734397586,
      2176403920,
      1280348187,
      1908823572,
      3871786941,
      846861322,
      1172426758,
      3287448474,
      3383383037,
      1655181056,
      3139813346,
      901632758,
      1897031941,
      2986607138,
      3066810236,
      3447102507,
      1393639104,
      373351379,
      950779232,
      625454576,
      3124240540,
      4148612726,
      2007998917,
      544563296,
      2244738638,
      2330496472,
      2058025392,
      1291430526,
      424198748,
      50039436,
      29584100,
      3605783033,
      2429876329,
      2791104160,
      1057563949,
      3255363231,
      3075367218,
      3463963227,
      1469046755,
      985887462
    ];
    var C_ORIG = [
      1332899944,
      1700884034,
      1701343084,
      1684370003,
      1668446532,
      1869963892
    ];
    function _encipher(lr, off, P, S) {
      var n, l = lr[off], r = lr[off + 1];
      l ^= P[0];
      n = S[l >>> 24];
      n += S[256 | l >> 16 & 255];
      n ^= S[512 | l >> 8 & 255];
      n += S[768 | l & 255];
      r ^= n ^ P[1];
      n = S[r >>> 24];
      n += S[256 | r >> 16 & 255];
      n ^= S[512 | r >> 8 & 255];
      n += S[768 | r & 255];
      l ^= n ^ P[2];
      n = S[l >>> 24];
      n += S[256 | l >> 16 & 255];
      n ^= S[512 | l >> 8 & 255];
      n += S[768 | l & 255];
      r ^= n ^ P[3];
      n = S[r >>> 24];
      n += S[256 | r >> 16 & 255];
      n ^= S[512 | r >> 8 & 255];
      n += S[768 | r & 255];
      l ^= n ^ P[4];
      n = S[l >>> 24];
      n += S[256 | l >> 16 & 255];
      n ^= S[512 | l >> 8 & 255];
      n += S[768 | l & 255];
      r ^= n ^ P[5];
      n = S[r >>> 24];
      n += S[256 | r >> 16 & 255];
      n ^= S[512 | r >> 8 & 255];
      n += S[768 | r & 255];
      l ^= n ^ P[6];
      n = S[l >>> 24];
      n += S[256 | l >> 16 & 255];
      n ^= S[512 | l >> 8 & 255];
      n += S[768 | l & 255];
      r ^= n ^ P[7];
      n = S[r >>> 24];
      n += S[256 | r >> 16 & 255];
      n ^= S[512 | r >> 8 & 255];
      n += S[768 | r & 255];
      l ^= n ^ P[8];
      n = S[l >>> 24];
      n += S[256 | l >> 16 & 255];
      n ^= S[512 | l >> 8 & 255];
      n += S[768 | l & 255];
      r ^= n ^ P[9];
      n = S[r >>> 24];
      n += S[256 | r >> 16 & 255];
      n ^= S[512 | r >> 8 & 255];
      n += S[768 | r & 255];
      l ^= n ^ P[10];
      n = S[l >>> 24];
      n += S[256 | l >> 16 & 255];
      n ^= S[512 | l >> 8 & 255];
      n += S[768 | l & 255];
      r ^= n ^ P[11];
      n = S[r >>> 24];
      n += S[256 | r >> 16 & 255];
      n ^= S[512 | r >> 8 & 255];
      n += S[768 | r & 255];
      l ^= n ^ P[12];
      n = S[l >>> 24];
      n += S[256 | l >> 16 & 255];
      n ^= S[512 | l >> 8 & 255];
      n += S[768 | l & 255];
      r ^= n ^ P[13];
      n = S[r >>> 24];
      n += S[256 | r >> 16 & 255];
      n ^= S[512 | r >> 8 & 255];
      n += S[768 | r & 255];
      l ^= n ^ P[14];
      n = S[l >>> 24];
      n += S[256 | l >> 16 & 255];
      n ^= S[512 | l >> 8 & 255];
      n += S[768 | l & 255];
      r ^= n ^ P[15];
      n = S[r >>> 24];
      n += S[256 | r >> 16 & 255];
      n ^= S[512 | r >> 8 & 255];
      n += S[768 | r & 255];
      l ^= n ^ P[16];
      lr[off] = r ^ P[BLOWFISH_NUM_ROUNDS + 1];
      lr[off + 1] = l;
      return lr;
    }
    function _streamtoword(data, offp) {
      for (var i2 = 0, word = 0;i2 < 4; ++i2)
        word = word << 8 | data[offp] & 255, offp = (offp + 1) % data.length;
      return { key: word, offp };
    }
    function _key(key, P, S) {
      var offset = 0, lr = [0, 0], plen = P.length, slen = S.length, sw;
      for (var i2 = 0;i2 < plen; i2++)
        sw = _streamtoword(key, offset), offset = sw.offp, P[i2] = P[i2] ^ sw.key;
      for (i2 = 0;i2 < plen; i2 += 2)
        lr = _encipher(lr, 0, P, S), P[i2] = lr[0], P[i2 + 1] = lr[1];
      for (i2 = 0;i2 < slen; i2 += 2)
        lr = _encipher(lr, 0, P, S), S[i2] = lr[0], S[i2 + 1] = lr[1];
    }
    function _ekskey(data, key, P, S) {
      var offp = 0, lr = [0, 0], plen = P.length, slen = S.length, sw;
      for (var i2 = 0;i2 < plen; i2++)
        sw = _streamtoword(key, offp), offp = sw.offp, P[i2] = P[i2] ^ sw.key;
      offp = 0;
      for (i2 = 0;i2 < plen; i2 += 2)
        sw = _streamtoword(data, offp), offp = sw.offp, lr[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr[1] ^= sw.key, lr = _encipher(lr, 0, P, S), P[i2] = lr[0], P[i2 + 1] = lr[1];
      for (i2 = 0;i2 < slen; i2 += 2)
        sw = _streamtoword(data, offp), offp = sw.offp, lr[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr[1] ^= sw.key, lr = _encipher(lr, 0, P, S), S[i2] = lr[0], S[i2 + 1] = lr[1];
    }
    function _crypt(b, salt, rounds, callback, progressCallback) {
      var cdata = C_ORIG.slice(), clen = cdata.length, err;
      if (rounds < 4 || rounds > 31) {
        err = Error("Illegal number of rounds (4-31): " + rounds);
        if (callback) {
          nextTick(callback.bind(this, err));
          return;
        } else
          throw err;
      }
      if (salt.length !== BCRYPT_SALT_LEN) {
        err = Error("Illegal salt length: " + salt.length + " != " + BCRYPT_SALT_LEN);
        if (callback) {
          nextTick(callback.bind(this, err));
          return;
        } else
          throw err;
      }
      rounds = 1 << rounds >>> 0;
      var P, S, i2 = 0, j;
      if (Int32Array) {
        P = new Int32Array(P_ORIG);
        S = new Int32Array(S_ORIG);
      } else {
        P = P_ORIG.slice();
        S = S_ORIG.slice();
      }
      _ekskey(salt, b, P, S);
      function next() {
        if (progressCallback)
          progressCallback(i2 / rounds);
        if (i2 < rounds) {
          var start = Date.now();
          for (;i2 < rounds; ) {
            i2 = i2 + 1;
            _key(b, P, S);
            _key(salt, P, S);
            if (Date.now() - start > MAX_EXECUTION_TIME)
              break;
          }
        } else {
          for (i2 = 0;i2 < 64; i2++)
            for (j = 0;j < clen >> 1; j++)
              _encipher(cdata, j << 1, P, S);
          var ret = [];
          for (i2 = 0;i2 < clen; i2++)
            ret.push((cdata[i2] >> 24 & 255) >>> 0), ret.push((cdata[i2] >> 16 & 255) >>> 0), ret.push((cdata[i2] >> 8 & 255) >>> 0), ret.push((cdata[i2] & 255) >>> 0);
          if (callback) {
            callback(null, ret);
            return;
          } else
            return ret;
        }
        if (callback)
          nextTick(next);
      }
      if (typeof callback !== "undefined") {
        next();
      } else {
        var res;
        while (true)
          if (typeof (res = next()) !== "undefined")
            return res || [];
      }
    }
    function _hash(s, salt, callback, progressCallback) {
      var err;
      if (typeof s !== "string" || typeof salt !== "string") {
        err = Error("Invalid string / salt: Not a string");
        if (callback) {
          nextTick(callback.bind(this, err));
          return;
        } else
          throw err;
      }
      var minor, offset;
      if (salt.charAt(0) !== "$" || salt.charAt(1) !== "2") {
        err = Error("Invalid salt version: " + salt.substring(0, 2));
        if (callback) {
          nextTick(callback.bind(this, err));
          return;
        } else
          throw err;
      }
      if (salt.charAt(2) === "$")
        minor = String.fromCharCode(0), offset = 3;
      else {
        minor = salt.charAt(2);
        if (minor !== "a" && minor !== "b" && minor !== "y" || salt.charAt(3) !== "$") {
          err = Error("Invalid salt revision: " + salt.substring(2, 4));
          if (callback) {
            nextTick(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        offset = 4;
      }
      if (salt.charAt(offset + 2) > "$") {
        err = Error("Missing salt rounds");
        if (callback) {
          nextTick(callback.bind(this, err));
          return;
        } else
          throw err;
      }
      var r1 = parseInt(salt.substring(offset, offset + 1), 10) * 10, r2 = parseInt(salt.substring(offset + 1, offset + 2), 10), rounds = r1 + r2, real_salt = salt.substring(offset + 3, offset + 25);
      s += minor >= "a" ? "\x00" : "";
      var passwordb = stringToBytes(s), saltb = base64_decode(real_salt, BCRYPT_SALT_LEN);
      function finish(bytes) {
        var res = [];
        res.push("$2");
        if (minor >= "a")
          res.push(minor);
        res.push("$");
        if (rounds < 10)
          res.push("0");
        res.push(rounds.toString());
        res.push("$");
        res.push(base64_encode(saltb, saltb.length));
        res.push(base64_encode(bytes, C_ORIG.length * 4 - 1));
        return res.join("");
      }
      if (typeof callback == "undefined")
        return finish(_crypt(passwordb, saltb, rounds));
      else {
        _crypt(passwordb, saltb, rounds, function(err2, bytes) {
          if (err2)
            callback(err2, null);
          else
            callback(null, finish(bytes));
        }, progressCallback);
      }
    }
    bcrypt.encodeBase64 = base64_encode;
    bcrypt.decodeBase64 = base64_decode;
    return bcrypt;
  });
});

// node_modules/safe-buffer/index.js
var require_safe_buffer2 = __commonJS((exports, module) => {
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var buffer = (init_buffer(), __toCommonJS(exports_buffer2));
  var Buffer3 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer3(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer3.prototype);
  copyProps(Buffer3, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer3(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill2, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer3(size);
    if (fill2 !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill2, encoding);
      } else {
        buf.fill(fill2);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer3(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS((exports, module) => {
  var Buffer3 = require_safe_buffer2().Buffer;
  var Stream = require_stream();
  var util = (init_util(), __toCommonJS(exports_util));
  function DataStream(data) {
    this.buffer = null;
    this.writable = true;
    this.readable = true;
    if (!data) {
      this.buffer = Buffer3.alloc(0);
      return this;
    }
    if (typeof data.pipe === "function") {
      this.buffer = Buffer3.alloc(0);
      data.pipe(this);
      return this;
    }
    if (data.length || typeof data === "object") {
      this.buffer = data;
      this.writable = false;
      process.nextTick(function() {
        this.emit("end", data);
        this.readable = false;
        this.emit("close");
      }.bind(this));
      return this;
    }
    throw new TypeError("Unexpected data type (" + typeof data + ")");
  }
  util.inherits(DataStream, Stream);
  DataStream.prototype.write = function write(data) {
    this.buffer = Buffer3.concat([this.buffer, Buffer3.from(data)]);
    this.emit("data", data);
  };
  DataStream.prototype.end = function end(data) {
    if (data)
      this.write(data);
    this.emit("end", data);
    this.emit("close");
    this.writable = false;
    this.readable = false;
  };
  module.exports = DataStream;
});

// node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS((exports, module) => {
  function getParamSize(keySize) {
    var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
    return result;
  }
  var paramBytesForAlg = {
    ES256: getParamSize(256),
    ES384: getParamSize(384),
    ES512: getParamSize(521)
  };
  function getParamBytesForAlg(alg) {
    var paramBytes = paramBytesForAlg[alg];
    if (paramBytes) {
      return paramBytes;
    }
    throw new Error('Unknown algorithm "' + alg + '"');
  }
  module.exports = getParamBytesForAlg;
});

// node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS((exports, module) => {
  var Buffer3 = require_safe_buffer2().Buffer;
  var getParamBytesForAlg = require_param_bytes_for_alg();
  var MAX_OCTET = 128;
  var CLASS_UNIVERSAL = 0;
  var PRIMITIVE_BIT = 32;
  var TAG_SEQ = 16;
  var TAG_INT = 2;
  var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
  var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
  function base64Url(base64) {
    return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function signatureAsBuffer(signature) {
    if (Buffer3.isBuffer(signature)) {
      return signature;
    } else if (typeof signature === "string") {
      return Buffer3.from(signature, "base64");
    }
    throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
  }
  function derToJose(signature, alg) {
    signature = signatureAsBuffer(signature);
    var paramBytes = getParamBytesForAlg(alg);
    var maxEncodedParamLength = paramBytes + 1;
    var inputLength = signature.length;
    var offset = 0;
    if (signature[offset++] !== ENCODED_TAG_SEQ) {
      throw new Error('Could not find expected "seq"');
    }
    var seqLength = signature[offset++];
    if (seqLength === (MAX_OCTET | 1)) {
      seqLength = signature[offset++];
    }
    if (inputLength - offset < seqLength) {
      throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
    }
    if (signature[offset++] !== ENCODED_TAG_INT) {
      throw new Error('Could not find expected "int" for "r"');
    }
    var rLength = signature[offset++];
    if (inputLength - offset - 2 < rLength) {
      throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
    }
    if (maxEncodedParamLength < rLength) {
      throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
    }
    var rOffset = offset;
    offset += rLength;
    if (signature[offset++] !== ENCODED_TAG_INT) {
      throw new Error('Could not find expected "int" for "s"');
    }
    var sLength = signature[offset++];
    if (inputLength - offset !== sLength) {
      throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
    }
    if (maxEncodedParamLength < sLength) {
      throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
    }
    var sOffset = offset;
    offset += sLength;
    if (offset !== inputLength) {
      throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
    }
    var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
    var dst = Buffer3.allocUnsafe(rPadding + rLength + sPadding + sLength);
    for (offset = 0;offset < rPadding; ++offset) {
      dst[offset] = 0;
    }
    signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
    offset = paramBytes;
    for (var o = offset;offset < o + sPadding; ++offset) {
      dst[offset] = 0;
    }
    signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
    dst = dst.toString("base64");
    dst = base64Url(dst);
    return dst;
  }
  function countPadding(buf, start, stop) {
    var padding = 0;
    while (start + padding < stop && buf[start + padding] === 0) {
      ++padding;
    }
    var needsSign = buf[start + padding] >= MAX_OCTET;
    if (needsSign) {
      --padding;
    }
    return padding;
  }
  function joseToDer(signature, alg) {
    signature = signatureAsBuffer(signature);
    var paramBytes = getParamBytesForAlg(alg);
    var signatureBytes = signature.length;
    if (signatureBytes !== paramBytes * 2) {
      throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
    }
    var rPadding = countPadding(signature, 0, paramBytes);
    var sPadding = countPadding(signature, paramBytes, signature.length);
    var rLength = paramBytes - rPadding;
    var sLength = paramBytes - sPadding;
    var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
    var shortLength = rsBytes < MAX_OCTET;
    var dst = Buffer3.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
    var offset = 0;
    dst[offset++] = ENCODED_TAG_SEQ;
    if (shortLength) {
      dst[offset++] = rsBytes;
    } else {
      dst[offset++] = MAX_OCTET | 1;
      dst[offset++] = rsBytes & 255;
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = rLength;
    if (rPadding < 0) {
      dst[offset++] = 0;
      offset += signature.copy(dst, offset, 0, paramBytes);
    } else {
      offset += signature.copy(dst, offset, rPadding, paramBytes);
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = sLength;
    if (sPadding < 0) {
      dst[offset++] = 0;
      signature.copy(dst, offset, paramBytes);
    } else {
      signature.copy(dst, offset, paramBytes + sPadding);
    }
    return dst;
  }
  module.exports = {
    derToJose,
    joseToDer
  };
});

// node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS((exports, module) => {
  var Buffer3 = (init_buffer(), __toCommonJS(exports_buffer2)).Buffer;
  var SlowBuffer = (init_buffer(), __toCommonJS(exports_buffer2)).SlowBuffer;
  module.exports = bufferEq;
  function bufferEq(a, b) {
    if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    var c = 0;
    for (var i2 = 0;i2 < a.length; i2++) {
      c |= a[i2] ^ b[i2];
    }
    return c === 0;
  }
  bufferEq.install = function() {
    Buffer3.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
      return bufferEq(this, that);
    };
  };
  var origBufEqual = Buffer3.prototype.equal;
  var origSlowBufEqual = SlowBuffer.prototype.equal;
  bufferEq.restore = function() {
    Buffer3.prototype.equal = origBufEqual;
    SlowBuffer.prototype.equal = origSlowBufEqual;
  };
});

// node_modules/jwa/index.js
var require_jwa = __commonJS((exports, module) => {
  var Buffer3 = require_safe_buffer2().Buffer;
  var crypto2 = (init_crypto(), __toCommonJS(exports_crypto));
  var formatEcdsa = require_ecdsa_sig_formatter();
  var util = (init_util(), __toCommonJS(exports_util));
  var MSG_INVALID_ALGORITHM = `"%s" is not a valid algorithm.
  Supported algorithms are:
  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".`;
  var MSG_INVALID_SECRET = "secret must be a string or buffer";
  var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
  var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
  var supportsKeyObjects = typeof crypto2.createPublicKey === "function";
  if (supportsKeyObjects) {
    MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
    MSG_INVALID_SECRET += "or a KeyObject";
  }
  function checkIsPublicKey(key) {
    if (Buffer3.isBuffer(key)) {
      return;
    }
    if (typeof key === "string") {
      return;
    }
    if (!supportsKeyObjects) {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key !== "object") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.type !== "string") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.asymmetricKeyType !== "string") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.export !== "function") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
  }
  function checkIsPrivateKey(key) {
    if (Buffer3.isBuffer(key)) {
      return;
    }
    if (typeof key === "string") {
      return;
    }
    if (typeof key === "object") {
      return;
    }
    throw typeError(MSG_INVALID_SIGNER_KEY);
  }
  function checkIsSecretKey(key) {
    if (Buffer3.isBuffer(key)) {
      return;
    }
    if (typeof key === "string") {
      return key;
    }
    if (!supportsKeyObjects) {
      throw typeError(MSG_INVALID_SECRET);
    }
    if (typeof key !== "object") {
      throw typeError(MSG_INVALID_SECRET);
    }
    if (key.type !== "secret") {
      throw typeError(MSG_INVALID_SECRET);
    }
    if (typeof key.export !== "function") {
      throw typeError(MSG_INVALID_SECRET);
    }
  }
  function fromBase64(base64) {
    return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function toBase64(base64url) {
    base64url = base64url.toString();
    var padding = 4 - base64url.length % 4;
    if (padding !== 4) {
      for (var i2 = 0;i2 < padding; ++i2) {
        base64url += "=";
      }
    }
    return base64url.replace(/\-/g, "+").replace(/_/g, "/");
  }
  function typeError(template) {
    var args = [].slice.call(arguments, 1);
    var errMsg = util.format.bind(util, template).apply(null, args);
    return new TypeError(errMsg);
  }
  function bufferOrString(obj) {
    return Buffer3.isBuffer(obj) || typeof obj === "string";
  }
  function normalizeInput(thing) {
    if (!bufferOrString(thing))
      thing = JSON.stringify(thing);
    return thing;
  }
  function createHmacSigner(bits) {
    return function sign(thing, secret) {
      checkIsSecretKey(secret);
      thing = normalizeInput(thing);
      var hmac = crypto2.createHmac("sha" + bits, secret);
      var sig = (hmac.update(thing), hmac.digest("base64"));
      return fromBase64(sig);
    };
  }
  var bufferEqual;
  var timingSafeEqual = "timingSafeEqual" in crypto2 ? function timingSafeEqual(a, b) {
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    return crypto2.timingSafeEqual(a, b);
  } : function timingSafeEqual(a, b) {
    if (!bufferEqual) {
      bufferEqual = require_buffer_equal_constant_time();
    }
    return bufferEqual(a, b);
  };
  function createHmacVerifier(bits) {
    return function verify(thing, signature, secret) {
      var computedSig = createHmacSigner(bits)(thing, secret);
      return timingSafeEqual(Buffer3.from(signature), Buffer3.from(computedSig));
    };
  }
  function createKeySigner(bits) {
    return function sign(thing, privateKey) {
      checkIsPrivateKey(privateKey);
      thing = normalizeInput(thing);
      var signer = crypto2.createSign("RSA-SHA" + bits);
      var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
      return fromBase64(sig);
    };
  }
  function createKeyVerifier(bits) {
    return function verify(thing, signature, publicKey) {
      checkIsPublicKey(publicKey);
      thing = normalizeInput(thing);
      signature = toBase64(signature);
      var verifier = crypto2.createVerify("RSA-SHA" + bits);
      verifier.update(thing);
      return verifier.verify(publicKey, signature, "base64");
    };
  }
  function createPSSKeySigner(bits) {
    return function sign(thing, privateKey) {
      checkIsPrivateKey(privateKey);
      thing = normalizeInput(thing);
      var signer = crypto2.createSign("RSA-SHA" + bits);
      var sig = (signer.update(thing), signer.sign({
        key: privateKey,
        padding: crypto2.constants.RSA_PKCS1_PSS_PADDING,
        saltLength: crypto2.constants.RSA_PSS_SALTLEN_DIGEST
      }, "base64"));
      return fromBase64(sig);
    };
  }
  function createPSSKeyVerifier(bits) {
    return function verify(thing, signature, publicKey) {
      checkIsPublicKey(publicKey);
      thing = normalizeInput(thing);
      signature = toBase64(signature);
      var verifier = crypto2.createVerify("RSA-SHA" + bits);
      verifier.update(thing);
      return verifier.verify({
        key: publicKey,
        padding: crypto2.constants.RSA_PKCS1_PSS_PADDING,
        saltLength: crypto2.constants.RSA_PSS_SALTLEN_DIGEST
      }, signature, "base64");
    };
  }
  function createECDSASigner(bits) {
    var inner = createKeySigner(bits);
    return function sign() {
      var signature = inner.apply(null, arguments);
      signature = formatEcdsa.derToJose(signature, "ES" + bits);
      return signature;
    };
  }
  function createECDSAVerifer(bits) {
    var inner = createKeyVerifier(bits);
    return function verify(thing, signature, publicKey) {
      signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
      var result = inner(thing, signature, publicKey);
      return result;
    };
  }
  function createNoneSigner() {
    return function sign() {
      return "";
    };
  }
  function createNoneVerifier() {
    return function verify(thing, signature) {
      return signature === "";
    };
  }
  module.exports = function jwa(algorithm) {
    var signerFactories = {
      hs: createHmacSigner,
      rs: createKeySigner,
      ps: createPSSKeySigner,
      es: createECDSASigner,
      none: createNoneSigner
    };
    var verifierFactories = {
      hs: createHmacVerifier,
      rs: createKeyVerifier,
      ps: createPSSKeyVerifier,
      es: createECDSAVerifer,
      none: createNoneVerifier
    };
    var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
    if (!match)
      throw typeError(MSG_INVALID_ALGORITHM, algorithm);
    var algo = (match[1] || match[3]).toLowerCase();
    var bits = match[2];
    return {
      sign: signerFactories[algo](bits),
      verify: verifierFactories[algo](bits)
    };
  };
});

// node_modules/jws/lib/tostring.js
var require_tostring = __commonJS((exports, module) => {
  var Buffer3 = (init_buffer(), __toCommonJS(exports_buffer2)).Buffer;
  module.exports = function toString(obj) {
    if (typeof obj === "string")
      return obj;
    if (typeof obj === "number" || Buffer3.isBuffer(obj))
      return obj.toString();
    return JSON.stringify(obj);
  };
});

// node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS((exports, module) => {
  var Buffer3 = require_safe_buffer2().Buffer;
  var DataStream = require_data_stream();
  var jwa = require_jwa();
  var Stream = require_stream();
  var toString2 = require_tostring();
  var util = (init_util(), __toCommonJS(exports_util));
  function base64url(string3, encoding) {
    return Buffer3.from(string3, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function jwsSecuredInput(header, payload, encoding) {
    encoding = encoding || "utf8";
    var encodedHeader = base64url(toString2(header), "binary");
    var encodedPayload = base64url(toString2(payload), encoding);
    return util.format("%s.%s", encodedHeader, encodedPayload);
  }
  function jwsSign(opts) {
    var header = opts.header;
    var payload = opts.payload;
    var secretOrKey = opts.secret || opts.privateKey;
    var encoding = opts.encoding;
    var algo = jwa(header.alg);
    var securedInput = jwsSecuredInput(header, payload, encoding);
    var signature = algo.sign(securedInput, secretOrKey);
    return util.format("%s.%s", securedInput, signature);
  }
  function SignStream(opts) {
    var secret = opts.secret || opts.privateKey || opts.key;
    var secretStream = new DataStream(secret);
    this.readable = true;
    this.header = opts.header;
    this.encoding = opts.encoding;
    this.secret = this.privateKey = this.key = secretStream;
    this.payload = new DataStream(opts.payload);
    this.secret.once("close", function() {
      if (!this.payload.writable && this.readable)
        this.sign();
    }.bind(this));
    this.payload.once("close", function() {
      if (!this.secret.writable && this.readable)
        this.sign();
    }.bind(this));
  }
  util.inherits(SignStream, Stream);
  SignStream.prototype.sign = function sign() {
    try {
      var signature = jwsSign({
        header: this.header,
        payload: this.payload.buffer,
        secret: this.secret.buffer,
        encoding: this.encoding
      });
      this.emit("done", signature);
      this.emit("data", signature);
      this.emit("end");
      this.readable = false;
      return signature;
    } catch (e) {
      this.readable = false;
      this.emit("error", e);
      this.emit("close");
    }
  };
  SignStream.sign = jwsSign;
  module.exports = SignStream;
});

// node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS((exports, module) => {
  var Buffer3 = require_safe_buffer2().Buffer;
  var DataStream = require_data_stream();
  var jwa = require_jwa();
  var Stream = require_stream();
  var toString2 = require_tostring();
  var util = (init_util(), __toCommonJS(exports_util));
  var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
  function isObject3(thing) {
    return Object.prototype.toString.call(thing) === "[object Object]";
  }
  function safeJsonParse(thing) {
    if (isObject3(thing))
      return thing;
    try {
      return JSON.parse(thing);
    } catch (e) {
      return;
    }
  }
  function headerFromJWS(jwsSig) {
    var encodedHeader = jwsSig.split(".", 1)[0];
    return safeJsonParse(Buffer3.from(encodedHeader, "base64").toString("binary"));
  }
  function securedInputFromJWS(jwsSig) {
    return jwsSig.split(".", 2).join(".");
  }
  function signatureFromJWS(jwsSig) {
    return jwsSig.split(".")[2];
  }
  function payloadFromJWS(jwsSig, encoding) {
    encoding = encoding || "utf8";
    var payload = jwsSig.split(".")[1];
    return Buffer3.from(payload, "base64").toString(encoding);
  }
  function isValidJws(string3) {
    return JWS_REGEX.test(string3) && !!headerFromJWS(string3);
  }
  function jwsVerify(jwsSig, algorithm, secretOrKey) {
    if (!algorithm) {
      var err = new Error("Missing algorithm parameter for jws.verify");
      err.code = "MISSING_ALGORITHM";
      throw err;
    }
    jwsSig = toString2(jwsSig);
    var signature = signatureFromJWS(jwsSig);
    var securedInput = securedInputFromJWS(jwsSig);
    var algo = jwa(algorithm);
    return algo.verify(securedInput, signature, secretOrKey);
  }
  function jwsDecode(jwsSig, opts) {
    opts = opts || {};
    jwsSig = toString2(jwsSig);
    if (!isValidJws(jwsSig))
      return null;
    var header = headerFromJWS(jwsSig);
    if (!header)
      return null;
    var payload = payloadFromJWS(jwsSig);
    if (header.typ === "JWT" || opts.json)
      payload = JSON.parse(payload, opts.encoding);
    return {
      header,
      payload,
      signature: signatureFromJWS(jwsSig)
    };
  }
  function VerifyStream(opts) {
    opts = opts || {};
    var secretOrKey = opts.secret || opts.publicKey || opts.key;
    var secretStream = new DataStream(secretOrKey);
    this.readable = true;
    this.algorithm = opts.algorithm;
    this.encoding = opts.encoding;
    this.secret = this.publicKey = this.key = secretStream;
    this.signature = new DataStream(opts.signature);
    this.secret.once("close", function() {
      if (!this.signature.writable && this.readable)
        this.verify();
    }.bind(this));
    this.signature.once("close", function() {
      if (!this.secret.writable && this.readable)
        this.verify();
    }.bind(this));
  }
  util.inherits(VerifyStream, Stream);
  VerifyStream.prototype.verify = function verify() {
    try {
      var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
      var obj = jwsDecode(this.signature.buffer, this.encoding);
      this.emit("done", valid, obj);
      this.emit("data", valid);
      this.emit("end");
      this.readable = false;
      return valid;
    } catch (e) {
      this.readable = false;
      this.emit("error", e);
      this.emit("close");
    }
  };
  VerifyStream.decode = jwsDecode;
  VerifyStream.isValid = isValidJws;
  VerifyStream.verify = jwsVerify;
  module.exports = VerifyStream;
});

// node_modules/jws/index.js
var require_jws = __commonJS((exports) => {
  var SignStream = require_sign_stream();
  var VerifyStream = require_verify_stream();
  var ALGORITHMS = [
    "HS256",
    "HS384",
    "HS512",
    "RS256",
    "RS384",
    "RS512",
    "PS256",
    "PS384",
    "PS512",
    "ES256",
    "ES384",
    "ES512"
  ];
  exports.ALGORITHMS = ALGORITHMS;
  exports.sign = SignStream.sign;
  exports.verify = VerifyStream.verify;
  exports.decode = VerifyStream.decode;
  exports.isValid = VerifyStream.isValid;
  exports.createSign = function createSign(opts) {
    return new SignStream(opts);
  };
  exports.createVerify = function createVerify(opts) {
    return new VerifyStream(opts);
  };
});

// node_modules/jsonwebtoken/decode.js
var require_decode = __commonJS((exports, module) => {
  var jws = require_jws();
  module.exports = function(jwt, options) {
    options = options || {};
    var decoded = jws.decode(jwt, options);
    if (!decoded) {
      return null;
    }
    var payload = decoded.payload;
    if (typeof payload === "string") {
      try {
        var obj = JSON.parse(payload);
        if (obj !== null && typeof obj === "object") {
          payload = obj;
        }
      } catch (e) {}
    }
    if (options.complete === true) {
      return {
        header: decoded.header,
        payload,
        signature: decoded.signature
      };
    }
    return payload;
  };
});

// node_modules/jsonwebtoken/lib/JsonWebTokenError.js
var require_JsonWebTokenError = __commonJS((exports, module) => {
  var JsonWebTokenError = function(message, error3) {
    Error.call(this, message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "JsonWebTokenError";
    this.message = message;
    if (error3)
      this.inner = error3;
  };
  JsonWebTokenError.prototype = Object.create(Error.prototype);
  JsonWebTokenError.prototype.constructor = JsonWebTokenError;
  module.exports = JsonWebTokenError;
});

// node_modules/jsonwebtoken/lib/NotBeforeError.js
var require_NotBeforeError = __commonJS((exports, module) => {
  var JsonWebTokenError = require_JsonWebTokenError();
  var NotBeforeError = function(message, date3) {
    JsonWebTokenError.call(this, message);
    this.name = "NotBeforeError";
    this.date = date3;
  };
  NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);
  NotBeforeError.prototype.constructor = NotBeforeError;
  module.exports = NotBeforeError;
});

// node_modules/jsonwebtoken/lib/TokenExpiredError.js
var require_TokenExpiredError = __commonJS((exports, module) => {
  var JsonWebTokenError = require_JsonWebTokenError();
  var TokenExpiredError = function(message, expiredAt) {
    JsonWebTokenError.call(this, message);
    this.name = "TokenExpiredError";
    this.expiredAt = expiredAt;
  };
  TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);
  TokenExpiredError.prototype.constructor = TokenExpiredError;
  module.exports = TokenExpiredError;
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type3 = typeof val;
    if (type3 === "string" && val.length > 0) {
      return parse3(val);
    } else if (type3 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse3(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type3 = (match[2] || "ms").toLowerCase();
    switch (type3) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/jsonwebtoken/lib/timespan.js
var require_timespan = __commonJS((exports, module) => {
  var ms = require_ms();
  module.exports = function(time, iat) {
    var timestamp2 = iat || Math.floor(Date.now() / 1000);
    if (typeof time === "string") {
      var milliseconds = ms(time);
      if (typeof milliseconds === "undefined") {
        return;
      }
      return Math.floor(timestamp2 + milliseconds / 1000);
    } else if (typeof time === "number") {
      return timestamp2 + time;
    } else {
      return;
    }
  };
});

// node_modules/semver/internal/constants.js
var require_constants2 = __commonJS((exports, module) => {
  var SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  var RELEASE_TYPES = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
  ];
  module.exports = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  };
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS((exports, module) => {
  var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {};
  module.exports = debug;
});

// node_modules/semver/internal/re.js
var require_re = __commonJS((exports, module) => {
  var {
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_LENGTH
  } = require_constants2();
  var debug = require_debug();
  exports = module.exports = {};
  var re = exports.re = [];
  var safeRe = exports.safeRe = [];
  var src = exports.src = [];
  var safeSrc = exports.safeSrc = [];
  var t2 = exports.t = {};
  var R = 0;
  var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  var safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
  ];
  var makeSafeRegex = (value2) => {
    for (const [token, max] of safeRegexReplacements) {
      value2 = value2.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
    }
    return value2;
  };
  var createToken = (name, value2, isGlobal) => {
    const safe = makeSafeRegex(value2);
    const index = R++;
    debug(name, index, value2);
    t2[name] = index;
    src[index] = value2;
    safeSrc[index] = safe;
    re[index] = new RegExp(value2, isGlobal ? "g" : undefined);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : undefined);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src[t2.NUMERICIDENTIFIER]})\\.` + `(${src[t2.NUMERICIDENTIFIER]})\\.` + `(${src[t2.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t2.NONNUMERICIDENTIFIER]}|${src[t2.NUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t2.NONNUMERICIDENTIFIER]}|${src[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASE", `(?:-(${src[t2.PRERELEASEIDENTIFIER]}(?:\\.${src[t2.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src[t2.BUILDIDENTIFIER]}(?:\\.${src[t2.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t2.MAINVERSION]}${src[t2.PRERELEASE]}?${src[t2.BUILD]}?`);
  createToken("FULL", `^${src[t2.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t2.MAINVERSIONLOOSE]}${src[t2.PRERELEASELOOSE]}?${src[t2.BUILD]}?`);
  createToken("LOOSE", `^${src[t2.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t2.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t2.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t2.XRANGEIDENTIFIER]})` + `(?:${src[t2.PRERELEASE]})?${src[t2.BUILD]}?` + `)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t2.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t2.PRERELEASELOOSE]})?${src[t2.BUILD]}?` + `)?)?`);
  createToken("XRANGE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COERCEPLAIN", `${"(^|[^\\d])" + "(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
  createToken("COERCE", `${src[t2.COERCEPLAIN]}(?:$|[^\\d])`);
  createToken("COERCEFULL", src[t2.COERCEPLAIN] + `(?:${src[t2.PRERELEASE]})?` + `(?:${src[t2.BUILD]})?` + `(?:$|[^\\d])`);
  createToken("COERCERTL", src[t2.COERCE], true);
  createToken("COERCERTLFULL", src[t2.COERCEFULL], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t2.LONETILDE]}\\s+`, true);
  exports.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t2.LONECARET]}\\s+`, true);
  exports.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src[t2.GTLT]}\\s*(${src[t2.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]}|${src[t2.XRANGEPLAIN]})`, true);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t2.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${src[t2.XRANGEPLAIN]})` + `\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t2.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${src[t2.XRANGEPLAINLOOSE]})` + `\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS((exports, module) => {
  var looseOption = Object.freeze({ loose: true });
  var emptyOpts = Object.freeze({});
  var parseOptions = (options) => {
    if (!options) {
      return emptyOpts;
    }
    if (typeof options !== "object") {
      return looseOption;
    }
    return options;
  };
  module.exports = parseOptions;
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS((exports, module) => {
  var numeric = /^[0-9]+$/;
  var compareIdentifiers = (a, b) => {
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };
  var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
  module.exports = {
    compareIdentifiers,
    rcompareIdentifiers
  };
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS((exports, module) => {
  var debug = require_debug();
  var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants2();
  var { safeRe: re, t: t2 } = require_re();
  var parseOptions = require_parse_options();
  var { compareIdentifiers } = require_identifiers();

  class SemVer {
    constructor(version, options) {
      options = parseOptions(options);
      if (version instanceof SemVer) {
        if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
      }
      debug("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      const m = version.trim().match(options.loose ? re[t2.LOOSE] : re[t2.FULL]);
      if (!m) {
        throw new TypeError(`Invalid Version: ${version}`);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map((id) => {
          if (/^[0-9]+$/.test(id)) {
            const num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new SemVer(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i2 = 0;
      do {
        const a = this.prerelease[i2];
        const b = other.prerelease[i2];
        debug("prerelease compare", i2, a, b);
        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    }
    compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      let i2 = 0;
      do {
        const a = this.build[i2];
        const b = other.build[i2];
        debug("build compare", i2, a, b);
        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    }
    inc(release, identifier, identifierBase) {
      if (release.startsWith("pre")) {
        if (!identifier && identifierBase === false) {
          throw new Error("invalid increment argument: identifier is empty");
        }
        if (identifier) {
          const match = `-${identifier}`.match(this.options.loose ? re[t2.PRERELEASELOOSE] : re[t2.PRERELEASE]);
          if (!match || match[1] !== identifier) {
            throw new Error(`invalid identifier: ${identifier}`);
          }
        }
      }
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier, identifierBase);
          this.inc("pre", identifier, identifierBase);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier, identifierBase);
          }
          this.inc("pre", identifier, identifierBase);
          break;
        case "release":
          if (this.prerelease.length === 0) {
            throw new Error(`version ${this.raw} is not a prerelease`);
          }
          this.prerelease.length = 0;
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre": {
          const base = Number(identifierBase) ? 1 : 0;
          if (this.prerelease.length === 0) {
            this.prerelease = [base];
          } else {
            let i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              if (identifier === this.prerelease.join(".") && identifierBase === false) {
                throw new Error("invalid increment argument: identifier already exists");
              }
              this.prerelease.push(base);
            }
          }
          if (identifier) {
            let prerelease = [identifier, base];
            if (identifierBase === false) {
              prerelease = [identifier];
            }
            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = prerelease;
              }
            } else {
              this.prerelease = prerelease;
            }
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${release}`);
      }
      this.raw = this.format();
      if (this.build.length) {
        this.raw += `+${this.build.join(".")}`;
      }
      return this;
    }
  }
  module.exports = SemVer;
});

// node_modules/semver/functions/parse.js
var require_parse2 = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var parse3 = (version, options, throwErrors = false) => {
    if (version instanceof SemVer) {
      return version;
    }
    try {
      return new SemVer(version, options);
    } catch (er) {
      if (!throwErrors) {
        return null;
      }
      throw er;
    }
  };
  module.exports = parse3;
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS((exports, module) => {
  var parse3 = require_parse2();
  var valid = (version, options) => {
    const v = parse3(version, options);
    return v ? v.version : null;
  };
  module.exports = valid;
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS((exports, module) => {
  var parse3 = require_parse2();
  var clean3 = (version, options) => {
    const s = parse3(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  };
  module.exports = clean3;
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var inc = (version, release, options, identifier, identifierBase) => {
    if (typeof options === "string") {
      identifierBase = identifier;
      identifier = options;
      options = undefined;
    }
    try {
      return new SemVer(version instanceof SemVer ? version.version : version, options).inc(release, identifier, identifierBase).version;
    } catch (er) {
      return null;
    }
  };
  module.exports = inc;
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS((exports, module) => {
  var parse3 = require_parse2();
  var diff = (version1, version2) => {
    const v1 = parse3(version1, null, true);
    const v2 = parse3(version2, null, true);
    const comparison = v1.compare(v2);
    if (comparison === 0) {
      return null;
    }
    const v1Higher = comparison > 0;
    const highVersion = v1Higher ? v1 : v2;
    const lowVersion = v1Higher ? v2 : v1;
    const highHasPre = !!highVersion.prerelease.length;
    const lowHasPre = !!lowVersion.prerelease.length;
    if (lowHasPre && !highHasPre) {
      if (!lowVersion.patch && !lowVersion.minor) {
        return "major";
      }
      if (lowVersion.compareMain(highVersion) === 0) {
        if (lowVersion.minor && !lowVersion.patch) {
          return "minor";
        }
        return "patch";
      }
    }
    const prefix = highHasPre ? "pre" : "";
    if (v1.major !== v2.major) {
      return prefix + "major";
    }
    if (v1.minor !== v2.minor) {
      return prefix + "minor";
    }
    if (v1.patch !== v2.patch) {
      return prefix + "patch";
    }
    return "prerelease";
  };
  module.exports = diff;
});

// node_modules/semver/functions/major.js
var require_major = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var major = (a, loose) => new SemVer(a, loose).major;
  module.exports = major;
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var minor = (a, loose) => new SemVer(a, loose).minor;
  module.exports = minor;
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var patch = (a, loose) => new SemVer(a, loose).patch;
  module.exports = patch;
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS((exports, module) => {
  var parse3 = require_parse2();
  var prerelease = (version, options) => {
    const parsed = parse3(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };
  module.exports = prerelease;
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var compare3 = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
  module.exports = compare3;
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS((exports, module) => {
  var compare3 = require_compare();
  var rcompare = (a, b, loose) => compare3(b, a, loose);
  module.exports = rcompare;
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS((exports, module) => {
  var compare3 = require_compare();
  var compareLoose = (a, b) => compare3(a, b, true);
  module.exports = compareLoose;
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var compareBuild = (a, b, loose) => {
    const versionA = new SemVer(a, loose);
    const versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };
  module.exports = compareBuild;
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS((exports, module) => {
  var compareBuild = require_compare_build();
  var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
  module.exports = sort;
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS((exports, module) => {
  var compareBuild = require_compare_build();
  var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
  module.exports = rsort;
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS((exports, module) => {
  var compare3 = require_compare();
  var gt = (a, b, loose) => compare3(a, b, loose) > 0;
  module.exports = gt;
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS((exports, module) => {
  var compare3 = require_compare();
  var lt = (a, b, loose) => compare3(a, b, loose) < 0;
  module.exports = lt;
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS((exports, module) => {
  var compare3 = require_compare();
  var eq = (a, b, loose) => compare3(a, b, loose) === 0;
  module.exports = eq;
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS((exports, module) => {
  var compare3 = require_compare();
  var neq = (a, b, loose) => compare3(a, b, loose) !== 0;
  module.exports = neq;
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS((exports, module) => {
  var compare3 = require_compare();
  var gte = (a, b, loose) => compare3(a, b, loose) >= 0;
  module.exports = gte;
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS((exports, module) => {
  var compare3 = require_compare();
  var lte = (a, b, loose) => compare3(a, b, loose) <= 0;
  module.exports = lte;
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS((exports, module) => {
  var eq = require_eq();
  var neq = require_neq();
  var gt = require_gt();
  var gte = require_gte();
  var lt = require_lt();
  var lte = require_lte();
  var cmp = (a, op, b, loose) => {
    switch (op) {
      case "===":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a === b;
      case "!==":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  };
  module.exports = cmp;
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var parse3 = require_parse2();
  var { safeRe: re, t: t2 } = require_re();
  var coerce = (version, options) => {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version === "number") {
      version = String(version);
    }
    if (typeof version !== "string") {
      return null;
    }
    options = options || {};
    let match = null;
    if (!options.rtl) {
      match = version.match(options.includePrerelease ? re[t2.COERCEFULL] : re[t2.COERCE]);
    } else {
      const coerceRtlRegex = options.includePrerelease ? re[t2.COERCERTLFULL] : re[t2.COERCERTL];
      let next;
      while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
      }
      coerceRtlRegex.lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    const major = match[2];
    const minor = match[3] || "0";
    const patch = match[4] || "0";
    const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
    const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
    return parse3(`${major}.${minor}.${patch}${prerelease}${build}`, options);
  };
  module.exports = coerce;
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS((exports, module) => {
  class LRUCache {
    constructor() {
      this.max = 1000;
      this.map = new Map;
    }
    get(key) {
      const value2 = this.map.get(key);
      if (value2 === undefined) {
        return;
      } else {
        this.map.delete(key);
        this.map.set(key, value2);
        return value2;
      }
    }
    delete(key) {
      return this.map.delete(key);
    }
    set(key, value2) {
      const deleted = this.delete(key);
      if (!deleted && value2 !== undefined) {
        if (this.map.size >= this.max) {
          const firstKey = this.map.keys().next().value;
          this.delete(firstKey);
        }
        this.map.set(key, value2);
      }
      return this;
    }
  }
  module.exports = LRUCache;
});

// node_modules/semver/classes/range.js
var require_range = __commonJS((exports, module) => {
  var SPACE_CHARACTERS = /\s+/g;

  class Range {
    constructor(range, options) {
      options = parseOptions(options);
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        this.raw = range.value;
        this.set = [[range]];
        this.formatted = undefined;
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.formatted = undefined;
    }
    get range() {
      if (this.formatted === undefined) {
        this.formatted = "";
        for (let i2 = 0;i2 < this.set.length; i2++) {
          if (i2 > 0) {
            this.formatted += "||";
          }
          const comps = this.set[i2];
          for (let k = 0;k < comps.length; k++) {
            if (k > 0) {
              this.formatted += " ";
            }
            this.formatted += comps[k].toString().trim();
          }
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range;
      const cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re[t2.HYPHENRANGELOOSE] : re[t2.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug("hyphen replace", range);
      range = range.replace(re[t2.COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range);
      range = range.replace(re[t2.TILDETRIM], tildeTrimReplace);
      debug("tilde trim", range);
      range = range.replace(re[t2.CARETTRIM], caretTrimReplace);
      debug("caret trim", range);
      let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug("loose invalid filter", comp, this.options);
          return !!comp.match(re[t2.COMPARATORLOOSE]);
        });
      }
      debug("range list", rangeList);
      const rangeMap = new Map;
      const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    test(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i2 = 0;i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  module.exports = Range;
  var LRU = require_lrucache();
  var cache = new LRU;
  var parseOptions = require_parse_options();
  var Comparator = require_comparator();
  var debug = require_debug();
  var SemVer = require_semver();
  var {
    safeRe: re,
    t: t2,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = require_re();
  var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants2();
  var isNullSet = (c) => c.value === "<0.0.0-0";
  var isAny = (c) => c.value === "";
  var isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  var parseComparator = (comp, options) => {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  };
  var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
  var replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
  };
  var replaceTilde = (comp, options) => {
    const r = options.loose ? re[t2.TILDELOOSE] : re[t2.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("tilde", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug("tilde return", ret);
      return ret;
    });
  };
  var replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
  };
  var replaceCaret = (comp, options) => {
    debug("caret", comp, options);
    const r = options.loose ? re[t2.CARETLOOSE] : re[t2.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("caret", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug("caret return", ret);
      return ret;
    });
  };
  var replaceXRanges = (comp, options) => {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
  };
  var replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re[t2.XRANGELOOSE] : re[t2.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug("xRange return", ret);
      return ret;
    });
  };
  var replaceStars = (comp, options) => {
    debug("replaceStars", comp, options);
    return comp.trim().replace(re[t2.STAR], "");
  };
  var replaceGTE0 = (comp, options) => {
    debug("replaceGTE0", comp, options);
    return comp.trim().replace(re[options.includePrerelease ? t2.GTE0PRE : t2.GTE0], "");
  };
  var hyphenReplace = (incPr) => ($0, from2, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
    if (isX(fM)) {
      from2 = "";
    } else if (isX(fm)) {
      from2 = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from2 = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from2 = `>=${from2}`;
    } else {
      from2 = `>=${from2}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from2} ${to}`.trim();
  };
  var testSet = (set2, version, options) => {
    for (let i2 = 0;i2 < set2.length; i2++) {
      if (!set2[i2].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (let i2 = 0;i2 < set2.length; i2++) {
        debug(set2[i2].semver);
        if (set2[i2].semver === Comparator.ANY) {
          continue;
        }
        if (set2[i2].semver.prerelease.length > 0) {
          const allowed = set2[i2].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS((exports, module) => {
  var ANY = Symbol("SemVer ANY");

  class Comparator {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      options = parseOptions(options);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re[t2.COMPARATORLOOSE] : re[t2.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== undefined ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version) {
      debug("Comparator.test", version, this.options.loose);
      if (this.semver === ANY || version === ANY) {
        return true;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range(this.value, options).test(comp.semver);
      }
      options = parseOptions(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  module.exports = Comparator;
  var parseOptions = require_parse_options();
  var { safeRe: re, t: t2 } = require_re();
  var cmp = require_cmp();
  var debug = require_debug();
  var SemVer = require_semver();
  var Range = require_range();
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS((exports, module) => {
  var Range = require_range();
  var satisfies = (version, range, options) => {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version);
  };
  module.exports = satisfies;
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS((exports, module) => {
  var Range = require_range();
  var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
  module.exports = toComparators;
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var maxSatisfying = (versions, range, options) => {
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  };
  module.exports = maxSatisfying;
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var minSatisfying = (versions, range, options) => {
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  };
  module.exports = minSatisfying;
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var gt = require_gt();
  var minVersion = (range, loose) => {
    range = new Range(range, loose);
    let minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (let i2 = 0;i2 < range.set.length; ++i2) {
      const comparators = range.set[i2];
      let setMin = null;
      comparators.forEach((comparator) => {
        const compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!setMin || gt(compver, setMin)) {
              setMin = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error(`Unexpected operation: ${comparator.operator}`);
        }
      });
      if (setMin && (!minver || gt(minver, setMin))) {
        minver = setMin;
      }
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  };
  module.exports = minVersion;
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS((exports, module) => {
  var Range = require_range();
  var validRange = (range, options) => {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  };
  module.exports = validRange;
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var Range = require_range();
  var satisfies = require_satisfies();
  var gt = require_gt();
  var lt = require_lt();
  var lte = require_lte();
  var gte = require_gte();
  var outside = (version, range, hilo, options) => {
    version = new SemVer(version, options);
    range = new Range(range, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) {
      return false;
    }
    for (let i2 = 0;i2 < range.set.length; ++i2) {
      const comparators = range.set[i2];
      let high = null;
      let low = null;
      comparators.forEach((comparator) => {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  };
  module.exports = outside;
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS((exports, module) => {
  var outside = require_outside();
  var gtr = (version, range, options) => outside(version, range, ">", options);
  module.exports = gtr;
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS((exports, module) => {
  var outside = require_outside();
  var ltr = (version, range, options) => outside(version, range, "<", options);
  module.exports = ltr;
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS((exports, module) => {
  var Range = require_range();
  var intersects = (r1, r2, options) => {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2, options);
  };
  module.exports = intersects;
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS((exports, module) => {
  var satisfies = require_satisfies();
  var compare3 = require_compare();
  module.exports = (versions, range, options) => {
    const set2 = [];
    let first = null;
    let prev = null;
    const v = versions.sort((a, b) => compare3(a, b, options));
    for (const version of v) {
      const included = satisfies(version, range, options);
      if (included) {
        prev = version;
        if (!first) {
          first = version;
        }
      } else {
        if (prev) {
          set2.push([first, prev]);
        }
        prev = null;
        first = null;
      }
    }
    if (first) {
      set2.push([first, null]);
    }
    const ranges = [];
    for (const [min, max] of set2) {
      if (min === max) {
        ranges.push(min);
      } else if (!max && min === v[0]) {
        ranges.push("*");
      } else if (!max) {
        ranges.push(`>=${min}`);
      } else if (min === v[0]) {
        ranges.push(`<=${max}`);
      } else {
        ranges.push(`${min} - ${max}`);
      }
    }
    const simplified = ranges.join(" || ");
    const original = typeof range.raw === "string" ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
  };
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS((exports, module) => {
  var Range = require_range();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var satisfies = require_satisfies();
  var compare3 = require_compare();
  var subset = (sub, dom, options = {}) => {
    if (sub === dom) {
      return true;
    }
    sub = new Range(sub, options);
    dom = new Range(dom, options);
    let sawNonNull = false;
    OUTER:
      for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
    return true;
  };
  var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
  var minimumVersion = [new Comparator(">=0.0.0")];
  var simpleSubset = (sub, dom, options) => {
    if (sub === dom) {
      return true;
    }
    if (sub.length === 1 && sub[0].semver === ANY) {
      if (dom.length === 1 && dom[0].semver === ANY) {
        return true;
      } else if (options.includePrerelease) {
        sub = minimumVersionWithPreRelease;
      } else {
        sub = minimumVersion;
      }
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
      if (options.includePrerelease) {
        return true;
      } else {
        dom = minimumVersion;
      }
    }
    const eqSet = new Set;
    let gt, lt;
    for (const c of sub) {
      if (c.operator === ">" || c.operator === ">=") {
        gt = higherGT(gt, c, options);
      } else if (c.operator === "<" || c.operator === "<=") {
        lt = lowerLT(lt, c, options);
      } else {
        eqSet.add(c.semver);
      }
    }
    if (eqSet.size > 1) {
      return null;
    }
    let gtltComp;
    if (gt && lt) {
      gtltComp = compare3(gt.semver, lt.semver, options);
      if (gtltComp > 0) {
        return null;
      } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
        return null;
      }
    }
    for (const eq of eqSet) {
      if (gt && !satisfies(eq, String(gt), options)) {
        return null;
      }
      if (lt && !satisfies(eq, String(lt), options)) {
        return null;
      }
      for (const c of dom) {
        if (!satisfies(eq, String(c), options)) {
          return false;
        }
      }
      return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
    let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
      needDomLTPre = false;
    }
    for (const c of dom) {
      hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
      hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
      if (gt) {
        if (needDomGTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
            needDomGTPre = false;
          }
        }
        if (c.operator === ">" || c.operator === ">=") {
          higher = higherGT(gt, c, options);
          if (higher === c && higher !== gt) {
            return false;
          }
        } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
          return false;
        }
      }
      if (lt) {
        if (needDomLTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
            needDomLTPre = false;
          }
        }
        if (c.operator === "<" || c.operator === "<=") {
          lower = lowerLT(lt, c, options);
          if (lower === c && lower !== lt) {
            return false;
          }
        } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
          return false;
        }
      }
      if (!c.operator && (lt || gt) && gtltComp !== 0) {
        return false;
      }
    }
    if (gt && hasDomLT && !lt && gtltComp !== 0) {
      return false;
    }
    if (lt && hasDomGT && !gt && gtltComp !== 0) {
      return false;
    }
    if (needDomGTPre || needDomLTPre) {
      return false;
    }
    return true;
  };
  var higherGT = (a, b, options) => {
    if (!a) {
      return b;
    }
    const comp = compare3(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
  };
  var lowerLT = (a, b, options) => {
    if (!a) {
      return b;
    }
    const comp = compare3(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
  };
  module.exports = subset;
});

// node_modules/semver/index.js
var require_semver2 = __commonJS((exports, module) => {
  var internalRe = require_re();
  var constants3 = require_constants2();
  var SemVer = require_semver();
  var identifiers = require_identifiers();
  var parse3 = require_parse2();
  var valid = require_valid();
  var clean3 = require_clean();
  var inc = require_inc();
  var diff = require_diff();
  var major = require_major();
  var minor = require_minor();
  var patch = require_patch();
  var prerelease = require_prerelease();
  var compare3 = require_compare();
  var rcompare = require_rcompare();
  var compareLoose = require_compare_loose();
  var compareBuild = require_compare_build();
  var sort = require_sort();
  var rsort = require_rsort();
  var gt = require_gt();
  var lt = require_lt();
  var eq = require_eq();
  var neq = require_neq();
  var gte = require_gte();
  var lte = require_lte();
  var cmp = require_cmp();
  var coerce = require_coerce();
  var Comparator = require_comparator();
  var Range = require_range();
  var satisfies = require_satisfies();
  var toComparators = require_to_comparators();
  var maxSatisfying = require_max_satisfying();
  var minSatisfying = require_min_satisfying();
  var minVersion = require_min_version();
  var validRange = require_valid2();
  var outside = require_outside();
  var gtr = require_gtr();
  var ltr = require_ltr();
  var intersects = require_intersects();
  var simplifyRange = require_simplify();
  var subset = require_subset();
  module.exports = {
    parse: parse3,
    valid,
    clean: clean3,
    inc,
    diff,
    major,
    minor,
    patch,
    prerelease,
    compare: compare3,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt,
    lt,
    eq,
    neq,
    gte,
    lte,
    cmp,
    coerce,
    Comparator,
    Range,
    satisfies,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants3.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants3.RELEASE_TYPES,
    compareIdentifiers: identifiers.compareIdentifiers,
    rcompareIdentifiers: identifiers.rcompareIdentifiers
  };
});

// node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js
var require_asymmetricKeyDetailsSupported = __commonJS((exports, module) => {
  var semver = require_semver2();
  module.exports = semver.satisfies(process.version, ">=15.7.0");
});

// node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js
var require_rsaPssKeyDetailsSupported = __commonJS((exports, module) => {
  var semver = require_semver2();
  module.exports = semver.satisfies(process.version, ">=16.9.0");
});

// node_modules/jsonwebtoken/lib/validateAsymmetricKey.js
var require_validateAsymmetricKey = __commonJS((exports, module) => {
  var ASYMMETRIC_KEY_DETAILS_SUPPORTED = require_asymmetricKeyDetailsSupported();
  var RSA_PSS_KEY_DETAILS_SUPPORTED = require_rsaPssKeyDetailsSupported();
  var allowedAlgorithmsForKeys = {
    ec: ["ES256", "ES384", "ES512"],
    rsa: ["RS256", "PS256", "RS384", "PS384", "RS512", "PS512"],
    "rsa-pss": ["PS256", "PS384", "PS512"]
  };
  var allowedCurves = {
    ES256: "prime256v1",
    ES384: "secp384r1",
    ES512: "secp521r1"
  };
  module.exports = function(algorithm, key) {
    if (!algorithm || !key)
      return;
    const keyType = key.asymmetricKeyType;
    if (!keyType)
      return;
    const allowedAlgorithms = allowedAlgorithmsForKeys[keyType];
    if (!allowedAlgorithms) {
      throw new Error(`Unknown key type "${keyType}".`);
    }
    if (!allowedAlgorithms.includes(algorithm)) {
      throw new Error(`"alg" parameter for "${keyType}" key type must be one of: ${allowedAlgorithms.join(", ")}.`);
    }
    if (ASYMMETRIC_KEY_DETAILS_SUPPORTED) {
      switch (keyType) {
        case "ec":
          const keyCurve = key.asymmetricKeyDetails.namedCurve;
          const allowedCurve = allowedCurves[algorithm];
          if (keyCurve !== allowedCurve) {
            throw new Error(`"alg" parameter "${algorithm}" requires curve "${allowedCurve}".`);
          }
          break;
        case "rsa-pss":
          if (RSA_PSS_KEY_DETAILS_SUPPORTED) {
            const length = parseInt(algorithm.slice(-3), 10);
            const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;
            if (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm) {
              throw new Error(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${algorithm}.`);
            }
            if (saltLength !== undefined && saltLength > length >> 3) {
              throw new Error(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${algorithm}.`);
            }
          }
          break;
      }
    }
  };
});

// node_modules/jsonwebtoken/lib/psSupported.js
var require_psSupported = __commonJS((exports, module) => {
  var semver = require_semver2();
  module.exports = semver.satisfies(process.version, "^6.12.0 || >=8.0.0");
});

// node_modules/jsonwebtoken/verify.js
var require_verify = __commonJS((exports, module) => {
  var JsonWebTokenError = require_JsonWebTokenError();
  var NotBeforeError = require_NotBeforeError();
  var TokenExpiredError = require_TokenExpiredError();
  var decode3 = require_decode();
  var timespan = require_timespan();
  var validateAsymmetricKey = require_validateAsymmetricKey();
  var PS_SUPPORTED = require_psSupported();
  var jws = require_jws();
  var { KeyObject, createSecretKey, createPublicKey } = (init_crypto(), __toCommonJS(exports_crypto));
  var PUB_KEY_ALGS = ["RS256", "RS384", "RS512"];
  var EC_KEY_ALGS = ["ES256", "ES384", "ES512"];
  var RSA_KEY_ALGS = ["RS256", "RS384", "RS512"];
  var HS_ALGS = ["HS256", "HS384", "HS512"];
  if (PS_SUPPORTED) {
    PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
    RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
  }
  module.exports = function(jwtString, secretOrPublicKey, options, callback) {
    if (typeof options === "function" && !callback) {
      callback = options;
      options = {};
    }
    if (!options) {
      options = {};
    }
    options = Object.assign({}, options);
    let done;
    if (callback) {
      done = callback;
    } else {
      done = function(err, data) {
        if (err)
          throw err;
        return data;
      };
    }
    if (options.clockTimestamp && typeof options.clockTimestamp !== "number") {
      return done(new JsonWebTokenError("clockTimestamp must be a number"));
    }
    if (options.nonce !== undefined && (typeof options.nonce !== "string" || options.nonce.trim() === "")) {
      return done(new JsonWebTokenError("nonce must be a non-empty string"));
    }
    if (options.allowInvalidAsymmetricKeyTypes !== undefined && typeof options.allowInvalidAsymmetricKeyTypes !== "boolean") {
      return done(new JsonWebTokenError("allowInvalidAsymmetricKeyTypes must be a boolean"));
    }
    const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);
    if (!jwtString) {
      return done(new JsonWebTokenError("jwt must be provided"));
    }
    if (typeof jwtString !== "string") {
      return done(new JsonWebTokenError("jwt must be a string"));
    }
    const parts = jwtString.split(".");
    if (parts.length !== 3) {
      return done(new JsonWebTokenError("jwt malformed"));
    }
    let decodedToken;
    try {
      decodedToken = decode3(jwtString, { complete: true });
    } catch (err) {
      return done(err);
    }
    if (!decodedToken) {
      return done(new JsonWebTokenError("invalid token"));
    }
    const header = decodedToken.header;
    let getSecret;
    if (typeof secretOrPublicKey === "function") {
      if (!callback) {
        return done(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
      }
      getSecret = secretOrPublicKey;
    } else {
      getSecret = function(header2, secretCallback) {
        return secretCallback(null, secretOrPublicKey);
      };
    }
    return getSecret(header, function(err, secretOrPublicKey2) {
      if (err) {
        return done(new JsonWebTokenError("error in secret or public key callback: " + err.message));
      }
      const hasSignature = parts[2].trim() !== "";
      if (!hasSignature && secretOrPublicKey2) {
        return done(new JsonWebTokenError("jwt signature is required"));
      }
      if (hasSignature && !secretOrPublicKey2) {
        return done(new JsonWebTokenError("secret or public key must be provided"));
      }
      if (!hasSignature && !options.algorithms) {
        return done(new JsonWebTokenError('please specify "none" in "algorithms" to verify unsigned tokens'));
      }
      if (secretOrPublicKey2 != null && !(secretOrPublicKey2 instanceof KeyObject)) {
        try {
          secretOrPublicKey2 = createPublicKey(secretOrPublicKey2);
        } catch (_) {
          try {
            secretOrPublicKey2 = createSecretKey(typeof secretOrPublicKey2 === "string" ? Buffer.from(secretOrPublicKey2) : secretOrPublicKey2);
          } catch (_2) {
            return done(new JsonWebTokenError("secretOrPublicKey is not valid key material"));
          }
        }
      }
      if (!options.algorithms) {
        if (secretOrPublicKey2.type === "secret") {
          options.algorithms = HS_ALGS;
        } else if (["rsa", "rsa-pss"].includes(secretOrPublicKey2.asymmetricKeyType)) {
          options.algorithms = RSA_KEY_ALGS;
        } else if (secretOrPublicKey2.asymmetricKeyType === "ec") {
          options.algorithms = EC_KEY_ALGS;
        } else {
          options.algorithms = PUB_KEY_ALGS;
        }
      }
      if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {
        return done(new JsonWebTokenError("invalid algorithm"));
      }
      if (header.alg.startsWith("HS") && secretOrPublicKey2.type !== "secret") {
        return done(new JsonWebTokenError(`secretOrPublicKey must be a symmetric key when using ${header.alg}`));
      } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey2.type !== "public") {
        return done(new JsonWebTokenError(`secretOrPublicKey must be an asymmetric key when using ${header.alg}`));
      }
      if (!options.allowInvalidAsymmetricKeyTypes) {
        try {
          validateAsymmetricKey(header.alg, secretOrPublicKey2);
        } catch (e) {
          return done(e);
        }
      }
      let valid;
      try {
        valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey2);
      } catch (e) {
        return done(e);
      }
      if (!valid) {
        return done(new JsonWebTokenError("invalid signature"));
      }
      const payload = decodedToken.payload;
      if (typeof payload.nbf !== "undefined" && !options.ignoreNotBefore) {
        if (typeof payload.nbf !== "number") {
          return done(new JsonWebTokenError("invalid nbf value"));
        }
        if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
          return done(new NotBeforeError("jwt not active", new Date(payload.nbf * 1000)));
        }
      }
      if (typeof payload.exp !== "undefined" && !options.ignoreExpiration) {
        if (typeof payload.exp !== "number") {
          return done(new JsonWebTokenError("invalid exp value"));
        }
        if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
          return done(new TokenExpiredError("jwt expired", new Date(payload.exp * 1000)));
        }
      }
      if (options.audience) {
        const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
        const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
        const match = target.some(function(targetAudience) {
          return audiences.some(function(audience) {
            return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
          });
        });
        if (!match) {
          return done(new JsonWebTokenError("jwt audience invalid. expected: " + audiences.join(" or ")));
        }
      }
      if (options.issuer) {
        const invalid_issuer = typeof options.issuer === "string" && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;
        if (invalid_issuer) {
          return done(new JsonWebTokenError("jwt issuer invalid. expected: " + options.issuer));
        }
      }
      if (options.subject) {
        if (payload.sub !== options.subject) {
          return done(new JsonWebTokenError("jwt subject invalid. expected: " + options.subject));
        }
      }
      if (options.jwtid) {
        if (payload.jti !== options.jwtid) {
          return done(new JsonWebTokenError("jwt jwtid invalid. expected: " + options.jwtid));
        }
      }
      if (options.nonce) {
        if (payload.nonce !== options.nonce) {
          return done(new JsonWebTokenError("jwt nonce invalid. expected: " + options.nonce));
        }
      }
      if (options.maxAge) {
        if (typeof payload.iat !== "number") {
          return done(new JsonWebTokenError("iat required when maxAge is specified"));
        }
        const maxAgeTimestamp = timespan(options.maxAge, payload.iat);
        if (typeof maxAgeTimestamp === "undefined") {
          return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
        if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
          return done(new TokenExpiredError("maxAge exceeded", new Date(maxAgeTimestamp * 1000)));
        }
      }
      if (options.complete === true) {
        const signature = decodedToken.signature;
        return done(null, {
          header,
          payload,
          signature
        });
      }
      return done(null, payload);
    });
  };
});

// node_modules/lodash.includes/index.js
var require_lodash2 = __commonJS((exports, module) => {
  var INFINITY = 1 / 0;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
  var NAN = 0 / 0;
  var argsTag = "[object Arguments]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var stringTag = "[object String]";
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var freeParseInt = parseInt;
  function arrayMap(array3, iteratee) {
    var index = -1, length = array3 ? array3.length : 0, result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array3[index], index, array3);
    }
    return result;
  }
  function baseFindIndex(array3, predicate, fromIndex, fromRight) {
    var length = array3.length, index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length) {
      if (predicate(array3[index], index, array3)) {
        return index;
      }
    }
    return -1;
  }
  function baseIndexOf(array3, value2, fromIndex) {
    if (value2 !== value2) {
      return baseFindIndex(array3, baseIsNaN, fromIndex);
    }
    var index = fromIndex - 1, length = array3.length;
    while (++index < length) {
      if (array3[index] === value2) {
        return index;
      }
    }
    return -1;
  }
  function baseIsNaN(value2) {
    return value2 !== value2;
  }
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  function baseValues(object3, props) {
    return arrayMap(props, function(key) {
      return object3[key];
    });
  }
  function overArg(func, transform4) {
    return function(arg) {
      return func(transform4(arg));
    };
  }
  var objectProto = Object.prototype;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  var objectToString2 = objectProto.toString;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var nativeKeys = overArg(Object.keys, Object);
  var nativeMax = Math.max;
  function arrayLikeKeys(value2, inherited) {
    var result = isArray2(value2) || isArguments(value2) ? baseTimes(value2.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value2) {
      if ((inherited || hasOwnProperty2.call(value2, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function baseKeys(object3) {
    if (!isPrototype(object3)) {
      return nativeKeys(object3);
    }
    var result = [];
    for (var key in Object(object3)) {
      if (hasOwnProperty2.call(object3, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function isIndex(value2, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value2 == "number" || reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length);
  }
  function isPrototype(value2) {
    var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value2 === proto;
  }
  function includes2(collection, value2, fromIndex, guard4) {
    collection = isArrayLike(collection) ? collection : values(collection);
    fromIndex = fromIndex && !guard4 ? toInteger(fromIndex) : 0;
    var length = collection.length;
    if (fromIndex < 0) {
      fromIndex = nativeMax(length + fromIndex, 0);
    }
    return isString2(collection) ? fromIndex <= length && collection.indexOf(value2, fromIndex) > -1 : !!length && baseIndexOf(collection, value2, fromIndex) > -1;
  }
  function isArguments(value2) {
    return isArrayLikeObject(value2) && hasOwnProperty2.call(value2, "callee") && (!propertyIsEnumerable.call(value2, "callee") || objectToString2.call(value2) == argsTag);
  }
  var isArray2 = Array.isArray;
  function isArrayLike(value2) {
    return value2 != null && isLength(value2.length) && !isFunction2(value2);
  }
  function isArrayLikeObject(value2) {
    return isObjectLike(value2) && isArrayLike(value2);
  }
  function isFunction2(value2) {
    var tag = isObject3(value2) ? objectToString2.call(value2) : "";
    return tag == funcTag || tag == genTag;
  }
  function isLength(value2) {
    return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER;
  }
  function isObject3(value2) {
    var type3 = typeof value2;
    return !!value2 && (type3 == "object" || type3 == "function");
  }
  function isObjectLike(value2) {
    return !!value2 && typeof value2 == "object";
  }
  function isString2(value2) {
    return typeof value2 == "string" || !isArray2(value2) && isObjectLike(value2) && objectToString2.call(value2) == stringTag;
  }
  function isSymbol2(value2) {
    return typeof value2 == "symbol" || isObjectLike(value2) && objectToString2.call(value2) == symbolTag;
  }
  function toFinite(value2) {
    if (!value2) {
      return value2 === 0 ? value2 : 0;
    }
    value2 = toNumber(value2);
    if (value2 === INFINITY || value2 === -INFINITY) {
      var sign = value2 < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value2 === value2 ? value2 : 0;
  }
  function toInteger(value2) {
    var result = toFinite(value2), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  function toNumber(value2) {
    if (typeof value2 == "number") {
      return value2;
    }
    if (isSymbol2(value2)) {
      return NAN;
    }
    if (isObject3(value2)) {
      var other = typeof value2.valueOf == "function" ? value2.valueOf() : value2;
      value2 = isObject3(other) ? other + "" : other;
    }
    if (typeof value2 != "string") {
      return value2 === 0 ? value2 : +value2;
    }
    value2 = value2.replace(reTrim, "");
    var isBinary = reIsBinary.test(value2);
    return isBinary || reIsOctal.test(value2) ? freeParseInt(value2.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value2) ? NAN : +value2;
  }
  function keys(object3) {
    return isArrayLike(object3) ? arrayLikeKeys(object3) : baseKeys(object3);
  }
  function values(object3) {
    return object3 ? baseValues(object3, keys(object3)) : [];
  }
  module.exports = includes2;
});

// node_modules/lodash.isboolean/index.js
var require_lodash3 = __commonJS((exports, module) => {
  var boolTag = "[object Boolean]";
  var objectProto = Object.prototype;
  var objectToString2 = objectProto.toString;
  function isBoolean2(value2) {
    return value2 === true || value2 === false || isObjectLike(value2) && objectToString2.call(value2) == boolTag;
  }
  function isObjectLike(value2) {
    return !!value2 && typeof value2 == "object";
  }
  module.exports = isBoolean2;
});

// node_modules/lodash.isinteger/index.js
var require_lodash4 = __commonJS((exports, module) => {
  var INFINITY = 1 / 0;
  var MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
  var NAN = 0 / 0;
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  var objectProto = Object.prototype;
  var objectToString2 = objectProto.toString;
  function isInteger(value2) {
    return typeof value2 == "number" && value2 == toInteger(value2);
  }
  function isObject3(value2) {
    var type3 = typeof value2;
    return !!value2 && (type3 == "object" || type3 == "function");
  }
  function isObjectLike(value2) {
    return !!value2 && typeof value2 == "object";
  }
  function isSymbol2(value2) {
    return typeof value2 == "symbol" || isObjectLike(value2) && objectToString2.call(value2) == symbolTag;
  }
  function toFinite(value2) {
    if (!value2) {
      return value2 === 0 ? value2 : 0;
    }
    value2 = toNumber(value2);
    if (value2 === INFINITY || value2 === -INFINITY) {
      var sign = value2 < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value2 === value2 ? value2 : 0;
  }
  function toInteger(value2) {
    var result = toFinite(value2), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  function toNumber(value2) {
    if (typeof value2 == "number") {
      return value2;
    }
    if (isSymbol2(value2)) {
      return NAN;
    }
    if (isObject3(value2)) {
      var other = typeof value2.valueOf == "function" ? value2.valueOf() : value2;
      value2 = isObject3(other) ? other + "" : other;
    }
    if (typeof value2 != "string") {
      return value2 === 0 ? value2 : +value2;
    }
    value2 = value2.replace(reTrim, "");
    var isBinary = reIsBinary.test(value2);
    return isBinary || reIsOctal.test(value2) ? freeParseInt(value2.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value2) ? NAN : +value2;
  }
  module.exports = isInteger;
});

// node_modules/lodash.isnumber/index.js
var require_lodash5 = __commonJS((exports, module) => {
  var numberTag = "[object Number]";
  var objectProto = Object.prototype;
  var objectToString2 = objectProto.toString;
  function isObjectLike(value2) {
    return !!value2 && typeof value2 == "object";
  }
  function isNumber2(value2) {
    return typeof value2 == "number" || isObjectLike(value2) && objectToString2.call(value2) == numberTag;
  }
  module.exports = isNumber2;
});

// node_modules/lodash.isplainobject/index.js
var require_lodash6 = __commonJS((exports, module) => {
  var objectTag = "[object Object]";
  function isHostObject(value2) {
    var result = false;
    if (value2 != null && typeof value2.toString != "function") {
      try {
        result = !!(value2 + "");
      } catch (e) {}
    }
    return result;
  }
  function overArg(func, transform4) {
    return function(arg) {
      return func(transform4(arg));
    };
  }
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  var objectToString2 = objectProto.toString;
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  function isObjectLike(value2) {
    return !!value2 && typeof value2 == "object";
  }
  function isPlainObject(value2) {
    if (!isObjectLike(value2) || objectToString2.call(value2) != objectTag || isHostObject(value2)) {
      return false;
    }
    var proto = getPrototype(value2);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  module.exports = isPlainObject;
});

// node_modules/lodash.isstring/index.js
var require_lodash7 = __commonJS((exports, module) => {
  var stringTag = "[object String]";
  var objectProto = Object.prototype;
  var objectToString2 = objectProto.toString;
  var isArray2 = Array.isArray;
  function isObjectLike(value2) {
    return !!value2 && typeof value2 == "object";
  }
  function isString2(value2) {
    return typeof value2 == "string" || !isArray2(value2) && isObjectLike(value2) && objectToString2.call(value2) == stringTag;
  }
  module.exports = isString2;
});

// node_modules/lodash.once/index.js
var require_lodash8 = __commonJS((exports, module) => {
  var FUNC_ERROR_TEXT = "Expected a function";
  var INFINITY = 1 / 0;
  var MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
  var NAN = 0 / 0;
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  var objectProto = Object.prototype;
  var objectToString2 = objectProto.toString;
  function before(n, func) {
    var result;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    n = toInteger(n);
    return function() {
      if (--n > 0) {
        result = func.apply(this, arguments);
      }
      if (n <= 1) {
        func = undefined;
      }
      return result;
    };
  }
  function once3(func) {
    return before(2, func);
  }
  function isObject3(value2) {
    var type3 = typeof value2;
    return !!value2 && (type3 == "object" || type3 == "function");
  }
  function isObjectLike(value2) {
    return !!value2 && typeof value2 == "object";
  }
  function isSymbol2(value2) {
    return typeof value2 == "symbol" || isObjectLike(value2) && objectToString2.call(value2) == symbolTag;
  }
  function toFinite(value2) {
    if (!value2) {
      return value2 === 0 ? value2 : 0;
    }
    value2 = toNumber(value2);
    if (value2 === INFINITY || value2 === -INFINITY) {
      var sign = value2 < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value2 === value2 ? value2 : 0;
  }
  function toInteger(value2) {
    var result = toFinite(value2), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  function toNumber(value2) {
    if (typeof value2 == "number") {
      return value2;
    }
    if (isSymbol2(value2)) {
      return NAN;
    }
    if (isObject3(value2)) {
      var other = typeof value2.valueOf == "function" ? value2.valueOf() : value2;
      value2 = isObject3(other) ? other + "" : other;
    }
    if (typeof value2 != "string") {
      return value2 === 0 ? value2 : +value2;
    }
    value2 = value2.replace(reTrim, "");
    var isBinary = reIsBinary.test(value2);
    return isBinary || reIsOctal.test(value2) ? freeParseInt(value2.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value2) ? NAN : +value2;
  }
  module.exports = once3;
});

// node_modules/jsonwebtoken/sign.js
var require_sign = __commonJS((exports, module) => {
  var timespan = require_timespan();
  var PS_SUPPORTED = require_psSupported();
  var validateAsymmetricKey = require_validateAsymmetricKey();
  var jws = require_jws();
  var includes2 = require_lodash2();
  var isBoolean2 = require_lodash3();
  var isInteger = require_lodash4();
  var isNumber2 = require_lodash5();
  var isPlainObject = require_lodash6();
  var isString2 = require_lodash7();
  var once3 = require_lodash8();
  var { KeyObject, createSecretKey, createPrivateKey } = (init_crypto(), __toCommonJS(exports_crypto));
  var SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
  if (PS_SUPPORTED) {
    SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
  }
  var sign_options_schema = {
    expiresIn: { isValid: function(value2) {
      return isInteger(value2) || isString2(value2) && value2;
    }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
    notBefore: { isValid: function(value2) {
      return isInteger(value2) || isString2(value2) && value2;
    }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
    audience: { isValid: function(value2) {
      return isString2(value2) || Array.isArray(value2);
    }, message: '"audience" must be a string or array' },
    algorithm: { isValid: includes2.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
    header: { isValid: isPlainObject, message: '"header" must be an object' },
    encoding: { isValid: isString2, message: '"encoding" must be a string' },
    issuer: { isValid: isString2, message: '"issuer" must be a string' },
    subject: { isValid: isString2, message: '"subject" must be a string' },
    jwtid: { isValid: isString2, message: '"jwtid" must be a string' },
    noTimestamp: { isValid: isBoolean2, message: '"noTimestamp" must be a boolean' },
    keyid: { isValid: isString2, message: '"keyid" must be a string' },
    mutatePayload: { isValid: isBoolean2, message: '"mutatePayload" must be a boolean' },
    allowInsecureKeySizes: { isValid: isBoolean2, message: '"allowInsecureKeySizes" must be a boolean' },
    allowInvalidAsymmetricKeyTypes: { isValid: isBoolean2, message: '"allowInvalidAsymmetricKeyTypes" must be a boolean' }
  };
  var registered_claims_schema = {
    iat: { isValid: isNumber2, message: '"iat" should be a number of seconds' },
    exp: { isValid: isNumber2, message: '"exp" should be a number of seconds' },
    nbf: { isValid: isNumber2, message: '"nbf" should be a number of seconds' }
  };
  function validate(schema3, allowUnknown, object3, parameterName) {
    if (!isPlainObject(object3)) {
      throw new Error('Expected "' + parameterName + '" to be a plain object.');
    }
    Object.keys(object3).forEach(function(key) {
      const validator = schema3[key];
      if (!validator) {
        if (!allowUnknown) {
          throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
        }
        return;
      }
      if (!validator.isValid(object3[key])) {
        throw new Error(validator.message);
      }
    });
  }
  function validateOptions(options) {
    return validate(sign_options_schema, false, options, "options");
  }
  function validatePayload(payload) {
    return validate(registered_claims_schema, true, payload, "payload");
  }
  var options_to_payload = {
    audience: "aud",
    issuer: "iss",
    subject: "sub",
    jwtid: "jti"
  };
  var options_for_objects = [
    "expiresIn",
    "notBefore",
    "noTimestamp",
    "audience",
    "issuer",
    "subject",
    "jwtid"
  ];
  module.exports = function(payload, secretOrPrivateKey, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    } else {
      options = options || {};
    }
    const isObjectPayload = typeof payload === "object" && !Buffer.isBuffer(payload);
    const header = Object.assign({
      alg: options.algorithm || "HS256",
      typ: isObjectPayload ? "JWT" : undefined,
      kid: options.keyid
    }, options.header);
    function failure(err) {
      if (callback) {
        return callback(err);
      }
      throw err;
    }
    if (!secretOrPrivateKey && options.algorithm !== "none") {
      return failure(new Error("secretOrPrivateKey must have a value"));
    }
    if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject)) {
      try {
        secretOrPrivateKey = createPrivateKey(secretOrPrivateKey);
      } catch (_) {
        try {
          secretOrPrivateKey = createSecretKey(typeof secretOrPrivateKey === "string" ? Buffer.from(secretOrPrivateKey) : secretOrPrivateKey);
        } catch (_2) {
          return failure(new Error("secretOrPrivateKey is not valid key material"));
        }
      }
    }
    if (header.alg.startsWith("HS") && secretOrPrivateKey.type !== "secret") {
      return failure(new Error(`secretOrPrivateKey must be a symmetric key when using ${header.alg}`));
    } else if (/^(?:RS|PS|ES)/.test(header.alg)) {
      if (secretOrPrivateKey.type !== "private") {
        return failure(new Error(`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`));
      }
      if (!options.allowInsecureKeySizes && !header.alg.startsWith("ES") && secretOrPrivateKey.asymmetricKeyDetails !== undefined && secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) {
        return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
      }
    }
    if (typeof payload === "undefined") {
      return failure(new Error("payload is required"));
    } else if (isObjectPayload) {
      try {
        validatePayload(payload);
      } catch (error3) {
        return failure(error3);
      }
      if (!options.mutatePayload) {
        payload = Object.assign({}, payload);
      }
    } else {
      const invalid_options = options_for_objects.filter(function(opt) {
        return typeof options[opt] !== "undefined";
      });
      if (invalid_options.length > 0) {
        return failure(new Error("invalid " + invalid_options.join(",") + " option for " + typeof payload + " payload"));
      }
    }
    if (typeof payload.exp !== "undefined" && typeof options.expiresIn !== "undefined") {
      return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
    }
    if (typeof payload.nbf !== "undefined" && typeof options.notBefore !== "undefined") {
      return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
    }
    try {
      validateOptions(options);
    } catch (error3) {
      return failure(error3);
    }
    if (!options.allowInvalidAsymmetricKeyTypes) {
      try {
        validateAsymmetricKey(header.alg, secretOrPrivateKey);
      } catch (error3) {
        return failure(error3);
      }
    }
    const timestamp2 = payload.iat || Math.floor(Date.now() / 1000);
    if (options.noTimestamp) {
      delete payload.iat;
    } else if (isObjectPayload) {
      payload.iat = timestamp2;
    }
    if (typeof options.notBefore !== "undefined") {
      try {
        payload.nbf = timespan(options.notBefore, timestamp2);
      } catch (err) {
        return failure(err);
      }
      if (typeof payload.nbf === "undefined") {
        return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
      }
    }
    if (typeof options.expiresIn !== "undefined" && typeof payload === "object") {
      try {
        payload.exp = timespan(options.expiresIn, timestamp2);
      } catch (err) {
        return failure(err);
      }
      if (typeof payload.exp === "undefined") {
        return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
      }
    }
    Object.keys(options_to_payload).forEach(function(key) {
      const claim = options_to_payload[key];
      if (typeof options[key] !== "undefined") {
        if (typeof payload[claim] !== "undefined") {
          return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
        }
        payload[claim] = options[key];
      }
    });
    const encoding = options.encoding || "utf8";
    if (typeof callback === "function") {
      callback = callback && once3(callback);
      jws.createSign({
        header,
        privateKey: secretOrPrivateKey,
        payload,
        encoding
      }).once("error", callback).once("done", function(signature) {
        if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
          return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
        }
        callback(null, signature);
      });
    } else {
      let signature = jws.sign({ header, payload, secret: secretOrPrivateKey, encoding });
      if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
        throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`);
      }
      return signature;
    }
  };
});

// node_modules/jsonwebtoken/index.js
var require_jsonwebtoken = __commonJS((exports, module) => {
  module.exports = {
    decode: require_decode(),
    verify: require_verify(),
    sign: require_sign(),
    JsonWebTokenError: require_JsonWebTokenError(),
    NotBeforeError: require_NotBeforeError(),
    TokenExpiredError: require_TokenExpiredError()
  };
});

// node_modules/memoirist/dist/index.mjs
var createNode = (part, inert) => ({
  part,
  store: null,
  inert: inert !== undefined ? new Map(inert.map((child) => [child.part.charCodeAt(0), child])) : null,
  params: null,
  wildcardStore: null
});
var cloneNode = (node, part) => ({
  ...node,
  part
});
var createParamNode = (paramName) => ({
  paramName,
  store: null,
  inert: null
});
var Memoirist = class _Memoirist {
  root = {};
  history = [];
  static regex = {
    static: /:.+?(?=\/|$)/,
    params: /:.+?(?=\/|$)/g
  };
  add(method, path, store) {
    if (typeof path !== "string")
      throw new TypeError("Route path must be a string");
    if (path === "")
      path = "/";
    else if (path[0] !== "/")
      path = `/${path}`;
    this.history.push([method, path, store]);
    const isWildcard = path[path.length - 1] === "*";
    if (isWildcard) {
      path = path.slice(0, -1);
    }
    const inertParts = path.split(_Memoirist.regex.static);
    const paramParts = path.match(_Memoirist.regex.params) || [];
    if (inertParts[inertParts.length - 1] === "")
      inertParts.pop();
    let node;
    if (!this.root[method])
      node = this.root[method] = createNode("/");
    else
      node = this.root[method];
    let paramPartsIndex = 0;
    for (let i = 0;i < inertParts.length; ++i) {
      let part = inertParts[i];
      if (i > 0) {
        const param = paramParts[paramPartsIndex++].slice(1);
        if (node.params === null)
          node.params = createParamNode(param);
        else if (node.params.paramName !== param)
          throw new Error(`Cannot create route "${path}" with parameter "${param}" because a route already exists with a different parameter name ("${node.params.paramName}") in the same location`);
        const params = node.params;
        if (params.inert === null) {
          node = params.inert = createNode(part);
          continue;
        }
        node = params.inert;
      }
      for (let j = 0;; ) {
        if (j === part.length) {
          if (j < node.part.length) {
            const childNode = cloneNode(node, node.part.slice(j));
            Object.assign(node, createNode(part, [childNode]));
          }
          break;
        }
        if (j === node.part.length) {
          if (node.inert === null)
            node.inert = /* @__PURE__ */ new Map;
          else if (node.inert.has(part.charCodeAt(j))) {
            node = node.inert.get(part.charCodeAt(j));
            part = part.slice(j);
            j = 0;
            continue;
          }
          const childNode = createNode(part.slice(j));
          node.inert.set(part.charCodeAt(j), childNode);
          node = childNode;
          break;
        }
        if (part[j] !== node.part[j]) {
          const existingChild = cloneNode(node, node.part.slice(j));
          const newChild = createNode(part.slice(j));
          Object.assign(node, createNode(node.part.slice(0, j), [
            existingChild,
            newChild
          ]));
          node = newChild;
          break;
        }
        ++j;
      }
    }
    if (paramPartsIndex < paramParts.length) {
      const param = paramParts[paramPartsIndex];
      const paramName = param.slice(1);
      if (node.params === null)
        node.params = createParamNode(paramName);
      else if (node.params.paramName !== paramName)
        throw new Error(`Cannot create route "${path}" with parameter "${paramName}" because a route already exists with a different parameter name ("${node.params.paramName}") in the same location`);
      if (node.params.store === null)
        node.params.store = store;
      return node.params.store;
    }
    if (isWildcard) {
      if (node.wildcardStore === null)
        node.wildcardStore = store;
      return node.wildcardStore;
    }
    if (node.store === null)
      node.store = store;
    return node.store;
  }
  find(method, url) {
    const root = this.root[method];
    if (!root)
      return null;
    return matchRoute(url, url.length, root, 0);
  }
};
var matchRoute = (url, urlLength, node, startIndex) => {
  const part = node?.part;
  const endIndex = startIndex + part.length;
  if (part.length > 1) {
    if (endIndex > urlLength)
      return null;
    if (part.length < 15) {
      for (let i = 1, j = startIndex + 1;i < part.length; ++i, ++j)
        if (part.charCodeAt(i) !== url.charCodeAt(j))
          return null;
    } else if (url.substring(startIndex, endIndex) !== part)
      return null;
  }
  if (endIndex === urlLength) {
    if (node.store !== null)
      return {
        store: node.store,
        params: {}
      };
    if (node.wildcardStore !== null)
      return {
        store: node.wildcardStore,
        params: { "*": "" }
      };
    return null;
  }
  if (node.inert !== null) {
    const inert = node.inert.get(url.charCodeAt(endIndex));
    if (inert !== undefined) {
      const route = matchRoute(url, urlLength, inert, endIndex);
      if (route !== null)
        return route;
    }
  }
  if (node.params !== null) {
    const param = node.params;
    const slashIndex = url.indexOf("/", endIndex);
    if (slashIndex !== endIndex) {
      if (slashIndex === -1 || slashIndex >= urlLength) {
        if (param.store !== null) {
          const params = {};
          params[param.paramName] = url.substring(endIndex, urlLength);
          return {
            store: param.store,
            params
          };
        }
      } else if (param.inert !== null) {
        const route = matchRoute(url, urlLength, param.inert, slashIndex);
        if (route !== null) {
          route.params[param.paramName] = url.substring(endIndex, slashIndex);
          return route;
        }
      }
    }
  }
  if (node.wildcardStore !== null)
    return {
      store: node.wildcardStore,
      params: {
        "*": url.substring(endIndex, urlLength)
      }
    };
  return null;
};

// node_modules/eventemitter3/index.mjs
var import__ = __toESM(require_eventemitter3(), 1);
var eventemitter3_default = import__.default;

// node_modules/@sinclair/typebox/build/esm/value/guard/guard.mjs
function IsAsyncIterator(value) {
  return IsObject(value) && Symbol.asyncIterator in value;
}
function IsIterator(value) {
  return IsObject(value) && Symbol.iterator in value;
}
function IsStandardObject(value) {
  return IsObject(value) && (Object.getPrototypeOf(value) === Object.prototype || Object.getPrototypeOf(value) === null);
}
function IsPromise(value) {
  return value instanceof Promise;
}
function IsDate(value) {
  return value instanceof Date && Number.isFinite(value.getTime());
}
function IsTypedArray(value) {
  return ArrayBuffer.isView(value);
}
function IsUint8Array(value) {
  return value instanceof globalThis.Uint8Array;
}
function HasPropertyKey(value, key) {
  return key in value;
}
function IsObject(value) {
  return value !== null && typeof value === "object";
}
function IsArray(value) {
  return Array.isArray(value) && !ArrayBuffer.isView(value);
}
function IsUndefined(value) {
  return value === undefined;
}
function IsNull(value) {
  return value === null;
}
function IsBoolean(value) {
  return typeof value === "boolean";
}
function IsNumber(value) {
  return typeof value === "number";
}
function IsInteger(value) {
  return Number.isInteger(value);
}
function IsBigInt(value) {
  return typeof value === "bigint";
}
function IsString(value) {
  return typeof value === "string";
}
function IsFunction(value) {
  return typeof value === "function";
}
function IsSymbol(value) {
  return typeof value === "symbol";
}
function IsValueType(value) {
  return IsBigInt(value) || IsBoolean(value) || IsNull(value) || IsNumber(value) || IsString(value) || IsSymbol(value) || IsUndefined(value);
}
// node_modules/@sinclair/typebox/build/esm/system/policy.mjs
var TypeSystemPolicy;
(function(TypeSystemPolicy2) {
  TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
  TypeSystemPolicy2.AllowArrayObject = false;
  TypeSystemPolicy2.AllowNaN = false;
  TypeSystemPolicy2.AllowNullVoid = false;
  function IsExactOptionalProperty(value, key) {
    return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
  }
  TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    const isObject = IsObject(value);
    return TypeSystemPolicy2.AllowArrayObject ? isObject : isObject && !IsArray(value);
  }
  TypeSystemPolicy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
  }
  TypeSystemPolicy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy2.AllowNaN ? IsNumber(value) : Number.isFinite(value);
  }
  TypeSystemPolicy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    const isUndefined = IsUndefined(value);
    return TypeSystemPolicy2.AllowNullVoid ? isUndefined || value === null : isUndefined;
  }
  TypeSystemPolicy2.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy || (TypeSystemPolicy = {}));
// node_modules/@sinclair/typebox/build/esm/type/registry/format.mjs
var exports_format = {};
__export(exports_format, {
  Set: () => Set2,
  Has: () => Has,
  Get: () => Get,
  Entries: () => Entries,
  Delete: () => Delete,
  Clear: () => Clear
});
var map = new Map;
function Entries() {
  return new Map(map);
}
function Clear() {
  return map.clear();
}
function Delete(format) {
  return map.delete(format);
}
function Has(format) {
  return map.has(format);
}
function Set2(format, func) {
  map.set(format, func);
}
function Get(format) {
  return map.get(format);
}
// node_modules/@sinclair/typebox/build/esm/type/registry/type.mjs
var exports_type = {};
__export(exports_type, {
  Set: () => Set3,
  Has: () => Has2,
  Get: () => Get2,
  Entries: () => Entries2,
  Delete: () => Delete2,
  Clear: () => Clear2
});
var map2 = new Map;
function Entries2() {
  return new Map(map2);
}
function Clear2() {
  return map2.clear();
}
function Delete2(kind) {
  return map2.delete(kind);
}
function Has2(kind) {
  return map2.has(kind);
}
function Set3(kind, func) {
  map2.set(kind, func);
}
function Get2(kind) {
  return map2.get(kind);
}
// node_modules/@sinclair/typebox/build/esm/type/symbols/symbols.mjs
var TransformKind = Symbol.for("TypeBox.Transform");
var ReadonlyKind = Symbol.for("TypeBox.Readonly");
var OptionalKind = Symbol.for("TypeBox.Optional");
var Hint = Symbol.for("TypeBox.Hint");
var Kind = Symbol.for("TypeBox.Kind");
// node_modules/@sinclair/typebox/build/esm/type/unsafe/unsafe.mjs
function Unsafe(options = {}) {
  return {
    ...options,
    [Kind]: options[Kind] ?? "Unsafe"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/error/error.mjs
class TypeBoxError extends Error {
  constructor(message) {
    super(message);
  }
}
// node_modules/@sinclair/typebox/build/esm/system/system.mjs
class TypeSystemDuplicateTypeKind extends TypeBoxError {
  constructor(kind) {
    super(`Duplicate type kind '${kind}' detected`);
  }
}

class TypeSystemDuplicateFormat extends TypeBoxError {
  constructor(kind) {
    super(`Duplicate string format '${kind}' detected`);
  }
}
var TypeSystem;
(function(TypeSystem2) {
  function Type(kind, check) {
    if (exports_type.Has(kind))
      throw new TypeSystemDuplicateTypeKind(kind);
    exports_type.Set(kind, check);
    return (options = {}) => Unsafe({ ...options, [Kind]: kind });
  }
  TypeSystem2.Type = Type;
  function Format(format, check) {
    if (exports_format.Has(format))
      throw new TypeSystemDuplicateFormat(format);
    exports_format.Set(format, check);
    return format;
  }
  TypeSystem2.Format = Format;
})(TypeSystem || (TypeSystem = {}));
// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped-result.mjs
function MappedResult(properties) {
  return {
    [Kind]: "MappedResult",
    properties
  };
}
// node_modules/@sinclair/typebox/build/esm/type/guard/value.mjs
var exports_value = {};
__export(exports_value, {
  IsUndefined: () => IsUndefined2,
  IsUint8Array: () => IsUint8Array2,
  IsSymbol: () => IsSymbol2,
  IsString: () => IsString2,
  IsRegExp: () => IsRegExp,
  IsObject: () => IsObject2,
  IsNumber: () => IsNumber2,
  IsNull: () => IsNull2,
  IsIterator: () => IsIterator2,
  IsFunction: () => IsFunction2,
  IsDate: () => IsDate2,
  IsBoolean: () => IsBoolean2,
  IsBigInt: () => IsBigInt2,
  IsAsyncIterator: () => IsAsyncIterator2,
  IsArray: () => IsArray2
});
function IsAsyncIterator2(value) {
  return IsObject2(value) && !IsArray2(value) && !IsUint8Array2(value) && Symbol.asyncIterator in value;
}
function IsArray2(value) {
  return Array.isArray(value);
}
function IsBigInt2(value) {
  return typeof value === "bigint";
}
function IsBoolean2(value) {
  return typeof value === "boolean";
}
function IsDate2(value) {
  return value instanceof globalThis.Date;
}
function IsFunction2(value) {
  return typeof value === "function";
}
function IsIterator2(value) {
  return IsObject2(value) && !IsArray2(value) && !IsUint8Array2(value) && Symbol.iterator in value;
}
function IsNull2(value) {
  return value === null;
}
function IsNumber2(value) {
  return typeof value === "number";
}
function IsObject2(value) {
  return typeof value === "object" && value !== null;
}
function IsRegExp(value) {
  return value instanceof globalThis.RegExp;
}
function IsString2(value) {
  return typeof value === "string";
}
function IsSymbol2(value) {
  return typeof value === "symbol";
}
function IsUint8Array2(value) {
  return value instanceof globalThis.Uint8Array;
}
function IsUndefined2(value) {
  return value === undefined;
}

// node_modules/@sinclair/typebox/build/esm/type/clone/value.mjs
function ArrayType(value) {
  return value.map((value2) => Visit(value2));
}
function DateType(value) {
  return new Date(value.getTime());
}
function Uint8ArrayType(value) {
  return new Uint8Array(value);
}
function RegExpType(value) {
  return new RegExp(value.source, value.flags);
}
function ObjectType(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Visit(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Visit(value[key]);
  }
  return result;
}
function Visit(value) {
  return IsArray2(value) ? ArrayType(value) : IsDate2(value) ? DateType(value) : IsUint8Array2(value) ? Uint8ArrayType(value) : IsRegExp(value) ? RegExpType(value) : IsObject2(value) ? ObjectType(value) : value;
}
function Clone(value) {
  return Visit(value);
}

// node_modules/@sinclair/typebox/build/esm/type/clone/type.mjs
function CloneRest(schemas) {
  return schemas.map((schema) => CloneType(schema));
}
function CloneType(schema, options = {}) {
  return { ...Clone(schema), ...options };
}

// node_modules/@sinclair/typebox/build/esm/type/discard/discard.mjs
function DiscardKey(value, key) {
  const { [key]: _, ...rest } = value;
  return rest;
}
function Discard(value, keys) {
  return keys.reduce((acc, key) => DiscardKey(acc, key), value);
}
// node_modules/@sinclair/typebox/build/esm/type/array/array.mjs
function Array2(schema, options = {}) {
  return {
    ...options,
    [Kind]: "Array",
    type: "array",
    items: CloneType(schema)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/async-iterator/async-iterator.mjs
function AsyncIterator(items, options = {}) {
  return {
    ...options,
    [Kind]: "AsyncIterator",
    type: "AsyncIterator",
    items: CloneType(items)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/constructor/constructor.mjs
function Constructor(parameters, returns, options) {
  return {
    ...options,
    [Kind]: "Constructor",
    type: "Constructor",
    parameters: CloneRest(parameters),
    returns: CloneType(returns)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/function/function.mjs
function Function2(parameters, returns, options) {
  return {
    ...options,
    [Kind]: "Function",
    type: "Function",
    parameters: CloneRest(parameters),
    returns: CloneType(returns)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/never/never.mjs
function Never(options = {}) {
  return {
    ...options,
    [Kind]: "Never",
    not: {}
  };
}
// node_modules/@sinclair/typebox/build/esm/type/guard/kind.mjs
function IsReadonly(value) {
  return IsObject2(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional(value) {
  return IsObject2(value) && value[OptionalKind] === "Optional";
}
function IsAny(value) {
  return IsKindOf(value, "Any");
}
function IsArray3(value) {
  return IsKindOf(value, "Array");
}
function IsAsyncIterator3(value) {
  return IsKindOf(value, "AsyncIterator");
}
function IsBigInt3(value) {
  return IsKindOf(value, "BigInt");
}
function IsBoolean3(value) {
  return IsKindOf(value, "Boolean");
}
function IsConstructor(value) {
  return IsKindOf(value, "Constructor");
}
function IsDate3(value) {
  return IsKindOf(value, "Date");
}
function IsFunction3(value) {
  return IsKindOf(value, "Function");
}
function IsInteger2(value) {
  return IsKindOf(value, "Integer");
}
function IsIntersect(value) {
  return IsKindOf(value, "Intersect");
}
function IsIterator3(value) {
  return IsKindOf(value, "Iterator");
}
function IsKindOf(value, kind) {
  return IsObject2(value) && Kind in value && value[Kind] === kind;
}
function IsLiteral(value) {
  return IsKindOf(value, "Literal");
}
function IsMappedKey(value) {
  return IsKindOf(value, "MappedKey");
}
function IsMappedResult(value) {
  return IsKindOf(value, "MappedResult");
}
function IsNever(value) {
  return IsKindOf(value, "Never");
}
function IsNot(value) {
  return IsKindOf(value, "Not");
}
function IsNull3(value) {
  return IsKindOf(value, "Null");
}
function IsNumber3(value) {
  return IsKindOf(value, "Number");
}
function IsObject3(value) {
  return IsKindOf(value, "Object");
}
function IsPromise2(value) {
  return IsKindOf(value, "Promise");
}
function IsRecord(value) {
  return IsKindOf(value, "Record");
}
function IsRef(value) {
  return IsKindOf(value, "Ref");
}
function IsRegExp2(value) {
  return IsKindOf(value, "RegExp");
}
function IsString3(value) {
  return IsKindOf(value, "String");
}
function IsSymbol3(value) {
  return IsKindOf(value, "Symbol");
}
function IsTemplateLiteral(value) {
  return IsKindOf(value, "TemplateLiteral");
}
function IsThis(value) {
  return IsKindOf(value, "This");
}
function IsTransform(value) {
  return IsObject2(value) && TransformKind in value;
}
function IsTuple(value) {
  return IsKindOf(value, "Tuple");
}
function IsUndefined3(value) {
  return IsKindOf(value, "Undefined");
}
function IsUnion(value) {
  return IsKindOf(value, "Union");
}
function IsUint8Array3(value) {
  return IsKindOf(value, "Uint8Array");
}
function IsUnknown(value) {
  return IsKindOf(value, "Unknown");
}
function IsUnsafe(value) {
  return IsKindOf(value, "Unsafe");
}
function IsVoid(value) {
  return IsKindOf(value, "Void");
}
function IsKind(value) {
  return IsObject2(value) && Kind in value && IsString2(value[Kind]);
}
function IsSchema(value) {
  return IsAny(value) || IsArray3(value) || IsBoolean3(value) || IsBigInt3(value) || IsAsyncIterator3(value) || IsConstructor(value) || IsDate3(value) || IsFunction3(value) || IsInteger2(value) || IsIntersect(value) || IsIterator3(value) || IsLiteral(value) || IsMappedKey(value) || IsMappedResult(value) || IsNever(value) || IsNot(value) || IsNull3(value) || IsNumber3(value) || IsObject3(value) || IsPromise2(value) || IsRecord(value) || IsRef(value) || IsRegExp2(value) || IsString3(value) || IsSymbol3(value) || IsTemplateLiteral(value) || IsThis(value) || IsTuple(value) || IsUndefined3(value) || IsUnion(value) || IsUint8Array3(value) || IsUnknown(value) || IsUnsafe(value) || IsVoid(value) || IsKind(value);
}

// node_modules/@sinclair/typebox/build/esm/type/optional/optional.mjs
function RemoveOptional(schema) {
  return Discard(CloneType(schema), [OptionalKind]);
}
function AddOptional(schema) {
  return { ...CloneType(schema), [OptionalKind]: "Optional" };
}
function OptionalWithFlag(schema, F) {
  return F === false ? RemoveOptional(schema) : AddOptional(schema);
}
function Optional(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? OptionalFromMappedResult(schema, F) : OptionalWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/esm/type/optional/optional-from-mapped-result.mjs
function FromProperties(P, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Optional(P[K2], F);
  return Acc;
}
function FromMappedResult(R, F) {
  return FromProperties(R.properties, F);
}
function OptionalFromMappedResult(R, F) {
  const P = FromMappedResult(R, F);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-create.mjs
function IntersectCreate(T, options) {
  const allObjects = T.every((schema) => IsObject3(schema));
  const clonedUnevaluatedProperties = IsSchema(options.unevaluatedProperties) ? { unevaluatedProperties: CloneType(options.unevaluatedProperties) } : {};
  return options.unevaluatedProperties === false || IsSchema(options.unevaluatedProperties) || allObjects ? { ...options, ...clonedUnevaluatedProperties, [Kind]: "Intersect", type: "object", allOf: CloneRest(T) } : { ...options, ...clonedUnevaluatedProperties, [Kind]: "Intersect", allOf: CloneRest(T) };
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-evaluated.mjs
function IsIntersectOptional(T) {
  return T.every((L) => IsOptional(L));
}
function RemoveOptionalFromType(T) {
  return Discard(T, [OptionalKind]);
}
function RemoveOptionalFromRest(T) {
  return T.map((L) => IsOptional(L) ? RemoveOptionalFromType(L) : L);
}
function ResolveIntersect(T, options) {
  return IsIntersectOptional(T) ? Optional(IntersectCreate(RemoveOptionalFromRest(T), options)) : IntersectCreate(RemoveOptionalFromRest(T), options);
}
function IntersectEvaluated(T, options = {}) {
  if (T.length === 0)
    return Never(options);
  if (T.length === 1)
    return CloneType(T[0], options);
  if (T.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect(T, options);
}
// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect.mjs
function Intersect(T, options = {}) {
  if (T.length === 0)
    return Never(options);
  if (T.length === 1)
    return CloneType(T[0], options);
  if (T.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate(T, options);
}
// node_modules/@sinclair/typebox/build/esm/type/union/union-create.mjs
function UnionCreate(T, options) {
  return { ...options, [Kind]: "Union", anyOf: CloneRest(T) };
}

// node_modules/@sinclair/typebox/build/esm/type/union/union-evaluated.mjs
function IsUnionOptional(T) {
  return T.some((L) => IsOptional(L));
}
function RemoveOptionalFromRest2(T) {
  return T.map((L) => IsOptional(L) ? RemoveOptionalFromType2(L) : L);
}
function RemoveOptionalFromType2(T) {
  return Discard(T, [OptionalKind]);
}
function ResolveUnion(T, options) {
  return IsUnionOptional(T) ? Optional(UnionCreate(RemoveOptionalFromRest2(T), options)) : UnionCreate(RemoveOptionalFromRest2(T), options);
}
function UnionEvaluated(T, options = {}) {
  return T.length === 0 ? Never(options) : T.length === 1 ? CloneType(T[0], options) : ResolveUnion(T, options);
}
// node_modules/@sinclair/typebox/build/esm/type/union/union.mjs
function Union(T, options = {}) {
  return T.length === 0 ? Never(options) : T.length === 1 ? CloneType(T[0], options) : UnionCreate(T, options);
}
// node_modules/@sinclair/typebox/build/esm/type/template-literal/parse.mjs
class TemplateLiteralParserError extends TypeBoxError {
}
function Unescape(pattern) {
  return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}
function IsNonEscaped(pattern, index, char) {
  return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
}
function IsOpenParen(pattern, index) {
  return IsNonEscaped(pattern, index, "(");
}
function IsCloseParen(pattern, index) {
  return IsNonEscaped(pattern, index, ")");
}
function IsSeparator(pattern, index) {
  return IsNonEscaped(pattern, index, "|");
}
function IsGroup(pattern) {
  if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
    return false;
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (count === 0 && index !== pattern.length - 1)
      return false;
  }
  return true;
}
function InGroup(pattern) {
  return pattern.slice(1, pattern.length - 1);
}
function IsPrecedenceOr(pattern) {
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0)
      return true;
  }
  return false;
}
function IsPrecedenceAnd(pattern) {
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      return true;
  }
  return false;
}
function Or(pattern) {
  let [count, start] = [0, 0];
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0) {
      const range2 = pattern.slice(start, index);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse(range2));
      start = index + 1;
    }
  }
  const range = pattern.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
}
function And(pattern) {
  function Group(value, index) {
    if (!IsOpenParen(value, index))
      throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
    let count = 0;
    for (let scan = index;scan < value.length; scan++) {
      if (IsOpenParen(value, scan))
        count += 1;
      if (IsCloseParen(value, scan))
        count -= 1;
      if (count === 0)
        return [index, scan];
    }
    throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern2, index) {
    for (let scan = index;scan < pattern2.length; scan++) {
      if (IsOpenParen(pattern2, scan))
        return [index, scan];
    }
    return [index, pattern2.length];
  }
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index)) {
      const [start, end] = Group(pattern, index);
      const range = pattern.slice(start, end + 1);
      expressions.push(TemplateLiteralParse(range));
      index = end;
    } else {
      const [start, end] = Range(pattern, index);
      const range = pattern.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse(range));
      index = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
}
function TemplateLiteralParse(pattern) {
  return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: Unescape(pattern) };
}
function TemplateLiteralParseExact(pattern) {
  return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/finite.mjs
class TemplateLiteralFiniteError extends TypeBoxError {
}
function IsNumberExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
}
function IsBooleanExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
}
function IsStringExpression(expression) {
  return expression.type === "const" && expression.const === ".*";
}
function IsTemplateLiteralExpressionFinite(expression) {
  return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression);
}
// node_modules/@sinclair/typebox/build/esm/type/template-literal/generate.mjs
class TemplateLiteralGenerateError extends TypeBoxError {
}
function* GenerateReduce(buffer) {
  if (buffer.length === 1)
    return yield* buffer[0];
  for (const left of buffer[0]) {
    for (const right of GenerateReduce(buffer.slice(1))) {
      yield `${left}${right}`;
    }
  }
}
function* GenerateAnd(expression) {
  return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
}
function* GenerateOr(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate(expr);
}
function* GenerateConst(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate(expression) {
  return expression.type === "and" ? yield* GenerateAnd(expression) : expression.type === "or" ? yield* GenerateOr(expression) : expression.type === "const" ? yield* GenerateConst(expression) : (() => {
    throw new TemplateLiteralGenerateError("Unknown expression");
  })();
}
function TemplateLiteralGenerate(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];
}
// node_modules/@sinclair/typebox/build/esm/type/literal/literal.mjs
function Literal(value, options = {}) {
  return {
    ...options,
    [Kind]: "Literal",
    const: value,
    type: typeof value
  };
}
// node_modules/@sinclair/typebox/build/esm/type/boolean/boolean.mjs
function Boolean2(options = {}) {
  return {
    ...options,
    [Kind]: "Boolean",
    type: "boolean"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/bigint/bigint.mjs
function BigInt2(options = {}) {
  return {
    ...options,
    [Kind]: "BigInt",
    type: "bigint"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/number/number.mjs
function Number2(options = {}) {
  return {
    ...options,
    [Kind]: "Number",
    type: "number"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/string/string.mjs
function String2(options = {}) {
  return { ...options, [Kind]: "String", type: "string" };
}
// node_modules/@sinclair/typebox/build/esm/type/template-literal/syntax.mjs
function* FromUnion(syntax) {
  const trim = syntax.trim().replace(/"|'/g, "");
  return trim === "boolean" ? yield Boolean2() : trim === "number" ? yield Number2() : trim === "bigint" ? yield BigInt2() : trim === "string" ? yield String2() : yield (() => {
    const literals = trim.split("|").map((literal2) => Literal(literal2.trim()));
    return literals.length === 0 ? Never() : literals.length === 1 ? literals[0] : UnionEvaluated(literals);
  })();
}
function* FromTerminal(syntax) {
  if (syntax[1] !== "{") {
    const L = Literal("$");
    const R = FromSyntax(syntax.slice(1));
    return yield* [L, ...R];
  }
  for (let i = 2;i < syntax.length; i++) {
    if (syntax[i] === "}") {
      const L = FromUnion(syntax.slice(2, i));
      const R = FromSyntax(syntax.slice(i + 1));
      return yield* [...L, ...R];
    }
  }
  yield Literal(syntax);
}
function* FromSyntax(syntax) {
  for (let i = 0;i < syntax.length; i++) {
    if (syntax[i] === "$") {
      const L = Literal(syntax.slice(0, i));
      const R = FromTerminal(syntax.slice(i));
      return yield* [L, ...R];
    }
  }
  yield Literal(syntax);
}
function TemplateLiteralSyntax(syntax) {
  return [...FromSyntax(syntax)];
}
// node_modules/@sinclair/typebox/build/esm/type/patterns/patterns.mjs
var PatternBoolean = "(true|false)";
var PatternNumber = "(0|[1-9][0-9]*)";
var PatternString = "(.*)";
var PatternNever = "(?!.*)";
var PatternBooleanExact = `^${PatternBoolean}$`;
var PatternNumberExact = `^${PatternNumber}$`;
var PatternStringExact = `^${PatternString}$`;
var PatternNeverExact = `^${PatternNever}$`;
// node_modules/@sinclair/typebox/build/esm/type/template-literal/pattern.mjs
class TemplateLiteralPatternError extends TypeBoxError {
}
function Escape(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Visit2(schema, acc) {
  return IsTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : IsUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit2(schema2, acc)).join("|")})` : IsNumber3(schema) ? `${acc}${PatternNumber}` : IsInteger2(schema) ? `${acc}${PatternNumber}` : IsBigInt3(schema) ? `${acc}${PatternNumber}` : IsString3(schema) ? `${acc}${PatternString}` : IsLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : IsBoolean3(schema) ? `${acc}${PatternBoolean}` : (() => {
    throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`);
  })();
}
function TemplateLiteralPattern(kinds) {
  return `^${kinds.map((schema) => Visit2(schema, "")).join("")}$`;
}
// node_modules/@sinclair/typebox/build/esm/type/template-literal/union.mjs
function TemplateLiteralToUnion(schema) {
  const R = TemplateLiteralGenerate(schema);
  const L = R.map((S) => Literal(S));
  return UnionEvaluated(L);
}
// node_modules/@sinclair/typebox/build/esm/type/template-literal/template-literal.mjs
function TemplateLiteral(unresolved, options = {}) {
  const pattern = IsString2(unresolved) ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved)) : TemplateLiteralPattern(unresolved);
  return { ...options, [Kind]: "TemplateLiteral", type: "string", pattern };
}
// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-property-keys.mjs
function FromTemplateLiteral(T) {
  const R = TemplateLiteralGenerate(T);
  return R.map((S) => S.toString());
}
function FromUnion2(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...IndexPropertyKeys(L));
  return Acc;
}
function FromLiteral(T) {
  return [T.toString()];
}
function IndexPropertyKeys(T) {
  return [...new Set(IsTemplateLiteral(T) ? FromTemplateLiteral(T) : IsUnion(T) ? FromUnion2(T.anyOf) : IsLiteral(T) ? FromLiteral(T.const) : IsNumber3(T) ? ["[number]"] : IsInteger2(T) ? ["[number]"] : [])];
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-result.mjs
function FromProperties2(T, P, options) {
  const Acc = {};
  for (const K2 of Object.getOwnPropertyNames(P)) {
    Acc[K2] = Index(T, IndexPropertyKeys(P[K2]), options);
  }
  return Acc;
}
function FromMappedResult2(T, R, options) {
  return FromProperties2(T, R.properties, options);
}
function IndexFromMappedResult(T, R, options) {
  const P = FromMappedResult2(T, R, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed.mjs
function FromRest(T, K) {
  return T.map((L) => IndexFromPropertyKey(L, K));
}
function FromIntersectRest(T) {
  return T.filter((L) => !IsNever(L));
}
function FromIntersect(T, K) {
  return IntersectEvaluated(FromIntersectRest(FromRest(T, K)));
}
function FromUnionRest(T) {
  return T.some((L) => IsNever(L)) ? [] : T;
}
function FromUnion3(T, K) {
  return UnionEvaluated(FromUnionRest(FromRest(T, K)));
}
function FromTuple(T, K) {
  return K in T ? T[K] : K === "[number]" ? UnionEvaluated(T) : Never();
}
function FromArray(T, K) {
  return K === "[number]" ? T : Never();
}
function FromProperty(T, K) {
  return K in T ? T[K] : Never();
}
function IndexFromPropertyKey(T, K) {
  return IsIntersect(T) ? FromIntersect(T.allOf, K) : IsUnion(T) ? FromUnion3(T.anyOf, K) : IsTuple(T) ? FromTuple(T.items ?? [], K) : IsArray3(T) ? FromArray(T.items, K) : IsObject3(T) ? FromProperty(T.properties, K) : Never();
}
function IndexFromPropertyKeys(T, K) {
  return K.map((L) => IndexFromPropertyKey(T, L));
}
function FromSchema(T, K) {
  return UnionEvaluated(IndexFromPropertyKeys(T, K));
}
function Index(T, K, options = {}) {
  return IsMappedResult(K) ? CloneType(IndexFromMappedResult(T, K, options)) : IsMappedKey(K) ? CloneType(IndexFromMappedKey(T, K, options)) : IsSchema(K) ? CloneType(FromSchema(T, IndexPropertyKeys(K)), options) : CloneType(FromSchema(T, K), options);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-key.mjs
function MappedIndexPropertyKey(T, K, options) {
  return { [K]: Index(T, [K], options) };
}
function MappedIndexPropertyKeys(T, K, options) {
  return K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIndexPropertyKey(T, L, options) };
  }, {});
}
function MappedIndexProperties(T, K, options) {
  return MappedIndexPropertyKeys(T, K.keys, options);
}
function IndexFromMappedKey(T, K, options) {
  const P = MappedIndexProperties(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/iterator/iterator.mjs
function Iterator(items, options = {}) {
  return {
    ...options,
    [Kind]: "Iterator",
    type: "Iterator",
    items: CloneType(items)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/object/object.mjs
function _Object(properties, options = {}) {
  const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);
  const optionalKeys = propertyKeys.filter((key) => IsOptional(properties[key]));
  const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
  const clonedAdditionalProperties = IsSchema(options.additionalProperties) ? { additionalProperties: CloneType(options.additionalProperties) } : {};
  const clonedProperties = {};
  for (const key of propertyKeys)
    clonedProperties[key] = CloneType(properties[key]);
  return requiredKeys.length > 0 ? { ...options, ...clonedAdditionalProperties, [Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys } : { ...options, ...clonedAdditionalProperties, [Kind]: "Object", type: "object", properties: clonedProperties };
}
var Object2 = _Object;
// node_modules/@sinclair/typebox/build/esm/type/promise/promise.mjs
function Promise2(item, options = {}) {
  return {
    ...options,
    [Kind]: "Promise",
    type: "Promise",
    item: CloneType(item)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/readonly/readonly.mjs
function RemoveReadonly(schema) {
  return Discard(CloneType(schema), [ReadonlyKind]);
}
function AddReadonly(schema) {
  return { ...CloneType(schema), [ReadonlyKind]: "Readonly" };
}
function ReadonlyWithFlag(schema, F) {
  return F === false ? RemoveReadonly(schema) : AddReadonly(schema);
}
function Readonly(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? ReadonlyFromMappedResult(schema, F) : ReadonlyWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly/readonly-from-mapped-result.mjs
function FromProperties3(K, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Readonly(K[K2], F);
  return Acc;
}
function FromMappedResult3(R, F) {
  return FromProperties3(R.properties, F);
}
function ReadonlyFromMappedResult(R, F) {
  const P = FromMappedResult3(R, F);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/tuple/tuple.mjs
function Tuple(items, options = {}) {
  const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
  return items.length > 0 ? { ...options, [Kind]: "Tuple", type: "array", items: CloneRest(items), additionalItems, minItems, maxItems } : { ...options, [Kind]: "Tuple", type: "array", minItems, maxItems };
}
// node_modules/@sinclair/typebox/build/esm/type/sets/set.mjs
function SetIncludes(T, S) {
  return T.includes(S);
}
function SetDistinct(T) {
  return [...new Set(T)];
}
function SetIntersect(T, S) {
  return T.filter((L) => S.includes(L));
}
function SetIntersectManyResolve(T, Init) {
  return T.reduce((Acc, L) => {
    return SetIntersect(Acc, L);
  }, Init);
}
function SetIntersectMany(T) {
  return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve(T.slice(1), T[0]) : [];
}
function SetUnionMany(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...L);
  return Acc;
}
// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped.mjs
function FromMappedResult4(K, P) {
  return K in P ? FromSchemaType(K, P[K]) : MappedResult(P);
}
function MappedKeyToKnownMappedResultProperties(K) {
  return { [K]: Literal(K) };
}
function MappedKeyToUnknownMappedResultProperties(P) {
  const Acc = {};
  for (const L of P)
    Acc[L] = Literal(L);
  return Acc;
}
function MappedKeyToMappedResultProperties(K, P) {
  return SetIncludes(P, K) ? MappedKeyToKnownMappedResultProperties(K) : MappedKeyToUnknownMappedResultProperties(P);
}
function FromMappedKey(K, P) {
  const R = MappedKeyToMappedResultProperties(K, P);
  return FromMappedResult4(K, R);
}
function FromRest2(K, T) {
  return T.map((L) => FromSchemaType(K, L));
}
function FromProperties4(K, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(T))
    Acc[K2] = FromSchemaType(K, T[K2]);
  return Acc;
}
function FromSchemaType(K, T) {
  return IsOptional(T) ? Optional(FromSchemaType(K, Discard(T, [OptionalKind]))) : IsReadonly(T) ? Readonly(FromSchemaType(K, Discard(T, [ReadonlyKind]))) : IsMappedResult(T) ? FromMappedResult4(K, T.properties) : IsMappedKey(T) ? FromMappedKey(K, T.keys) : IsConstructor(T) ? Constructor(FromRest2(K, T.parameters), FromSchemaType(K, T.returns)) : IsFunction3(T) ? Function2(FromRest2(K, T.parameters), FromSchemaType(K, T.returns)) : IsAsyncIterator3(T) ? AsyncIterator(FromSchemaType(K, T.items)) : IsIterator3(T) ? Iterator(FromSchemaType(K, T.items)) : IsIntersect(T) ? Intersect(FromRest2(K, T.allOf)) : IsUnion(T) ? Union(FromRest2(K, T.anyOf)) : IsTuple(T) ? Tuple(FromRest2(K, T.items ?? [])) : IsObject3(T) ? Object2(FromProperties4(K, T.properties)) : IsArray3(T) ? Array2(FromSchemaType(K, T.items)) : IsPromise2(T) ? Promise2(FromSchemaType(K, T.item)) : T;
}
function MappedFunctionReturnType(K, T) {
  const Acc = {};
  for (const L of K)
    Acc[L] = FromSchemaType(L, T);
  return Acc;
}
function Mapped(key, map3, options = {}) {
  const K = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const RT = map3({ [Kind]: "MappedKey", keys: K });
  const R = MappedFunctionReturnType(K, RT);
  return CloneType(Object2(R), options);
}
// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-keys.mjs
function FromRest3(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(KeyOfPropertyKeys(L));
  return Acc;
}
function FromIntersect2(T) {
  const C = FromRest3(T);
  const R = SetUnionMany(C);
  return R;
}
function FromUnion4(T) {
  const C = FromRest3(T);
  const R = SetIntersectMany(C);
  return R;
}
function FromTuple2(T) {
  return T.map((_, I) => I.toString());
}
function FromArray2(_) {
  return ["[number]"];
}
function FromProperties5(T) {
  return globalThis.Object.getOwnPropertyNames(T);
}
function FromPatternProperties(patternProperties) {
  if (!includePatternProperties)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key) => {
    return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
  });
}
function KeyOfPropertyKeys(T) {
  return IsIntersect(T) ? FromIntersect2(T.allOf) : IsUnion(T) ? FromUnion4(T.anyOf) : IsTuple(T) ? FromTuple2(T.items ?? []) : IsArray3(T) ? FromArray2(T.items) : IsObject3(T) ? FromProperties5(T.properties) : IsRecord(T) ? FromPatternProperties(T.patternProperties) : [];
}
var includePatternProperties = false;
function KeyOfPattern(schema) {
  includePatternProperties = true;
  const keys = KeyOfPropertyKeys(schema);
  includePatternProperties = false;
  const pattern2 = keys.map((key) => `(${key})`);
  return `^(${pattern2.join("|")})$`;
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof.mjs
function KeyOfPropertyKeysToRest(T) {
  return T.map((L) => L === "[number]" ? Number2() : Literal(L));
}
function KeyOf(T, options = {}) {
  if (IsMappedResult(T)) {
    return KeyOfFromMappedResult(T, options);
  } else {
    const K = KeyOfPropertyKeys(T);
    const S = KeyOfPropertyKeysToRest(K);
    const U = UnionEvaluated(S);
    return CloneType(U, options);
  }
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-from-mapped-result.mjs
function FromProperties6(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = KeyOf(K[K2], options);
  return Acc;
}
function FromMappedResult5(R, options) {
  return FromProperties6(R.properties, options);
}
function KeyOfFromMappedResult(R, options) {
  const P = FromMappedResult5(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-entries.mjs
function KeyOfPropertyEntries(schema) {
  const keys = KeyOfPropertyKeys(schema);
  const schemas = IndexFromPropertyKeys(schema, keys);
  return keys.map((_, index) => [keys[index], schemas[index]]);
}
// node_modules/@sinclair/typebox/build/esm/type/extends/extends-undefined.mjs
function Intersect2(schema) {
  return schema.allOf.every((schema2) => ExtendsUndefinedCheck(schema2));
}
function Union2(schema) {
  return schema.anyOf.some((schema2) => ExtendsUndefinedCheck(schema2));
}
function Not(schema) {
  return !ExtendsUndefinedCheck(schema.not);
}
function ExtendsUndefinedCheck(schema) {
  return schema[Kind] === "Intersect" ? Intersect2(schema) : schema[Kind] === "Union" ? Union2(schema) : schema[Kind] === "Not" ? Not(schema) : schema[Kind] === "Undefined" ? true : false;
}

// node_modules/@sinclair/typebox/build/esm/errors/function.mjs
function DefaultErrorFunction(error2) {
  switch (error2.errorType) {
    case ValueErrorType.ArrayContains:
      return "Expected array to contain at least one matching value";
    case ValueErrorType.ArrayMaxContains:
      return `Expected array to contain no more than ${error2.schema.maxContains} matching values`;
    case ValueErrorType.ArrayMinContains:
      return `Expected array to contain at least ${error2.schema.minContains} matching values`;
    case ValueErrorType.ArrayMaxItems:
      return `Expected array length to be less or equal to ${error2.schema.maxItems}`;
    case ValueErrorType.ArrayMinItems:
      return `Expected array length to be greater or equal to ${error2.schema.minItems}`;
    case ValueErrorType.ArrayUniqueItems:
      return "Expected array elements to be unique";
    case ValueErrorType.Array:
      return "Expected array";
    case ValueErrorType.AsyncIterator:
      return "Expected AsyncIterator";
    case ValueErrorType.BigIntExclusiveMaximum:
      return `Expected bigint to be less than ${error2.schema.exclusiveMaximum}`;
    case ValueErrorType.BigIntExclusiveMinimum:
      return `Expected bigint to be greater than ${error2.schema.exclusiveMinimum}`;
    case ValueErrorType.BigIntMaximum:
      return `Expected bigint to be less or equal to ${error2.schema.maximum}`;
    case ValueErrorType.BigIntMinimum:
      return `Expected bigint to be greater or equal to ${error2.schema.minimum}`;
    case ValueErrorType.BigIntMultipleOf:
      return `Expected bigint to be a multiple of ${error2.schema.multipleOf}`;
    case ValueErrorType.BigInt:
      return "Expected bigint";
    case ValueErrorType.Boolean:
      return "Expected boolean";
    case ValueErrorType.DateExclusiveMinimumTimestamp:
      return `Expected Date timestamp to be greater than ${error2.schema.exclusiveMinimumTimestamp}`;
    case ValueErrorType.DateExclusiveMaximumTimestamp:
      return `Expected Date timestamp to be less than ${error2.schema.exclusiveMaximumTimestamp}`;
    case ValueErrorType.DateMinimumTimestamp:
      return `Expected Date timestamp to be greater or equal to ${error2.schema.minimumTimestamp}`;
    case ValueErrorType.DateMaximumTimestamp:
      return `Expected Date timestamp to be less or equal to ${error2.schema.maximumTimestamp}`;
    case ValueErrorType.DateMultipleOfTimestamp:
      return `Expected Date timestamp to be a multiple of ${error2.schema.multipleOfTimestamp}`;
    case ValueErrorType.Date:
      return "Expected Date";
    case ValueErrorType.Function:
      return "Expected function";
    case ValueErrorType.IntegerExclusiveMaximum:
      return `Expected integer to be less than ${error2.schema.exclusiveMaximum}`;
    case ValueErrorType.IntegerExclusiveMinimum:
      return `Expected integer to be greater than ${error2.schema.exclusiveMinimum}`;
    case ValueErrorType.IntegerMaximum:
      return `Expected integer to be less or equal to ${error2.schema.maximum}`;
    case ValueErrorType.IntegerMinimum:
      return `Expected integer to be greater or equal to ${error2.schema.minimum}`;
    case ValueErrorType.IntegerMultipleOf:
      return `Expected integer to be a multiple of ${error2.schema.multipleOf}`;
    case ValueErrorType.Integer:
      return "Expected integer";
    case ValueErrorType.IntersectUnevaluatedProperties:
      return "Unexpected property";
    case ValueErrorType.Intersect:
      return "Expected all values to match";
    case ValueErrorType.Iterator:
      return "Expected Iterator";
    case ValueErrorType.Literal:
      return `Expected ${typeof error2.schema.const === "string" ? `'${error2.schema.const}'` : error2.schema.const}`;
    case ValueErrorType.Never:
      return "Never";
    case ValueErrorType.Not:
      return "Value should not match";
    case ValueErrorType.Null:
      return "Expected null";
    case ValueErrorType.NumberExclusiveMaximum:
      return `Expected number to be less than ${error2.schema.exclusiveMaximum}`;
    case ValueErrorType.NumberExclusiveMinimum:
      return `Expected number to be greater than ${error2.schema.exclusiveMinimum}`;
    case ValueErrorType.NumberMaximum:
      return `Expected number to be less or equal to ${error2.schema.maximum}`;
    case ValueErrorType.NumberMinimum:
      return `Expected number to be greater or equal to ${error2.schema.minimum}`;
    case ValueErrorType.NumberMultipleOf:
      return `Expected number to be a multiple of ${error2.schema.multipleOf}`;
    case ValueErrorType.Number:
      return "Expected number";
    case ValueErrorType.Object:
      return "Expected object";
    case ValueErrorType.ObjectAdditionalProperties:
      return "Unexpected property";
    case ValueErrorType.ObjectMaxProperties:
      return `Expected object to have no more than ${error2.schema.maxProperties} properties`;
    case ValueErrorType.ObjectMinProperties:
      return `Expected object to have at least ${error2.schema.minProperties} properties`;
    case ValueErrorType.ObjectRequiredProperty:
      return "Expected required property";
    case ValueErrorType.Promise:
      return "Expected Promise";
    case ValueErrorType.RegExp:
      return "Expected string to match regular expression";
    case ValueErrorType.StringFormatUnknown:
      return `Unknown format '${error2.schema.format}'`;
    case ValueErrorType.StringFormat:
      return `Expected string to match '${error2.schema.format}' format`;
    case ValueErrorType.StringMaxLength:
      return `Expected string length less or equal to ${error2.schema.maxLength}`;
    case ValueErrorType.StringMinLength:
      return `Expected string length greater or equal to ${error2.schema.minLength}`;
    case ValueErrorType.StringPattern:
      return `Expected string to match '${error2.schema.pattern}'`;
    case ValueErrorType.String:
      return "Expected string";
    case ValueErrorType.Symbol:
      return "Expected symbol";
    case ValueErrorType.TupleLength:
      return `Expected tuple to have ${error2.schema.maxItems || 0} elements`;
    case ValueErrorType.Tuple:
      return "Expected tuple";
    case ValueErrorType.Uint8ArrayMaxByteLength:
      return `Expected byte length less or equal to ${error2.schema.maxByteLength}`;
    case ValueErrorType.Uint8ArrayMinByteLength:
      return `Expected byte length greater or equal to ${error2.schema.minByteLength}`;
    case ValueErrorType.Uint8Array:
      return "Expected Uint8Array";
    case ValueErrorType.Undefined:
      return "Expected undefined";
    case ValueErrorType.Union:
      return "Expected union value";
    case ValueErrorType.Void:
      return "Expected void";
    case ValueErrorType.Kind:
      return `Expected kind '${error2.schema[Kind]}'`;
    default:
      return "Unknown error type";
  }
}
var errorFunction = DefaultErrorFunction;
function GetErrorFunction() {
  return errorFunction;
}

// node_modules/@sinclair/typebox/build/esm/value/deref/deref.mjs
class TypeDereferenceError extends TypeBoxError {
  constructor(schema) {
    super(`Unable to dereference schema with $id '${schema.$id}'`);
    this.schema = schema;
  }
}
function Resolve(schema, references) {
  const target = references.find((target2) => target2.$id === schema.$ref);
  if (target === undefined)
    throw new TypeDereferenceError(schema);
  return Deref(target, references);
}
function Deref(schema, references) {
  return schema[Kind] === "This" || schema[Kind] === "Ref" ? Resolve(schema, references) : schema;
}
// node_modules/@sinclair/typebox/build/esm/value/hash/hash.mjs
class ValueHashError extends TypeBoxError {
  constructor(value) {
    super(`Unable to hash value`);
    this.value = value;
  }
}
var ByteMarker;
(function(ByteMarker2) {
  ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
  ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
  ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
  ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
  ByteMarker2[ByteMarker2["String"] = 4] = "String";
  ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
  ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
  ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
  ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
  ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
  ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
})(ByteMarker || (ByteMarker = {}));
var Accumulator = BigInt("14695981039346656037");
var [Prime, Size] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")];
var Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));
var F64 = new Float64Array(1);
var F64In = new DataView(F64.buffer);
var F64Out = new Uint8Array(F64.buffer);
function* NumberToBytes(value) {
  const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
  for (let i = 0;i < byteCount; i++) {
    yield value >> 8 * (byteCount - 1 - i) & 255;
  }
}
function ArrayType2(value) {
  FNV1A64(ByteMarker.Array);
  for (const item of value) {
    Visit3(item);
  }
}
function BooleanType(value) {
  FNV1A64(ByteMarker.Boolean);
  FNV1A64(value ? 1 : 0);
}
function BigIntType(value) {
  FNV1A64(ByteMarker.BigInt);
  F64In.setBigInt64(0, value);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function DateType2(value) {
  FNV1A64(ByteMarker.Date);
  Visit3(value.getTime());
}
function NullType(value) {
  FNV1A64(ByteMarker.Null);
}
function NumberType(value) {
  FNV1A64(ByteMarker.Number);
  F64In.setFloat64(0, value);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function ObjectType2(value) {
  FNV1A64(ByteMarker.Object);
  for (const key of globalThis.Object.getOwnPropertyNames(value).sort()) {
    Visit3(key);
    Visit3(value[key]);
  }
}
function StringType(value) {
  FNV1A64(ByteMarker.String);
  for (let i = 0;i < value.length; i++) {
    for (const byte of NumberToBytes(value.charCodeAt(i))) {
      FNV1A64(byte);
    }
  }
}
function SymbolType(value) {
  FNV1A64(ByteMarker.Symbol);
  Visit3(value.description);
}
function Uint8ArrayType2(value) {
  FNV1A64(ByteMarker.Uint8Array);
  for (let i = 0;i < value.length; i++) {
    FNV1A64(value[i]);
  }
}
function UndefinedType(value) {
  return FNV1A64(ByteMarker.Undefined);
}
function Visit3(value) {
  if (IsArray(value))
    return ArrayType2(value);
  if (IsBoolean(value))
    return BooleanType(value);
  if (IsBigInt(value))
    return BigIntType(value);
  if (IsDate(value))
    return DateType2(value);
  if (IsNull(value))
    return NullType(value);
  if (IsNumber(value))
    return NumberType(value);
  if (IsStandardObject(value))
    return ObjectType2(value);
  if (IsString(value))
    return StringType(value);
  if (IsSymbol(value))
    return SymbolType(value);
  if (IsUint8Array(value))
    return Uint8ArrayType2(value);
  if (IsUndefined(value))
    return UndefinedType(value);
  throw new ValueHashError(value);
}
function FNV1A64(byte) {
  Accumulator = Accumulator ^ Bytes[byte];
  Accumulator = Accumulator * Prime % Size;
}
function Hash(value) {
  Accumulator = BigInt("14695981039346656037");
  Visit3(value);
  return Accumulator;
}
// node_modules/@sinclair/typebox/build/esm/errors/errors.mjs
var ValueErrorType;
(function(ValueErrorType2) {
  ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
  ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
  ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
  ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
  ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
  ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
  ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
  ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
  ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
  ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
  ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
  ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
  ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
  ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
  ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
  ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
  ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
  ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
  ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
  ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
  ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
  ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
  ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
  ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
  ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
  ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
  ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
  ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
  ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
  ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
  ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
  ValueErrorType2[ValueErrorType2["RegExp"] = 48] = "RegExp";
  ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 49] = "StringFormatUnknown";
  ValueErrorType2[ValueErrorType2["StringFormat"] = 50] = "StringFormat";
  ValueErrorType2[ValueErrorType2["StringMaxLength"] = 51] = "StringMaxLength";
  ValueErrorType2[ValueErrorType2["StringMinLength"] = 52] = "StringMinLength";
  ValueErrorType2[ValueErrorType2["StringPattern"] = 53] = "StringPattern";
  ValueErrorType2[ValueErrorType2["String"] = 54] = "String";
  ValueErrorType2[ValueErrorType2["Symbol"] = 55] = "Symbol";
  ValueErrorType2[ValueErrorType2["TupleLength"] = 56] = "TupleLength";
  ValueErrorType2[ValueErrorType2["Tuple"] = 57] = "Tuple";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
  ValueErrorType2[ValueErrorType2["Uint8Array"] = 60] = "Uint8Array";
  ValueErrorType2[ValueErrorType2["Undefined"] = 61] = "Undefined";
  ValueErrorType2[ValueErrorType2["Union"] = 62] = "Union";
  ValueErrorType2[ValueErrorType2["Void"] = 63] = "Void";
})(ValueErrorType || (ValueErrorType = {}));

class ValueErrorsUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}
function EscapeKey(key) {
  return key.replace(/~/g, "~0").replace(/\//g, "~1");
}
function IsDefined(value) {
  return value !== undefined;
}

class ValueErrorIterator {
  constructor(iterator2) {
    this.iterator = iterator2;
  }
  [Symbol.iterator]() {
    return this.iterator;
  }
  First() {
    const next = this.iterator.next();
    return next.done ? undefined : next.value;
  }
}
function Create(errorType, schema, path, value) {
  return { type: errorType, schema, path, value, message: GetErrorFunction()({ errorType, path, schema, value }) };
}
function* FromAny(schema, references, path, value) {}
function* FromArray3(schema, references, path, value) {
  if (!IsArray(value)) {
    return yield Create(ValueErrorType.Array, schema, path, value);
  }
  if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
    yield Create(ValueErrorType.ArrayMinItems, schema, path, value);
  }
  if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
    yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);
  }
  for (let i = 0;i < value.length; i++) {
    yield* Visit4(schema.items, references, `${path}/${i}`, value[i]);
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);
  }
  if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {
    return;
  }
  const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();
  const containsCount = value.reduce((acc, value2, index) => Visit4(containsSchema, references, `${path}${index}`, value2).next().done === true ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    yield Create(ValueErrorType.ArrayContains, schema, path, value);
  }
  if (IsNumber(schema.minContains) && containsCount < schema.minContains) {
    yield Create(ValueErrorType.ArrayMinContains, schema, path, value);
  }
  if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {
    yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);
  }
}
function* FromAsyncIterator(schema, references, path, value) {
  if (!IsAsyncIterator(value))
    yield Create(ValueErrorType.AsyncIterator, schema, path, value);
}
function* FromBigInt(schema, references, path, value) {
  if (!IsBigInt(value))
    return yield Create(ValueErrorType.BigInt, schema, path, value);
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.BigIntMaximum, schema, path, value);
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.BigIntMinimum, schema, path, value);
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);
  }
}
function* FromBoolean(schema, references, path, value) {
  if (!IsBoolean(value))
    yield Create(ValueErrorType.Boolean, schema, path, value);
}
function* FromConstructor(schema, references, path, value) {
  yield* Visit4(schema.returns, references, path, value.prototype);
}
function* FromDate(schema, references, path, value) {
  if (!IsDate(value))
    return yield Create(ValueErrorType.Date, schema, path, value);
  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);
  }
  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);
  }
  if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);
  }
  if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);
  }
  if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);
  }
}
function* FromFunction(schema, references, path, value) {
  if (!IsFunction(value))
    yield Create(ValueErrorType.Function, schema, path, value);
}
function* FromInteger(schema, references, path, value) {
  if (!IsInteger(value))
    return yield Create(ValueErrorType.Integer, schema, path, value);
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.IntegerMaximum, schema, path, value);
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.IntegerMinimum, schema, path, value);
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);
  }
}
function* FromIntersect3(schema, references, path, value) {
  for (const inner of schema.allOf) {
    const next = Visit4(inner, references, path, value).next();
    if (!next.done) {
      yield Create(ValueErrorType.Intersect, schema, path, value);
      yield next.value;
    }
  }
  if (schema.unevaluatedProperties === false) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);
      }
    }
  }
  if (typeof schema.unevaluatedProperties === "object") {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        const next = Visit4(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();
        if (!next.done)
          yield next.value;
      }
    }
  }
}
function* FromIterator(schema, references, path, value) {
  if (!IsIterator(value))
    yield Create(ValueErrorType.Iterator, schema, path, value);
}
function* FromLiteral2(schema, references, path, value) {
  if (!(value === schema.const))
    yield Create(ValueErrorType.Literal, schema, path, value);
}
function* FromNever(schema, references, path, value) {
  yield Create(ValueErrorType.Never, schema, path, value);
}
function* FromNot(schema, references, path, value) {
  if (Visit4(schema.not, references, path, value).next().done === true)
    yield Create(ValueErrorType.Not, schema, path, value);
}
function* FromNull(schema, references, path, value) {
  if (!IsNull(value))
    yield Create(ValueErrorType.Null, schema, path, value);
}
function* FromNumber(schema, references, path, value) {
  if (!TypeSystemPolicy.IsNumberLike(value))
    return yield Create(ValueErrorType.Number, schema, path, value);
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.NumberMaximum, schema, path, value);
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.NumberMinimum, schema, path, value);
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);
  }
}
function* FromObject(schema, references, path, value) {
  if (!TypeSystemPolicy.IsObjectLike(value))
    return yield Create(ValueErrorType.Object, schema, path, value);
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
  }
  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  const unknownKeys = Object.getOwnPropertyNames(value);
  for (const requiredKey of requiredKeys) {
    if (unknownKeys.includes(requiredKey))
      continue;
    yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);
  }
  if (schema.additionalProperties === false) {
    for (const valueKey of unknownKeys) {
      if (!knownKeys.includes(valueKey)) {
        yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
      }
    }
  }
  if (typeof schema.additionalProperties === "object") {
    for (const valueKey of unknownKeys) {
      if (knownKeys.includes(valueKey))
        continue;
      yield* Visit4(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
    }
  }
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      yield* Visit4(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
      if (ExtendsUndefinedCheck(schema) && !(knownKey in value)) {
        yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {
        yield* Visit4(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
      }
    }
  }
}
function* FromPromise(schema, references, path, value) {
  if (!IsPromise(value))
    yield Create(ValueErrorType.Promise, schema, path, value);
}
function* FromRecord(schema, references, path, value) {
  if (!TypeSystemPolicy.IsRecordLike(value))
    return yield Create(ValueErrorType.Object, schema, path, value);
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  for (const [propertyKey, propertyValue] of Object.entries(value)) {
    if (regex.test(propertyKey))
      yield* Visit4(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
  }
  if (typeof schema.additionalProperties === "object") {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (!regex.test(propertyKey))
        yield* Visit4(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
  if (schema.additionalProperties === false) {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (regex.test(propertyKey))
        continue;
      return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
}
function* FromRef(schema, references, path, value) {
  yield* Visit4(Deref(schema, references), references, path, value);
}
function* FromRegExp(schema, references, path, value) {
  if (!IsString(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value);
  }
  if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value);
  }
  const regex = new RegExp(schema.source, schema.flags);
  if (!regex.test(value)) {
    return yield Create(ValueErrorType.RegExp, schema, path, value);
  }
}
function* FromString(schema, references, path, value) {
  if (!IsString(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value);
  }
  if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value);
  }
  if (IsString(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value)) {
      yield Create(ValueErrorType.StringPattern, schema, path, value);
    }
  }
  if (IsString(schema.format)) {
    if (!exports_format.Has(schema.format)) {
      yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);
    } else {
      const format = exports_format.Get(schema.format);
      if (!format(value)) {
        yield Create(ValueErrorType.StringFormat, schema, path, value);
      }
    }
  }
}
function* FromSymbol(schema, references, path, value) {
  if (!IsSymbol(value))
    yield Create(ValueErrorType.Symbol, schema, path, value);
}
function* FromTemplateLiteral2(schema, references, path, value) {
  if (!IsString(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  const regex = new RegExp(schema.pattern);
  if (!regex.test(value)) {
    yield Create(ValueErrorType.StringPattern, schema, path, value);
  }
}
function* FromThis(schema, references, path, value) {
  yield* Visit4(Deref(schema, references), references, path, value);
}
function* FromTuple3(schema, references, path, value) {
  if (!IsArray(value))
    return yield Create(ValueErrorType.Tuple, schema, path, value);
  if (schema.items === undefined && !(value.length === 0)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value);
  }
  if (!(value.length === schema.maxItems)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value);
  }
  if (!schema.items) {
    return;
  }
  for (let i = 0;i < schema.items.length; i++) {
    yield* Visit4(schema.items[i], references, `${path}/${i}`, value[i]);
  }
}
function* FromUndefined(schema, references, path, value) {
  if (!IsUndefined(value))
    yield Create(ValueErrorType.Undefined, schema, path, value);
}
function* FromUnion5(schema, references, path, value) {
  let count = 0;
  for (const subschema of schema.anyOf) {
    const errors = [...Visit4(subschema, references, path, value)];
    if (errors.length === 0)
      return;
    count += errors.length;
  }
  if (count > 0) {
    yield Create(ValueErrorType.Union, schema, path, value);
  }
}
function* FromUint8Array(schema, references, path, value) {
  if (!IsUint8Array(value))
    return yield Create(ValueErrorType.Uint8Array, schema, path, value);
  if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);
  }
  if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);
  }
}
function* FromUnknown(schema, references, path, value) {}
function* FromVoid(schema, references, path, value) {
  if (!TypeSystemPolicy.IsVoidLike(value))
    yield Create(ValueErrorType.Void, schema, path, value);
}
function* FromKind(schema, references, path, value) {
  const check = exports_type.Get(schema[Kind]);
  if (!check(schema, value))
    yield Create(ValueErrorType.Kind, schema, path, value);
}
function* Visit4(schema, references, path, value) {
  const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return yield* FromAny(schema_, references_, path, value);
    case "Array":
      return yield* FromArray3(schema_, references_, path, value);
    case "AsyncIterator":
      return yield* FromAsyncIterator(schema_, references_, path, value);
    case "BigInt":
      return yield* FromBigInt(schema_, references_, path, value);
    case "Boolean":
      return yield* FromBoolean(schema_, references_, path, value);
    case "Constructor":
      return yield* FromConstructor(schema_, references_, path, value);
    case "Date":
      return yield* FromDate(schema_, references_, path, value);
    case "Function":
      return yield* FromFunction(schema_, references_, path, value);
    case "Integer":
      return yield* FromInteger(schema_, references_, path, value);
    case "Intersect":
      return yield* FromIntersect3(schema_, references_, path, value);
    case "Iterator":
      return yield* FromIterator(schema_, references_, path, value);
    case "Literal":
      return yield* FromLiteral2(schema_, references_, path, value);
    case "Never":
      return yield* FromNever(schema_, references_, path, value);
    case "Not":
      return yield* FromNot(schema_, references_, path, value);
    case "Null":
      return yield* FromNull(schema_, references_, path, value);
    case "Number":
      return yield* FromNumber(schema_, references_, path, value);
    case "Object":
      return yield* FromObject(schema_, references_, path, value);
    case "Promise":
      return yield* FromPromise(schema_, references_, path, value);
    case "Record":
      return yield* FromRecord(schema_, references_, path, value);
    case "Ref":
      return yield* FromRef(schema_, references_, path, value);
    case "RegExp":
      return yield* FromRegExp(schema_, references_, path, value);
    case "String":
      return yield* FromString(schema_, references_, path, value);
    case "Symbol":
      return yield* FromSymbol(schema_, references_, path, value);
    case "TemplateLiteral":
      return yield* FromTemplateLiteral2(schema_, references_, path, value);
    case "This":
      return yield* FromThis(schema_, references_, path, value);
    case "Tuple":
      return yield* FromTuple3(schema_, references_, path, value);
    case "Undefined":
      return yield* FromUndefined(schema_, references_, path, value);
    case "Union":
      return yield* FromUnion5(schema_, references_, path, value);
    case "Uint8Array":
      return yield* FromUint8Array(schema_, references_, path, value);
    case "Unknown":
      return yield* FromUnknown(schema_, references_, path, value);
    case "Void":
      return yield* FromVoid(schema_, references_, path, value);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueErrorsUnknownTypeError(schema);
      return yield* FromKind(schema_, references_, path, value);
  }
}
function Errors(...args) {
  const iterator2 = args.length === 3 ? Visit4(args[0], args[1], "", args[2]) : Visit4(args[0], [], "", args[1]);
  return new ValueErrorIterator(iterator2);
}
// node_modules/@sinclair/typebox/build/esm/type/any/any.mjs
function Any(options = {}) {
  return { ...options, [Kind]: "Any" };
}
// node_modules/@sinclair/typebox/build/esm/type/unknown/unknown.mjs
function Unknown(options = {}) {
  return {
    ...options,
    [Kind]: "Unknown"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/guard/type.mjs
var exports_type2 = {};
__export(exports_type2, {
  TypeGuardUnknownTypeError: () => TypeGuardUnknownTypeError,
  IsVoid: () => IsVoid2,
  IsUnsafe: () => IsUnsafe2,
  IsUnknown: () => IsUnknown2,
  IsUnionLiteral: () => IsUnionLiteral,
  IsUnion: () => IsUnion2,
  IsUndefined: () => IsUndefined4,
  IsUint8Array: () => IsUint8Array4,
  IsTuple: () => IsTuple2,
  IsTransform: () => IsTransform2,
  IsThis: () => IsThis2,
  IsTemplateLiteral: () => IsTemplateLiteral2,
  IsSymbol: () => IsSymbol4,
  IsString: () => IsString4,
  IsSchema: () => IsSchema2,
  IsRegExp: () => IsRegExp3,
  IsRef: () => IsRef2,
  IsRecursive: () => IsRecursive,
  IsRecord: () => IsRecord2,
  IsReadonly: () => IsReadonly2,
  IsProperties: () => IsProperties,
  IsPromise: () => IsPromise3,
  IsOptional: () => IsOptional2,
  IsObject: () => IsObject4,
  IsNumber: () => IsNumber4,
  IsNull: () => IsNull4,
  IsNot: () => IsNot2,
  IsNever: () => IsNever2,
  IsMappedResult: () => IsMappedResult2,
  IsMappedKey: () => IsMappedKey2,
  IsLiteralValue: () => IsLiteralValue,
  IsLiteralString: () => IsLiteralString,
  IsLiteralNumber: () => IsLiteralNumber,
  IsLiteralBoolean: () => IsLiteralBoolean,
  IsLiteral: () => IsLiteral2,
  IsKindOf: () => IsKindOf2,
  IsKind: () => IsKind2,
  IsIterator: () => IsIterator4,
  IsIntersect: () => IsIntersect2,
  IsInteger: () => IsInteger3,
  IsFunction: () => IsFunction4,
  IsDate: () => IsDate4,
  IsConstructor: () => IsConstructor2,
  IsBoolean: () => IsBoolean4,
  IsBigInt: () => IsBigInt4,
  IsAsyncIterator: () => IsAsyncIterator4,
  IsArray: () => IsArray4,
  IsAny: () => IsAny2
});
class TypeGuardUnknownTypeError extends TypeBoxError {
}
var KnownTypes = [
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];
function IsPattern(value) {
  try {
    new RegExp(value);
    return true;
  } catch {
    return false;
  }
}
function IsControlCharacterFree(value) {
  if (!IsString2(value))
    return false;
  for (let i = 0;i < value.length; i++) {
    const code = value.charCodeAt(i);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
}
function IsAdditionalProperties(value) {
  return IsOptionalBoolean(value) || IsSchema2(value);
}
function IsOptionalBigInt(value) {
  return IsUndefined2(value) || IsBigInt2(value);
}
function IsOptionalNumber(value) {
  return IsUndefined2(value) || IsNumber2(value);
}
function IsOptionalBoolean(value) {
  return IsUndefined2(value) || IsBoolean2(value);
}
function IsOptionalString(value) {
  return IsUndefined2(value) || IsString2(value);
}
function IsOptionalPattern(value) {
  return IsUndefined2(value) || IsString2(value) && IsControlCharacterFree(value) && IsPattern(value);
}
function IsOptionalFormat(value) {
  return IsUndefined2(value) || IsString2(value) && IsControlCharacterFree(value);
}
function IsOptionalSchema(value) {
  return IsUndefined2(value) || IsSchema2(value);
}
function IsReadonly2(value) {
  return IsObject2(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional2(value) {
  return IsObject2(value) && value[OptionalKind] === "Optional";
}
function IsAny2(value) {
  return IsKindOf2(value, "Any") && IsOptionalString(value.$id);
}
function IsArray4(value) {
  return IsKindOf2(value, "Array") && value.type === "array" && IsOptionalString(value.$id) && IsSchema2(value.items) && IsOptionalNumber(value.minItems) && IsOptionalNumber(value.maxItems) && IsOptionalBoolean(value.uniqueItems) && IsOptionalSchema(value.contains) && IsOptionalNumber(value.minContains) && IsOptionalNumber(value.maxContains);
}
function IsAsyncIterator4(value) {
  return IsKindOf2(value, "AsyncIterator") && value.type === "AsyncIterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsBigInt4(value) {
  return IsKindOf2(value, "BigInt") && value.type === "bigint" && IsOptionalString(value.$id) && IsOptionalBigInt(value.exclusiveMaximum) && IsOptionalBigInt(value.exclusiveMinimum) && IsOptionalBigInt(value.maximum) && IsOptionalBigInt(value.minimum) && IsOptionalBigInt(value.multipleOf);
}
function IsBoolean4(value) {
  return IsKindOf2(value, "Boolean") && value.type === "boolean" && IsOptionalString(value.$id);
}
function IsConstructor2(value) {
  return IsKindOf2(value, "Constructor") && value.type === "Constructor" && IsOptionalString(value.$id) && IsArray2(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsDate4(value) {
  return IsKindOf2(value, "Date") && value.type === "Date" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximumTimestamp) && IsOptionalNumber(value.exclusiveMinimumTimestamp) && IsOptionalNumber(value.maximumTimestamp) && IsOptionalNumber(value.minimumTimestamp) && IsOptionalNumber(value.multipleOfTimestamp);
}
function IsFunction4(value) {
  return IsKindOf2(value, "Function") && value.type === "Function" && IsOptionalString(value.$id) && IsArray2(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsInteger3(value) {
  return IsKindOf2(value, "Integer") && value.type === "integer" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsProperties(value) {
  return IsObject2(value) && Object.entries(value).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema2(schema));
}
function IsIntersect2(value) {
  return IsKindOf2(value, "Intersect") && (IsString2(value.type) && value.type !== "object" ? false : true) && IsArray2(value.allOf) && value.allOf.every((schema) => IsSchema2(schema) && !IsTransform2(schema)) && IsOptionalString(value.type) && (IsOptionalBoolean(value.unevaluatedProperties) || IsOptionalSchema(value.unevaluatedProperties)) && IsOptionalString(value.$id);
}
function IsIterator4(value) {
  return IsKindOf2(value, "Iterator") && value.type === "Iterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsKindOf2(value, kind) {
  return IsObject2(value) && Kind in value && value[Kind] === kind;
}
function IsLiteralString(value) {
  return IsLiteral2(value) && IsString2(value.const);
}
function IsLiteralNumber(value) {
  return IsLiteral2(value) && IsNumber2(value.const);
}
function IsLiteralBoolean(value) {
  return IsLiteral2(value) && IsBoolean2(value.const);
}
function IsLiteral2(value) {
  return IsKindOf2(value, "Literal") && IsOptionalString(value.$id) && IsLiteralValue(value.const);
}
function IsLiteralValue(value) {
  return IsBoolean2(value) || IsNumber2(value) || IsString2(value);
}
function IsMappedKey2(value) {
  return IsKindOf2(value, "MappedKey") && IsArray2(value.keys) && value.keys.every((key) => IsNumber2(key) || IsString2(key));
}
function IsMappedResult2(value) {
  return IsKindOf2(value, "MappedResult") && IsProperties(value.properties);
}
function IsNever2(value) {
  return IsKindOf2(value, "Never") && IsObject2(value.not) && Object.getOwnPropertyNames(value.not).length === 0;
}
function IsNot2(value) {
  return IsKindOf2(value, "Not") && IsSchema2(value.not);
}
function IsNull4(value) {
  return IsKindOf2(value, "Null") && value.type === "null" && IsOptionalString(value.$id);
}
function IsNumber4(value) {
  return IsKindOf2(value, "Number") && value.type === "number" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsObject4(value) {
  return IsKindOf2(value, "Object") && value.type === "object" && IsOptionalString(value.$id) && IsProperties(value.properties) && IsAdditionalProperties(value.additionalProperties) && IsOptionalNumber(value.minProperties) && IsOptionalNumber(value.maxProperties);
}
function IsPromise3(value) {
  return IsKindOf2(value, "Promise") && value.type === "Promise" && IsOptionalString(value.$id) && IsSchema2(value.item);
}
function IsRecord2(value) {
  return IsKindOf2(value, "Record") && value.type === "object" && IsOptionalString(value.$id) && IsAdditionalProperties(value.additionalProperties) && IsObject2(value.patternProperties) && ((schema) => {
    const keys = Object.getOwnPropertyNames(schema.patternProperties);
    return keys.length === 1 && IsPattern(keys[0]) && IsObject2(schema.patternProperties) && IsSchema2(schema.patternProperties[keys[0]]);
  })(value);
}
function IsRecursive(value) {
  return IsObject2(value) && Hint in value && value[Hint] === "Recursive";
}
function IsRef2(value) {
  return IsKindOf2(value, "Ref") && IsOptionalString(value.$id) && IsString2(value.$ref);
}
function IsRegExp3(value) {
  return IsKindOf2(value, "RegExp") && IsOptionalString(value.$id) && IsString2(value.source) && IsString2(value.flags) && IsOptionalNumber(value.maxLength) && IsOptionalNumber(value.minLength);
}
function IsString4(value) {
  return IsKindOf2(value, "String") && value.type === "string" && IsOptionalString(value.$id) && IsOptionalNumber(value.minLength) && IsOptionalNumber(value.maxLength) && IsOptionalPattern(value.pattern) && IsOptionalFormat(value.format);
}
function IsSymbol4(value) {
  return IsKindOf2(value, "Symbol") && value.type === "symbol" && IsOptionalString(value.$id);
}
function IsTemplateLiteral2(value) {
  return IsKindOf2(value, "TemplateLiteral") && value.type === "string" && IsString2(value.pattern) && value.pattern[0] === "^" && value.pattern[value.pattern.length - 1] === "$";
}
function IsThis2(value) {
  return IsKindOf2(value, "This") && IsOptionalString(value.$id) && IsString2(value.$ref);
}
function IsTransform2(value) {
  return IsObject2(value) && TransformKind in value;
}
function IsTuple2(value) {
  return IsKindOf2(value, "Tuple") && value.type === "array" && IsOptionalString(value.$id) && IsNumber2(value.minItems) && IsNumber2(value.maxItems) && value.minItems === value.maxItems && (IsUndefined2(value.items) && IsUndefined2(value.additionalItems) && value.minItems === 0 || IsArray2(value.items) && value.items.every((schema) => IsSchema2(schema)));
}
function IsUndefined4(value) {
  return IsKindOf2(value, "Undefined") && value.type === "undefined" && IsOptionalString(value.$id);
}
function IsUnionLiteral(value) {
  return IsUnion2(value) && value.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));
}
function IsUnion2(value) {
  return IsKindOf2(value, "Union") && IsOptionalString(value.$id) && IsObject2(value) && IsArray2(value.anyOf) && value.anyOf.every((schema) => IsSchema2(schema));
}
function IsUint8Array4(value) {
  return IsKindOf2(value, "Uint8Array") && value.type === "Uint8Array" && IsOptionalString(value.$id) && IsOptionalNumber(value.minByteLength) && IsOptionalNumber(value.maxByteLength);
}
function IsUnknown2(value) {
  return IsKindOf2(value, "Unknown") && IsOptionalString(value.$id);
}
function IsUnsafe2(value) {
  return IsKindOf2(value, "Unsafe");
}
function IsVoid2(value) {
  return IsKindOf2(value, "Void") && value.type === "void" && IsOptionalString(value.$id);
}
function IsKind2(value) {
  return IsObject2(value) && Kind in value && IsString2(value[Kind]) && !KnownTypes.includes(value[Kind]);
}
function IsSchema2(value) {
  return IsObject2(value) && (IsAny2(value) || IsArray4(value) || IsBoolean4(value) || IsBigInt4(value) || IsAsyncIterator4(value) || IsConstructor2(value) || IsDate4(value) || IsFunction4(value) || IsInteger3(value) || IsIntersect2(value) || IsIterator4(value) || IsLiteral2(value) || IsMappedKey2(value) || IsMappedResult2(value) || IsNever2(value) || IsNot2(value) || IsNull4(value) || IsNumber4(value) || IsObject4(value) || IsPromise3(value) || IsRecord2(value) || IsRef2(value) || IsRegExp3(value) || IsString4(value) || IsSymbol4(value) || IsTemplateLiteral2(value) || IsThis2(value) || IsTuple2(value) || IsUndefined4(value) || IsUnion2(value) || IsUint8Array4(value) || IsUnknown2(value) || IsUnsafe2(value) || IsVoid2(value) || IsKind2(value));
}
// node_modules/@sinclair/typebox/build/esm/type/extends/extends-check.mjs
class ExtendsResolverError extends TypeBoxError {
}
var ExtendsResult;
(function(ExtendsResult2) {
  ExtendsResult2[ExtendsResult2["Union"] = 0] = "Union";
  ExtendsResult2[ExtendsResult2["True"] = 1] = "True";
  ExtendsResult2[ExtendsResult2["False"] = 2] = "False";
})(ExtendsResult || (ExtendsResult = {}));
function IntoBooleanResult(result) {
  return result === ExtendsResult.False ? result : ExtendsResult.True;
}
function Throw(message) {
  throw new ExtendsResolverError(message);
}
function IsStructuralRight(right) {
  return exports_type2.IsNever(right) || exports_type2.IsIntersect(right) || exports_type2.IsUnion(right) || exports_type2.IsUnknown(right) || exports_type2.IsAny(right);
}
function StructuralRight(left, right) {
  return exports_type2.IsNever(right) ? FromNeverRight(left, right) : exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) ? FromUnionRight(left, right) : exports_type2.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type2.IsAny(right) ? FromAnyRight(left, right) : Throw("StructuralRight");
}
function FromAnyRight(left, right) {
  return ExtendsResult.True;
}
function FromAny2(left, right) {
  return exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) && right.anyOf.some((schema) => exports_type2.IsAny(schema) || exports_type2.IsUnknown(schema)) ? ExtendsResult.True : exports_type2.IsUnion(right) ? ExtendsResult.Union : exports_type2.IsUnknown(right) ? ExtendsResult.True : exports_type2.IsAny(right) ? ExtendsResult.True : ExtendsResult.Union;
}
function FromArrayRight(left, right) {
  return exports_type2.IsUnknown(left) ? ExtendsResult.False : exports_type2.IsAny(left) ? ExtendsResult.Union : exports_type2.IsNever(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromArray4(left, right) {
  return exports_type2.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type2.IsArray(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
}
function FromAsyncIterator2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type2.IsAsyncIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
}
function FromBigInt2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsBigInt(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBooleanRight(left, right) {
  return exports_type2.IsLiteralBoolean(left) ? ExtendsResult.True : exports_type2.IsBoolean(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBoolean2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsBoolean(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromConstructor2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : !exports_type2.IsConstructor(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit5(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.returns, right.returns));
}
function FromDate2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsDate(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromFunction2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : !exports_type2.IsFunction(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit5(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.returns, right.returns));
}
function FromIntegerRight(left, right) {
  return exports_type2.IsLiteral(left) && exports_value.IsNumber(left.const) ? ExtendsResult.True : exports_type2.IsNumber(left) || exports_type2.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromInteger2(left, right) {
  return exports_type2.IsInteger(right) || exports_type2.IsNumber(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : ExtendsResult.False;
}
function FromIntersectRight(left, right) {
  return right.allOf.every((schema) => Visit5(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIntersect4(left, right) {
  return left.allOf.some((schema) => Visit5(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIterator2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type2.IsIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
}
function FromLiteral3(left, right) {
  return exports_type2.IsLiteral(right) && right.const === left.const ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsString(right) ? FromStringRight(left, right) : exports_type2.IsNumber(right) ? FromNumberRight(left, right) : exports_type2.IsInteger(right) ? FromIntegerRight(left, right) : exports_type2.IsBoolean(right) ? FromBooleanRight(left, right) : ExtendsResult.False;
}
function FromNeverRight(left, right) {
  return ExtendsResult.False;
}
function FromNever2(left, right) {
  return ExtendsResult.True;
}
function UnwrapTNot(schema) {
  let [current, depth] = [schema, 0];
  while (true) {
    if (!exports_type2.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown();
}
function FromNot2(left, right) {
  return exports_type2.IsNot(left) ? Visit5(UnwrapTNot(left), right) : exports_type2.IsNot(right) ? Visit5(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
}
function FromNull2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsNull(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumberRight(left, right) {
  return exports_type2.IsLiteralNumber(left) ? ExtendsResult.True : exports_type2.IsNumber(left) || exports_type2.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumber2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsInteger(right) || exports_type2.IsNumber(right) ? ExtendsResult.True : ExtendsResult.False;
}
function IsObjectPropertyCount(schema, count) {
  return Object.getOwnPropertyNames(schema.properties).length === count;
}
function IsObjectStringLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectSymbolLike(schema) {
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && exports_type2.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (exports_type2.IsString(schema.properties.description.anyOf[0]) && exports_type2.IsUndefined(schema.properties.description.anyOf[1]) || exports_type2.IsString(schema.properties.description.anyOf[1]) && exports_type2.IsUndefined(schema.properties.description.anyOf[0]));
}
function IsObjectNumberLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBooleanLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBigIntLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectDateLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectUint8ArrayLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectFunctionLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit5(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectConstructorLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectArrayLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit5(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectPromiseLike(schema) {
  const then = Function2([Any()], Any());
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit5(schema.properties["then"], then)) === ExtendsResult.True;
}
function Property(left, right) {
  return Visit5(left, right) === ExtendsResult.False ? ExtendsResult.False : exports_type2.IsOptional(left) && !exports_type2.IsOptional(right) ? ExtendsResult.False : ExtendsResult.True;
}
function FromObjectRight(left, right) {
  return exports_type2.IsUnknown(left) ? ExtendsResult.False : exports_type2.IsAny(left) ? ExtendsResult.Union : exports_type2.IsNever(left) || exports_type2.IsLiteralString(left) && IsObjectStringLike(right) || exports_type2.IsLiteralNumber(left) && IsObjectNumberLike(right) || exports_type2.IsLiteralBoolean(left) && IsObjectBooleanLike(right) || exports_type2.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type2.IsBigInt(left) && IsObjectBigIntLike(right) || exports_type2.IsString(left) && IsObjectStringLike(right) || exports_type2.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type2.IsNumber(left) && IsObjectNumberLike(right) || exports_type2.IsInteger(left) && IsObjectNumberLike(right) || exports_type2.IsBoolean(left) && IsObjectBooleanLike(right) || exports_type2.IsUint8Array(left) && IsObjectUint8ArrayLike(right) || exports_type2.IsDate(left) && IsObjectDateLike(right) || exports_type2.IsConstructor(left) && IsObjectConstructorLike(right) || exports_type2.IsFunction(left) && IsObjectFunctionLike(right) ? ExtendsResult.True : exports_type2.IsRecord(left) && exports_type2.IsString(RecordKey(left)) ? (() => {
    return right[Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
  })() : exports_type2.IsRecord(left) && exports_type2.IsNumber(RecordKey(left)) ? (() => {
    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
  })() : ExtendsResult.False;
}
function FromObject2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : !exports_type2.IsObject(right) ? ExtendsResult.False : (() => {
    for (const key of Object.getOwnPropertyNames(right.properties)) {
      if (!(key in left.properties) && !exports_type2.IsOptional(right.properties[key])) {
        return ExtendsResult.False;
      }
      if (exports_type2.IsOptional(right.properties[key])) {
        return ExtendsResult.True;
      }
      if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })();
}
function FromPromise2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True : !exports_type2.IsPromise(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.item, right.item));
}
function RecordKey(schema) {
  return PatternNumberExact in schema.patternProperties ? Number2() : (PatternStringExact in schema.patternProperties) ? String2() : Throw("Unknown record key pattern");
}
function RecordValue(schema) {
  return PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] : (PatternStringExact in schema.patternProperties) ? schema.patternProperties[PatternStringExact] : Throw("Unable to get record value schema");
}
function FromRecordRight(left, right) {
  const [Key, Value] = [RecordKey(right), RecordValue(right)];
  return exports_type2.IsLiteralString(left) && exports_type2.IsNumber(Key) && IntoBooleanResult(Visit5(left, Value)) === ExtendsResult.True ? ExtendsResult.True : exports_type2.IsUint8Array(left) && exports_type2.IsNumber(Key) ? Visit5(left, Value) : exports_type2.IsString(left) && exports_type2.IsNumber(Key) ? Visit5(left, Value) : exports_type2.IsArray(left) && exports_type2.IsNumber(Key) ? Visit5(left, Value) : exports_type2.IsObject(left) ? (() => {
    for (const key of Object.getOwnPropertyNames(left.properties)) {
      if (Property(Value, left.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })() : ExtendsResult.False;
}
function FromRecord2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : !exports_type2.IsRecord(right) ? ExtendsResult.False : Visit5(RecordValue(left), RecordValue(right));
}
function FromRegExp2(left, right) {
  const L = exports_type2.IsRegExp(left) ? String2() : left;
  const R = exports_type2.IsRegExp(right) ? String2() : right;
  return Visit5(L, R);
}
function FromStringRight(left, right) {
  return exports_type2.IsLiteral(left) && exports_value.IsString(left.const) ? ExtendsResult.True : exports_type2.IsString(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromString2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsString(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromSymbol2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsSymbol(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromTemplateLiteral3(left, right) {
  return exports_type2.IsTemplateLiteral(left) ? Visit5(TemplateLiteralToUnion(left), right) : exports_type2.IsTemplateLiteral(right) ? Visit5(left, TemplateLiteralToUnion(right)) : Throw("Invalid fallthrough for TemplateLiteral");
}
function IsArrayOfTuple(left, right) {
  return exports_type2.IsArray(right) && left.items !== undefined && left.items.every((schema) => Visit5(schema, right.items) === ExtendsResult.True);
}
function FromTupleRight(left, right) {
  return exports_type2.IsNever(left) ? ExtendsResult.True : exports_type2.IsUnknown(left) ? ExtendsResult.False : exports_type2.IsAny(left) ? ExtendsResult.Union : ExtendsResult.False;
}
function FromTuple4(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : exports_type2.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True : !exports_type2.IsTuple(right) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) || !exports_value.IsUndefined(left.items) && exports_value.IsUndefined(right.items) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) ? ExtendsResult.True : left.items.every((schema, index) => Visit5(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUint8Array2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsUint8Array(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUndefined2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsVoid(right) ? FromVoidRight(left, right) : exports_type2.IsUndefined(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnionRight(left, right) {
  return right.anyOf.some((schema) => Visit5(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnion6(left, right) {
  return left.anyOf.every((schema) => Visit5(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnknownRight(left, right) {
  return ExtendsResult.True;
}
function FromUnknown2(left, right) {
  return exports_type2.IsNever(right) ? FromNeverRight(left, right) : exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) ? FromUnionRight(left, right) : exports_type2.IsAny(right) ? FromAnyRight(left, right) : exports_type2.IsString(right) ? FromStringRight(left, right) : exports_type2.IsNumber(right) ? FromNumberRight(left, right) : exports_type2.IsInteger(right) ? FromIntegerRight(left, right) : exports_type2.IsBoolean(right) ? FromBooleanRight(left, right) : exports_type2.IsArray(right) ? FromArrayRight(left, right) : exports_type2.IsTuple(right) ? FromTupleRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsUnknown(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoidRight(left, right) {
  return exports_type2.IsUndefined(left) ? ExtendsResult.True : exports_type2.IsUndefined(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoid2(left, right) {
  return exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) ? FromUnionRight(left, right) : exports_type2.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type2.IsAny(right) ? FromAnyRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsVoid(right) ? ExtendsResult.True : ExtendsResult.False;
}
function Visit5(left, right) {
  return exports_type2.IsTemplateLiteral(left) || exports_type2.IsTemplateLiteral(right) ? FromTemplateLiteral3(left, right) : exports_type2.IsRegExp(left) || exports_type2.IsRegExp(right) ? FromRegExp2(left, right) : exports_type2.IsNot(left) || exports_type2.IsNot(right) ? FromNot2(left, right) : exports_type2.IsAny(left) ? FromAny2(left, right) : exports_type2.IsArray(left) ? FromArray4(left, right) : exports_type2.IsBigInt(left) ? FromBigInt2(left, right) : exports_type2.IsBoolean(left) ? FromBoolean2(left, right) : exports_type2.IsAsyncIterator(left) ? FromAsyncIterator2(left, right) : exports_type2.IsConstructor(left) ? FromConstructor2(left, right) : exports_type2.IsDate(left) ? FromDate2(left, right) : exports_type2.IsFunction(left) ? FromFunction2(left, right) : exports_type2.IsInteger(left) ? FromInteger2(left, right) : exports_type2.IsIntersect(left) ? FromIntersect4(left, right) : exports_type2.IsIterator(left) ? FromIterator2(left, right) : exports_type2.IsLiteral(left) ? FromLiteral3(left, right) : exports_type2.IsNever(left) ? FromNever2(left, right) : exports_type2.IsNull(left) ? FromNull2(left, right) : exports_type2.IsNumber(left) ? FromNumber2(left, right) : exports_type2.IsObject(left) ? FromObject2(left, right) : exports_type2.IsRecord(left) ? FromRecord2(left, right) : exports_type2.IsString(left) ? FromString2(left, right) : exports_type2.IsSymbol(left) ? FromSymbol2(left, right) : exports_type2.IsTuple(left) ? FromTuple4(left, right) : exports_type2.IsPromise(left) ? FromPromise2(left, right) : exports_type2.IsUint8Array(left) ? FromUint8Array2(left, right) : exports_type2.IsUndefined(left) ? FromUndefined2(left, right) : exports_type2.IsUnion(left) ? FromUnion6(left, right) : exports_type2.IsUnknown(left) ? FromUnknown2(left, right) : exports_type2.IsVoid(left) ? FromVoid2(left, right) : Throw(`Unknown left type operand '${left[Kind]}'`);
}
function ExtendsCheck(left, right) {
  return Visit5(left, right);
}
// node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-result.mjs
function FromProperties7(P, Right, True, False, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extends(P[K2], Right, True, False, options);
  return Acc;
}
function FromMappedResult6(Left, Right, True, False, options) {
  return FromProperties7(Left.properties, Right, True, False, options);
}
function ExtendsFromMappedResult(Left, Right, True, False, options) {
  const P = FromMappedResult6(Left, Right, True, False, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends.mjs
function ExtendsResolve(left, right, trueType, falseType) {
  const R = ExtendsCheck(left, right);
  return R === ExtendsResult.Union ? Union([trueType, falseType]) : R === ExtendsResult.True ? trueType : falseType;
}
function Extends(L, R, T, F, options = {}) {
  return IsMappedResult(L) ? ExtendsFromMappedResult(L, R, T, F, options) : IsMappedKey(L) ? CloneType(ExtendsFromMappedKey(L, R, T, F, options)) : CloneType(ExtendsResolve(L, R, T, F), options);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-key.mjs
function FromPropertyKey(K, U, L, R, options) {
  return {
    [K]: Extends(Literal(K), U, L, R, options)
  };
}
function FromPropertyKeys(K, U, L, R, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };
  }, {});
}
function FromMappedKey2(K, U, L, R, options) {
  return FromPropertyKeys(K.keys, U, L, R, options);
}
function ExtendsFromMappedKey(T, U, L, R, options) {
  const P = FromMappedKey2(T, U, L, R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/value/check/check.mjs
class ValueCheckUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super(`Unknown type`);
    this.schema = schema;
  }
}
function IsAnyOrUnknown(schema) {
  return schema[Kind] === "Any" || schema[Kind] === "Unknown";
}
function IsDefined2(value) {
  return value !== undefined;
}
function FromAny3(schema, references, value) {
  return true;
}
function FromArray5(schema, references, value) {
  if (!IsArray(value))
    return false;
  if (IsDefined2(schema.minItems) && !(value.length >= schema.minItems)) {
    return false;
  }
  if (IsDefined2(schema.maxItems) && !(value.length <= schema.maxItems)) {
    return false;
  }
  if (!value.every((value2) => Visit6(schema.items, references, value2))) {
    return false;
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    return false;
  }
  if (!(IsDefined2(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains))) {
    return true;
  }
  const containsSchema = IsDefined2(schema.contains) ? schema.contains : Never();
  const containsCount = value.reduce((acc, value2) => Visit6(containsSchema, references, value2) ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    return false;
  }
  if (IsNumber(schema.minContains) && containsCount < schema.minContains) {
    return false;
  }
  if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {
    return false;
  }
  return true;
}
function FromAsyncIterator3(schema, references, value) {
  return IsAsyncIterator(value);
}
function FromBigInt3(schema, references, value) {
  if (!IsBigInt(value))
    return false;
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    return false;
  }
  return true;
}
function FromBoolean3(schema, references, value) {
  return IsBoolean(value);
}
function FromConstructor3(schema, references, value) {
  return Visit6(schema.returns, references, value.prototype);
}
function FromDate3(schema, references, value) {
  if (!IsDate(value))
    return false;
  if (IsDefined2(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    return false;
  }
  return true;
}
function FromFunction3(schema, references, value) {
  return IsFunction(value);
}
function FromInteger3(schema, references, value) {
  if (!IsInteger(value)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromIntersect5(schema, references, value) {
  const check1 = schema.allOf.every((schema2) => Visit6(schema2, references, value));
  if (schema.unevaluatedProperties === false) {
    const keyPattern = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));
    return check1 && check2;
  } else if (IsSchema2(schema.unevaluatedProperties)) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key) => keyCheck.test(key) || Visit6(schema.unevaluatedProperties, references, value[key]));
    return check1 && check2;
  } else {
    return check1;
  }
}
function FromIterator3(schema, references, value) {
  return IsIterator(value);
}
function FromLiteral4(schema, references, value) {
  return value === schema.const;
}
function FromNever3(schema, references, value) {
  return false;
}
function FromNot3(schema, references, value) {
  return !Visit6(schema.not, references, value);
}
function FromNull3(schema, references, value) {
  return IsNull(value);
}
function FromNumber3(schema, references, value) {
  if (!TypeSystemPolicy.IsNumberLike(value))
    return false;
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromObject3(schema, references, value) {
  if (!TypeSystemPolicy.IsObjectLike(value))
    return false;
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      if (!Visit6(property, references, value[knownKey])) {
        return false;
      }
      if ((ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {
        return false;
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit6(property, references, value[knownKey])) {
        return false;
      }
    }
  }
  if (schema.additionalProperties === false) {
    const valueKeys = Object.getOwnPropertyNames(value);
    if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
      return true;
    } else {
      return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
    }
  } else if (typeof schema.additionalProperties === "object") {
    const valueKeys = Object.getOwnPropertyNames(value);
    return valueKeys.every((key) => knownKeys.includes(key) || Visit6(schema.additionalProperties, references, value[key]));
  } else {
    return true;
  }
}
function FromPromise3(schema, references, value) {
  return IsPromise(value);
}
function FromRecord3(schema, references, value) {
  if (!TypeSystemPolicy.IsRecordLike(value)) {
    return false;
  }
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  const check1 = Object.entries(value).every(([key, value2]) => {
    return regex.test(key) ? Visit6(patternSchema, references, value2) : true;
  });
  const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value).every(([key, value2]) => {
    return !regex.test(key) ? Visit6(schema.additionalProperties, references, value2) : true;
  }) : true;
  const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value).every((key) => {
    return regex.test(key);
  }) : true;
  return check1 && check2 && check3;
}
function FromRef2(schema, references, value) {
  return Visit6(Deref(schema, references), references, value);
}
function FromRegExp3(schema, references, value) {
  const regex = new RegExp(schema.source, schema.flags);
  if (IsDefined2(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined2(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  return regex.test(value);
}
function FromString3(schema, references, value) {
  if (!IsString(value)) {
    return false;
  }
  if (IsDefined2(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined2(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  if (IsDefined2(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value))
      return false;
  }
  if (IsDefined2(schema.format)) {
    if (!exports_format.Has(schema.format))
      return false;
    const func = exports_format.Get(schema.format);
    return func(value);
  }
  return true;
}
function FromSymbol3(schema, references, value) {
  return IsSymbol(value);
}
function FromTemplateLiteral4(schema, references, value) {
  return IsString(value) && new RegExp(schema.pattern).test(value);
}
function FromThis2(schema, references, value) {
  return Visit6(Deref(schema, references), references, value);
}
function FromTuple5(schema, references, value) {
  if (!IsArray(value)) {
    return false;
  }
  if (schema.items === undefined && !(value.length === 0)) {
    return false;
  }
  if (!(value.length === schema.maxItems)) {
    return false;
  }
  if (!schema.items) {
    return true;
  }
  for (let i = 0;i < schema.items.length; i++) {
    if (!Visit6(schema.items[i], references, value[i]))
      return false;
  }
  return true;
}
function FromUndefined3(schema, references, value) {
  return IsUndefined(value);
}
function FromUnion7(schema, references, value) {
  return schema.anyOf.some((inner) => Visit6(inner, references, value));
}
function FromUint8Array3(schema, references, value) {
  if (!IsUint8Array(value)) {
    return false;
  }
  if (IsDefined2(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    return false;
  }
  if (IsDefined2(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    return false;
  }
  return true;
}
function FromUnknown3(schema, references, value) {
  return true;
}
function FromVoid3(schema, references, value) {
  return TypeSystemPolicy.IsVoidLike(value);
}
function FromKind2(schema, references, value) {
  if (!exports_type.Has(schema[Kind]))
    return false;
  const func = exports_type.Get(schema[Kind]);
  return func(schema, value);
}
function Visit6(schema, references, value) {
  const references_ = IsDefined2(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny3(schema_, references_, value);
    case "Array":
      return FromArray5(schema_, references_, value);
    case "AsyncIterator":
      return FromAsyncIterator3(schema_, references_, value);
    case "BigInt":
      return FromBigInt3(schema_, references_, value);
    case "Boolean":
      return FromBoolean3(schema_, references_, value);
    case "Constructor":
      return FromConstructor3(schema_, references_, value);
    case "Date":
      return FromDate3(schema_, references_, value);
    case "Function":
      return FromFunction3(schema_, references_, value);
    case "Integer":
      return FromInteger3(schema_, references_, value);
    case "Intersect":
      return FromIntersect5(schema_, references_, value);
    case "Iterator":
      return FromIterator3(schema_, references_, value);
    case "Literal":
      return FromLiteral4(schema_, references_, value);
    case "Never":
      return FromNever3(schema_, references_, value);
    case "Not":
      return FromNot3(schema_, references_, value);
    case "Null":
      return FromNull3(schema_, references_, value);
    case "Number":
      return FromNumber3(schema_, references_, value);
    case "Object":
      return FromObject3(schema_, references_, value);
    case "Promise":
      return FromPromise3(schema_, references_, value);
    case "Record":
      return FromRecord3(schema_, references_, value);
    case "Ref":
      return FromRef2(schema_, references_, value);
    case "RegExp":
      return FromRegExp3(schema_, references_, value);
    case "String":
      return FromString3(schema_, references_, value);
    case "Symbol":
      return FromSymbol3(schema_, references_, value);
    case "TemplateLiteral":
      return FromTemplateLiteral4(schema_, references_, value);
    case "This":
      return FromThis2(schema_, references_, value);
    case "Tuple":
      return FromTuple5(schema_, references_, value);
    case "Undefined":
      return FromUndefined3(schema_, references_, value);
    case "Union":
      return FromUnion7(schema_, references_, value);
    case "Uint8Array":
      return FromUint8Array3(schema_, references_, value);
    case "Unknown":
      return FromUnknown3(schema_, references_, value);
    case "Void":
      return FromVoid3(schema_, references_, value);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueCheckUnknownTypeError(schema_);
      return FromKind2(schema_, references_, value);
  }
}
function Check(...args) {
  return args.length === 3 ? Visit6(args[0], args[1], args[2]) : Visit6(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/clone/clone.mjs
function ObjectType3(value) {
  const Acc = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    Acc[key] = Clone2(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    Acc[key] = Clone2(value[key]);
  }
  return Acc;
}
function ArrayType3(value) {
  return value.map((element) => Clone2(element));
}
function TypedArrayType(value) {
  return value.slice();
}
function DateType3(value) {
  return new Date(value.toISOString());
}
function ValueType(value) {
  return value;
}
function Clone2(value) {
  if (IsArray(value))
    return ArrayType3(value);
  if (IsDate(value))
    return DateType3(value);
  if (IsStandardObject(value))
    return ObjectType3(value);
  if (IsTypedArray(value))
    return TypedArrayType(value);
  if (IsValueType(value))
    return ValueType(value);
  throw new Error("ValueClone: Unable to clone value");
}
// node_modules/@sinclair/typebox/build/esm/value/create/create.mjs
class ValueCreateError extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
function FromDefault(value) {
  return typeof value === "function" ? value : Clone2(value);
}
function FromAny4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromArray6(schema, references) {
  if (schema.uniqueItems === true && !HasPropertyKey(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the uniqueItems constraint requires a default value");
  } else if ("contains" in schema && !HasPropertyKey(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the contains constraint requires a default value");
  } else if ("default" in schema) {
    return FromDefault(schema.default);
  } else if (schema.minItems !== undefined) {
    return Array.from({ length: schema.minItems }).map((item) => {
      return Visit7(schema.items, references);
    });
  } else {
    return [];
  }
}
function FromAsyncIterator4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return async function* () {}();
  }
}
function FromBigInt4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return BigInt(0);
  }
}
function FromBoolean4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return false;
  }
}
function FromConstructor4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value = Visit7(schema.returns, references);
    if (typeof value === "object" && !Array.isArray(value)) {
      return class {
        constructor() {
          for (const [key, val] of Object.entries(value)) {
            const self2 = this;
            self2[key] = val;
          }
        }
      };
    } else {
      return class {
      };
    }
  }
}
function FromDate4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimumTimestamp !== undefined) {
    return new Date(schema.minimumTimestamp);
  } else {
    return new Date;
  }
}
function FromFunction4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return () => Visit7(schema.returns, references);
  }
}
function FromInteger4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromIntersect6(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value = schema.allOf.reduce((acc, schema2) => {
      const next = Visit7(schema2, references);
      return typeof next === "object" ? { ...acc, ...next } : next;
    }, {});
    if (!Check(schema, references, value))
      throw new ValueCreateError(schema, "Intersect produced invalid value. Consider using a default value.");
    return value;
  }
}
function FromIterator4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return function* () {}();
  }
}
function FromLiteral5(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return schema.const;
  }
}
function FromNever4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Never types cannot be created. Consider using a default value.");
  }
}
function FromNot4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Not types must have a default value");
  }
}
function FromNull4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return null;
  }
}
function FromNumber4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromObject4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const required = new Set(schema.required);
    const Acc = {};
    for (const [key, subschema] of Object.entries(schema.properties)) {
      if (!required.has(key))
        continue;
      Acc[key] = Visit7(subschema, references);
    }
    return Acc;
  }
}
function FromPromise4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Promise.resolve(Visit7(schema.item, references));
  }
}
function FromRecord4(schema, references) {
  const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (!(keyPattern === PatternStringExact || keyPattern === PatternNumberExact)) {
    const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
    const Acc = {};
    for (const key of propertyKeys)
      Acc[key] = Visit7(valueSchema, references);
    return Acc;
  } else {
    return {};
  }
}
function FromRef3(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
}
function FromRegExp4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "RegExp types cannot be created. Consider using a default value.");
  }
}
function FromString4(schema, references) {
  if (schema.pattern !== undefined) {
    if (!HasPropertyKey(schema, "default")) {
      throw new ValueCreateError(schema, "String types with patterns must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else if (schema.format !== undefined) {
    if (!HasPropertyKey(schema, "default")) {
      throw new ValueCreateError(schema, "String types with formats must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else {
    if (HasPropertyKey(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minLength !== undefined) {
      return Array.from({ length: schema.minLength }).map(() => " ").join("");
    } else {
      return "";
    }
  }
}
function FromSymbol4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if ("value" in schema) {
    return Symbol.for(schema.value);
  } else {
    return Symbol();
  }
}
function FromTemplateLiteral5(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (!IsTemplateLiteralFinite(schema))
    throw new ValueCreateError(schema, "Can only create template literals that produce a finite variants. Consider using a default value.");
  const generated = TemplateLiteralGenerate(schema);
  return generated[0];
}
function FromThis3(schema, references) {
  if (recursiveDepth++ > recursiveMaxDepth)
    throw new ValueCreateError(schema, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
}
function FromTuple6(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (schema.items === undefined) {
    return [];
  } else {
    return Array.from({ length: schema.minItems }).map((_, index) => Visit7(schema.items[index], references));
  }
}
function FromUndefined4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
}
function FromUnion8(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.anyOf.length === 0) {
    throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
  } else {
    return Visit7(schema.anyOf[0], references);
  }
}
function FromUint8Array4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minByteLength !== undefined) {
    return new Uint8Array(schema.minByteLength);
  } else {
    return new Uint8Array(0);
  }
}
function FromUnknown4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromVoid4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
}
function FromKind3(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new Error("User defined types must specify a default value");
  }
}
function Visit7(schema, references) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny4(schema_, references_);
    case "Array":
      return FromArray6(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator4(schema_, references_);
    case "BigInt":
      return FromBigInt4(schema_, references_);
    case "Boolean":
      return FromBoolean4(schema_, references_);
    case "Constructor":
      return FromConstructor4(schema_, references_);
    case "Date":
      return FromDate4(schema_, references_);
    case "Function":
      return FromFunction4(schema_, references_);
    case "Integer":
      return FromInteger4(schema_, references_);
    case "Intersect":
      return FromIntersect6(schema_, references_);
    case "Iterator":
      return FromIterator4(schema_, references_);
    case "Literal":
      return FromLiteral5(schema_, references_);
    case "Never":
      return FromNever4(schema_, references_);
    case "Not":
      return FromNot4(schema_, references_);
    case "Null":
      return FromNull4(schema_, references_);
    case "Number":
      return FromNumber4(schema_, references_);
    case "Object":
      return FromObject4(schema_, references_);
    case "Promise":
      return FromPromise4(schema_, references_);
    case "Record":
      return FromRecord4(schema_, references_);
    case "Ref":
      return FromRef3(schema_, references_);
    case "RegExp":
      return FromRegExp4(schema_, references_);
    case "String":
      return FromString4(schema_, references_);
    case "Symbol":
      return FromSymbol4(schema_, references_);
    case "TemplateLiteral":
      return FromTemplateLiteral5(schema_, references_);
    case "This":
      return FromThis3(schema_, references_);
    case "Tuple":
      return FromTuple6(schema_, references_);
    case "Undefined":
      return FromUndefined4(schema_, references_);
    case "Union":
      return FromUnion8(schema_, references_);
    case "Uint8Array":
      return FromUint8Array4(schema_, references_);
    case "Unknown":
      return FromUnknown4(schema_, references_);
    case "Void":
      return FromVoid4(schema_, references_);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueCreateError(schema_, "Unknown type");
      return FromKind3(schema_, references_);
  }
}
var recursiveMaxDepth = 512;
var recursiveDepth = 0;
function Create2(...args) {
  recursiveDepth = 0;
  return args.length === 2 ? Visit7(args[0], args[1]) : Visit7(args[0], []);
}
// node_modules/@sinclair/typebox/build/esm/value/cast/cast.mjs
class ValueCastError extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
function ScoreUnion(schema, references, value) {
  if (schema[Kind] === "Object" && typeof value === "object" && !IsNull(value)) {
    const object2 = schema;
    const keys = Object.getOwnPropertyNames(value);
    const entries = Object.entries(object2.properties);
    const [point, max] = [1 / entries.length, entries.length];
    return entries.reduce((acc, [key, schema2]) => {
      const literal2 = schema2[Kind] === "Literal" && schema2.const === value[key] ? max : 0;
      const checks = Check(schema2, references, value[key]) ? point : 0;
      const exists = keys.includes(key) ? point : 0;
      return acc + (literal2 + checks + exists);
    }, 0);
  } else {
    return Check(schema, references, value) ? 1 : 0;
  }
}
function SelectUnion(union3, references, value) {
  const schemas = union3.anyOf.map((schema) => Deref(schema, references));
  let [select, best] = [schemas[0], 0];
  for (const schema of schemas) {
    const score = ScoreUnion(schema, references, value);
    if (score > best) {
      select = schema;
      best = score;
    }
  }
  return select;
}
function CastUnion(union3, references, value) {
  if ("default" in union3) {
    return typeof value === "function" ? union3.default : Clone2(union3.default);
  } else {
    const schema = SelectUnion(union3, references, value);
    return Cast(schema, references, value);
  }
}
function DefaultClone(schema, references, value) {
  return Check(schema, references, value) ? Clone2(value) : Create2(schema, references);
}
function Default(schema, references, value) {
  return Check(schema, references, value) ? value : Create2(schema, references);
}
function FromArray7(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  const created = IsArray(value) ? Clone2(value) : Create2(schema, references);
  const minimum = IsNumber(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
  const maximum = IsNumber(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
  const casted = maximum.map((value2) => Visit8(schema.items, references, value2));
  if (schema.uniqueItems !== true)
    return casted;
  const unique = [...new Set(casted)];
  if (!Check(schema, references, unique))
    throw new ValueCastError(schema, "Array cast produced invalid data due to uniqueItems constraint");
  return unique;
}
function FromConstructor5(schema, references, value) {
  if (Check(schema, references, value))
    return Create2(schema, references);
  const required = new Set(schema.returns.required || []);
  const result = function() {};
  for (const [key, property] of Object.entries(schema.returns.properties)) {
    if (!required.has(key) && value.prototype[key] === undefined)
      continue;
    result.prototype[key] = Visit8(property, references, value.prototype[key]);
  }
  return result;
}
function FromIntersect7(schema, references, value) {
  const created = Create2(schema, references);
  const mapped2 = IsStandardObject(created) && IsStandardObject(value) ? { ...created, ...value } : value;
  return Check(schema, references, mapped2) ? mapped2 : Create2(schema, references);
}
function FromNever5(schema, references, value) {
  throw new ValueCastError(schema, "Never types cannot be cast");
}
function FromObject5(schema, references, value) {
  if (Check(schema, references, value))
    return value;
  if (value === null || typeof value !== "object")
    return Create2(schema, references);
  const required = new Set(schema.required || []);
  const result = {};
  for (const [key, property] of Object.entries(schema.properties)) {
    if (!required.has(key) && value[key] === undefined)
      continue;
    result[key] = Visit8(property, references, value[key]);
  }
  if (typeof schema.additionalProperties === "object") {
    const propertyNames = Object.getOwnPropertyNames(schema.properties);
    for (const propertyName of Object.getOwnPropertyNames(value)) {
      if (propertyNames.includes(propertyName))
        continue;
      result[propertyName] = Visit8(schema.additionalProperties, references, value[propertyName]);
    }
  }
  return result;
}
function FromRecord5(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  if (value === null || typeof value !== "object" || Array.isArray(value) || value instanceof Date)
    return Create2(schema, references);
  const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const subschema = schema.patternProperties[subschemaPropertyName];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value)) {
    result[propKey] = Visit8(subschema, references, propValue);
  }
  return result;
}
function FromRef4(schema, references, value) {
  return Visit8(Deref(schema, references), references, value);
}
function FromThis4(schema, references, value) {
  return Visit8(Deref(schema, references), references, value);
}
function FromTuple7(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  if (!IsArray(value))
    return Create2(schema, references);
  if (schema.items === undefined)
    return [];
  return schema.items.map((schema2, index) => Visit8(schema2, references, value[index]));
}
function FromUnion9(schema, references, value) {
  return Check(schema, references, value) ? Clone2(value) : CastUnion(schema, references, value);
}
function Visit8(schema, references, value) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray7(schema_, references_, value);
    case "Constructor":
      return FromConstructor5(schema_, references_, value);
    case "Intersect":
      return FromIntersect7(schema_, references_, value);
    case "Never":
      return FromNever5(schema_, references_, value);
    case "Object":
      return FromObject5(schema_, references_, value);
    case "Record":
      return FromRecord5(schema_, references_, value);
    case "Ref":
      return FromRef4(schema_, references_, value);
    case "This":
      return FromThis4(schema_, references_, value);
    case "Tuple":
      return FromTuple7(schema_, references_, value);
    case "Union":
      return FromUnion9(schema_, references_, value);
    case "Date":
    case "Symbol":
    case "Uint8Array":
      return DefaultClone(schema, references, value);
    default:
      return Default(schema_, references_, value);
  }
}
function Cast(...args) {
  return args.length === 3 ? Visit8(args[0], args[1], args[2]) : Visit8(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/clean/clean.mjs
function IsCheckable(schema) {
  return IsSchema2(schema) && schema[Kind] !== "Unsafe";
}
function FromArray8(schema, references, value) {
  if (!IsArray(value))
    return value;
  return value.map((value2) => Visit9(schema.items, references, value2));
}
function FromIntersect8(schema, references, value) {
  const unevaluatedProperties = schema.unevaluatedProperties;
  const intersections = schema.allOf.map((schema2) => Visit9(schema2, references, Clone2(value)));
  const composite = intersections.reduce((acc, value2) => IsObject(value2) ? { ...acc, ...value2 } : value2, {});
  if (!IsObject(value) || !IsObject(composite) || !IsSchema2(unevaluatedProperties))
    return composite;
  const knownkeys = KeyOfPropertyKeys(schema);
  for (const key of Object.getOwnPropertyNames(value)) {
    if (knownkeys.includes(key))
      continue;
    if (Check(unevaluatedProperties, references, value[key])) {
      composite[key] = Visit9(unevaluatedProperties, references, value[key]);
    }
  }
  return composite;
}
function FromObject6(schema, references, value) {
  if (!IsObject(value) || IsArray(value))
    return value;
  const additionalProperties = schema.additionalProperties;
  for (const key of Object.getOwnPropertyNames(value)) {
    if (key in schema.properties) {
      value[key] = Visit9(schema.properties[key], references, value[key]);
      continue;
    }
    if (IsSchema2(additionalProperties) && Check(additionalProperties, references, value[key])) {
      value[key] = Visit9(additionalProperties, references, value[key]);
      continue;
    }
    delete value[key];
  }
  return value;
}
function FromRecord6(schema, references, value) {
  if (!IsObject(value))
    return value;
  const additionalProperties = schema.additionalProperties;
  const propertyKeys = Object.getOwnPropertyNames(value);
  const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
  const propertyKeyTest = new RegExp(propertyKey);
  for (const key of propertyKeys) {
    if (propertyKeyTest.test(key)) {
      value[key] = Visit9(propertySchema, references, value[key]);
      continue;
    }
    if (IsSchema2(additionalProperties) && Check(additionalProperties, references, value[key])) {
      value[key] = Visit9(additionalProperties, references, value[key]);
      continue;
    }
    delete value[key];
  }
  return value;
}
function FromRef5(schema, references, value) {
  return Visit9(Deref(schema, references), references, value);
}
function FromThis5(schema, references, value) {
  return Visit9(Deref(schema, references), references, value);
}
function FromTuple8(schema, references, value) {
  if (!IsArray(value))
    return value;
  if (IsUndefined(schema.items))
    return [];
  const length = Math.min(value.length, schema.items.length);
  for (let i = 0;i < length; i++) {
    value[i] = Visit9(schema.items[i], references, value[i]);
  }
  return value.length > length ? value.slice(0, length) : value;
}
function FromUnion10(schema, references, value) {
  for (const inner of schema.anyOf) {
    if (IsCheckable(inner) && Check(inner, references, value)) {
      return Visit9(inner, references, value);
    }
  }
  return value;
}
function Visit9(schema, references, value) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray8(schema_, references_, value);
    case "Intersect":
      return FromIntersect8(schema_, references_, value);
    case "Object":
      return FromObject6(schema_, references_, value);
    case "Record":
      return FromRecord6(schema_, references_, value);
    case "Ref":
      return FromRef5(schema_, references_, value);
    case "This":
      return FromThis5(schema_, references_, value);
    case "Tuple":
      return FromTuple8(schema_, references_, value);
    case "Union":
      return FromUnion10(schema_, references_, value);
    default:
      return value;
  }
}
function Clean(...args) {
  return args.length === 3 ? Visit9(args[0], args[1], args[2]) : Visit9(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/convert/convert.mjs
function IsStringNumeric(value) {
  return IsString(value) && !isNaN(value) && !isNaN(parseFloat(value));
}
function IsValueToString(value) {
  return IsBigInt(value) || IsBoolean(value) || IsNumber(value);
}
function IsValueTrue(value) {
  return value === true || IsNumber(value) && value === 1 || IsBigInt(value) && value === BigInt("1") || IsString(value) && (value.toLowerCase() === "true" || value === "1");
}
function IsValueFalse(value) {
  return value === false || IsNumber(value) && (value === 0 || Object.is(value, -0)) || IsBigInt(value) && value === BigInt("0") || IsString(value) && (value.toLowerCase() === "false" || value === "0" || value === "-0");
}
function IsTimeStringWithTimeZone(value) {
  return IsString(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsTimeStringWithoutTimeZone(value) {
  return IsString(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateTimeStringWithTimeZone(value) {
  return IsString(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsDateTimeStringWithoutTimeZone(value) {
  return IsString(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateString(value) {
  return IsString(value) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value);
}
function TryConvertLiteralString(value, target) {
  const conversion = TryConvertString(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteralNumber(value, target) {
  const conversion = TryConvertNumber(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteralBoolean(value, target) {
  const conversion = TryConvertBoolean(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteral(schema, value) {
  return IsString(schema.const) ? TryConvertLiteralString(value, schema.const) : IsNumber(schema.const) ? TryConvertLiteralNumber(value, schema.const) : IsBoolean(schema.const) ? TryConvertLiteralBoolean(value, schema.const) : Clone2(value);
}
function TryConvertBoolean(value) {
  return IsValueTrue(value) ? true : IsValueFalse(value) ? false : value;
}
function TryConvertBigInt(value) {
  return IsStringNumeric(value) ? BigInt(parseInt(value)) : IsNumber(value) ? BigInt(value | 0) : IsValueFalse(value) ? BigInt(0) : IsValueTrue(value) ? BigInt(1) : value;
}
function TryConvertString(value) {
  return IsValueToString(value) ? value.toString() : IsSymbol(value) && value.description !== undefined ? value.description.toString() : value;
}
function TryConvertNumber(value) {
  return IsStringNumeric(value) ? parseFloat(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
}
function TryConvertInteger(value) {
  return IsStringNumeric(value) ? parseInt(value) : IsNumber(value) ? value | 0 : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
}
function TryConvertNull(value) {
  return IsString(value) && value.toLowerCase() === "null" ? null : value;
}
function TryConvertUndefined(value) {
  return IsString(value) && value === "undefined" ? undefined : value;
}
function TryConvertDate(value) {
  return IsDate(value) ? value : IsNumber(value) ? new Date(value) : IsValueTrue(value) ? new Date(1) : IsValueFalse(value) ? new Date(0) : IsStringNumeric(value) ? new Date(parseInt(value)) : IsTimeStringWithoutTimeZone(value) ? new Date(`1970-01-01T${value}.000Z`) : IsTimeStringWithTimeZone(value) ? new Date(`1970-01-01T${value}`) : IsDateTimeStringWithoutTimeZone(value) ? new Date(`${value}.000Z`) : IsDateTimeStringWithTimeZone(value) ? new Date(value) : IsDateString(value) ? new Date(`${value}T00:00:00.000Z`) : value;
}
function Default2(value) {
  return value;
}
function FromArray9(schema, references, value) {
  const elements = IsArray(value) ? value : [value];
  return elements.map((element) => Visit10(schema.items, references, element));
}
function FromBigInt5(schema, references, value) {
  return TryConvertBigInt(value);
}
function FromBoolean5(schema, references, value) {
  return TryConvertBoolean(value);
}
function FromDate5(schema, references, value) {
  return TryConvertDate(value);
}
function FromInteger5(schema, references, value) {
  return TryConvertInteger(value);
}
function FromIntersect9(schema, references, value) {
  return schema.allOf.reduce((value2, schema2) => Visit10(schema2, references, value2), value);
}
function FromLiteral6(schema, references, value) {
  return TryConvertLiteral(schema, value);
}
function FromNull5(schema, references, value) {
  return TryConvertNull(value);
}
function FromNumber5(schema, references, value) {
  return TryConvertNumber(value);
}
function FromObject7(schema, references, value) {
  const isConvertable = IsObject(value);
  if (!isConvertable)
    return value;
  const result = {};
  for (const key of Object.keys(value)) {
    result[key] = HasPropertyKey(schema.properties, key) ? Visit10(schema.properties[key], references, value[key]) : value[key];
  }
  return result;
}
function FromRecord7(schema, references, value) {
  const isConvertable = IsObject(value);
  if (!isConvertable)
    return value;
  const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[propertyKey];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value)) {
    result[propKey] = Visit10(property, references, propValue);
  }
  return result;
}
function FromRef6(schema, references, value) {
  return Visit10(Deref(schema, references), references, value);
}
function FromString5(schema, references, value) {
  return TryConvertString(value);
}
function FromSymbol5(schema, references, value) {
  return IsString(value) || IsNumber(value) ? Symbol(value) : value;
}
function FromThis6(schema, references, value) {
  return Visit10(Deref(schema, references), references, value);
}
function FromTuple9(schema, references, value) {
  const isConvertable = IsArray(value) && !IsUndefined(schema.items);
  if (!isConvertable)
    return value;
  return value.map((value2, index) => {
    return index < schema.items.length ? Visit10(schema.items[index], references, value2) : value2;
  });
}
function FromUndefined5(schema, references, value) {
  return TryConvertUndefined(value);
}
function FromUnion11(schema, references, value) {
  for (const subschema of schema.anyOf) {
    const converted = Visit10(subschema, references, value);
    if (!Check(subschema, references, converted))
      continue;
    return converted;
  }
  return value;
}
function Visit10(schema, references, value) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray9(schema_, references_, value);
    case "BigInt":
      return FromBigInt5(schema_, references_, value);
    case "Boolean":
      return FromBoolean5(schema_, references_, value);
    case "Date":
      return FromDate5(schema_, references_, value);
    case "Integer":
      return FromInteger5(schema_, references_, value);
    case "Intersect":
      return FromIntersect9(schema_, references_, value);
    case "Literal":
      return FromLiteral6(schema_, references_, value);
    case "Null":
      return FromNull5(schema_, references_, value);
    case "Number":
      return FromNumber5(schema_, references_, value);
    case "Object":
      return FromObject7(schema_, references_, value);
    case "Record":
      return FromRecord7(schema_, references_, value);
    case "Ref":
      return FromRef6(schema_, references_, value);
    case "String":
      return FromString5(schema_, references_, value);
    case "Symbol":
      return FromSymbol5(schema_, references_, value);
    case "This":
      return FromThis6(schema_, references_, value);
    case "Tuple":
      return FromTuple9(schema_, references_, value);
    case "Undefined":
      return FromUndefined5(schema_, references_, value);
    case "Union":
      return FromUnion11(schema_, references_, value);
    default:
      return Default2(value);
  }
}
function Convert(...args) {
  return args.length === 3 ? Visit10(args[0], args[1], args[2]) : Visit10(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/default/default.mjs
function ValueOrDefault(schema, value) {
  return value === undefined && "default" in schema ? Clone2(schema.default) : value;
}
function IsCheckable2(schema) {
  return IsSchema2(schema) && schema[Kind] !== "Unsafe";
}
function IsDefaultSchema(value) {
  return IsSchema2(value) && "default" in value;
}
function FromArray10(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsArray(defaulted))
    return defaulted;
  for (let i = 0;i < defaulted.length; i++) {
    defaulted[i] = Visit11(schema.items, references, defaulted[i]);
  }
  return defaulted;
}
function FromIntersect10(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  return schema.allOf.reduce((acc, schema2) => {
    const next = Visit11(schema2, references, defaulted);
    return IsObject(next) ? { ...acc, ...next } : next;
  }, {});
}
function FromObject8(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsObject(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
  for (const key of knownPropertyKeys) {
    if (!IsDefaultSchema(schema.properties[key]))
      continue;
    defaulted[key] = Visit11(schema.properties[key], references, defaulted[key]);
  }
  if (!IsDefaultSchema(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKeys.includes(key))
      continue;
    defaulted[key] = Visit11(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
}
function FromRecord8(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsObject(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
  const knownPropertyKey = new RegExp(propertyKeyPattern);
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (!(knownPropertyKey.test(key) && IsDefaultSchema(propertySchema)))
      continue;
    defaulted[key] = Visit11(propertySchema, references, defaulted[key]);
  }
  if (!IsDefaultSchema(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKey.test(key))
      continue;
    defaulted[key] = Visit11(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
}
function FromRef7(schema, references, value) {
  return Visit11(Deref(schema, references), references, ValueOrDefault(schema, value));
}
function FromThis7(schema, references, value) {
  return Visit11(Deref(schema, references), references, value);
}
function FromTuple10(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsArray(defaulted) || IsUndefined(schema.items))
    return defaulted;
  const [items, max] = [schema.items, Math.max(schema.items.length, defaulted.length)];
  for (let i = 0;i < max; i++) {
    if (i < items.length)
      defaulted[i] = Visit11(items[i], references, defaulted[i]);
  }
  return defaulted;
}
function FromUnion12(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  for (const inner of schema.anyOf) {
    const result = Visit11(inner, references, defaulted);
    if (IsCheckable2(inner) && Check(inner, result)) {
      return result;
    }
  }
  return defaulted;
}
function Visit11(schema, references, value) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray10(schema_, references_, value);
    case "Intersect":
      return FromIntersect10(schema_, references_, value);
    case "Object":
      return FromObject8(schema_, references_, value);
    case "Record":
      return FromRecord8(schema_, references_, value);
    case "Ref":
      return FromRef7(schema_, references_, value);
    case "This":
      return FromThis7(schema_, references_, value);
    case "Tuple":
      return FromTuple10(schema_, references_, value);
    case "Union":
      return FromUnion12(schema_, references_, value);
    default:
      return ValueOrDefault(schema_, value);
  }
}
function Default3(...args) {
  return args.length === 3 ? Visit11(args[0], args[1], args[2]) : Visit11(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/pointer/pointer.mjs
var exports_pointer = {};
__export(exports_pointer, {
  ValuePointerRootSetError: () => ValuePointerRootSetError,
  ValuePointerRootDeleteError: () => ValuePointerRootDeleteError,
  Set: () => Set4,
  Has: () => Has3,
  Get: () => Get3,
  Format: () => Format,
  Delete: () => Delete3
});
class ValuePointerRootSetError extends TypeBoxError {
  constructor(value, path, update) {
    super("Cannot set root value");
    this.value = value;
    this.path = path;
    this.update = update;
  }
}

class ValuePointerRootDeleteError extends TypeBoxError {
  constructor(value, path) {
    super("Cannot delete root value");
    this.value = value;
    this.path = path;
  }
}
function Escape2(component) {
  return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
}
function* Format(pointer) {
  if (pointer === "")
    return;
  let [start, end] = [0, 0];
  for (let i = 0;i < pointer.length; i++) {
    const char = pointer.charAt(i);
    if (char === "/") {
      if (i === 0) {
        start = i + 1;
      } else {
        end = i;
        yield Escape2(pointer.slice(start, end));
        start = i + 1;
      }
    } else {
      end = i;
    }
  }
  yield Escape2(pointer.slice(start));
}
function Set4(value, pointer, update) {
  if (pointer === "")
    throw new ValuePointerRootSetError(value, pointer, update);
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      next[component] = {};
    owner = next;
    next = next[component];
    key = component;
  }
  owner[key] = update;
}
function Delete3(value, pointer) {
  if (pointer === "")
    throw new ValuePointerRootDeleteError(value, pointer);
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined || next[component] === null)
      return;
    owner = next;
    next = next[component];
    key = component;
  }
  if (Array.isArray(owner)) {
    const index = parseInt(key);
    owner.splice(index, 1);
  } else {
    delete owner[key];
  }
}
function Has3(value, pointer) {
  if (pointer === "")
    return true;
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      return false;
    owner = next;
    next = next[component];
    key = component;
  }
  return Object.getOwnPropertyNames(owner).includes(key);
}
function Get3(value, pointer) {
  if (pointer === "")
    return value;
  let current = value;
  for (const component of Format(pointer)) {
    if (current[component] === undefined)
      return;
    current = current[component];
  }
  return current;
}
// node_modules/@sinclair/typebox/build/esm/value/delta/delta.mjs
var Insert = Object2({
  type: Literal("insert"),
  path: String2(),
  value: Unknown()
});
var Update = Object2({
  type: Literal("update"),
  path: String2(),
  value: Unknown()
});
var Delete4 = Object2({
  type: Literal("delete"),
  path: String2()
});
var Edit = Union([Insert, Update, Delete4]);

class ValueDeltaError extends TypeBoxError {
  constructor(value, message) {
    super(message);
    this.value = value;
  }
}

class ValueDeltaSymbolError extends ValueDeltaError {
  constructor(value) {
    super(value, "Cannot diff objects with symbol keys");
    this.value = value;
  }
}
function CreateUpdate(path, value) {
  return { type: "update", path, value };
}
function CreateInsert(path, value) {
  return { type: "insert", path, value };
}
function CreateDelete(path) {
  return { type: "delete", path };
}
function* ObjectType4(path, current, next) {
  if (!IsStandardObject(next))
    return yield CreateUpdate(path, next);
  const currentKeys = [...globalThis.Object.keys(current), ...globalThis.Object.getOwnPropertySymbols(current)];
  const nextKeys = [...globalThis.Object.keys(next), ...globalThis.Object.getOwnPropertySymbols(next)];
  for (const key of currentKeys) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(next[key]) && nextKeys.includes(key))
      yield CreateUpdate(`${path}/${globalThis.String(key)}`, undefined);
  }
  for (const key of nextKeys) {
    if (IsUndefined(current[key]) || IsUndefined(next[key]))
      continue;
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    yield* Visit12(`${path}/${globalThis.String(key)}`, current[key], next[key]);
  }
  for (const key of nextKeys) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(current[key]))
      yield CreateInsert(`${path}/${globalThis.String(key)}`, next[key]);
  }
  for (const key of currentKeys.reverse()) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(next[key]) && !nextKeys.includes(key))
      yield CreateDelete(`${path}/${globalThis.String(key)}`);
  }
}
function* ArrayType4(path, current, next) {
  if (!IsArray(next))
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit12(`${path}/${i}`, current[i], next[i]);
  }
  for (let i = 0;i < next.length; i++) {
    if (i < current.length)
      continue;
    yield CreateInsert(`${path}/${i}`, next[i]);
  }
  for (let i = current.length - 1;i >= 0; i--) {
    if (i < next.length)
      continue;
    yield CreateDelete(`${path}/${i}`);
  }
}
function* TypedArrayType2(path, current, next) {
  if (!IsTypedArray(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit12(`${path}/${i}`, current[i], next[i]);
  }
}
function* ValueType2(path, current, next) {
  if (current === next)
    return;
  yield CreateUpdate(path, next);
}
function* Visit12(path, current, next) {
  if (IsStandardObject(current))
    return yield* ObjectType4(path, current, next);
  if (IsArray(current))
    return yield* ArrayType4(path, current, next);
  if (IsTypedArray(current))
    return yield* TypedArrayType2(path, current, next);
  if (IsValueType(current))
    return yield* ValueType2(path, current, next);
  throw new ValueDeltaError(current, "Unable to create diff edits for unknown value");
}
function Diff(current, next) {
  return [...Visit12("", current, next)];
}
function IsRootUpdate(edits) {
  return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
}
function IsIdentity(edits) {
  return edits.length === 0;
}
function Patch(current, edits) {
  if (IsRootUpdate(edits)) {
    return Clone2(edits[0].value);
  }
  if (IsIdentity(edits)) {
    return Clone2(current);
  }
  const clone2 = Clone2(current);
  for (const edit of edits) {
    switch (edit.type) {
      case "insert": {
        exports_pointer.Set(clone2, edit.path, edit.value);
        break;
      }
      case "update": {
        exports_pointer.Set(clone2, edit.path, edit.value);
        break;
      }
      case "delete": {
        exports_pointer.Delete(clone2, edit.path);
        break;
      }
    }
  }
  return clone2;
}
// node_modules/@sinclair/typebox/build/esm/value/equal/equal.mjs
function ObjectType5(left, right) {
  if (!IsStandardObject(right))
    return false;
  const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
  const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
  if (leftKeys.length !== rightKeys.length)
    return false;
  return leftKeys.every((key) => Equal(left[key], right[key]));
}
function DateType4(left, right) {
  return IsDate(right) && left.getTime() === right.getTime();
}
function ArrayType5(left, right) {
  if (!IsArray(right) || left.length !== right.length)
    return false;
  return left.every((value, index) => Equal(value, right[index]));
}
function TypedArrayType3(left, right) {
  if (!IsTypedArray(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
    return false;
  return left.every((value, index) => Equal(value, right[index]));
}
function ValueType3(left, right) {
  return left === right;
}
function Equal(left, right) {
  if (IsStandardObject(left))
    return ObjectType5(left, right);
  if (IsDate(left))
    return DateType4(left, right);
  if (IsTypedArray(left))
    return TypedArrayType3(left, right);
  if (IsArray(left))
    return ArrayType5(left, right);
  if (IsValueType(left))
    return ValueType3(left, right);
  throw new Error("ValueEquals: Unable to compare value");
}
// node_modules/@sinclair/typebox/build/esm/value/mutate/mutate.mjs
class ValueMutateError extends TypeBoxError {
  constructor(message) {
    super(message);
  }
}
function ObjectType6(root, path, current, next) {
  if (!IsStandardObject(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    const currentKeys = Object.getOwnPropertyNames(current);
    const nextKeys = Object.getOwnPropertyNames(next);
    for (const currentKey of currentKeys) {
      if (!nextKeys.includes(currentKey)) {
        delete current[currentKey];
      }
    }
    for (const nextKey of nextKeys) {
      if (!currentKeys.includes(nextKey)) {
        current[nextKey] = null;
      }
    }
    for (const nextKey of nextKeys) {
      Visit13(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
    }
  }
}
function ArrayType6(root, path, current, next) {
  if (!IsArray(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    for (let index = 0;index < next.length; index++) {
      Visit13(root, `${path}/${index}`, current[index], next[index]);
    }
    current.splice(next.length);
  }
}
function TypedArrayType4(root, path, current, next) {
  if (IsTypedArray(current) && current.length === next.length) {
    for (let i = 0;i < current.length; i++) {
      current[i] = next[i];
    }
  } else {
    exports_pointer.Set(root, path, Clone2(next));
  }
}
function ValueType4(root, path, current, next) {
  if (current === next)
    return;
  exports_pointer.Set(root, path, next);
}
function Visit13(root, path, current, next) {
  if (IsArray(next))
    return ArrayType6(root, path, current, next);
  if (IsTypedArray(next))
    return TypedArrayType4(root, path, current, next);
  if (IsStandardObject(next))
    return ObjectType6(root, path, current, next);
  if (IsValueType(next))
    return ValueType4(root, path, current, next);
}
function IsNonMutableValue(value) {
  return IsTypedArray(value) || IsValueType(value);
}
function IsMismatchedValue(current, next) {
  return IsStandardObject(current) && IsArray(next) || IsArray(current) && IsStandardObject(next);
}
function Mutate(current, next) {
  if (IsNonMutableValue(current) || IsNonMutableValue(next))
    throw new ValueMutateError("Only object and array types can be mutated at the root level");
  if (IsMismatchedValue(current, next))
    throw new ValueMutateError("Cannot assign due type mismatch of assignable values");
  Visit13(current, "", current, next);
}
// node_modules/@sinclair/typebox/build/esm/value/transform/decode.mjs
class TransformDecodeCheckError extends TypeBoxError {
  constructor(schema, value, error2) {
    super(`Unable to decode value as it does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error2;
  }
}

class TransformDecodeError extends TypeBoxError {
  constructor(schema, path, value, error2) {
    super(error2 instanceof Error ? error2.message : "Unknown error");
    this.schema = schema;
    this.path = path;
    this.value = value;
    this.error = error2;
  }
}
function Default4(schema, path, value) {
  try {
    return IsTransform2(schema) ? schema[TransformKind].Decode(value) : value;
  } catch (error2) {
    throw new TransformDecodeError(schema, path, value, error2);
  }
}
function FromArray11(schema, references, path, value) {
  return IsArray(value) ? Default4(schema, path, value.map((value2, index) => Visit14(schema.items, references, `${path}/${index}`, value2))) : Default4(schema, path, value);
}
function FromIntersect11(schema, references, path, value) {
  if (!IsStandardObject(value) || IsValueType(value))
    return Default4(schema, path, value);
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...value };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit14(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform2(schema.unevaluatedProperties)) {
    return Default4(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default4(unevaluatedProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default4(schema, path, unknownProperties);
}
function FromNot5(schema, references, path, value) {
  return Default4(schema, path, Visit14(schema.not, references, path, value));
}
function FromObject9(schema, references, path, value) {
  if (!IsStandardObject(value))
    return Default4(schema, path, value);
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...value };
  for (const key of knownKeys)
    if (key in knownProperties) {
      knownProperties[key] = Visit14(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return Default4(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default4(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default4(schema, path, unknownProperties);
}
function FromRecord9(schema, references, path, value) {
  if (!IsStandardObject(value))
    return Default4(schema, path, value);
  const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern2);
  const knownProperties = { ...value };
  for (const key of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit14(schema.patternProperties[pattern2], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return Default4(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      unknownProperties[key] = Default4(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default4(schema, path, unknownProperties);
}
function FromRef8(schema, references, path, value) {
  const target = Deref(schema, references);
  return Default4(schema, path, Visit14(target, references, path, value));
}
function FromThis8(schema, references, path, value) {
  const target = Deref(schema, references);
  return Default4(schema, path, Visit14(target, references, path, value));
}
function FromTuple11(schema, references, path, value) {
  return IsArray(value) && IsArray(schema.items) ? Default4(schema, path, schema.items.map((schema2, index) => Visit14(schema2, references, `${path}/${index}`, value[index]))) : Default4(schema, path, value);
}
function FromUnion13(schema, references, path, value) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value))
      continue;
    const decoded = Visit14(subschema, references, path, value);
    return Default4(schema, path, decoded);
  }
  return Default4(schema, path, value);
}
function Visit14(schema, references, path, value) {
  const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray11(schema_, references_, path, value);
    case "Intersect":
      return FromIntersect11(schema_, references_, path, value);
    case "Not":
      return FromNot5(schema_, references_, path, value);
    case "Object":
      return FromObject9(schema_, references_, path, value);
    case "Record":
      return FromRecord9(schema_, references_, path, value);
    case "Ref":
      return FromRef8(schema_, references_, path, value);
    case "Symbol":
      return Default4(schema_, path, value);
    case "This":
      return FromThis8(schema_, references_, path, value);
    case "Tuple":
      return FromTuple11(schema_, references_, path, value);
    case "Union":
      return FromUnion13(schema_, references_, path, value);
    default:
      return Default4(schema_, path, value);
  }
}
function TransformDecode(schema, references, value) {
  return Visit14(schema, references, "", value);
}
// node_modules/@sinclair/typebox/build/esm/value/transform/encode.mjs
class TransformEncodeCheckError extends TypeBoxError {
  constructor(schema, value, error2) {
    super(`The encoded value does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error2;
  }
}

class TransformEncodeError extends TypeBoxError {
  constructor(schema, path, value, error2) {
    super(`${error2 instanceof Error ? error2.message : "Unknown error"}`);
    this.schema = schema;
    this.path = path;
    this.value = value;
    this.error = error2;
  }
}
function Default5(schema, path, value) {
  try {
    return IsTransform2(schema) ? schema[TransformKind].Encode(value) : value;
  } catch (error2) {
    throw new TransformEncodeError(schema, path, value, error2);
  }
}
function FromArray12(schema, references, path, value) {
  const defaulted = Default5(schema, path, value);
  return IsArray(defaulted) ? defaulted.map((value2, index) => Visit15(schema.items, references, `${path}/${index}`, value2)) : defaulted;
}
function FromIntersect12(schema, references, path, value) {
  const defaulted = Default5(schema, path, value);
  if (!IsStandardObject(value) || IsValueType(value))
    return defaulted;
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...defaulted };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit15(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform2(schema.unevaluatedProperties)) {
    return Default5(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default5(unevaluatedProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromNot6(schema, references, path, value) {
  return Default5(schema.not, path, Default5(schema, path, value));
}
function FromObject10(schema, references, path, value) {
  const defaulted = Default5(schema, path, value);
  if (!IsStandardObject(defaulted))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...defaulted };
  for (const key of knownKeys)
    if (key in knownProperties) {
      knownProperties[key] = Visit15(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default5(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromRecord10(schema, references, path, value) {
  const defaulted = Default5(schema, path, value);
  if (!IsStandardObject(value))
    return defaulted;
  const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern2);
  const knownProperties = { ...defaulted };
  for (const key of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit15(schema.patternProperties[pattern2], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return Default5(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      properties[key] = Default5(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromRef9(schema, references, path, value) {
  const target = Deref(schema, references);
  const resolved = Visit15(target, references, path, value);
  return Default5(schema, path, resolved);
}
function FromThis9(schema, references, path, value) {
  const target = Deref(schema, references);
  const resolved = Visit15(target, references, path, value);
  return Default5(schema, path, resolved);
}
function FromTuple12(schema, references, path, value) {
  const value1 = Default5(schema, path, value);
  return IsArray(schema.items) ? schema.items.map((schema2, index) => Visit15(schema2, references, `${path}/${index}`, value1[index])) : [];
}
function FromUnion14(schema, references, path, value) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value))
      continue;
    const value1 = Visit15(subschema, references, path, value);
    return Default5(schema, path, value1);
  }
  for (const subschema of schema.anyOf) {
    const value1 = Visit15(subschema, references, path, value);
    if (!Check(schema, references, value1))
      continue;
    return Default5(schema, path, value1);
  }
  return Default5(schema, path, value);
}
function Visit15(schema, references, path, value) {
  const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray12(schema_, references_, path, value);
    case "Intersect":
      return FromIntersect12(schema_, references_, path, value);
    case "Not":
      return FromNot6(schema_, references_, path, value);
    case "Object":
      return FromObject10(schema_, references_, path, value);
    case "Record":
      return FromRecord10(schema_, references_, path, value);
    case "Ref":
      return FromRef9(schema_, references_, path, value);
    case "This":
      return FromThis9(schema_, references_, path, value);
    case "Tuple":
      return FromTuple12(schema_, references_, path, value);
    case "Union":
      return FromUnion14(schema_, references_, path, value);
    default:
      return Default5(schema_, path, value);
  }
}
function TransformEncode(schema, references, value) {
  return Visit15(schema, references, "", value);
}
// node_modules/@sinclair/typebox/build/esm/value/transform/has.mjs
function FromArray13(schema, references) {
  return IsTransform2(schema) || Visit16(schema.items, references);
}
function FromAsyncIterator5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.items, references);
}
function FromConstructor6(schema, references) {
  return IsTransform2(schema) || Visit16(schema.returns, references) || schema.parameters.some((schema2) => Visit16(schema2, references));
}
function FromFunction5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.returns, references) || schema.parameters.some((schema2) => Visit16(schema2, references));
}
function FromIntersect13(schema, references) {
  return IsTransform2(schema) || IsTransform2(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit16(schema2, references));
}
function FromIterator5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.items, references);
}
function FromNot7(schema, references) {
  return IsTransform2(schema) || Visit16(schema.not, references);
}
function FromObject11(schema, references) {
  return IsTransform2(schema) || Object.values(schema.properties).some((schema2) => Visit16(schema2, references)) || IsSchema2(schema.additionalProperties) && Visit16(schema.additionalProperties, references);
}
function FromPromise5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.item, references);
}
function FromRecord11(schema, references) {
  const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[pattern2];
  return IsTransform2(schema) || Visit16(property, references) || IsSchema2(schema.additionalProperties) && IsTransform2(schema.additionalProperties);
}
function FromRef10(schema, references) {
  if (IsTransform2(schema))
    return true;
  return Visit16(Deref(schema, references), references);
}
function FromThis10(schema, references) {
  if (IsTransform2(schema))
    return true;
  return Visit16(Deref(schema, references), references);
}
function FromTuple13(schema, references) {
  return IsTransform2(schema) || !IsUndefined(schema.items) && schema.items.some((schema2) => Visit16(schema2, references));
}
function FromUnion15(schema, references) {
  return IsTransform2(schema) || schema.anyOf.some((schema2) => Visit16(schema2, references));
}
function Visit16(schema, references) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  if (schema.$id && visited.has(schema.$id))
    return false;
  if (schema.$id)
    visited.add(schema.$id);
  switch (schema[Kind]) {
    case "Array":
      return FromArray13(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator5(schema_, references_);
    case "Constructor":
      return FromConstructor6(schema_, references_);
    case "Function":
      return FromFunction5(schema_, references_);
    case "Intersect":
      return FromIntersect13(schema_, references_);
    case "Iterator":
      return FromIterator5(schema_, references_);
    case "Not":
      return FromNot7(schema_, references_);
    case "Object":
      return FromObject11(schema_, references_);
    case "Promise":
      return FromPromise5(schema_, references_);
    case "Record":
      return FromRecord11(schema_, references_);
    case "Ref":
      return FromRef10(schema_, references_);
    case "This":
      return FromThis10(schema_, references_);
    case "Tuple":
      return FromTuple13(schema_, references_);
    case "Union":
      return FromUnion15(schema_, references_);
    default:
      return IsTransform2(schema);
  }
}
var visited = new Set;
function HasTransform(schema, references) {
  visited.clear();
  return Visit16(schema, references);
}
// node_modules/@sinclair/typebox/build/esm/value/value/value.mjs
var exports_value2 = {};
__export(exports_value2, {
  Patch: () => Patch2,
  Mutate: () => Mutate2,
  Hash: () => Hash2,
  Errors: () => Errors2,
  Equal: () => Equal2,
  Encode: () => Encode,
  Diff: () => Diff2,
  Default: () => Default6,
  Decode: () => Decode,
  Create: () => Create3,
  Convert: () => Convert2,
  Clone: () => Clone3,
  Clean: () => Clean2,
  Check: () => Check2,
  Cast: () => Cast2
});
function Cast2(...args) {
  return Cast.apply(Cast, args);
}
function Create3(...args) {
  return Create2.apply(Create2, args);
}
function Check2(...args) {
  return Check.apply(Check, args);
}
function Clean2(...args) {
  return Clean.apply(Clean, args);
}
function Convert2(...args) {
  return Convert.apply(Convert, args);
}
function Clone3(value) {
  return Clone2(value);
}
function Decode(...args) {
  const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  if (!Check2(schema, references, value))
    throw new TransformDecodeCheckError(schema, value, Errors2(schema, references, value).First());
  return HasTransform(schema, references) ? TransformDecode(schema, references, value) : value;
}
function Default6(...args) {
  return Default3.apply(Default3, args);
}
function Encode(...args) {
  const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  const encoded = HasTransform(schema, references) ? TransformEncode(schema, references, value) : value;
  if (!Check2(schema, references, encoded))
    throw new TransformEncodeCheckError(schema, encoded, Errors2(schema, references, encoded).First());
  return encoded;
}
function Errors2(...args) {
  return Errors.apply(Errors, args);
}
function Equal2(left, right) {
  return Equal(left, right);
}
function Diff2(current, next) {
  return Diff(current, next);
}
function Hash2(value) {
  return Hash(value);
}
function Patch2(current, edits) {
  return Patch(current, edits);
}
function Mutate2(current, next) {
  Mutate(current, next);
}
// node_modules/@sinclair/typebox/build/esm/type/awaited/awaited.mjs
function FromRest4(T) {
  return T.map((L) => AwaitedResolve(L));
}
function FromIntersect14(T) {
  return Intersect(FromRest4(T));
}
function FromUnion16(T) {
  return Union(FromRest4(T));
}
function FromPromise6(T) {
  return AwaitedResolve(T);
}
function AwaitedResolve(T) {
  return IsIntersect(T) ? FromIntersect14(T.allOf) : IsUnion(T) ? FromUnion16(T.anyOf) : IsPromise2(T) ? FromPromise6(T.item) : T;
}
function Awaited(T, options = {}) {
  return CloneType(AwaitedResolve(T), options);
}
// node_modules/@sinclair/typebox/build/esm/type/composite/composite.mjs
function CompositeKeys(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...KeyOfPropertyKeys(L));
  return SetDistinct(Acc);
}
function FilterNever(T) {
  return T.filter((L) => !IsNever(L));
}
function CompositeProperty(T, K) {
  const Acc = [];
  for (const L of T)
    Acc.push(...IndexFromPropertyKeys(L, [K]));
  return FilterNever(Acc);
}
function CompositeProperties(T, K) {
  const Acc = {};
  for (const L of K) {
    Acc[L] = IntersectEvaluated(CompositeProperty(T, L));
  }
  return Acc;
}
function Composite(T, options = {}) {
  const K = CompositeKeys(T);
  const P = CompositeProperties(T, K);
  const R = Object2(P, options);
  return R;
}
// node_modules/@sinclair/typebox/build/esm/type/date/date.mjs
function Date2(options = {}) {
  return {
    ...options,
    [Kind]: "Date",
    type: "Date"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/null/null.mjs
function Null(options = {}) {
  return {
    ...options,
    [Kind]: "Null",
    type: "null"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/symbol/symbol.mjs
function Symbol2(options) {
  return { ...options, [Kind]: "Symbol", type: "symbol" };
}
// node_modules/@sinclair/typebox/build/esm/type/undefined/undefined.mjs
function Undefined(options = {}) {
  return { ...options, [Kind]: "Undefined", type: "undefined" };
}
// node_modules/@sinclair/typebox/build/esm/type/uint8array/uint8array.mjs
function Uint8Array2(options = {}) {
  return { ...options, [Kind]: "Uint8Array", type: "Uint8Array" };
}
// node_modules/@sinclair/typebox/build/esm/type/const/const.mjs
function FromArray14(T) {
  return T.map((L) => FromValue(L, false));
}
function FromProperties8(value2) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(value2))
    Acc[K] = Readonly(FromValue(value2[K], false));
  return Acc;
}
function ConditionalReadonly(T, root) {
  return root === true ? T : Readonly(T);
}
function FromValue(value2, root) {
  return IsAsyncIterator2(value2) ? ConditionalReadonly(Any(), root) : IsIterator2(value2) ? ConditionalReadonly(Any(), root) : IsArray2(value2) ? Readonly(Tuple(FromArray14(value2))) : IsUint8Array2(value2) ? Uint8Array2() : IsDate2(value2) ? Date2() : IsObject2(value2) ? ConditionalReadonly(Object2(FromProperties8(value2)), root) : IsFunction2(value2) ? ConditionalReadonly(Function2([], Unknown()), root) : IsUndefined2(value2) ? Undefined() : IsNull2(value2) ? Null() : IsSymbol2(value2) ? Symbol2() : IsBigInt2(value2) ? BigInt2() : IsNumber2(value2) ? Literal(value2) : IsBoolean2(value2) ? Literal(value2) : IsString2(value2) ? Literal(value2) : Object2({});
}
function Const(T, options = {}) {
  return CloneType(FromValue(T, true), options);
}
// node_modules/@sinclair/typebox/build/esm/type/constructor-parameters/constructor-parameters.mjs
function ConstructorParameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}
// node_modules/@sinclair/typebox/build/esm/type/deref/deref.mjs
function FromRest5(schema, references) {
  return schema.map((schema2) => Deref2(schema2, references));
}
function FromProperties9(properties, references) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties)) {
    Acc[K] = Deref2(properties[K], references);
  }
  return Acc;
}
function FromConstructor7(schema, references) {
  schema.parameters = FromRest5(schema.parameters, references);
  schema.returns = Deref2(schema.returns, references);
  return schema;
}
function FromFunction6(schema, references) {
  schema.parameters = FromRest5(schema.parameters, references);
  schema.returns = Deref2(schema.returns, references);
  return schema;
}
function FromIntersect15(schema, references) {
  schema.allOf = FromRest5(schema.allOf, references);
  return schema;
}
function FromUnion17(schema, references) {
  schema.anyOf = FromRest5(schema.anyOf, references);
  return schema;
}
function FromTuple14(schema, references) {
  if (IsUndefined2(schema.items))
    return schema;
  schema.items = FromRest5(schema.items, references);
  return schema;
}
function FromArray15(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
}
function FromObject12(schema, references) {
  schema.properties = FromProperties9(schema.properties, references);
  return schema;
}
function FromPromise7(schema, references) {
  schema.item = Deref2(schema.item, references);
  return schema;
}
function FromAsyncIterator6(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
}
function FromIterator6(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
}
function FromRef11(schema, references) {
  const target = references.find((remote) => remote.$id === schema.$ref);
  if (target === undefined)
    throw Error(`Unable to dereference schema with $id ${schema.$ref}`);
  const discard2 = Discard(target, ["$id"]);
  return Deref2(discard2, references);
}
function DerefResolve(schema, references) {
  return IsConstructor(schema) ? FromConstructor7(schema, references) : IsFunction3(schema) ? FromFunction6(schema, references) : IsIntersect(schema) ? FromIntersect15(schema, references) : IsUnion(schema) ? FromUnion17(schema, references) : IsTuple(schema) ? FromTuple14(schema, references) : IsArray3(schema) ? FromArray15(schema, references) : IsObject3(schema) ? FromObject12(schema, references) : IsPromise2(schema) ? FromPromise7(schema, references) : IsAsyncIterator3(schema) ? FromAsyncIterator6(schema, references) : IsIterator3(schema) ? FromIterator6(schema, references) : IsRef(schema) ? FromRef11(schema, references) : schema;
}
function Deref2(schema, references) {
  return DerefResolve(CloneType(schema), CloneRest(references));
}
// node_modules/@sinclair/typebox/build/esm/type/enum/enum.mjs
function Enum(item, options = {}) {
  if (IsUndefined2(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value2) => Literal(value2));
  return Union(anyOf, { ...options, [Hint]: "Enum" });
}
// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-template-literal.mjs
function ExcludeFromTemplateLiteral(L, R) {
  return Exclude(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude.mjs
function ExcludeRest(L, R) {
  const excluded = L.filter((inner) => ExtendsCheck(inner, R) === ExtendsResult.False);
  return excluded.length === 1 ? excluded[0] : Union(excluded);
}
function Exclude(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CloneType(ExcludeFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CloneType(ExcludeFromMappedResult(L, R), options);
  return CloneType(IsUnion(L) ? ExcludeRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? Never() : L, options);
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-mapped-result.mjs
function FromProperties10(P, U) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Exclude(P[K2], U);
  return Acc;
}
function FromMappedResult7(R, T) {
  return FromProperties10(R.properties, T);
}
function ExcludeFromMappedResult(R, T) {
  const P = FromMappedResult7(R, T);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-template-literal.mjs
function ExtractFromTemplateLiteral(L, R) {
  return Extract(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract.mjs
function ExtractRest(L, R) {
  const extracted = L.filter((inner) => ExtendsCheck(inner, R) !== ExtendsResult.False);
  return extracted.length === 1 ? extracted[0] : Union(extracted);
}
function Extract(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CloneType(ExtractFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CloneType(ExtractFromMappedResult(L, R), options);
  return CloneType(IsUnion(L) ? ExtractRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? L : Never(), options);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-mapped-result.mjs
function FromProperties11(P, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extract(P[K2], T);
  return Acc;
}
function FromMappedResult8(R, T) {
  return FromProperties11(R.properties, T);
}
function ExtractFromMappedResult(R, T) {
  const P = FromMappedResult8(R, T);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/instance-type/instance-type.mjs
function InstanceType(schema, options = {}) {
  return CloneType(schema.returns, options);
}
// node_modules/@sinclair/typebox/build/esm/type/integer/integer.mjs
function Integer(options = {}) {
  return {
    ...options,
    [Kind]: "Integer",
    type: "integer"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic-from-mapped-key.mjs
function MappedIntrinsicPropertyKey(K, M, options) {
  return {
    [K]: Intrinsic(Literal(K), M, options)
  };
}
function MappedIntrinsicPropertyKeys(K, M, options) {
  return K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
  }, {});
}
function MappedIntrinsicProperties(T, M, options) {
  return MappedIntrinsicPropertyKeys(T["keys"], M, options);
}
function IntrinsicFromMappedKey(T, M, options) {
  const P = MappedIntrinsicProperties(T, M, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic.mjs
function ApplyUncapitalize(value2) {
  const [first, rest] = [value2.slice(0, 1), value2.slice(1)];
  return [first.toLowerCase(), rest].join("");
}
function ApplyCapitalize(value2) {
  const [first, rest] = [value2.slice(0, 1), value2.slice(1)];
  return [first.toUpperCase(), rest].join("");
}
function ApplyUppercase(value2) {
  return value2.toUpperCase();
}
function ApplyLowercase(value2) {
  return value2.toLowerCase();
}
function FromTemplateLiteral6(schema, mode, options) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  const finite2 = IsTemplateLiteralExpressionFinite(expression);
  if (!finite2)
    return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate(expression)];
  const literals = strings.map((value2) => Literal(value2));
  const mapped2 = FromRest6(literals, mode);
  const union3 = Union(mapped2);
  return TemplateLiteral([union3], options);
}
function FromLiteralValue(value2, mode) {
  return typeof value2 === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value2) : mode === "Capitalize" ? ApplyCapitalize(value2) : mode === "Uppercase" ? ApplyUppercase(value2) : mode === "Lowercase" ? ApplyLowercase(value2) : value2 : value2.toString();
}
function FromRest6(T, M) {
  return T.map((L) => Intrinsic(L, M));
}
function Intrinsic(schema, mode, options = {}) {
  return IsMappedKey(schema) ? IntrinsicFromMappedKey(schema, mode, options) : IsTemplateLiteral(schema) ? FromTemplateLiteral6(schema, mode, schema) : IsUnion(schema) ? Union(FromRest6(schema.anyOf, mode), options) : IsLiteral(schema) ? Literal(FromLiteralValue(schema.const, mode), options) : schema;
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/capitalize.mjs
function Capitalize(T, options = {}) {
  return Intrinsic(T, "Capitalize", options);
}
// node_modules/@sinclair/typebox/build/esm/type/intrinsic/lowercase.mjs
function Lowercase(T, options = {}) {
  return Intrinsic(T, "Lowercase", options);
}
// node_modules/@sinclair/typebox/build/esm/type/intrinsic/uncapitalize.mjs
function Uncapitalize(T, options = {}) {
  return Intrinsic(T, "Uncapitalize", options);
}
// node_modules/@sinclair/typebox/build/esm/type/intrinsic/uppercase.mjs
function Uppercase(T, options = {}) {
  return Intrinsic(T, "Uppercase", options);
}
// node_modules/@sinclair/typebox/build/esm/type/not/not.mjs
function Not2(schema, options) {
  return {
    ...options,
    [Kind]: "Not",
    not: CloneType(schema)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-result.mjs
function FromProperties12(P, K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Omit(P[K2], K, options);
  return Acc;
}
function FromMappedResult9(R, K, options) {
  return FromProperties12(R.properties, K, options);
}
function OmitFromMappedResult(R, K, options) {
  const P = FromMappedResult9(R, K, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit.mjs
function FromIntersect16(T, K) {
  return T.map((T2) => OmitResolve(T2, K));
}
function FromUnion18(T, K) {
  return T.map((T2) => OmitResolve(T2, K));
}
function FromProperty2(T, K) {
  const { [K]: _, ...R } = T;
  return R;
}
function FromProperties13(T, K) {
  return K.reduce((T2, K2) => FromProperty2(T2, K2), T);
}
function OmitResolve(T, K) {
  return IsIntersect(T) ? Intersect(FromIntersect16(T.allOf, K)) : IsUnion(T) ? Union(FromUnion18(T.anyOf, K)) : IsObject3(T) ? Object2(FromProperties13(T.properties, K)) : Object2({});
}
function Omit(T, K, options = {}) {
  if (IsMappedKey(K))
    return OmitFromMappedKey(T, K, options);
  if (IsMappedResult(T))
    return OmitFromMappedResult(T, K, options);
  const I = IsSchema(K) ? IndexPropertyKeys(K) : K;
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(OmitResolve(T, I), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-key.mjs
function FromPropertyKey2(T, K, options) {
  return {
    [K]: Omit(T, [K], options)
  };
}
function FromPropertyKeys2(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey2(T, LK, options) };
  }, {});
}
function FromMappedKey3(T, K, options) {
  return FromPropertyKeys2(T, K.keys, options);
}
function OmitFromMappedKey(T, K, options) {
  const P = FromMappedKey3(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/parameters/parameters.mjs
function Parameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}
// node_modules/@sinclair/typebox/build/esm/type/partial/partial.mjs
function FromRest7(T) {
  return T.map((L) => PartialResolve(L));
}
function FromProperties14(T) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(T))
    Acc[K] = Optional(T[K]);
  return Acc;
}
function PartialResolve(T) {
  return IsIntersect(T) ? Intersect(FromRest7(T.allOf)) : IsUnion(T) ? Union(FromRest7(T.anyOf)) : IsObject3(T) ? Object2(FromProperties14(T.properties)) : Object2({});
}
function Partial(T, options = {}) {
  if (IsMappedResult(T))
    return PartialFromMappedResult(T, options);
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(PartialResolve(T), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/esm/type/partial/partial-from-mapped-result.mjs
function FromProperties15(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Partial(K[K2], options);
  return Acc;
}
function FromMappedResult10(R, options) {
  return FromProperties15(R.properties, options);
}
function PartialFromMappedResult(R, options) {
  const P = FromMappedResult10(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-result.mjs
function FromProperties16(P, K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Pick(P[K2], K, options);
  return Acc;
}
function FromMappedResult11(R, K, options) {
  return FromProperties16(R.properties, K, options);
}
function PickFromMappedResult(R, K, options) {
  const P = FromMappedResult11(R, K, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick.mjs
function FromIntersect17(T, K) {
  return T.map((T2) => PickResolve(T2, K));
}
function FromUnion19(T, K) {
  return T.map((T2) => PickResolve(T2, K));
}
function FromProperties17(T, K) {
  const Acc = {};
  for (const K2 of K)
    if (K2 in T)
      Acc[K2] = T[K2];
  return Acc;
}
function PickResolve(T, K) {
  return IsIntersect(T) ? Intersect(FromIntersect17(T.allOf, K)) : IsUnion(T) ? Union(FromUnion19(T.anyOf, K)) : IsObject3(T) ? Object2(FromProperties17(T.properties, K)) : Object2({});
}
function Pick(T, K, options = {}) {
  if (IsMappedKey(K))
    return PickFromMappedKey(T, K, options);
  if (IsMappedResult(T))
    return PickFromMappedResult(T, K, options);
  const I = IsSchema(K) ? IndexPropertyKeys(K) : K;
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(PickResolve(T, I), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-key.mjs
function FromPropertyKey3(T, K, options) {
  return {
    [K]: Pick(T, [K], options)
  };
}
function FromPropertyKeys3(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey3(T, LK, options) };
  }, {});
}
function FromMappedKey4(T, K, options) {
  return FromPropertyKeys3(T, K.keys, options);
}
function PickFromMappedKey(T, K, options) {
  const P = FromMappedKey4(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/readonly-optional/readonly-optional.mjs
function ReadonlyOptional(schema) {
  return Readonly(Optional(schema));
}
// node_modules/@sinclair/typebox/build/esm/type/record/record.mjs
function RecordCreateFromPattern(pattern2, T, options) {
  return {
    ...options,
    [Kind]: "Record",
    type: "object",
    patternProperties: { [pattern2]: CloneType(T) }
  };
}
function RecordCreateFromKeys(K, T, options) {
  const Acc = {};
  for (const K2 of K)
    Acc[K2] = CloneType(T);
  return Object2(Acc, { ...options, [Hint]: "Record" });
}
function FromTemplateLiteralKey(K, T, options) {
  return IsTemplateLiteralFinite(K) ? RecordCreateFromKeys(IndexPropertyKeys(K), T, options) : RecordCreateFromPattern(K.pattern, T, options);
}
function FromUnionKey(K, T, options) {
  return RecordCreateFromKeys(IndexPropertyKeys(Union(K)), T, options);
}
function FromLiteralKey(K, T, options) {
  return RecordCreateFromKeys([K.toString()], T, options);
}
function FromRegExpKey(K, T, options) {
  return RecordCreateFromPattern(K.source, T, options);
}
function FromStringKey(K, T, options) {
  const pattern2 = IsUndefined2(K.pattern) ? PatternStringExact : K.pattern;
  return RecordCreateFromPattern(pattern2, T, options);
}
function FromAnyKey(K, T, options) {
  return RecordCreateFromPattern(PatternStringExact, T, options);
}
function FromNeverKey(K, T, options) {
  return RecordCreateFromPattern(PatternNeverExact, T, options);
}
function FromIntegerKey(_, T, options) {
  return RecordCreateFromPattern(PatternNumberExact, T, options);
}
function FromNumberKey(_, T, options) {
  return RecordCreateFromPattern(PatternNumberExact, T, options);
}
function Record(K, T, options = {}) {
  return IsUnion(K) ? FromUnionKey(K.anyOf, T, options) : IsTemplateLiteral(K) ? FromTemplateLiteralKey(K, T, options) : IsLiteral(K) ? FromLiteralKey(K.const, T, options) : IsInteger2(K) ? FromIntegerKey(K, T, options) : IsNumber3(K) ? FromNumberKey(K, T, options) : IsRegExp2(K) ? FromRegExpKey(K, T, options) : IsString3(K) ? FromStringKey(K, T, options) : IsAny(K) ? FromAnyKey(K, T, options) : IsNever(K) ? FromNeverKey(K, T, options) : Never(options);
}
// node_modules/@sinclair/typebox/build/esm/type/recursive/recursive.mjs
var Ordinal = 0;
function Recursive(callback, options = {}) {
  if (IsUndefined2(options.$id))
    options.$id = `T${Ordinal++}`;
  const thisType = callback({ [Kind]: "This", $ref: `${options.$id}` });
  thisType.$id = options.$id;
  return CloneType({ ...options, [Hint]: "Recursive", ...thisType });
}
// node_modules/@sinclair/typebox/build/esm/type/ref/ref.mjs
function Ref(unresolved, options = {}) {
  if (IsString2(unresolved))
    return { ...options, [Kind]: "Ref", $ref: unresolved };
  if (IsUndefined2(unresolved.$id))
    throw new Error("Reference target type must specify an $id");
  return {
    ...options,
    [Kind]: "Ref",
    $ref: unresolved.$id
  };
}
// node_modules/@sinclair/typebox/build/esm/type/regexp/regexp.mjs
function RegExp2(unresolved, options = {}) {
  const expr = IsString2(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return { ...options, [Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags };
}
// node_modules/@sinclair/typebox/build/esm/type/required/required.mjs
function FromRest8(T) {
  return T.map((L) => RequiredResolve(L));
}
function FromProperties18(T) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(T))
    Acc[K] = Discard(T[K], [OptionalKind]);
  return Acc;
}
function RequiredResolve(T) {
  return IsIntersect(T) ? Intersect(FromRest8(T.allOf)) : IsUnion(T) ? Union(FromRest8(T.anyOf)) : IsObject3(T) ? Object2(FromProperties18(T.properties)) : Object2({});
}
function Required(T, options = {}) {
  if (IsMappedResult(T)) {
    return RequiredFromMappedResult(T, options);
  } else {
    const D = Discard(T, [TransformKind, "$id", "required"]);
    const R = CloneType(RequiredResolve(T), options);
    return { ...D, ...R };
  }
}

// node_modules/@sinclair/typebox/build/esm/type/required/required-from-mapped-result.mjs
function FromProperties19(P, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Required(P[K2], options);
  return Acc;
}
function FromMappedResult12(R, options) {
  return FromProperties19(R.properties, options);
}
function RequiredFromMappedResult(R, options) {
  const P = FromMappedResult12(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/rest/rest.mjs
function RestResolve(T) {
  return IsIntersect(T) ? CloneRest(T.allOf) : IsUnion(T) ? CloneRest(T.anyOf) : IsTuple(T) ? CloneRest(T.items ?? []) : [];
}
function Rest(T) {
  return CloneRest(RestResolve(T));
}
// node_modules/@sinclair/typebox/build/esm/type/return-type/return-type.mjs
function ReturnType(schema, options = {}) {
  return CloneType(schema.returns, options);
}
// node_modules/@sinclair/typebox/build/esm/type/strict/strict.mjs
function Strict(schema2) {
  return JSON.parse(JSON.stringify(schema2));
}
// node_modules/@sinclair/typebox/build/esm/type/transform/transform.mjs
class TransformDecodeBuilder {
  constructor(schema2) {
    this.schema = schema2;
  }
  Decode(decode2) {
    return new TransformEncodeBuilder(this.schema, decode2);
  }
}

class TransformEncodeBuilder {
  constructor(schema2, decode2) {
    this.schema = schema2;
    this.decode = decode2;
  }
  EncodeTransform(encode2, schema2) {
    const Encode2 = (value2) => schema2[TransformKind].Encode(encode2(value2));
    const Decode2 = (value2) => this.decode(schema2[TransformKind].Decode(value2));
    const Codec = { Encode: Encode2, Decode: Decode2 };
    return { ...schema2, [TransformKind]: Codec };
  }
  EncodeSchema(encode2, schema2) {
    const Codec = { Decode: this.decode, Encode: encode2 };
    return { ...schema2, [TransformKind]: Codec };
  }
  Encode(encode2) {
    const schema2 = CloneType(this.schema);
    return IsTransform(schema2) ? this.EncodeTransform(encode2, schema2) : this.EncodeSchema(encode2, schema2);
  }
}
function Transform(schema2) {
  return new TransformDecodeBuilder(schema2);
}
// node_modules/@sinclair/typebox/build/esm/type/void/void.mjs
function Void(options = {}) {
  return {
    ...options,
    [Kind]: "Void",
    type: "void"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/type/type.mjs
var exports_type3 = {};
__export(exports_type3, {
  Void: () => Void,
  Uppercase: () => Uppercase,
  Unsafe: () => Unsafe,
  Unknown: () => Unknown,
  Union: () => Union,
  Undefined: () => Undefined,
  Uncapitalize: () => Uncapitalize,
  Uint8Array: () => Uint8Array2,
  Tuple: () => Tuple,
  Transform: () => Transform,
  TemplateLiteral: () => TemplateLiteral,
  Symbol: () => Symbol2,
  String: () => String2,
  Strict: () => Strict,
  ReturnType: () => ReturnType,
  Rest: () => Rest,
  Required: () => Required,
  RegExp: () => RegExp2,
  Ref: () => Ref,
  Recursive: () => Recursive,
  Record: () => Record,
  ReadonlyOptional: () => ReadonlyOptional,
  Readonly: () => Readonly,
  Promise: () => Promise2,
  Pick: () => Pick,
  Partial: () => Partial,
  Parameters: () => Parameters,
  Optional: () => Optional,
  Omit: () => Omit,
  Object: () => Object2,
  Number: () => Number2,
  Null: () => Null,
  Not: () => Not2,
  Never: () => Never,
  Mapped: () => Mapped,
  Lowercase: () => Lowercase,
  Literal: () => Literal,
  KeyOf: () => KeyOf,
  Iterator: () => Iterator,
  Intersect: () => Intersect,
  Integer: () => Integer,
  InstanceType: () => InstanceType,
  Index: () => Index,
  Function: () => Function2,
  Extract: () => Extract,
  Extends: () => Extends,
  Exclude: () => Exclude,
  Enum: () => Enum,
  Deref: () => Deref2,
  Date: () => Date2,
  ConstructorParameters: () => ConstructorParameters,
  Constructor: () => Constructor,
  Const: () => Const,
  Composite: () => Composite,
  Capitalize: () => Capitalize,
  Boolean: () => Boolean2,
  BigInt: () => BigInt2,
  Awaited: () => Awaited,
  AsyncIterator: () => AsyncIterator,
  Array: () => Array2,
  Any: () => Any
});

// node_modules/@sinclair/typebox/build/esm/type/type/index.mjs
var Type = exports_type3;
// node_modules/@sinclair/typebox/build/esm/compiler/compiler.mjs
class TypeCheck {
  constructor(schema3, references, checkFunc, code) {
    this.schema = schema3;
    this.references = references;
    this.checkFunc = checkFunc;
    this.code = code;
    this.hasTransform = HasTransform(schema3, references);
  }
  Code() {
    return this.code;
  }
  Errors(value2) {
    return Errors(this.schema, this.references, value2);
  }
  Check(value2) {
    return this.checkFunc(value2);
  }
  Decode(value2) {
    if (!this.checkFunc(value2))
      throw new TransformDecodeCheckError(this.schema, value2, this.Errors(value2).First());
    return this.hasTransform ? TransformDecode(this.schema, this.references, value2) : value2;
  }
  Encode(value2) {
    const encoded = this.hasTransform ? TransformEncode(this.schema, this.references, value2) : value2;
    if (!this.checkFunc(encoded))
      throw new TransformEncodeCheckError(this.schema, value2, this.Errors(value2).First());
    return encoded;
  }
}
var Character;
(function(Character2) {
  function DollarSign(code) {
    return code === 36;
  }
  Character2.DollarSign = DollarSign;
  function IsUnderscore(code) {
    return code === 95;
  }
  Character2.IsUnderscore = IsUnderscore;
  function IsAlpha(code) {
    return code >= 65 && code <= 90 || code >= 97 && code <= 122;
  }
  Character2.IsAlpha = IsAlpha;
  function IsNumeric(code) {
    return code >= 48 && code <= 57;
  }
  Character2.IsNumeric = IsNumeric;
})(Character || (Character = {}));
var MemberExpression;
(function(MemberExpression2) {
  function IsFirstCharacterNumeric(value2) {
    if (value2.length === 0)
      return false;
    return Character.IsNumeric(value2.charCodeAt(0));
  }
  function IsAccessor(value2) {
    if (IsFirstCharacterNumeric(value2))
      return false;
    for (let i = 0;i < value2.length; i++) {
      const code = value2.charCodeAt(i);
      const check3 = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
      if (!check3)
        return false;
    }
    return true;
  }
  function EscapeHyphen(key) {
    return key.replace(/'/g, "\\'");
  }
  function Encode2(object3, key) {
    return IsAccessor(key) ? `${object3}.${key}` : `${object3}['${EscapeHyphen(key)}']`;
  }
  MemberExpression2.Encode = Encode2;
})(MemberExpression || (MemberExpression = {}));
var Identifier;
(function(Identifier2) {
  function Encode2($id) {
    const buffer = [];
    for (let i = 0;i < $id.length; i++) {
      const code = $id.charCodeAt(i);
      if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
        buffer.push($id.charAt(i));
      } else {
        buffer.push(`_${code}_`);
      }
    }
    return buffer.join("").replace(/__/g, "_");
  }
  Identifier2.Encode = Encode2;
})(Identifier || (Identifier = {}));
var LiteralString;
(function(LiteralString2) {
  function Escape3(content) {
    return content.replace(/'/g, "\\'");
  }
  LiteralString2.Escape = Escape3;
})(LiteralString || (LiteralString = {}));

class TypeCompilerUnknownTypeError extends TypeBoxError {
  constructor(schema3) {
    super("Unknown type");
    this.schema = schema3;
  }
}

class TypeCompilerTypeGuardError extends TypeBoxError {
  constructor(schema3) {
    super("Preflight validation check failed to guard for the given schema");
    this.schema = schema3;
  }
}
var Policy;
(function(Policy2) {
  function IsExactOptionalProperty(value2, key, expression) {
    return TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value2} ? ${expression} : true)` : `(${MemberExpression.Encode(value2, key)} !== undefined ? ${expression} : true)`;
  }
  Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value2) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value2} === 'object' && ${value2} !== null && !Array.isArray(${value2}))` : `(typeof ${value2} === 'object' && ${value2} !== null)`;
  }
  Policy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value2) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value2} === 'object' && ${value2} !== null && !Array.isArray(${value2}) && !(${value2} instanceof Date) && !(${value2} instanceof Uint8Array))` : `(typeof ${value2} === 'object' && ${value2} !== null && !(${value2} instanceof Date) && !(${value2} instanceof Uint8Array))`;
  }
  Policy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value2) {
    return TypeSystemPolicy.AllowNaN ? `typeof ${value2} === 'number'` : `Number.isFinite(${value2})`;
  }
  Policy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value2) {
    return TypeSystemPolicy.AllowNullVoid ? `(${value2} === undefined || ${value2} === null)` : `${value2} === undefined`;
  }
  Policy2.IsVoidLike = IsVoidLike;
})(Policy || (Policy = {}));
var TypeCompiler;
(function(TypeCompiler2) {
  function IsAnyOrUnknown2(schema3) {
    return schema3[Kind] === "Any" || schema3[Kind] === "Unknown";
  }
  function* FromAny5(schema3, references, value2) {
    yield "true";
  }
  function* FromArray16(schema3, references, value2) {
    yield `Array.isArray(${value2})`;
    const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
    if (IsNumber(schema3.maxItems))
      yield `${value2}.length <= ${schema3.maxItems}`;
    if (IsNumber(schema3.minItems))
      yield `${value2}.length >= ${schema3.minItems}`;
    const elementExpression = CreateExpression(schema3.items, references, "value");
    yield `${value2}.every((${parameter}) => ${elementExpression})`;
    if (IsSchema2(schema3.contains) || IsNumber(schema3.minContains) || IsNumber(schema3.maxContains)) {
      const containsSchema = IsSchema2(schema3.contains) ? schema3.contains : Never();
      const checkExpression = CreateExpression(containsSchema, references, "value");
      const checkMinContains = IsNumber(schema3.minContains) ? [`(count >= ${schema3.minContains})`] : [];
      const checkMaxContains = IsNumber(schema3.maxContains) ? [`(count <= ${schema3.maxContains})`] : [];
      const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
      const check3 = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
      yield `((${parameter}) => { ${checkCount}; return ${check3}})(${value2})`;
    }
    if (schema3.uniqueItems === true) {
      const check3 = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
      const block = `const set = new Set(); for(const element of value) { ${check3} }`;
      yield `((${parameter}) => { ${block} )(${value2})`;
    }
  }
  function* FromAsyncIterator7(schema3, references, value2) {
    yield `(typeof value === 'object' && Symbol.asyncIterator in ${value2})`;
  }
  function* FromBigInt6(schema3, references, value2) {
    yield `(typeof ${value2} === 'bigint')`;
    if (IsBigInt(schema3.exclusiveMaximum))
      yield `${value2} < BigInt(${schema3.exclusiveMaximum})`;
    if (IsBigInt(schema3.exclusiveMinimum))
      yield `${value2} > BigInt(${schema3.exclusiveMinimum})`;
    if (IsBigInt(schema3.maximum))
      yield `${value2} <= BigInt(${schema3.maximum})`;
    if (IsBigInt(schema3.minimum))
      yield `${value2} >= BigInt(${schema3.minimum})`;
    if (IsBigInt(schema3.multipleOf))
      yield `(${value2} % BigInt(${schema3.multipleOf})) === 0`;
  }
  function* FromBoolean6(schema3, references, value2) {
    yield `(typeof ${value2} === 'boolean')`;
  }
  function* FromConstructor8(schema3, references, value2) {
    yield* Visit17(schema3.returns, references, `${value2}.prototype`);
  }
  function* FromDate6(schema3, references, value2) {
    yield `(${value2} instanceof Date) && Number.isFinite(${value2}.getTime())`;
    if (IsNumber(schema3.exclusiveMaximumTimestamp))
      yield `${value2}.getTime() < ${schema3.exclusiveMaximumTimestamp}`;
    if (IsNumber(schema3.exclusiveMinimumTimestamp))
      yield `${value2}.getTime() > ${schema3.exclusiveMinimumTimestamp}`;
    if (IsNumber(schema3.maximumTimestamp))
      yield `${value2}.getTime() <= ${schema3.maximumTimestamp}`;
    if (IsNumber(schema3.minimumTimestamp))
      yield `${value2}.getTime() >= ${schema3.minimumTimestamp}`;
    if (IsNumber(schema3.multipleOfTimestamp))
      yield `(${value2}.getTime() % ${schema3.multipleOfTimestamp}) === 0`;
  }
  function* FromFunction7(schema3, references, value2) {
    yield `(typeof ${value2} === 'function')`;
  }
  function* FromInteger6(schema3, references, value2) {
    yield `Number.isInteger(${value2})`;
    if (IsNumber(schema3.exclusiveMaximum))
      yield `${value2} < ${schema3.exclusiveMaximum}`;
    if (IsNumber(schema3.exclusiveMinimum))
      yield `${value2} > ${schema3.exclusiveMinimum}`;
    if (IsNumber(schema3.maximum))
      yield `${value2} <= ${schema3.maximum}`;
    if (IsNumber(schema3.minimum))
      yield `${value2} >= ${schema3.minimum}`;
    if (IsNumber(schema3.multipleOf))
      yield `(${value2} % ${schema3.multipleOf}) === 0`;
  }
  function* FromIntersect18(schema3, references, value2) {
    const check1 = schema3.allOf.map((schema4) => CreateExpression(schema4, references, value2)).join(" && ");
    if (schema3.unevaluatedProperties === false) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema3))};`);
      const check22 = `Object.getOwnPropertyNames(${value2}).every(key => ${keyCheck}.test(key))`;
      yield `(${check1} && ${check22})`;
    } else if (IsSchema2(schema3.unevaluatedProperties)) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema3))};`);
      const check22 = `Object.getOwnPropertyNames(${value2}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema3.unevaluatedProperties, references, `${value2}[key]`)})`;
      yield `(${check1} && ${check22})`;
    } else {
      yield `(${check1})`;
    }
  }
  function* FromIterator7(schema3, references, value2) {
    yield `(typeof value === 'object' && Symbol.iterator in ${value2})`;
  }
  function* FromLiteral7(schema3, references, value2) {
    if (typeof schema3.const === "number" || typeof schema3.const === "boolean") {
      yield `(${value2} === ${schema3.const})`;
    } else {
      yield `(${value2} === '${LiteralString.Escape(schema3.const)}')`;
    }
  }
  function* FromNever6(schema3, references, value2) {
    yield `false`;
  }
  function* FromNot8(schema3, references, value2) {
    const expression = CreateExpression(schema3.not, references, value2);
    yield `(!${expression})`;
  }
  function* FromNull6(schema3, references, value2) {
    yield `(${value2} === null)`;
  }
  function* FromNumber6(schema3, references, value2) {
    yield Policy.IsNumberLike(value2);
    if (IsNumber(schema3.exclusiveMaximum))
      yield `${value2} < ${schema3.exclusiveMaximum}`;
    if (IsNumber(schema3.exclusiveMinimum))
      yield `${value2} > ${schema3.exclusiveMinimum}`;
    if (IsNumber(schema3.maximum))
      yield `${value2} <= ${schema3.maximum}`;
    if (IsNumber(schema3.minimum))
      yield `${value2} >= ${schema3.minimum}`;
    if (IsNumber(schema3.multipleOf))
      yield `(${value2} % ${schema3.multipleOf}) === 0`;
  }
  function* FromObject13(schema3, references, value2) {
    yield Policy.IsObjectLike(value2);
    if (IsNumber(schema3.minProperties))
      yield `Object.getOwnPropertyNames(${value2}).length >= ${schema3.minProperties}`;
    if (IsNumber(schema3.maxProperties))
      yield `Object.getOwnPropertyNames(${value2}).length <= ${schema3.maxProperties}`;
    const knownKeys = Object.getOwnPropertyNames(schema3.properties);
    for (const knownKey of knownKeys) {
      const memberExpression = MemberExpression.Encode(value2, knownKey);
      const property = schema3.properties[knownKey];
      if (schema3.required && schema3.required.includes(knownKey)) {
        yield* Visit17(property, references, memberExpression);
        if (ExtendsUndefinedCheck(property) || IsAnyOrUnknown2(property))
          yield `('${knownKey}' in ${value2})`;
      } else {
        const expression = CreateExpression(property, references, memberExpression);
        yield Policy.IsExactOptionalProperty(value2, knownKey, expression);
      }
    }
    if (schema3.additionalProperties === false) {
      if (schema3.required && schema3.required.length === knownKeys.length) {
        yield `Object.getOwnPropertyNames(${value2}).length === ${knownKeys.length}`;
      } else {
        const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `Object.getOwnPropertyNames(${value2}).every(key => ${keys}.includes(key))`;
      }
    }
    if (typeof schema3.additionalProperties === "object") {
      const expression = CreateExpression(schema3.additionalProperties, references, `${value2}[key]`);
      const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
      yield `(Object.getOwnPropertyNames(${value2}).every(key => ${keys}.includes(key) || ${expression}))`;
    }
  }
  function* FromPromise8(schema3, references, value2) {
    yield `(typeof value === 'object' && typeof ${value2}.then === 'function')`;
  }
  function* FromRecord12(schema3, references, value2) {
    yield Policy.IsRecordLike(value2);
    if (IsNumber(schema3.minProperties))
      yield `Object.getOwnPropertyNames(${value2}).length >= ${schema3.minProperties}`;
    if (IsNumber(schema3.maxProperties))
      yield `Object.getOwnPropertyNames(${value2}).length <= ${schema3.maxProperties}`;
    const [patternKey, patternSchema] = Object.entries(schema3.patternProperties)[0];
    const variable = CreateVariable(`${new RegExp(patternKey)}`);
    const check1 = CreateExpression(patternSchema, references, "value");
    const check22 = IsSchema2(schema3.additionalProperties) ? CreateExpression(schema3.additionalProperties, references, value2) : schema3.additionalProperties === false ? "false" : "true";
    const expression = `(${variable}.test(key) ? ${check1} : ${check22})`;
    yield `(Object.entries(${value2}).every(([key, value]) => ${expression}))`;
  }
  function* FromRef12(schema3, references, value2) {
    const target = Deref(schema3, references);
    if (state.functions.has(schema3.$ref))
      return yield `${CreateFunctionName(schema3.$ref)}(${value2})`;
    yield* Visit17(target, references, value2);
  }
  function* FromRegExp5(schema3, references, value2) {
    const variable = CreateVariable(`${new RegExp(schema3.source, schema3.flags)};`);
    yield `(typeof ${value2} === 'string')`;
    if (IsNumber(schema3.maxLength))
      yield `${value2}.length <= ${schema3.maxLength}`;
    if (IsNumber(schema3.minLength))
      yield `${value2}.length >= ${schema3.minLength}`;
    yield `${variable}.test(${value2})`;
  }
  function* FromString6(schema3, references, value2) {
    yield `(typeof ${value2} === 'string')`;
    if (IsNumber(schema3.maxLength))
      yield `${value2}.length <= ${schema3.maxLength}`;
    if (IsNumber(schema3.minLength))
      yield `${value2}.length >= ${schema3.minLength}`;
    if (schema3.pattern !== undefined) {
      const variable = CreateVariable(`${new RegExp(schema3.pattern)};`);
      yield `${variable}.test(${value2})`;
    }
    if (schema3.format !== undefined) {
      yield `format('${schema3.format}', ${value2})`;
    }
  }
  function* FromSymbol6(schema3, references, value2) {
    yield `(typeof ${value2} === 'symbol')`;
  }
  function* FromTemplateLiteral7(schema3, references, value2) {
    yield `(typeof ${value2} === 'string')`;
    const variable = CreateVariable(`${new RegExp(schema3.pattern)};`);
    yield `${variable}.test(${value2})`;
  }
  function* FromThis11(schema3, references, value2) {
    yield `${CreateFunctionName(schema3.$ref)}(${value2})`;
  }
  function* FromTuple15(schema3, references, value2) {
    yield `Array.isArray(${value2})`;
    if (schema3.items === undefined)
      return yield `${value2}.length === 0`;
    yield `(${value2}.length === ${schema3.maxItems})`;
    for (let i = 0;i < schema3.items.length; i++) {
      const expression = CreateExpression(schema3.items[i], references, `${value2}[${i}]`);
      yield `${expression}`;
    }
  }
  function* FromUndefined6(schema3, references, value2) {
    yield `${value2} === undefined`;
  }
  function* FromUnion20(schema3, references, value2) {
    const expressions = schema3.anyOf.map((schema4) => CreateExpression(schema4, references, value2));
    yield `(${expressions.join(" || ")})`;
  }
  function* FromUint8Array5(schema3, references, value2) {
    yield `${value2} instanceof Uint8Array`;
    if (IsNumber(schema3.maxByteLength))
      yield `(${value2}.length <= ${schema3.maxByteLength})`;
    if (IsNumber(schema3.minByteLength))
      yield `(${value2}.length >= ${schema3.minByteLength})`;
  }
  function* FromUnknown5(schema3, references, value2) {
    yield "true";
  }
  function* FromVoid5(schema3, references, value2) {
    yield Policy.IsVoidLike(value2);
  }
  function* FromKind4(schema3, references, value2) {
    const instance = state.instances.size;
    state.instances.set(instance, schema3);
    yield `kind('${schema3[Kind]}', ${instance}, ${value2})`;
  }
  function* Visit17(schema3, references, value2, useHoisting = true) {
    const references_ = IsString(schema3.$id) ? [...references, schema3] : references;
    const schema_ = schema3;
    if (useHoisting && IsString(schema3.$id)) {
      const functionName = CreateFunctionName(schema3.$id);
      if (state.functions.has(functionName)) {
        return yield `${functionName}(${value2})`;
      } else {
        const functionCode = CreateFunction(functionName, schema3, references, "value", false);
        state.functions.set(functionName, functionCode);
        return yield `${functionName}(${value2})`;
      }
    }
    switch (schema_[Kind]) {
      case "Any":
        return yield* FromAny5(schema_, references_, value2);
      case "Array":
        return yield* FromArray16(schema_, references_, value2);
      case "AsyncIterator":
        return yield* FromAsyncIterator7(schema_, references_, value2);
      case "BigInt":
        return yield* FromBigInt6(schema_, references_, value2);
      case "Boolean":
        return yield* FromBoolean6(schema_, references_, value2);
      case "Constructor":
        return yield* FromConstructor8(schema_, references_, value2);
      case "Date":
        return yield* FromDate6(schema_, references_, value2);
      case "Function":
        return yield* FromFunction7(schema_, references_, value2);
      case "Integer":
        return yield* FromInteger6(schema_, references_, value2);
      case "Intersect":
        return yield* FromIntersect18(schema_, references_, value2);
      case "Iterator":
        return yield* FromIterator7(schema_, references_, value2);
      case "Literal":
        return yield* FromLiteral7(schema_, references_, value2);
      case "Never":
        return yield* FromNever6(schema_, references_, value2);
      case "Not":
        return yield* FromNot8(schema_, references_, value2);
      case "Null":
        return yield* FromNull6(schema_, references_, value2);
      case "Number":
        return yield* FromNumber6(schema_, references_, value2);
      case "Object":
        return yield* FromObject13(schema_, references_, value2);
      case "Promise":
        return yield* FromPromise8(schema_, references_, value2);
      case "Record":
        return yield* FromRecord12(schema_, references_, value2);
      case "Ref":
        return yield* FromRef12(schema_, references_, value2);
      case "RegExp":
        return yield* FromRegExp5(schema_, references_, value2);
      case "String":
        return yield* FromString6(schema_, references_, value2);
      case "Symbol":
        return yield* FromSymbol6(schema_, references_, value2);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral7(schema_, references_, value2);
      case "This":
        return yield* FromThis11(schema_, references_, value2);
      case "Tuple":
        return yield* FromTuple15(schema_, references_, value2);
      case "Undefined":
        return yield* FromUndefined6(schema_, references_, value2);
      case "Union":
        return yield* FromUnion20(schema_, references_, value2);
      case "Uint8Array":
        return yield* FromUint8Array5(schema_, references_, value2);
      case "Unknown":
        return yield* FromUnknown5(schema_, references_, value2);
      case "Void":
        return yield* FromVoid5(schema_, references_, value2);
      default:
        if (!exports_type.Has(schema_[Kind]))
          throw new TypeCompilerUnknownTypeError(schema3);
        return yield* FromKind4(schema_, references_, value2);
    }
  }
  const state = {
    language: "javascript",
    functions: new Map,
    variables: new Map,
    instances: new Map
  };
  function CreateExpression(schema3, references, value2, useHoisting = true) {
    return `(${[...Visit17(schema3, references, value2, useHoisting)].join(" && ")})`;
  }
  function CreateFunctionName($id) {
    return `check_${Identifier.Encode($id)}`;
  }
  function CreateVariable(expression) {
    const variableName = `local_${state.variables.size}`;
    state.variables.set(variableName, `const ${variableName} = ${expression}`);
    return variableName;
  }
  function CreateFunction(name, schema3, references, value2, useHoisting = true) {
    const [newline, pad] = [`
`, (length) => "".padStart(length, " ")];
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const expression = [...Visit17(schema3, references, value2, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
    return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})
}`;
  }
  function CreateParameter(name, type3) {
    const annotation = state.language === "typescript" ? `: ${type3}` : "";
    return `${name}${annotation}`;
  }
  function CreateReturns(type3) {
    return state.language === "typescript" ? `: ${type3}` : "";
  }
  function Build(schema3, references, options) {
    const functionCode = CreateFunction("check", schema3, references, "value");
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const functions = [...state.functions.values()];
    const variables = [...state.variables.values()];
    const checkFunction = IsString(schema3.$id) ? `return function check(${parameter})${returns} {
  return ${CreateFunctionName(schema3.$id)}(value)
}` : `return ${functionCode}`;
    return [...variables, ...functions, checkFunction].join(`
`);
  }
  function Code(...args) {
    const defaults = { language: "javascript" };
    const [schema3, references, options] = args.length === 2 && IsArray(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !IsArray(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
    state.language = options.language;
    state.variables.clear();
    state.functions.clear();
    state.instances.clear();
    if (!IsSchema2(schema3))
      throw new TypeCompilerTypeGuardError(schema3);
    for (const schema4 of references)
      if (!IsSchema2(schema4))
        throw new TypeCompilerTypeGuardError(schema4);
    return Build(schema3, references, options);
  }
  TypeCompiler2.Code = Code;
  function Compile(schema3, references = []) {
    const generatedCode = Code(schema3, references, { language: "javascript" });
    const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
    const instances = new Map(state.instances);
    function typeRegistryFunction(kind, instance, value2) {
      if (!exports_type.Has(kind) || !instances.has(instance))
        return false;
      const checkFunc = exports_type.Get(kind);
      const schema4 = instances.get(instance);
      return checkFunc(schema4, value2);
    }
    function formatRegistryFunction(format, value2) {
      if (!exports_format.Has(format))
        return false;
      const checkFunc = exports_format.Get(format);
      return checkFunc(value2);
    }
    function hashFunction(value2) {
      return Hash(value2);
    }
    const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
    return new TypeCheck(schema3, references, checkFunction, generatedCode);
  }
  TypeCompiler2.Compile = Compile;
})(TypeCompiler || (TypeCompiler = {}));
// node_modules/cookie/index.js
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var $parse = parse2;
var $serialize = serialize;
var __toString = Object.prototype.toString;
var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
function parse2(str, options) {
  if (typeof str !== "string") {
    throw new TypeError("argument str must be a string");
  }
  var obj = {};
  var opt = options || {};
  var dec = opt.decode || decode2;
  var index = 0;
  while (index < str.length) {
    var eqIdx = str.indexOf("=", index);
    if (eqIdx === -1) {
      break;
    }
    var endIdx = str.indexOf(";", index);
    if (endIdx === -1) {
      endIdx = str.length;
    } else if (endIdx < eqIdx) {
      index = str.lastIndexOf(";", eqIdx - 1) + 1;
      continue;
    }
    var key = str.slice(index, eqIdx).trim();
    if (obj[key] === undefined) {
      var val = str.slice(eqIdx + 1, endIdx).trim();
      if (val.charCodeAt(0) === 34) {
        val = val.slice(1, -1);
      }
      obj[key] = tryDecode(val, dec);
    }
    index = endIdx + 1;
  }
  return obj;
}
function serialize(name, val, options) {
  var opt = options || {};
  var enc = opt.encode || encode2;
  if (typeof enc !== "function") {
    throw new TypeError("option encode is invalid");
  }
  if (!fieldContentRegExp.test(name)) {
    throw new TypeError("argument name is invalid");
  }
  var value2 = enc(val);
  if (value2 && !fieldContentRegExp.test(value2)) {
    throw new TypeError("argument val is invalid");
  }
  var str = name + "=" + value2;
  if (opt.maxAge != null) {
    var maxAge = opt.maxAge - 0;
    if (isNaN(maxAge) || !isFinite(maxAge)) {
      throw new TypeError("option maxAge is invalid");
    }
    str += "; Max-Age=" + Math.floor(maxAge);
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += "; Domain=" + opt.domain;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += "; Path=" + opt.path;
  }
  if (opt.expires) {
    var expires = opt.expires;
    if (!isDate(expires) || isNaN(expires.valueOf())) {
      throw new TypeError("option expires is invalid");
    }
    str += "; Expires=" + expires.toUTCString();
  }
  if (opt.httpOnly) {
    str += "; HttpOnly";
  }
  if (opt.secure) {
    str += "; Secure";
  }
  if (opt.partitioned) {
    str += "; Partitioned";
  }
  if (opt.priority) {
    var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
    switch (priority) {
      case "low":
        str += "; Priority=Low";
        break;
      case "medium":
        str += "; Priority=Medium";
        break;
      case "high":
        str += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str;
}
function decode2(str) {
  return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
}
function encode2(val) {
  return encodeURIComponent(val);
}
function isDate(val) {
  return __toString.call(val) === "[object Date]" || val instanceof Date;
}
function tryDecode(str, decode3) {
  try {
    return decode3(str);
  } catch (e) {
    return str;
  }
}

// node_modules/elysia/dist/index.mjs
var import_fast_querystring = __toESM(require_lib(), 1);
var import_fast_decode_uri_component = __toESM(require_fast_decode_uri_component(), 1);
var import_fast_querystring2 = __toESM(require_lib(), 1);
var resolver = () => {
  let resolve;
  const promise3 = new Promise((r) => {
    resolve = r;
  });
  return [promise3, resolve];
};
var createSignal = () => {
  const [start, resolveStart] = resolver();
  const [end, resolveEnd] = resolver();
  const children = [];
  const resolvers = [];
  return {
    signal: start,
    consume: (trace) => {
      switch (trace.type) {
        case "begin":
          if (trace.unit && children.length === 0)
            for (let i = 0;i < trace.unit; i++) {
              const [start2, resolveStart2] = resolver();
              const [end2, resolveEnd2] = resolver();
              children.push(start2);
              resolvers.push([
                (trace2) => {
                  resolveStart2({
                    children: [],
                    end: end2,
                    name: trace2.name ?? "",
                    skip: false,
                    time: trace2.time
                  });
                },
                (time) => {
                  resolveEnd2(time);
                }
              ]);
            }
          resolveStart({
            children,
            end,
            name: trace.name ?? "",
            skip: false,
            time: trace.time
          });
          break;
        case "end":
          resolveEnd(trace.time);
          break;
      }
    },
    consumeChild(trace) {
      switch (trace.type) {
        case "begin":
          if (!resolvers[0])
            return;
          const [resolveStart2] = resolvers[0];
          resolveStart2({
            children: [],
            end,
            name: trace.name ?? "",
            skip: false,
            time: trace.time
          });
          break;
        case "end":
          const child = resolvers.shift();
          if (!child)
            return;
          child[1](trace.time);
      }
    },
    resolve() {
      resolveStart({
        children: [],
        end: new Promise((resolve) => resolve(0)),
        name: "",
        skip: true,
        time: 0
      });
      for (const [resolveStart2, resolveEnd2] of resolvers) {
        resolveStart2({
          children: [],
          end: new Promise((resolve) => resolve(0)),
          name: "",
          skip: true,
          time: 0
        });
        resolveEnd2(0);
      }
      resolveEnd(0);
    }
  };
};
var createTraceListener = (getReporter, totalListener, handler) => {
  return async function trace(trace) {
    if (trace.event !== "request" || trace.type !== "begin")
      return;
    const id = trace.id;
    const reporter = getReporter();
    const request = createSignal();
    const parse22 = createSignal();
    const transform4 = createSignal();
    const beforeHandle = createSignal();
    const handle = createSignal();
    const afterHandle = createSignal();
    const error22 = createSignal();
    const response = createSignal();
    request.consume(trace);
    const reducer = (event) => {
      if (event.id === id)
        switch (event.event) {
          case "request":
            request.consume(event);
            break;
          case "request.unit":
            request.consumeChild(event);
            break;
          case "parse":
            parse22.consume(event);
            break;
          case "parse.unit":
            parse22.consumeChild(event);
            break;
          case "transform":
            transform4.consume(event);
            break;
          case "transform.unit":
            transform4.consumeChild(event);
            break;
          case "beforeHandle":
            beforeHandle.consume(event);
            break;
          case "beforeHandle.unit":
            beforeHandle.consumeChild(event);
            break;
          case "handle":
            handle.consume(event);
            break;
          case "afterHandle":
            afterHandle.consume(event);
            break;
          case "afterHandle.unit":
            afterHandle.consumeChild(event);
            break;
          case "error":
            error22.consume(event);
            break;
          case "error.unit":
            error22.consumeChild(event);
            break;
          case "response":
            if (event.type === "begin") {
              request.resolve();
              parse22.resolve();
              transform4.resolve();
              beforeHandle.resolve();
              handle.resolve();
              afterHandle.resolve();
              error22.resolve();
            } else
              reporter.off("event", reducer);
            response.consume(event);
            break;
          case "response.unit":
            response.consumeChild(event);
            break;
          case "exit":
            request.resolve();
            parse22.resolve();
            transform4.resolve();
            beforeHandle.resolve();
            handle.resolve();
            afterHandle.resolve();
            error22.resolve();
            break;
        }
    };
    reporter.on("event", reducer);
    await handler({
      id,
      context: trace.ctx,
      set: trace.ctx?.set,
      store: trace.ctx?.store,
      time: trace.time,
      request: request.signal,
      parse: parse22.signal,
      transform: transform4.signal,
      beforeHandle: beforeHandle.signal,
      handle: handle.signal,
      afterHandle: afterHandle.signal,
      error: error22.signal,
      response: response.signal
    });
    reporter.emit(`res${id}.${totalListener}`, undefined);
  };
};
var Cookie = class {
  constructor(_value, property = {}) {
    this._value = _value;
    this.property = property;
  }
  get() {
    return this._value;
  }
  get value() {
    return this._value;
  }
  set value(value2) {
    if (typeof value2 === "object") {
      if (JSON.stringify(this.value) === JSON.stringify(value2))
        return;
    } else if (this.value === value2)
      return;
    this._value = value2;
    this.sync();
  }
  add(config) {
    const updated = Object.assign(this.property, typeof config === "function" ? config(Object.assign(this.property, this.value)) : config);
    if ("value" in updated) {
      this._value = updated.value;
      delete updated.value;
    }
    this.property = updated;
    return this.sync();
  }
  set(config) {
    const updated = typeof config === "function" ? config(Object.assign(this.property, this.value)) : config;
    if ("value" in updated) {
      this._value = updated.value;
      delete updated.value;
    }
    this.property = updated;
    return this.sync();
  }
  remove(options) {
    if (this.value === undefined)
      return;
    this.set({
      domain: options?.domain,
      expires: /* @__PURE__ */ new Date(0),
      maxAge: 0,
      path: options?.path,
      sameSite: options?.sameSite,
      secure: options?.secure,
      value: ""
    });
  }
  get domain() {
    return this.property.domain;
  }
  set domain(value2) {
    if (this.property.domain === value2)
      return;
    this.property.domain = value2;
    this.sync();
  }
  get expires() {
    return this.property.expires;
  }
  set expires(value2) {
    if (this.property.expires?.getTime() === value2?.getTime())
      return;
    this.property.expires = value2;
    this.sync();
  }
  get httpOnly() {
    return this.property.httpOnly;
  }
  set httpOnly(value2) {
    if (this.property.domain === value2)
      return;
    this.property.httpOnly = value2;
    this.sync();
  }
  get maxAge() {
    return this.property.maxAge;
  }
  set maxAge(value2) {
    if (this.property.maxAge === value2)
      return;
    this.property.maxAge = value2;
    this.sync();
  }
  get path() {
    return this.property.path;
  }
  set path(value2) {
    if (this.property.path === value2)
      return;
    this.property.path = value2;
    this.sync();
  }
  get priority() {
    return this.property.priority;
  }
  set priority(value2) {
    if (this.property.priority === value2)
      return;
    this.property.priority = value2;
    this.sync();
  }
  get sameSite() {
    return this.property.sameSite;
  }
  set sameSite(value2) {
    if (this.property.sameSite === value2)
      return;
    this.property.sameSite = value2;
    this.sync();
  }
  get secure() {
    return this.property.secure;
  }
  set secure(value2) {
    if (this.property.secure === value2)
      return;
    this.property.secure = value2;
    this.sync();
  }
  toString() {
    return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
  }
  sync() {
    if (!this.name || !this.setter)
      return this;
    if (!this.setter.cookie)
      this.setter.cookie = {
        [this.name]: Object.assign(this.property, {
          value: this.toString()
        })
      };
    else
      this.setter.cookie[this.name] = Object.assign(this.property, {
        value: this.toString()
      });
    return this;
  }
};
var createCookieJar = (initial, set2, properties) => new Proxy(initial, {
  get(target, key) {
    if (key in target)
      return target[key];
    const cookie = new Cookie(undefined, properties ? { ...properties } : undefined);
    cookie.setter = set2;
    cookie.name = key;
    return cookie;
  },
  set(target, key, value2) {
    if (!(value2 instanceof Cookie))
      return false;
    if (!set2.cookie)
      set2.cookie = {};
    value2.setter = set2;
    value2.name = key;
    value2.sync();
    target[key] = value2;
    return true;
  }
});
var parseCookie = async (set2, cookieString, {
  secret,
  sign,
  ...properties
} = {}) => {
  if (!cookieString)
    return createCookieJar({}, set2, properties);
  const jar = {};
  const isStringKey = typeof secret === "string";
  if (sign && sign !== true && !Array.isArray(sign))
    sign = [sign];
  const cookieKeys = Object.keys($parse(cookieString));
  for (let i = 0;i < cookieKeys.length; i++) {
    const key = cookieKeys[i];
    let value2 = $parse(cookieString)[key];
    if (sign === true || sign?.includes(key)) {
      if (!secret)
        throw new Error("No secret is provided to cookie plugin");
      if (isStringKey) {
        value2 = await unsignCookie(value2, secret);
        if (value2 === false)
          throw new InvalidCookieSignature(key);
      } else {
        let fail = true;
        for (let i2 = 0;i2 < secret.length; i2++) {
          const temp = await unsignCookie(value2, secret[i2]);
          if (temp !== false) {
            value2 = temp;
            fail = false;
            break;
          }
        }
        if (fail)
          throw new InvalidCookieSignature(key);
      }
    }
    if (value2 === undefined)
      continue;
    const start = value2.charCodeAt(0);
    if (start === 123 || start === 91)
      try {
        const cookie2 = new Cookie(JSON.parse(value2));
        cookie2.setter = set2;
        cookie2.name = key;
        jar[key] = cookie2;
        continue;
      } catch {}
    if (isNumericString(value2))
      value2 = +value2;
    else if (value2 === "true")
      value2 = true;
    else if (value2 === "false")
      value2 = false;
    const cookie = new Cookie(value2, properties);
    cookie.setter = set2;
    cookie.name = key;
    jar[key] = cookie;
  }
  return createCookieJar(jar, set2);
};
var hasHeaderShorthand = "toJSON" in new Headers;
var isNotEmpty = (obj) => {
  for (const x in obj)
    return true;
  return false;
};
var handleFile = (response, set2) => {
  const size = response.size;
  if (size && set2 && set2.status !== 206 && set2.status !== 304 && set2.status !== 412 && set2.status !== 416 || !set2 && size) {
    if (set2) {
      if (set2.headers instanceof Headers) {
        if (hasHeaderShorthand)
          set2.headers = set2.headers.toJSON();
        else
          for (const [key, value2] of set2.headers.entries())
            if (key in set2.headers)
              set2.headers[key] = value2;
      }
      return new Response(response, {
        status: set2.status,
        headers: Object.assign({
          "accept-ranges": "bytes",
          "content-range": `bytes 0-${size - 1}/${size}`
        }, set2.headers)
      });
    }
    return new Response(response, {
      headers: {
        "accept-ranges": "bytes",
        "content-range": `bytes 0-${size - 1}/${size}`
      }
    });
  }
  return new Response(response);
};
var parseSetCookies = (headers, setCookie) => {
  if (!headers || !Array.isArray(setCookie))
    return headers;
  headers.delete("Set-Cookie");
  for (let i = 0;i < setCookie.length; i++) {
    const index = setCookie[i].indexOf("=");
    headers.append("Set-Cookie", `${setCookie[i].slice(0, index)}=${setCookie[i].slice(index + 1)}`);
  }
  return headers;
};
var cookieToHeader = (cookies) => {
  if (!cookies || typeof cookies !== "object" || !isNotEmpty(cookies))
    return;
  const set2 = [];
  for (const [key, property] of Object.entries(cookies)) {
    if (!key || !property)
      continue;
    if (Array.isArray(property.value)) {
      for (let i = 0;i < property.value.length; i++) {
        let value2 = property.value[i];
        if (value2 === undefined || value2 === null)
          continue;
        if (typeof value2 === "object")
          value2 = JSON.stringify(value2);
        set2.push($serialize(key, value2, property));
      }
    } else {
      let value2 = property.value;
      if (value2 === undefined || value2 === null)
        continue;
      if (typeof value2 === "object")
        value2 = JSON.stringify(value2);
      set2.push($serialize(key, property.value, property));
    }
  }
  if (set2.length === 0)
    return;
  if (set2.length === 1)
    return set2[0];
  return set2;
};
var mapResponse = (response, set2) => {
  if (response?.[response.$passthrough])
    response = response[response.$passthrough];
  if (response?.[ELYSIA_RESPONSE]) {
    set2.status = response[ELYSIA_RESPONSE];
    response = response.response;
  }
  if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.redirect || set2.cookie) {
    if (typeof set2.status === "string")
      set2.status = StatusMap[set2.status];
    if (set2.redirect) {
      set2.headers.Location = set2.redirect;
      if (!set2.status || set2.status < 300 || set2.status >= 400)
        set2.status = 302;
    }
    if (set2.cookie && isNotEmpty(set2.cookie))
      set2.headers["Set-Cookie"] = cookieToHeader(set2.cookie);
    if (set2.headers["Set-Cookie"] && Array.isArray(set2.headers["Set-Cookie"]))
      set2.headers = parseSetCookies(new Headers(set2.headers), set2.headers["Set-Cookie"]);
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response, set2);
      case "Blob":
        return handleFile(response, set2);
      case "Object":
      case "Array":
        return Response.json(response, set2);
      case "ReadableStream":
        if (!set2.headers["content-type"]?.startsWith("text/event-stream"))
          set2.headers["content-type"] = "text/event-stream; charset=utf-8";
        return new Response(response, set2);
      case undefined:
        if (!response)
          return new Response("", set2);
        return Response.json(response, set2);
      case "Response":
        const inherits = { ...set2.headers };
        if (hasHeaderShorthand)
          set2.headers = response.headers.toJSON();
        else
          for (const [key, value2] of response.headers.entries())
            if (key in set2.headers)
              set2.headers[key] = value2;
        for (const key in inherits)
          response.headers.append(key, inherits[key]);
        return response;
      case "Error":
        return errorToResponse(response, set2);
      case "Promise":
        return response.then((x) => mapResponse(x, set2));
      case "Function":
        return mapResponse(response(), set2);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set2);
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      default:
        if (response instanceof Response) {
          const inherits2 = { ...set2.headers };
          if (hasHeaderShorthand)
            set2.headers = response.headers.toJSON();
          else
            for (const [key, value2] of response.headers.entries())
              if (key in set2.headers)
                set2.headers[key] = value2;
          for (const key in inherits2)
            response.headers.append(key, inherits2[key]);
          return response;
        }
        if (response instanceof Promise)
          return response.then((x) => mapResponse(x, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        const r = JSON.stringify(response);
        if (r.charCodeAt(0) === 123) {
          if (!set2.headers["Content-Type"])
            set2.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify(response), set2);
        }
        return new Response(r, set2);
    }
  } else
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response);
      case "Blob":
        return handleFile(response, set2);
      case "Object":
      case "Array":
        return new Response(JSON.stringify(response), {
          headers: {
            "content-type": "application/json"
          }
        });
      case "ReadableStream":
        return new Response(response, {
          headers: {
            "Content-Type": "text/event-stream; charset=utf-8"
          }
        });
      case undefined:
        if (!response)
          return new Response("");
        return new Response(JSON.stringify(response), {
          headers: {
            "content-type": "application/json"
          }
        });
      case "Response":
        return response;
      case "Error":
        return errorToResponse(response, set2);
      case "Promise":
        return response.then((x) => {
          const r2 = mapCompactResponse(x);
          if (r2 !== undefined)
            return r2;
          return new Response("");
        });
      case "Function":
        return mapCompactResponse(response());
      case "Number":
      case "Boolean":
        return new Response(response.toString());
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      default:
        if (response instanceof Response)
          return new Response(response.body, {
            headers: {
              "Content-Type": "application/json"
            }
          });
        if (response instanceof Promise)
          return response.then((x) => mapResponse(x, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        const r = JSON.stringify(response);
        if (r.charCodeAt(0) === 123)
          return new Response(JSON.stringify(response), {
            headers: {
              "Content-Type": "application/json"
            }
          });
        return new Response(r);
    }
};
var mapEarlyResponse = (response, set2) => {
  if (response === undefined || response === null)
    return;
  if (response?.$passthrough)
    response = response[response.$passthrough];
  if (response?.[ELYSIA_RESPONSE]) {
    set2.status = response[ELYSIA_RESPONSE];
    response = response.response;
  }
  if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.redirect || set2.cookie) {
    if (typeof set2.status === "string")
      set2.status = StatusMap[set2.status];
    if (set2.redirect) {
      set2.headers.Location = set2.redirect;
      if (!set2.status || set2.status < 300 || set2.status >= 400)
        set2.status = 302;
    }
    if (set2.cookie && isNotEmpty(set2.cookie))
      set2.headers["Set-Cookie"] = cookieToHeader(set2.cookie);
    if (set2.headers["Set-Cookie"] && Array.isArray(set2.headers["Set-Cookie"]))
      set2.headers = parseSetCookies(new Headers(set2.headers), set2.headers["Set-Cookie"]);
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response, set2);
      case "Blob":
        return handleFile(response, set2);
      case "Object":
      case "Array":
        return Response.json(response, set2);
      case "ReadableStream":
        if (!set2.headers["content-type"]?.startsWith("text/event-stream"))
          set2.headers["content-type"] = "text/event-stream; charset=utf-8";
        return new Response(response, set2);
      case undefined:
        if (!response)
          return;
        return Response.json(response, set2);
      case "Response":
        const inherits = Object.assign({}, set2.headers);
        if (hasHeaderShorthand)
          set2.headers = response.headers.toJSON();
        else
          for (const [key, value2] of response.headers.entries())
            if (!(key in set2.headers))
              set2.headers[key] = value2;
        for (const key in inherits)
          response.headers.append(key, inherits[key]);
        if (response.status !== set2.status)
          set2.status = response.status;
        return response;
      case "Promise":
        return response.then((x) => {
          const r2 = mapEarlyResponse(x, set2);
          if (r2 !== undefined)
            return r2;
          return;
        });
      case "Error":
        return errorToResponse(response, set2);
      case "Function":
        return mapEarlyResponse(response(), set2);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set2);
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      default:
        if (response instanceof Response) {
          const inherits2 = { ...set2.headers };
          if (hasHeaderShorthand)
            set2.headers = response.headers.toJSON();
          else
            for (const [key, value2] of response.headers.entries())
              if (key in set2.headers)
                set2.headers[key] = value2;
          for (const key in inherits2)
            response.headers.append(key, inherits2[key]);
          return response;
        }
        if (response instanceof Promise)
          return response.then((x) => mapEarlyResponse(x, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        const r = JSON.stringify(response);
        if (r.charCodeAt(0) === 123) {
          if (!set2.headers["Content-Type"])
            set2.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify(response), set2);
        }
        return new Response(r, set2);
    }
  } else
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response);
      case "Blob":
        return handleFile(response, set2);
      case "Object":
      case "Array":
        return new Response(JSON.stringify(response), {
          headers: {
            "content-type": "application/json"
          }
        });
      case "ReadableStream":
        return new Response(response, {
          headers: {
            "Content-Type": "text/event-stream; charset=utf-8"
          }
        });
      case undefined:
        if (!response)
          return new Response("");
        return new Response(JSON.stringify(response), {
          headers: {
            "content-type": "application/json"
          }
        });
      case "Response":
        return response;
      case "Promise":
        return response.then((x) => {
          const r2 = mapEarlyResponse(x, set2);
          if (r2 !== undefined)
            return r2;
          return;
        });
      case "Error":
        return errorToResponse(response, set2);
      case "Function":
        return mapCompactResponse(response());
      case "Number":
      case "Boolean":
        return new Response(response.toString());
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      default:
        if (response instanceof Response)
          return new Response(response.body, {
            headers: {
              "Content-Type": "application/json"
            }
          });
        if (response instanceof Promise)
          return response.then((x) => mapEarlyResponse(x, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        const r = JSON.stringify(response);
        if (r.charCodeAt(0) === 123)
          return new Response(JSON.stringify(response), {
            headers: {
              "Content-Type": "application/json"
            }
          });
        return new Response(r);
    }
};
var mapCompactResponse = (response) => {
  if (response?.$passthrough)
    response = response[response.$passthrough];
  if (response?.[ELYSIA_RESPONSE])
    return mapResponse(response.response, {
      status: response[ELYSIA_RESPONSE],
      headers: {}
    });
  switch (response?.constructor?.name) {
    case "String":
      return new Response(response);
    case "Blob":
      return handleFile(response);
    case "Object":
    case "Array":
      return new Response(JSON.stringify(response), {
        headers: {
          "content-type": "application/json"
        }
      });
    case "ReadableStream":
      return new Response(response, {
        headers: {
          "Content-Type": "text/event-stream; charset=utf-8"
        }
      });
    case undefined:
      if (!response)
        return new Response("");
      return new Response(JSON.stringify(response), {
        headers: {
          "content-type": "application/json"
        }
      });
    case "Response":
      return response;
    case "Error":
      return errorToResponse(response);
    case "Promise":
      return response.then(mapCompactResponse);
    case "Function":
      return mapCompactResponse(response());
    case "Number":
    case "Boolean":
      return new Response(response.toString());
    default:
      if (response instanceof Response)
        return new Response(response.body, {
          headers: {
            "Content-Type": "application/json"
          }
        });
      if (response instanceof Promise)
        return response.then(mapCompactResponse);
      if (response instanceof Error)
        return errorToResponse(response);
      const r = JSON.stringify(response);
      if (r.charCodeAt(0) === 123)
        return new Response(JSON.stringify(response), {
          headers: {
            "Content-Type": "application/json"
          }
        });
      return new Response(r);
  }
};
var errorToResponse = (error22, set2) => new Response(JSON.stringify({
  name: error22?.name,
  message: error22?.message,
  cause: error22?.cause
}), {
  status: set2?.status !== 200 ? set2?.status ?? 500 : 500,
  headers: set2?.headers
});
var isObject = (item) => item && typeof item === "object" && !Array.isArray(item);
var replaceUrlPath = (url, pathname) => {
  const urlObject = new URL(url);
  urlObject.pathname = pathname;
  return urlObject.toString();
};
var isClass = (v) => typeof v === "function" && /^\s*class\s+/.test(v.toString()) || v.toString().startsWith("[object ") || isNotEmpty(Object.getPrototypeOf(v));
var mergeDeep = (target, source, {
  skipKeys
} = {}) => {
  if (isObject(target) && isObject(source))
    for (const [key, value2] of Object.entries(source)) {
      if (skipKeys?.includes(key))
        continue;
      if (!isObject(value2)) {
        target[key] = value2;
        continue;
      }
      if (!(key in target)) {
        target[key] = value2;
        continue;
      }
      if (isClass(value2)) {
        target[key] = value2;
        continue;
      }
      target[key] = mergeDeep(target[key], value2);
    }
  return target;
};
var mergeCookie = (target, source) => mergeDeep(target, source, {
  skipKeys: ["properties"]
});
var mergeObjectArray = (a, b) => {
  if (!a)
    return [];
  const array3 = [...Array.isArray(a) ? a : [a]];
  const checksums = [];
  for (const item of array3) {
    if (item.$elysiaChecksum)
      checksums.push(item.$elysiaChecksum);
  }
  for (const item of Array.isArray(b) ? b : [b]) {
    if (!checksums.includes(item?.$elysiaChecksum)) {
      array3.push(item);
    }
  }
  return array3;
};
var primitiveHooks = [
  "start",
  "request",
  "parse",
  "transform",
  "resolve",
  "beforeHandle",
  "afterHandle",
  "onResponse",
  "mapResponse",
  "trace",
  "error",
  "stop",
  "body",
  "headers",
  "params",
  "query",
  "response",
  "type",
  "detail"
];
var mergeHook = (a, b) => {
  return {
    ...a,
    ...b,
    body: b?.body ?? a?.body,
    headers: b?.headers ?? a?.headers,
    params: b?.params ?? a?.params,
    query: b?.query ?? a?.query,
    response: b?.response ?? a?.response,
    type: a?.type || b?.type,
    detail: mergeDeep(b?.detail ?? {}, a?.detail ?? {}),
    parse: mergeObjectArray(a?.parse ?? [], b?.parse ?? []),
    transform: mergeObjectArray(a?.transform ?? [], b?.transform ?? []),
    beforeHandle: mergeObjectArray(a?.beforeHandle ?? [], b?.beforeHandle ?? []),
    afterHandle: mergeObjectArray(a?.afterHandle ?? [], b?.afterHandle ?? []),
    onResponse: mergeObjectArray(a?.onResponse ?? [], b?.onResponse ?? []),
    mapResponse: mergeObjectArray(a?.mapResponse ?? [], b?.mapResponse ?? []),
    trace: mergeObjectArray(a?.trace ?? [], b?.trace ?? []),
    error: mergeObjectArray(a?.error ?? [], b?.error ?? [])
  };
};
var getSchemaValidator = (s, {
  models = {},
  additionalProperties = false,
  dynamic = false
}) => {
  if (!s)
    return;
  if (typeof s === "string" && !(s in models))
    return;
  const schema3 = typeof s === "string" ? models[s] : s;
  if (schema3.type === "object" && "additionalProperties" in schema3 === false)
    schema3.additionalProperties = additionalProperties;
  if (dynamic)
    return {
      schema: schema3,
      references: "",
      checkFunc: () => {},
      code: "",
      Check: (value2) => exports_value2.Check(schema3, value2),
      Errors: (value2) => exports_value2.Errors(schema3, value2),
      Code: () => ""
    };
  return TypeCompiler.Compile(schema3, Object.values(models));
};
var getResponseSchemaValidator = (s, {
  models = {},
  additionalProperties = false,
  dynamic = false
}) => {
  if (!s)
    return;
  if (typeof s === "string" && !(s in models))
    return;
  const maybeSchemaOrRecord = typeof s === "string" ? models[s] : s;
  const compile = (schema3, references) => {
    if (dynamic)
      return {
        schema: schema3,
        references: "",
        checkFunc: () => {},
        code: "",
        Check: (value2) => exports_value2.Check(schema3, value2),
        Errors: (value2) => exports_value2.Errors(schema3, value2),
        Code: () => ""
      };
    return TypeCompiler.Compile(schema3, references);
  };
  if (Kind in maybeSchemaOrRecord) {
    if ("additionalProperties" in maybeSchemaOrRecord === false)
      maybeSchemaOrRecord.additionalProperties = additionalProperties;
    return {
      200: compile(maybeSchemaOrRecord, Object.values(models))
    };
  }
  const record3 = {};
  Object.keys(maybeSchemaOrRecord).forEach((status) => {
    const maybeNameOrSchema = maybeSchemaOrRecord[+status];
    if (typeof maybeNameOrSchema === "string") {
      if (maybeNameOrSchema in models) {
        const schema3 = models[maybeNameOrSchema];
        schema3.type === "object" && "additionalProperties" in schema3;
        record3[+status] = Kind in schema3 ? compile(schema3, Object.values(models)) : schema3;
      }
      return;
    }
    if (maybeNameOrSchema.type === "object" && "additionalProperties" in maybeNameOrSchema === false)
      maybeNameOrSchema.additionalProperties = additionalProperties;
    record3[+status] = Kind in maybeNameOrSchema ? compile(maybeNameOrSchema, Object.values(models)) : maybeNameOrSchema;
  });
  return record3;
};
var isBun = typeof Bun !== "undefined";
var hasHash = isBun && typeof Bun.hash === "function";
var checksum = (s) => {
  if (hasHash)
    return Bun.hash(s);
  let h = 9;
  for (let i = 0;i < s.length; )
    h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9);
  return h = h ^ h >>> 9;
};
var mergeLifeCycle = (a, b, checksum2) => {
  const injectChecksum = (x) => {
    if (checksum2 && !x.$elysiaChecksum)
      x.$elysiaChecksum = checksum2;
    return x;
  };
  return {
    ...a,
    ...b,
    start: mergeObjectArray(a.start, ("start" in b ? b.start ?? [] : []).map(injectChecksum)),
    request: mergeObjectArray(a.request, ("request" in b ? b.request ?? [] : []).map(injectChecksum)),
    parse: mergeObjectArray(a.parse, "parse" in b ? b?.parse ?? [] : []).map(injectChecksum),
    transform: mergeObjectArray(a.transform, (b?.transform ?? []).map(injectChecksum)),
    beforeHandle: mergeObjectArray(a.beforeHandle, (b?.beforeHandle ?? []).map(injectChecksum)),
    afterHandle: mergeObjectArray(a.afterHandle, (b?.afterHandle ?? []).map(injectChecksum)),
    mapResponse: mergeObjectArray(a.mapResponse, (b?.mapResponse ?? []).map(injectChecksum)),
    onResponse: mergeObjectArray(a.onResponse, (b?.onResponse ?? []).map(injectChecksum)),
    trace: a.trace,
    error: mergeObjectArray(a.error, (b?.error ?? []).map(injectChecksum)),
    stop: mergeObjectArray(a.stop, ("stop" in b ? b.stop ?? [] : []).map(injectChecksum))
  };
};
var asGlobal = (fn, inject = true) => {
  if (!fn)
    return fn;
  if (typeof fn === "function") {
    if (inject)
      fn.$elysiaHookType = "global";
    else
      fn.$elysiaHookType = undefined;
    return fn;
  }
  return fn.map((x) => {
    if (inject)
      x.$elysiaHookType = "global";
    else
      x.$elysiaHookType = undefined;
    return x;
  });
};
var filterGlobal = (fn) => {
  if (!fn)
    return fn;
  if (typeof fn === "function") {
    return fn.$elysiaHookType === "global" ? fn : undefined;
  }
  return fn.filter((x) => x.$elysiaHookType === "global");
};
var filterGlobalHook = (hook) => {
  return {
    ...hook,
    type: hook?.type,
    detail: hook?.detail,
    parse: filterGlobal(hook?.parse),
    transform: filterGlobal(hook?.transform),
    beforeHandle: filterGlobal(hook?.beforeHandle),
    afterHandle: filterGlobal(hook?.afterHandle),
    onResponse: filterGlobal(hook?.onResponse),
    error: filterGlobal(hook?.error)
  };
};
var StatusMap = {
  Continue: 100,
  "Switching Protocols": 101,
  Processing: 102,
  "Early Hints": 103,
  OK: 200,
  Created: 201,
  Accepted: 202,
  "Non-Authoritative Information": 203,
  "No Content": 204,
  "Reset Content": 205,
  "Partial Content": 206,
  "Multi-Status": 207,
  "Already Reported": 208,
  "Multiple Choices": 300,
  "Moved Permanently": 301,
  Found: 302,
  "See Other": 303,
  "Not Modified": 304,
  "Temporary Redirect": 307,
  "Permanent Redirect": 308,
  "Bad Request": 400,
  Unauthorized: 401,
  "Payment Required": 402,
  Forbidden: 403,
  "Not Found": 404,
  "Method Not Allowed": 405,
  "Not Acceptable": 406,
  "Proxy Authentication Required": 407,
  "Request Timeout": 408,
  Conflict: 409,
  Gone: 410,
  "Length Required": 411,
  "Precondition Failed": 412,
  "Payload Too Large": 413,
  "URI Too Long": 414,
  "Unsupported Media Type": 415,
  "Range Not Satisfiable": 416,
  "Expectation Failed": 417,
  "I'm a teapot": 418,
  "Misdirected Request": 421,
  "Unprocessable Content": 422,
  Locked: 423,
  "Failed Dependency": 424,
  "Too Early": 425,
  "Upgrade Required": 426,
  "Precondition Required": 428,
  "Too Many Requests": 429,
  "Request Header Fields Too Large": 431,
  "Unavailable For Legal Reasons": 451,
  "Internal Server Error": 500,
  "Not Implemented": 501,
  "Bad Gateway": 502,
  "Service Unavailable": 503,
  "Gateway Timeout": 504,
  "HTTP Version Not Supported": 505,
  "Variant Also Negotiates": 506,
  "Insufficient Storage": 507,
  "Loop Detected": 508,
  "Not Extended": 510,
  "Network Authentication Required": 511
};
var signCookie = async (val, secret) => {
  if (typeof val !== "string")
    throw new TypeError("Cookie value must be provided as a string.");
  if (secret === null)
    throw new TypeError("Secret key must be provided.");
  const encoder = new TextEncoder;
  const secretKey = await crypto.subtle.importKey("raw", encoder.encode(secret), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
  const hmacBuffer = await crypto.subtle.sign("HMAC", secretKey, encoder.encode(val));
  const hmacArray = Array.from(new Uint8Array(hmacBuffer));
  const digest = btoa(String.fromCharCode(...hmacArray));
  return `${val}.${digest.replace(/=+$/, "")}`;
};
var unsignCookie = async (input, secret) => {
  if (typeof input !== "string")
    throw new TypeError("Signed cookie string must be provided.");
  if (secret === null)
    throw new TypeError("Secret key must be provided.");
  const tentativeValue = input.slice(0, input.lastIndexOf("."));
  const expectedInput = await signCookie(tentativeValue, secret);
  return expectedInput === input ? tentativeValue : false;
};
var traceBackMacro = (extension, property, hooks = property) => {
  for (const [key, value2] of Object.entries(property ?? {})) {
    if (primitiveHooks.includes(key) || !(key in extension))
      continue;
    if (typeof extension[key] === "function") {
      extension[key](value2);
    } else if (typeof extension[key] === "object")
      traceBackMacro(extension[key], value2, hooks);
  }
};
var isNumericString = (message) => {
  if (message.length < 16)
    return message.trim().length !== 0 && !Number.isNaN(Number(message));
  if (message.length === 16) {
    const numVal = Number(message);
    if (numVal.toString() === message)
      return message.trim().length !== 0 && !Number.isNaN(numVal);
  }
  return false;
};
var env = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
var ERROR_CODE = Symbol("ElysiaErrorCode");
var ELYSIA_RESPONSE = Symbol("ElysiaResponse");
var isProduction = (env?.NODE_ENV ?? env?.ENV) === "production";
var InternalServerError = class extends Error {
  constructor(message) {
    super(message ?? "INTERNAL_SERVER_ERROR");
    this.code = "INTERNAL_SERVER_ERROR";
    this.status = 500;
  }
};
var NotFoundError = class extends Error {
  constructor(message) {
    super(message ?? "NOT_FOUND");
    this.code = "NOT_FOUND";
    this.status = 404;
  }
};
var InvalidCookieSignature = class extends Error {
  constructor(key, message) {
    super(message ?? `"${key}" has invalid cookie signature`);
    this.key = key;
    this.code = "INVALID_COOKIE_SIGNATURE";
    this.status = 400;
  }
};
var ValidationError = class _ValidationError extends Error {
  constructor(type3, validator, value2) {
    const error22 = isProduction ? undefined : ("Errors" in validator) ? validator.Errors(value2).First() : exports_value2.Errors(validator, value2).First();
    const customError = error22?.schema.error ? typeof error22.schema.error === "function" ? error22.schema.error(type3, validator, value2) : error22.schema.error : undefined;
    const accessor = error22?.path?.slice(1) || "root";
    let message = "";
    if (customError) {
      message = typeof customError === "object" ? JSON.stringify(customError) : customError + "";
    } else if (isProduction) {
      message = JSON.stringify({
        type: type3,
        message: error22?.message
      });
    } else {
      message = JSON.stringify({
        type: type3,
        at: accessor,
        message: error22?.message,
        expected: exports_value2.Create(validator.schema),
        found: value2,
        errors: [...validator.Errors(value2)]
      }, null, 2);
    }
    super(message);
    this.type = type3;
    this.validator = validator;
    this.value = value2;
    this.code = "VALIDATION";
    this.status = 400;
    Object.setPrototypeOf(this, _ValidationError.prototype);
  }
  get all() {
    return [...this.validator.Errors(this.value)];
  }
  static simplifyModel(validator) {
    const model = "schema" in validator ? validator.schema : validator;
    try {
      return exports_value2.Create(model);
    } catch {
      return model;
    }
  }
  get model() {
    return _ValidationError.simplifyModel(this.validator);
  }
  toResponse(headers) {
    return new Response(this.message, {
      status: 400,
      headers
    });
  }
};
var websocket = {
  open(ws) {
    ws.data.open?.(ws);
  },
  message(ws, message) {
    ws.data.message?.(ws, message);
  },
  drain(ws) {
    ws.data.drain?.(ws);
  },
  close(ws, code, reason) {
    ws.data.close?.(ws, code, reason);
  }
};
var ElysiaWS = class {
  constructor(raw, data) {
    this.raw = raw;
    this.data = data;
    this.validator = raw.data.validator;
    if (raw.data.id) {
      this.id = raw.data.id;
    } else {
      const array3 = new Uint32Array(1);
      crypto.getRandomValues(array3);
      this.id = array3[0].toString();
    }
  }
  get id() {
    return this.raw.data.id;
  }
  set id(newID) {
    this.raw.data.id = newID;
  }
  get publish() {
    return (topic, data = undefined, compress) => {
      if (this.validator?.Check(data) === false)
        throw new ValidationError("message", this.validator, data);
      if (typeof data === "object")
        data = JSON.stringify(data);
      this.raw.publish(topic, data, compress);
      return this;
    };
  }
  get send() {
    return (data) => {
      if (this.validator?.Check(data) === false)
        throw new ValidationError("message", this.validator, data);
      if (Buffer.isBuffer(data)) {
        this.raw.send(data);
        return this;
      }
      if (typeof data === "object")
        data = JSON.stringify(data);
      this.raw.send(data);
      return this;
    };
  }
  get subscribe() {
    return (room) => {
      this.raw.subscribe(room);
      return this;
    };
  }
  get unsubscribe() {
    return (room) => {
      this.raw.unsubscribe(room);
      return this;
    };
  }
  get cork() {
    return (callback) => {
      this.raw.cork(callback);
      return this;
    };
  }
  get close() {
    return () => {
      this.raw.close();
      return this;
    };
  }
  get terminate() {
    return this.raw.terminate.bind(this.raw);
  }
  get isSubscribed() {
    return this.raw.isSubscribed.bind(this.raw);
  }
  get remoteAddress() {
    return this.raw.remoteAddress;
  }
};
var headersHasToJSON = new Headers().toJSON;
var findAliases = new RegExp(` (\\w+) = context`, "g");
var requestId = { value: 0 };
var createReport = ({
  hasTrace,
  hasTraceSet = false,
  addFn,
  condition = {}
}) => {
  if (hasTrace) {
    addFn(`
const reporter = getReporter()
`);
    return (event, {
      name,
      attribute = "",
      unit = 0
    } = {}) => {
      const dotIndex = event.indexOf(".");
      const isGroup = dotIndex === -1;
      if (event !== "request" && event !== "response" && !condition[isGroup ? event : event.slice(0, dotIndex)])
        return () => {
          if (hasTraceSet && event === "afterHandle")
            addFn(`
await traceDone
`);
        };
      if (isGroup)
        name ||= event;
      else
        name ||= "anonymous";
      addFn(`
` + `reporter.emit('event', {
					id,
					event: '${event}',
					type: 'begin',
					name: '${name}',
					time: performance.now(),
					${isGroup ? `unit: ${unit},` : ""}
					${attribute}
				})`.replace(/(\t| |\n)/g, "") + `
`);
      let handled = false;
      return () => {
        if (handled)
          return;
        handled = true;
        addFn(`
` + `reporter.emit('event', {
							id,
							event: '${event}',
							type: 'end',
							time: performance.now()
						})`.replace(/(\t| |\n)/g, "") + `
`);
        if (hasTraceSet && event === "afterHandle")
          addFn(`
await traceDone
`);
      };
    };
  } else {
    return () => () => {};
  }
};
var hasReturn = (fnLiteral) => {
  const parenthesisEnd = fnLiteral.indexOf(")");
  if (fnLiteral.charCodeAt(parenthesisEnd + 2) === 61 && fnLiteral.charCodeAt(parenthesisEnd + 5) !== 123) {
    return true;
  }
  return fnLiteral.includes("return");
};
var composeValidationFactory = (hasErrorHandler, {
  injectResponse = ""
} = {}) => ({
  composeValidation: (type3, value2 = `c.${type3}`) => hasErrorHandler ? `c.set.status = 400; throw new ValidationError(
'${type3}',
${type3},
${value2}
)` : `c.set.status = 400; return new ValidationError(
	'${type3}',
	${type3},
	${value2}
).toResponse(c.set.headers)`,
  composeResponseValidation: (name = "r") => {
    const returnError = hasErrorHandler ? `throw new ValidationError(
'response',
response[c.set.status],
${name}
)` : `return new ValidationError(
'response',
response[c.set.status],
${name}
).toResponse(c.set.headers)`;
    return `
${injectResponse}
		if(!(${name} instanceof Response) && response[c.set.status]?.Check(${name}) === false) {
	if(!(response instanceof Error))
		${returnError}
}
`;
  }
});
var isFnUse = (keyword, fnLiteral) => {
  if (fnLiteral.startsWith("[object "))
    return false;
  fnLiteral = fnLiteral.trimStart();
  fnLiteral = fnLiteral.replaceAll(/^async /g, "");
  if (/^(\w+)\(/g.test(fnLiteral))
    fnLiteral = fnLiteral.slice(fnLiteral.indexOf("("));
  const argument = fnLiteral.charCodeAt(0) === 40 || fnLiteral.startsWith("function") ? fnLiteral.slice(fnLiteral.indexOf("(") + 1, fnLiteral.indexOf(")")) : fnLiteral.slice(0, fnLiteral.indexOf("=") - 1);
  if (argument === "")
    return false;
  const restIndex = argument.charCodeAt(0) === 123 ? argument.indexOf("...") : -1;
  if (argument.charCodeAt(0) === 123) {
    if (argument.includes(keyword))
      return true;
    if (restIndex === -1)
      return false;
  }
  if (fnLiteral.match(new RegExp(`${argument}(.${keyword}|\\["${keyword}"\\])`))) {
    return true;
  }
  const restAlias = restIndex !== -1 ? argument.slice(restIndex + 3, argument.indexOf(" ", restIndex + 3)) : undefined;
  if (fnLiteral.match(new RegExp(`${restAlias}(.${keyword}|\\["${keyword}"\\])`)))
    return true;
  const aliases = [argument];
  if (restAlias)
    aliases.push(restAlias);
  for (const found of fnLiteral.matchAll(findAliases))
    aliases.push(found[1]);
  const destructuringRegex = new RegExp(`{.*?} = (${aliases.join("|")})`, "g");
  for (const [params] of fnLiteral.matchAll(destructuringRegex))
    if (params.includes(`{ ${keyword}`) || params.includes(`, ${keyword}`))
      return true;
  return false;
};
var isContextPassToFunction = (fnLiteral) => {
  fnLiteral = fnLiteral.trimStart();
  if (fnLiteral.startsWith("[object"))
    return false;
  fnLiteral = fnLiteral.replaceAll(/^async /g, "");
  if (/^(\w+)\(/g.test(fnLiteral))
    fnLiteral = fnLiteral.slice(fnLiteral.indexOf("("));
  const argument = fnLiteral.charCodeAt(0) === 40 || fnLiteral.startsWith("function") ? fnLiteral.slice(fnLiteral.indexOf("(") + 1, fnLiteral.indexOf(")")) : fnLiteral.slice(0, fnLiteral.indexOf("=") - 1);
  if (argument === "")
    return false;
  const restIndex = argument.charCodeAt(0) === 123 ? argument.indexOf("...") : -1;
  const restAlias = restIndex !== -1 ? argument.slice(restIndex + 3, argument.indexOf(" ", restIndex + 3)) : undefined;
  const aliases = [argument];
  if (restAlias)
    aliases.push(restAlias);
  for (const found of fnLiteral.matchAll(findAliases))
    aliases.push(found[1]);
  for (const alias of aliases)
    if (new RegExp(`\\b\\w+\\([^)]*\\b${alias}\\b[^)]*\\)`).test(fnLiteral))
      return true;
  const destructuringRegex = new RegExp(`{.*?} = (${aliases.join("|")})`, "g");
  for (const [renamed] of fnLiteral.matchAll(destructuringRegex))
    if (new RegExp(`\\b\\w+\\([^)]*\\b${renamed}\\b[^)]*\\)`).test(fnLiteral))
      return true;
  return false;
};
var KindSymbol = Symbol.for("TypeBox.Kind");
var hasType = (type3, schema3) => {
  if (!schema3)
    return;
  if (KindSymbol in schema3 && schema3[KindSymbol] === type3)
    return true;
  if (schema3.type === "object") {
    const properties = schema3.properties;
    for (const key of Object.keys(properties)) {
      const property = properties[key];
      if (property.type === "object") {
        if (hasType(type3, property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++)
          if (hasType(type3, property.anyOf[i]))
            return true;
      }
      if (KindSymbol in property && property[KindSymbol] === type3)
        return true;
    }
    return false;
  }
  return schema3.properties && KindSymbol in schema3.properties && schema3.properties[KindSymbol] === type3;
};
var hasProperty = (expectedProperty, schema3) => {
  if (!schema3)
    return;
  if (schema3.type === "object") {
    const properties = schema3.properties;
    if (!properties)
      return false;
    for (const key of Object.keys(properties)) {
      const property = properties[key];
      if (expectedProperty in property)
        return true;
      if (property.type === "object") {
        if (hasProperty(expectedProperty, property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++) {
          if (hasProperty(expectedProperty, property.anyOf[i]))
            return true;
        }
      }
    }
    return false;
  }
  return expectedProperty in schema3;
};
var TransformSymbol = Symbol.for("TypeBox.Transform");
var hasTransform = (schema3) => {
  if (!schema3)
    return;
  if (schema3.type === "object" && schema3.properties) {
    const properties = schema3.properties;
    for (const key of Object.keys(properties)) {
      const property = properties[key];
      if (property.type === "object") {
        if (hasTransform(property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++)
          if (hasTransform(property.anyOf[i]))
            return true;
      }
      const hasTransformSymbol = TransformSymbol in property;
      if (hasTransformSymbol)
        return true;
    }
    return false;
  }
  return TransformSymbol in schema3 || schema3.properties && TransformSymbol in schema3.properties;
};
var getUnionedType = (validator) => {
  if (!validator)
    return;
  const schema3 = validator?.schema;
  if (schema3 && "anyOf" in schema3) {
    let foundDifference = false;
    const type3 = schema3.anyOf[0].type;
    for (const validator2 of schema3.anyOf) {
      if (validator2.type !== type3) {
        foundDifference = true;
        break;
      }
    }
    if (!foundDifference)
      return type3;
  }
  return validator.schema?.type;
};
var matchFnReturn = /(?:return|=>) \S+\(/g;
var isAsync = (fn) => {
  if (fn.constructor.name === "AsyncFunction")
    return true;
  const literal3 = fn.toString();
  if (literal3.includes("=> response.clone("))
    return false;
  return !!literal3.match(matchFnReturn);
};
var getDestructureQuery = (fn) => {
  if (!fn.includes("query: {") || fn.includes("query,") || fn.includes("query }"))
    return false;
  const start = fn.indexOf("query: {");
  fn = fn.slice(start + 9);
  fn = fn.slice(0, fn.indexOf("}"));
  return fn.split(",").map((x) => {
    const indexOf = x.indexOf(":");
    if (indexOf === -1)
      return x.trim();
    return x.slice(0, indexOf).trim();
  });
};
var composeHandler = ({
  path,
  method,
  hooks,
  validator,
  handler,
  handleError,
  definitions,
  schema: schema3,
  onRequest,
  config,
  getReporter,
  setHeader
}) => {
  const hasErrorHandler = config.forceErrorEncapsulation || hooks.error.length > 0 || typeof Bun === "undefined" || hooks.onResponse.length > 0 || !!hooks.trace.length;
  const isHandleFn = typeof handler === "function";
  const handle = isHandleFn ? `handler(c)` : `handler`;
  const handleResponse = hooks.onResponse.length ? `
;(async () => {${hooks.onResponse.map((_, i) => `await res${i}(c)`).join(";")}})();
` : "";
  const traceLiteral = hooks.trace.map((x) => x.toString());
  let hasUnknownContext = false;
  if (isHandleFn && isContextPassToFunction(handler.toString()))
    hasUnknownContext = true;
  if (!hasUnknownContext)
    for (const [key, value2] of Object.entries(hooks)) {
      if (!Array.isArray(value2) || !value2.length || ![
        "parse",
        "transform",
        "beforeHandle",
        "afterHandle",
        "onResponse"
      ].includes(key))
        continue;
      for (const handle2 of value2) {
        if (typeof handle2 !== "function")
          continue;
        if (isContextPassToFunction(handle2.toString())) {
          hasUnknownContext = true;
          break;
        }
      }
      if (hasUnknownContext)
        break;
    }
  const traceConditions = {
    parse: traceLiteral.some((x) => isFnUse("parse", x)),
    transform: traceLiteral.some((x) => isFnUse("transform", x)),
    handle: traceLiteral.some((x) => isFnUse("handle", x)),
    beforeHandle: traceLiteral.some((x) => isFnUse("beforeHandle", x)),
    afterHandle: traceLiteral.some((x) => isFnUse("afterHandle", x)),
    error: hasErrorHandler || traceLiteral.some((x) => isFnUse("error", x))
  };
  const hasTrace = hooks.trace.length > 0;
  let fnLiteral = "";
  const lifeCycleLiteral = validator || method !== "GET" && method !== "HEAD" ? [
    handler,
    ...hooks.transform,
    ...hooks.beforeHandle,
    ...hooks.afterHandle,
    ...hooks.mapResponse
  ].map((x) => typeof x === "function" ? x.toString() : `${x}`) : [];
  const hasBody = method !== "GET" && method !== "HEAD" && (hasUnknownContext || hooks.type !== "none" && (!!validator.body || !!hooks.type || lifeCycleLiteral.some((fn) => isFnUse("body", fn))));
  const hasHeaders = hasUnknownContext || validator.headers || lifeCycleLiteral.some((fn) => isFnUse("headers", fn)) || setHeader && Object.keys(setHeader).length;
  const hasCookie = hasUnknownContext || !!validator.cookie || lifeCycleLiteral.some((fn) => isFnUse("cookie", fn));
  const cookieMeta = validator?.cookie?.schema;
  let encodeCookie = "";
  if (cookieMeta?.sign) {
    if (!cookieMeta.secrets)
      throw new Error(`t.Cookie required secret which is not set in (${method}) ${path}.`);
    const secret = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
    encodeCookie += `const _setCookie = c.set.cookie
		if(_setCookie) {`;
    if (cookieMeta.sign === true) {
      encodeCookie += `for(const [key, cookie] of Object.entries(_setCookie)) {
				c.set.cookie[key].value = await signCookie(cookie.value, '${secret}')
			}`;
    } else
      for (const name of cookieMeta.sign) {
        encodeCookie += `if(_setCookie['${name}']?.value) { c.set.cookie['${name}'].value = await signCookie(_setCookie['${name}'].value, '${secret}') }
`;
      }
    encodeCookie += `}
`;
  }
  const { composeValidation, composeResponseValidation } = composeValidationFactory(hasErrorHandler);
  if (hasHeaders) {
    fnLiteral += headersHasToJSON ? `c.headers = c.request.headers.toJSON()
` : `c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`;
  }
  if (hasCookie) {
    const get = (name, defaultValue) => {
      const value2 = cookieMeta?.[name] ?? defaultValue;
      if (!value2)
        return typeof defaultValue === "string" ? `${name}: "${defaultValue}",` : `${name}: ${defaultValue},`;
      if (typeof value2 === "string")
        return `${name}: '${value2}',`;
      if (value2 instanceof Date)
        return `${name}: new Date(${value2.getTime()}),`;
      return `${name}: ${value2},`;
    };
    const options = cookieMeta ? `{
			secret: ${cookieMeta.secrets !== undefined ? typeof cookieMeta.secrets === "string" ? `'${cookieMeta.secrets}'` : "[" + cookieMeta.secrets.reduce((a, b) => a + `'${b}',`, "") + "]" : "undefined"},
			sign: ${cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? "[" + cookieMeta.sign.reduce((a, b) => a + `'${b}',`, "") + "]" : "undefined"},
			${get("domain")}
			${get("expires")}
			${get("httpOnly")}
			${get("maxAge")}
			${get("path", "/")}
			${get("priority")}
			${get("sameSite")}
			${get("secure")}
		}` : "undefined";
    if (hasHeaders)
      fnLiteral += `
c.cookie = await parseCookie(c.set, c.headers.cookie, ${options})
`;
    else
      fnLiteral += `
c.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${options})
`;
  }
  const hasQuery = hasUnknownContext || validator.query || lifeCycleLiteral.some((fn) => isFnUse("query", fn));
  if (hasQuery) {
    let destructured = [];
    let referenceFullQuery = false;
    if (validator.query && validator.query.schema.type === "object") {
      destructured = Object.keys(validator.query.schema.properties);
    } else
      for (const event of lifeCycleLiteral) {
        const queries = getDestructureQuery(event);
        if (!queries) {
          referenceFullQuery = true;
          continue;
        }
        for (const query of queries)
          if (destructured.indexOf(query) === -1)
            destructured.push(query);
      }
    if (!referenceFullQuery && destructured.length) {
      fnLiteral += `
			let requestUrl = c.request.url.slice(c.qi + 1)
			if(requestUrl.includes('+')) requestUrl = requestUrl.replaceAll('+', ' ')

			if(c.qi !== -1) {	
				const url = decodeURIComponent(requestUrl)
				let memory = 0

				${destructured.map((name, index) => `
						memory = url.indexOf('${name}=')

						const a${index} = memory === -1 ? undefined : url.slice(memory = memory + ${name.length + 1}, (memory = url.indexOf('&', memory)) === -1 ? undefined : memory)`).join(`
`)}

				c.query = {
					${destructured.map((name, index) => `'${name}': a${index}`).join(", ")}
				}
			} else {
				c.query = {}
			}`;
    } else {
      fnLiteral += `c.query = c.qi !== -1 ? parseQuery(decodeURIComponent(c.request.url.slice(c.qi + 1))) : {}`;
    }
  }
  const traceLiterals = hooks.trace.map((x) => x.toString());
  const hasTraceSet = traceLiterals.some((fn) => isFnUse("set", fn) || isContextPassToFunction(fn));
  hasUnknownContext || hooks.trace.some((fn) => isFnUse("set", fn.toString()));
  const hasSet = setHeader && Object.keys(setHeader).length || hasTraceSet || hasCookie || lifeCycleLiteral.some((fn) => isFnUse("set", fn)) || onRequest.some((fn) => isFnUse("set", fn.toString()));
  if (hasTrace)
    fnLiteral += `
const id = c.$$requestId
`;
  const report = createReport({
    hasTrace,
    hasTraceSet,
    condition: traceConditions,
    addFn: (word) => {
      fnLiteral += word;
    }
  });
  fnLiteral += hasErrorHandler ? `
 try {
` : "";
  if (hasTraceSet) {
    fnLiteral += `
const traceDone = Promise.all([`;
    for (let i = 0;i < hooks.trace.length; i++) {
      fnLiteral += `new Promise(r => { reporter.once(\`res\${id}.${i}\`, r) }),`;
    }
    fnLiteral += `])
`;
  }
  const isAsyncHandler = typeof handler === "function" && isAsync(handler);
  const maybeAsync = hasCookie || hasBody || hasTraceSet || isAsyncHandler || !!hooks.mapResponse.length || hooks.parse.length > 0 || hooks.afterHandle.some(isAsync) || hooks.beforeHandle.some(isAsync) || hooks.transform.some(isAsync);
  const endParse = report("parse", {
    unit: hooks.parse.length
  });
  if (hasBody) {
    const type3 = getUnionedType(validator?.body);
    if (hooks.type && !Array.isArray(hooks.type)) {
      if (hooks.type) {
        switch (hooks.type) {
          case "json":
          case "application/json":
            fnLiteral += `c.body = await c.request.json()
`;
            break;
          case "text":
          case "text/plain":
            fnLiteral += `c.body = await c.request.text()
`;
            break;
          case "urlencoded":
          case "application/x-www-form-urlencoded":
            fnLiteral += `c.body = parseQuery(await c.request.text())
`;
            break;
          case "arrayBuffer":
          case "application/octet-stream":
            fnLiteral += `c.body = await c.request.arrayBuffer()
`;
            break;
          case "formdata":
          case "multipart/form-data":
            fnLiteral += `c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}
`;
            break;
        }
      }
      if (hooks.parse.length)
        fnLiteral += "}}";
    } else {
      const getAotParser = () => {
        if (hooks.parse.length && type3 && !Array.isArray(hooks.type)) {
          const schema22 = validator?.body?.schema;
          switch (type3) {
            case "object":
              if (hasType("File", schema22) || hasType("Files", schema22))
                return `c.body = {}

								const form = await c.request.formData()
								for (const key of form.keys()) {
									if (c.body[key])
										continue

									const value = form.getAll(key)
									if (value.length === 1)
										c.body[key] = value[0]
									else c.body[key] = value
								}`;
              break;
            default:
              break;
          }
        }
      };
      const aotParse = getAotParser();
      if (aotParse)
        fnLiteral += aotParse;
      else {
        fnLiteral += `
`;
        fnLiteral += hasHeaders ? `let contentType = c.headers['content-type']` : `let contentType = c.request.headers.get('content-type')`;
        fnLiteral += `
				if (contentType) {
					const index = contentType.indexOf(';')
					if (index !== -1) contentType = contentType.substring(0, index)
`;
        if (hooks.parse.length) {
          fnLiteral += `let used = false
`;
          const endReport = report("parse", {
            unit: hooks.parse.length
          });
          for (let i = 0;i < hooks.parse.length; i++) {
            const endUnit = report("parse.unit", {
              name: hooks.parse[i].name
            });
            const name = `bo${i}`;
            if (i !== 0)
              fnLiteral += `if(!used) {
`;
            fnLiteral += `let ${name} = parse[${i}](c, contentType)
`;
            fnLiteral += `if(${name} instanceof Promise) ${name} = await ${name}
`;
            fnLiteral += `if(${name} !== undefined) { c.body = ${name}; used = true }
`;
            endUnit();
            if (i !== 0)
              fnLiteral += `}`;
          }
          endReport();
        }
        if (hooks.parse.length)
          fnLiteral += `if (!used)`;
        fnLiteral += `
				switch (contentType) {
					case 'application/json':
						c.body = await c.request.json()
						break

					case 'text/plain':
						c.body = await c.request.text()
						break

					case 'application/x-www-form-urlencoded':
						c.body = parseQuery(await c.request.text())
						break

					case 'application/octet-stream':
						c.body = await c.request.arrayBuffer();
						break

					case 'multipart/form-data':
						c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}

						break
					}
`;
        fnLiteral += `}
`;
      }
    }
    fnLiteral += `
`;
  }
  endParse();
  if (hooks?.transform) {
    const endTransform = report("transform", {
      unit: hooks.transform.length
    });
    for (let i = 0;i < hooks.transform.length; i++) {
      const transform4 = hooks.transform[i];
      const endUnit = report("transform.unit", {
        name: transform4.name
      });
      if (transform4.$elysia === "derive")
        fnLiteral += isAsync(transform4) ? `Object.assign(c, await transform[${i}](c));` : `Object.assign(c, transform[${i}](c));`;
      else
        fnLiteral += isAsync(transform4) ? `await transform[${i}](c);` : `transform[${i}](c);`;
      endUnit();
    }
    endTransform();
  }
  if (validator) {
    fnLiteral += `
`;
    if (validator.headers) {
      if (hasProperty("default", validator.headers.params))
        for (const [key, value2] of Object.entries(exports_value2.Default(validator.headers.schema, {}))) {
          const parsed = typeof value2 === "object" ? JSON.stringify(value2) : `'${value2}'`;
          if (parsed)
            fnLiteral += `c.headers['${key}'] ??= ${parsed}
`;
        }
      fnLiteral += `if(headers.Check(c.headers) === false) {
				${composeValidation("headers")}
			}`;
      if (hasTransform(validator.headers.schema))
        fnLiteral += `
c.headers = headers.Decode(c.headers)
`;
    }
    if (validator.params) {
      if (hasProperty("default", validator.params.schema))
        for (const [key, value2] of Object.entries(exports_value2.Default(validator.params.schema, {}))) {
          const parsed = typeof value2 === "object" ? JSON.stringify(value2) : `'${value2}'`;
          if (parsed)
            fnLiteral += `c.params['${key}'] ??= ${parsed}
`;
        }
      fnLiteral += `if(params.Check(c.params) === false) {
				${composeValidation("params")}
			}`;
      if (hasTransform(validator.params.schema))
        fnLiteral += `
c.params = params.Decode(c.params)
`;
    }
    if (validator.query) {
      if (hasProperty("default", validator.query.schema))
        for (const [key, value2] of Object.entries(exports_value2.Default(validator.query.schema, {}))) {
          const parsed = typeof value2 === "object" ? JSON.stringify(value2) : `'${value2}'`;
          if (parsed)
            fnLiteral += `c.query['${key}'] ??= ${parsed}
`;
        }
      fnLiteral += `if(query.Check(c.query) === false) {
				${composeValidation("query")}
			}`;
      if (hasTransform(validator.query.schema))
        fnLiteral += `
c.query = query.Decode(Object.assign({}, c.query))
`;
    }
    if (validator.body) {
      if (hasProperty("default", validator.body.schema))
        fnLiteral += `if(body.Check(c.body) === false) {
    				c.body = Object.assign(${JSON.stringify(exports_value2.Default(validator.body.schema, null) ?? {})}, c.body)

    				if(body.Check(c.query) === false) {
        				${composeValidation("body")}
     			}
            }`;
      else
        fnLiteral += `if(body.Check(c.body) === false) {
			${composeValidation("body")}
		}`;
      if (hasTransform(validator.body.schema))
        fnLiteral += `
c.body = body.Decode(c.body)
`;
    }
    if (isNotEmpty(validator.cookie?.schema.properties ?? {})) {
      fnLiteral += `const cookieValue = {}
    			for(const [key, value] of Object.entries(c.cookie))
    				cookieValue[key] = value.value
`;
      if (hasProperty("default", validator.cookie.schema))
        for (const [key, value2] of Object.entries(exports_value2.Default(validator.cookie.schema, {}))) {
          fnLiteral += `cookieValue['${key}'] = ${typeof value2 === "object" ? JSON.stringify(value2) : value2}
`;
        }
      fnLiteral += `if(cookie.Check(cookieValue) === false) {
				${composeValidation("cookie", "cookieValue")}
			}`;
      if (hasTransform(validator.cookie.schema))
        fnLiteral += `
c.cookie = params.Decode(c.cookie)
`;
    }
  }
  if (hooks?.beforeHandle) {
    const endBeforeHandle = report("beforeHandle", {
      unit: hooks.beforeHandle.length
    });
    for (let i = 0;i < hooks.beforeHandle.length; i++) {
      const beforeHandle = hooks.beforeHandle[i];
      const endUnit = report("beforeHandle.unit", {
        name: beforeHandle.name
      });
      const returning = hasReturn(beforeHandle.toString());
      if (beforeHandle.$elysia === "resolve") {
        fnLiteral += isAsync(beforeHandle) ? `Object.assign(c, await beforeHandle[${i}](c));` : `Object.assign(c, beforeHandle[${i}](c));`;
      } else if (!returning) {
        fnLiteral += isAsync(beforeHandle) ? `await beforeHandle[${i}](c);
` : `beforeHandle[${i}](c);
`;
        endUnit();
      } else {
        fnLiteral += isAsync(beforeHandle) ? `be = await beforeHandle[${i}](c);
` : `be = beforeHandle[${i}](c);
`;
        endUnit();
        fnLiteral += `if(be !== undefined) {
`;
        const endAfterHandle = report("afterHandle", {
          unit: hooks.transform.length
        });
        if (hooks.afterHandle) {
          report("handle", {
            name: isHandleFn ? handler.name : undefined
          })();
          for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
            const returning2 = hasReturn(hooks.afterHandle[i2].toString());
            const endUnit2 = report("afterHandle.unit", {
              name: hooks.afterHandle[i2].name
            });
            fnLiteral += `c.response = be
`;
            if (!returning2) {
              fnLiteral += isAsync(hooks.afterHandle[i2]) ? `await afterHandle[${i2}](c, be)
` : `afterHandle[${i2}](c, be)
`;
            } else {
              fnLiteral += isAsync(hooks.afterHandle[i2]) ? `af = await afterHandle[${i2}](c)
` : `af = afterHandle[${i2}](c)
`;
              fnLiteral += `if(af !== undefined) { c.response = be = af }
`;
            }
            endUnit2();
          }
        }
        endAfterHandle();
        if (validator.response)
          fnLiteral += composeResponseValidation("be");
        if (hooks.mapResponse.length) {
          fnLiteral += `c.response = be`;
          for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
            fnLiteral += `
if(mr === undefined) {
							mr = onMapResponse[${i2}](c)
							if(mr instanceof Promise) mr = await mr
							if(mr !== undefined) c.response = mr
						}
`;
          }
        }
        fnLiteral += encodeCookie;
        fnLiteral += `return mapEarlyResponse(be, c.set)}
`;
      }
    }
    endBeforeHandle();
  }
  if (hooks?.afterHandle.length) {
    const endHandle = report("handle", {
      name: isHandleFn ? handler.name : undefined
    });
    if (hooks.afterHandle.length)
      fnLiteral += isAsyncHandler ? `let r = c.response = await ${handle};
` : `let r = c.response = ${handle};
`;
    else
      fnLiteral += isAsyncHandler ? `let r = await ${handle};
` : `let r = ${handle};
`;
    endHandle();
    const endAfterHandle = report("afterHandle", {
      unit: hooks.afterHandle.length
    });
    for (let i = 0;i < hooks.afterHandle.length; i++) {
      const returning = hasReturn(hooks.afterHandle[i].toString());
      const endUnit = report("afterHandle.unit", {
        name: hooks.afterHandle[i].name
      });
      if (!returning) {
        fnLiteral += isAsync(hooks.afterHandle[i]) ? `await afterHandle[${i}](c)
` : `afterHandle[${i}](c)
`;
        endUnit();
      } else {
        fnLiteral += isAsync(hooks.afterHandle[i]) ? `af = await afterHandle[${i}](c)
` : `af = afterHandle[${i}](c)
`;
        endUnit();
        if (validator.response) {
          fnLiteral += `if(af !== undefined) {`;
          endAfterHandle();
          fnLiteral += composeResponseValidation("af");
          fnLiteral += `c.response = af }`;
        } else {
          fnLiteral += `if(af !== undefined) {`;
          endAfterHandle();
          fnLiteral += `c.response = af}
`;
        }
      }
    }
    endAfterHandle();
    fnLiteral += `r = c.response
`;
    if (validator.response)
      fnLiteral += composeResponseValidation();
    fnLiteral += encodeCookie;
    if (hooks.mapResponse.length) {
      for (let i = 0;i < hooks.mapResponse.length; i++) {
        fnLiteral += `
mr = onMapResponse[${i}](c)
				if(mr instanceof Promise) mr = await mr
				if(mr !== undefined) c.response = mr
`;
      }
    }
    if (hasSet)
      fnLiteral += `return mapResponse(r, c.set)
`;
    else
      fnLiteral += `return mapCompactResponse(r)
`;
  } else {
    const endHandle = report("handle", {
      name: isHandleFn ? handler.name : undefined
    });
    if (validator.response || hooks.mapResponse.length) {
      fnLiteral += isAsyncHandler ? `let r = await ${handle};
` : `let r = ${handle};
`;
      endHandle();
      if (validator.response)
        fnLiteral += composeResponseValidation();
      report("afterHandle")();
      if (hooks.mapResponse.length) {
        fnLiteral += "c.response = r";
        for (let i = 0;i < hooks.mapResponse.length; i++) {
          fnLiteral += `
if(mr === undefined) { 
						mr = onMapResponse[${i}](c)
						if(mr instanceof Promise) mr = await mr
    					if(mr !== undefined) r = c.response = mr
					}
`;
        }
      }
      fnLiteral += encodeCookie;
      if (handler instanceof Response)
        fnLiteral += `return ${handle}.clone()
`;
      else if (hasSet)
        fnLiteral += `return mapResponse(r, c.set)
`;
      else
        fnLiteral += `return mapCompactResponse(r)
`;
    } else {
      if (traceConditions.handle || hasCookie) {
        fnLiteral += isAsyncHandler ? `let r = await ${handle};
` : `let r = ${handle};
`;
        endHandle();
        report("afterHandle")();
        if (hooks.mapResponse.length) {
          fnLiteral += "c.response = r";
          for (let i = 0;i < hooks.mapResponse.length; i++) {
            fnLiteral += `
if(mr === undefined) {
							mr = onMapResponse[${i}](c)
							if(mr instanceof Promise) mr = await mr
    						if(mr !== undefined) r = c.response = mr
						}
`;
          }
        }
        fnLiteral += encodeCookie;
        if (hasSet)
          fnLiteral += `return mapResponse(r, c.set)
`;
        else
          fnLiteral += `return mapCompactResponse(r)
`;
      } else {
        endHandle();
        const handled = isAsyncHandler ? `await ${handle}` : handle;
        report("afterHandle")();
        if (handler instanceof Response)
          fnLiteral += `return ${handle}.clone()
`;
        else if (hasSet)
          fnLiteral += `return mapResponse(${handled}, c.set)
`;
        else
          fnLiteral += `return mapCompactResponse(${handled})
`;
      }
    }
  }
  if (hasErrorHandler || handleResponse) {
    fnLiteral += `
} catch(error) {`;
    if (!maybeAsync)
      fnLiteral += `return (async () => {`;
    fnLiteral += `const set = c.set

		if (!set.status || set.status < 300) set.status = error?.status || 500
	`;
    const endError = report("error", {
      unit: hooks.error.length
    });
    if (hooks.error.length) {
      fnLiteral += `
				c.error = error
				c.code = error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
			`;
      for (let i = 0;i < hooks.error.length; i++) {
        const name = `er${i}`;
        const endUnit = report("error.unit", {
          name: hooks.error[i].name
        });
        fnLiteral += `
let ${name} = handleErrors[${i}](c)
`;
        if (isAsync(hooks.error[i]))
          fnLiteral += `if (${name} instanceof Promise) ${name} = await ${name}
`;
        endUnit();
        fnLiteral += `${name} = mapEarlyResponse(${name}, set)
`;
        fnLiteral += `if (${name}) {`;
        fnLiteral += `return ${name} }
`;
      }
    }
    endError();
    fnLiteral += `return handleError(c, error)

`;
    if (!maybeAsync)
      fnLiteral += "})()";
    fnLiteral += "}";
    if (handleResponse || hasTrace) {
      fnLiteral += ` finally { `;
      const endResponse = report("response", {
        unit: hooks.onResponse.length
      });
      fnLiteral += handleResponse;
      endResponse();
      fnLiteral += `}`;
    }
  }
  fnLiteral = `const {
		handler,
		handleError,
		hooks: {
			transform,
			resolve,
			beforeHandle,
			afterHandle,
			mapResponse: onMapResponse,
			parse,
			error: handleErrors,
			onResponse
		},
		validator: {
			body,
			headers,
			params,
			query,
			response,
			cookie
		},
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError
		},
		schema,
		definitions,
		ERROR_CODE,
		getReporter,
		requestId,
		parseCookie,
		signCookie,
		decodeURIComponent
	} = hooks

	${hooks.onResponse.length ? `const ${hooks.onResponse.map((x, i) => `res${i} = onResponse[${i}]`).join(",")}` : ""}

	return ${maybeAsync ? "async" : ""} function handle(c) {
		${hooks.beforeHandle.length ? "let be" : ""}
		${hooks.afterHandle.length ? "let af" : ""}
		${hooks.mapResponse.length ? "let mr" : ""}

		${schema3 && definitions ? "c.schema = schema; c.defs = definitions;" : ""}
		${fnLiteral}
	}`;
  const createHandler = Function("hooks", fnLiteral);
  return createHandler({
    handler,
    hooks,
    validator,
    handleError,
    utils: {
      mapResponse,
      mapCompactResponse,
      mapEarlyResponse,
      parseQuery: import_fast_querystring.parse
    },
    error: {
      NotFoundError,
      ValidationError,
      InternalServerError
    },
    schema: schema3,
    definitions,
    ERROR_CODE,
    getReporter,
    requestId,
    parseCookie,
    signCookie,
    decodeURIComponent: import_fast_decode_uri_component.default
  });
};
var composeGeneralHandler = (app) => {
  let decoratorsLiteral = "";
  let fnLiteral = "";
  for (const key of Object.keys(app.decorators))
    decoratorsLiteral += `,${key}: app.decorators.${key}`;
  const { router, staticRouter } = app;
  const hasTrace = app.event.trace.length > 0;
  const findDynamicRoute = `
	const route = router.find(request.method, path) ${router.root.ALL ? '?? router.find("ALL", path)' : ""}
	if (route === null)
		return ${app.event.error.length ? `app.handleError(ctx, notFound)` : app.event.request.length ? `new Response(error404Message, {
					status: ctx.set.status === 200 ? 404 : ctx.set.status,
					headers: ctx.set.headers
				})` : `error404.clone()`}

	ctx.params = route.params

	return route.store(ctx)`;
  let switchMap = ``;
  for (const [path, { code, all }] of Object.entries(staticRouter.map))
    switchMap += `case '${path}':
switch(request.method) {
${code}
${all ?? `default: break map`}}

`;
  const maybeAsync = app.event.request.some(isAsync);
  fnLiteral += `const {
		app,
		app: { store, router, staticRouter, wsRouter },
		mapEarlyResponse,
		NotFoundError,
		requestId,
		getReporter,
		handleError
	} = data

	const notFound = new NotFoundError()

	${app.event.request.length ? `const onRequest = app.event.request` : ""}
	${staticRouter.variables}
	${app.event.error.length ? "" : `
	const error404Message = notFound.message.toString()
	const error404 = new Response(error404Message, { status: 404 });
	`}

	return ${maybeAsync ? "async" : ""} function map(request) {
`;
  if (app.event.request.length)
    fnLiteral += `let re`;
  const traceLiteral = app.event.trace.map((x) => x.toString());
  const report = createReport({
    hasTrace,
    hasTraceSet: app.event.trace.some((fn) => {
      const literal3 = fn.toString();
      return isFnUse("set", literal3) || isContextPassToFunction(literal3);
    }),
    condition: {
      request: traceLiteral.some((x) => isFnUse("request", x) || isContextPassToFunction(x))
    },
    addFn: (word) => {
      fnLiteral += word;
    }
  });
  if (app.event.request.length) {
    fnLiteral += `
			${hasTrace ? "const id = +requestId.value++" : ""}

			const ctx = {
				request,
				store,
				set: {
					headers: ${Object.keys(app.setHeaders ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}"},
					status: 200
				}
				${hasTrace ? ",$$requestId: +id" : ""}
				${decoratorsLiteral}
			}
		`;
    const endReport = report("request", {
      attribute: "ctx",
      unit: app.event.request.length
    });
    fnLiteral += `
 try {
`;
    for (let i = 0;i < app.event.request.length; i++) {
      const fn = app.event.request[i];
      const withReturn = hasReturn(fn.toString());
      const maybeAsync2 = isAsync(fn);
      const endUnit = report("request.unit", {
        name: app.event.request[i].name
      });
      if (withReturn) {
        fnLiteral += `re = mapEarlyResponse(
					${maybeAsync2 ? "await" : ""} onRequest[${i}](ctx),
					ctx.set
				)
`;
        endUnit();
        if (withReturn)
          fnLiteral += `if(re !== undefined) return re
`;
      } else {
        fnLiteral += `${maybeAsync2 ? "await" : ""} onRequest[${i}](ctx)
`;
        endUnit();
      }
    }
    fnLiteral += `} catch (error) {
			return app.handleError(ctx, error)
		}`;
    endReport();
    fnLiteral += `
		const url = request.url
		const s = url.indexOf('/', 11)
		const qi = ctx.qi = url.indexOf('?', s + 1)
		const path = ctx.path = url.substring(s, qi === -1 ? undefined : qi)`;
  } else {
    fnLiteral += `
		const url = request.url
		const s = url.indexOf('/', 11)
		const qi = url.indexOf('?', s + 1)
		const path = url.substring(s, qi === -1 ? undefined : qi)
		${hasTrace ? "const id = +requestId.value++" : ""}
		const ctx = {
			request,
			store,
			qi,
			path,
			set: {
				headers: ${Object.keys(app.setHeaders ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}"},
				status: 200
			}
			${hasTrace ? ",$$requestId: id" : ""}
			${decoratorsLiteral}
		}`;
    report("request", {
      unit: app.event.request.length,
      attribute: traceLiteral.some((x) => isFnUse("context", x)) || traceLiteral.some((x) => isFnUse("store", x)) || traceLiteral.some((x) => isFnUse("set", x)) ? "ctx" : ""
    })();
  }
  const wsPaths = app.wsPaths;
  const wsRouter = app.wsRouter;
  if (Object.keys(wsPaths).length || wsRouter.history.length) {
    fnLiteral += `
			if(request.method === 'GET') {
				switch(path) {`;
    for (const [path, index] of Object.entries(wsPaths)) {
      fnLiteral += `
					case '${path}':
						if(request.headers.get('upgrade') === 'websocket')
							return st${index}(ctx)

						break`;
    }
    fnLiteral += `
				default:
					if(request.headers.get('upgrade') === 'websocket') {
						const route = wsRouter.find('ws', path)

						if(route) {
							ctx.params = route.params

							return route.store(ctx)
						}
					}

					break
			}
		}
`;
  }
  fnLiteral += `
		map: switch(path) {
			${switchMap}

			default:
				break
		}

		${findDynamicRoute}
	}`;
  const handleError = composeErrorHandler(app);
  app.handleError = handleError;
  return Function("data", fnLiteral)({
    app,
    mapEarlyResponse,
    NotFoundError,
    getReporter: () => app.reporter,
    requestId,
    handleError
  });
};
var composeErrorHandler = (app) => {
  let fnLiteral = `const {
		app: { event: { error: onError, onResponse: res } },
		mapResponse,
		ERROR_CODE,
		ELYSIA_RESPONSE
	} = inject

	return ${app.event.error.find(isAsync) ? "async" : ""} function(context, error) {
		let r

		const { set } = context

		context.code = error.code
		context.error = error

		if(error[ELYSIA_RESPONSE]) {
			error.status = error[ELYSIA_RESPONSE]
			error.message = error.response
		}
`;
  for (let i = 0;i < app.event.error.length; i++) {
    const handler = app.event.error[i];
    const response = `${isAsync(handler) ? "await " : ""}onError[${i}](context)`;
    if (hasReturn(handler.toString()))
      fnLiteral += `r = ${response}; if(r !== undefined) {
				if(r instanceof Response) return r

				if(r[ELYSIA_RESPONSE]) {
					error.status = error[ELYSIA_RESPONSE]
					error.message = error.response
				}
		
				if(set.status === 200) set.status = error.status
				return mapResponse(r, set)
			}
`;
    else
      fnLiteral += response + `
`;
  }
  fnLiteral += `if(error.constructor.name === "ValidationError" || error.constructor.name === "TransformDecodeError") {
		set.status = error.status ?? 400
		return new Response(
			error.message,
			{ headers: set.headers, status: set.status }
		)
	} else {
		if(error.code && typeof error.status === "number")
			return new Response(
				error.message,
				{ headers: set.headers, status: error.status }
			)

		return mapResponse(error, set)
	}
}`;
  return Function("inject", fnLiteral)({
    app,
    mapResponse,
    ERROR_CODE,
    ELYSIA_RESPONSE
  });
};
var createDynamicHandler = (app) => async (request) => {
  const set2 = {
    cookie: {},
    status: 200,
    headers: {}
  };
  let context;
  if (app.decorators) {
    context = app.decorators;
    context.request = request;
    context.set = set2;
    context.store = app.store;
  } else {
    context = {
      set: set2,
      store: app.store,
      request
    };
  }
  const url = request.url, s = url.indexOf("/", 11), q = url.indexOf("?", s + 1), path = q === -1 ? url.substring(s) : url.substring(s, q);
  try {
    for (let i = 0;i < app.event.request.length; i++) {
      const onRequest = app.event.request[i];
      let response2 = onRequest(context);
      if (response2 instanceof Promise)
        response2 = await response2;
      response2 = mapEarlyResponse(response2, set2);
      if (response2)
        return response2;
    }
    const handler = app.dynamicRouter.find(request.method, path) ?? app.dynamicRouter.find("ALL", path);
    if (!handler)
      throw new NotFoundError;
    const { handle, hooks, validator, content } = handler.store;
    let body;
    if (request.method !== "GET" && request.method !== "HEAD") {
      if (content) {
        switch (content) {
          case "application/json":
            body = await request.json();
            break;
          case "text/plain":
            body = await request.text();
            break;
          case "application/x-www-form-urlencoded":
            body = import_fast_querystring2.parse(await request.text());
            break;
          case "application/octet-stream":
            body = await request.arrayBuffer();
            break;
          case "multipart/form-data":
            body = {};
            const form = await request.formData();
            for (const key of form.keys()) {
              if (body[key])
                continue;
              const value2 = form.getAll(key);
              if (value2.length === 1)
                body[key] = value2[0];
              else
                body[key] = value2;
            }
            break;
        }
      } else {
        let contentType = request.headers.get("content-type");
        if (contentType) {
          const index = contentType.indexOf(";");
          if (index !== -1)
            contentType = contentType.slice(0, index);
          for (let i = 0;i < hooks.parse.length; i++) {
            let temp = hooks.parse[i](context, contentType);
            if (temp instanceof Promise)
              temp = await temp;
            if (temp) {
              body = temp;
              break;
            }
          }
          if (body === undefined) {
            switch (contentType) {
              case "application/json":
                body = await request.json();
                break;
              case "text/plain":
                body = await request.text();
                break;
              case "application/x-www-form-urlencoded":
                body = import_fast_querystring2.parse(await request.text());
                break;
              case "application/octet-stream":
                body = await request.arrayBuffer();
                break;
              case "multipart/form-data":
                body = {};
                const form = await request.formData();
                for (const key of form.keys()) {
                  if (body[key])
                    continue;
                  const value2 = form.getAll(key);
                  if (value2.length === 1)
                    body[key] = value2[0];
                  else
                    body[key] = value2;
                }
                break;
            }
          }
        }
      }
    }
    context.body = body;
    context.params = handler?.params || undefined;
    context.query = q === -1 ? {} : import_fast_querystring2.parse(url.substring(q + 1));
    context.headers = {};
    for (const [key, value2] of request.headers.entries())
      context.headers[key] = value2;
    const cookieMeta = validator?.cookie?.schema;
    context.cookie = await parseCookie(context.set, context.headers.cookie, cookieMeta ? {
      secret: cookieMeta.secrets !== undefined ? typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets.join(",") : undefined,
      sign: cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? typeof cookieMeta.sign === "string" ? cookieMeta.sign : cookieMeta.sign.join(",") : undefined
    } : undefined);
    for (let i = 0;i < hooks.transform.length; i++) {
      const operation = hooks.transform[i](context);
      if (hooks.transform[i].$elysia === "derive") {
        if (operation instanceof Promise)
          Object.assign(context, await operation);
        else
          Object.assign(context, operation);
      } else if (operation instanceof Promise)
        await operation;
    }
    if (validator) {
      if (validator.headers) {
        const _header = {};
        for (const key in request.headers)
          _header[key] = request.headers.get(key);
        if (validator.headers.Check(_header) === false)
          throw new ValidationError("header", validator.headers, _header);
      }
      if (validator.params?.Check(context.params) === false)
        throw new ValidationError("params", validator.params, context.params);
      if (validator.query?.Check(context.query) === false)
        throw new ValidationError("query", validator.query, context.query);
      if (validator.cookie) {
        const cookieValue = {};
        for (const [key, value2] of Object.entries(context.cookie))
          cookieValue[key] = value2.value;
        if (validator.cookie?.Check(cookieValue) === false)
          throw new ValidationError("cookie", validator.cookie, cookieValue);
      }
      if (validator.body?.Check(body) === false)
        throw new ValidationError("body", validator.body, body);
    }
    for (let i = 0;i < hooks.beforeHandle.length; i++) {
      let response2 = hooks.beforeHandle[i](context);
      if (response2 instanceof Promise)
        response2 = await response2;
      if (response2 !== undefined) {
        context.response = response2;
        for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
          let newResponse = hooks.afterHandle[i2](context);
          if (newResponse instanceof Promise)
            newResponse = await newResponse;
          if (newResponse)
            response2 = newResponse;
        }
        const result = mapEarlyResponse(response2, context.set);
        if (result)
          return result;
      }
    }
    let response = handle(context);
    if (response instanceof Promise)
      response = await response;
    if (!hooks.afterHandle.length) {
      const responseValidator = validator?.response?.[response.status];
      if (responseValidator?.Check(response) === false)
        throw new ValidationError("response", responseValidator, response);
    } else {
      context.response = response;
      for (let i = 0;i < hooks.afterHandle.length; i++) {
        let newResponse = hooks.afterHandle[i](context);
        if (newResponse instanceof Promise)
          newResponse = await newResponse;
        const result = mapEarlyResponse(newResponse, context.set);
        if (result !== undefined) {
          const responseValidator = validator?.response?.[response.status];
          if (responseValidator?.Check(result) === false)
            throw new ValidationError("response", responseValidator, result);
          return result;
        }
      }
    }
    if (context.set.cookie && cookieMeta?.sign) {
      const secret = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
      if (cookieMeta.sign === true)
        for (const [key, cookie] of Object.entries(context.set.cookie))
          context.set.cookie[key].value = await signCookie(cookie.value, "${secret}");
      else
        for (const name of cookieMeta.sign) {
          if (!(name in cookieMeta.properties))
            continue;
          if (context.set.cookie[name]?.value) {
            context.set.cookie[name].value = await signCookie(context.set.cookie[name].value, secret);
          }
        }
    }
    return mapResponse(response, context.set);
  } catch (error22) {
    if (error22.status)
      set2.status = error22.status;
    return app.handleError(context, error22);
  } finally {
    for (const onResponse of app.event.onResponse)
      await onResponse(context);
  }
};
var createDynamicErrorHandler = (app) => async (context, error22) => {
  const errorContext = Object.assign(context, { error: error22, code: error22.code });
  errorContext.set = context.set;
  for (let i = 0;i < app.event.error.length; i++) {
    let response = app.event.error[i](errorContext);
    if (response instanceof Promise)
      response = await response;
    if (response !== undefined && response !== null)
      return mapResponse(response, context.set);
  }
  return new Response(typeof error22.cause === "string" ? error22.cause : error22.message, {
    headers: context.set.headers,
    status: error22.status ?? 500
  });
};
var t = Object.assign({}, Type);
try {
  TypeSystem.Format("email", (value2) => /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(value2));
  TypeSystem.Format("uuid", (value2) => /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(value2));
  TypeSystem.Format("date", (value2) => !Number.isNaN(new Date(value2).getTime()));
  TypeSystem.Format("date-time", (value2) => !Number.isNaN(new Date(value2).getTime()));
} catch {}
var parseFileUnit = (size) => {
  if (typeof size === "string")
    switch (size.slice(-1)) {
      case "k":
        return +size.slice(0, size.length - 1) * 1024;
      case "m":
        return +size.slice(0, size.length - 1) * 1048576;
      default:
        return +size;
    }
  return size;
};
var validateFile = (options, value2) => {
  if (!(value2 instanceof Blob))
    return false;
  if (options.minSize && value2.size < parseFileUnit(options.minSize))
    return false;
  if (options.maxSize && value2.size > parseFileUnit(options.maxSize))
    return false;
  if (options.extension)
    if (typeof options.extension === "string") {
      if (!value2.type.startsWith(options.extension))
        return false;
    } else {
      for (let i = 0;i < options.extension.length; i++)
        if (value2.type.startsWith(options.extension[i]))
          return true;
      return false;
    }
  return true;
};
var Files = TypeSystem.Type("Files", (options, value2) => {
  if (!Array.isArray(value2))
    return validateFile(options, value2);
  if (options.minItems && value2.length < options.minItems)
    return false;
  if (options.maxItems && value2.length > options.maxItems)
    return false;
  for (let i = 0;i < value2.length; i++)
    if (!validateFile(options, value2[i]))
      return false;
  return true;
});
exports_format.Set("numeric", (value2) => !!value2 && !isNaN(+value2));
exports_format.Set("boolean", (value2) => value2 === "true" || value2 === "false");
exports_format.Set("ObjectString", (value2) => {
  let start = value2.charCodeAt(0);
  if (start === 9 || start === 10 || start === 32)
    start = value2.trimStart().charCodeAt(0);
  if (start !== 123 && start !== 91)
    return false;
  try {
    JSON.parse(value2);
    return true;
  } catch {
    return false;
  }
});
var ElysiaType = {
  Numeric: (property) => {
    const schema3 = Type.Number(property);
    return t.Transform(t.Union([
      t.String({
        format: "numeric",
        default: 0
      }),
      t.Number(property)
    ], property)).Decode((value2) => {
      const number3 = +value2;
      if (isNaN(number3))
        return value2;
      if (property && !exports_value2.Check(schema3, number3))
        throw new ValidationError("property", schema3, number3);
      return number3;
    }).Encode((value2) => value2);
  },
  BooleanString: (property) => {
    const schema3 = Type.Boolean(property);
    return t.Transform(t.Union([
      t.String({
        format: "boolean",
        default: false
      }),
      t.Boolean(property)
    ], property)).Decode((value2) => {
      if (typeof value2 === "string")
        return value2 === "true";
      if (property && !exports_value2.Check(schema3, value2))
        throw new ValidationError("property", schema3, value2);
      return value2;
    }).Encode((value2) => value2);
  },
  ObjectString: (properties, options) => t.Transform(t.Union([
    t.String({
      format: "ObjectString",
      default: ""
    }),
    t.Object(properties, options)
  ], options)).Decode((value2) => {
    if (typeof value2 === "string")
      try {
        return JSON.parse(value2);
      } catch {
        return value2;
      }
    return value2;
  }).Encode((value2) => JSON.stringify(value2)),
  File: TypeSystem.Type("File", validateFile),
  Files: (options = {}) => t.Transform(t.Union([Files(options)])).Decode((value2) => {
    if (Array.isArray(value2))
      return value2;
    return [value2];
  }).Encode((value2) => value2),
  Nullable: (schema3) => t.Union([t.Null(), schema3]),
  MaybeEmpty: (schema3) => t.Union([t.Null(), t.Undefined(), schema3]),
  Cookie: (properties, options) => t.Object(properties, options)
};
t.BooleanString = ElysiaType.BooleanString;
t.ObjectString = ElysiaType.ObjectString;
t.Numeric = ElysiaType.Numeric;
t.File = (arg = {}) => ElysiaType.File({
  default: "File",
  ...arg,
  extension: arg?.type,
  type: "string",
  format: "binary"
});
t.Files = (arg = {}) => ElysiaType.Files({
  ...arg,
  elysiaMeta: "Files",
  default: "Files",
  extension: arg?.type,
  type: "array",
  items: {
    ...arg,
    default: "Files",
    type: "string",
    format: "binary"
  }
});
t.Nullable = (schema3) => ElysiaType.Nullable(schema3);
t.MaybeEmpty = ElysiaType.MaybeEmpty;
t.Cookie = ElysiaType.Cookie;
var Elysia = class _Elysia {
  constructor(config) {
    this.dependencies = {};
    this.store = {};
    this.decorators = {};
    this.definitions = {
      type: {},
      error: {}
    };
    this.schema = {};
    this.macros = [];
    this.event = {
      start: [],
      request: [],
      parse: [],
      transform: [],
      beforeHandle: [],
      afterHandle: [],
      mapResponse: [],
      onResponse: [],
      trace: [],
      error: [],
      stop: []
    };
    this.reporter = new eventemitter3_default;
    this.server = null;
    this.validator = null;
    this.router = new Memoirist;
    this.wsRouter = new Memoirist;
    this.routes = [];
    this.staticRouter = {
      handlers: [],
      variables: "",
      map: {},
      all: ""
    };
    this.wsPaths = {};
    this.dynamicRouter = new Memoirist;
    this.lazyLoadModules = [];
    this.path = "";
    this.stack = undefined;
    this.handle = async (request) => this.fetch(request);
    this.fetch = (request) => {
      if (false)
        ;
      return (this.fetch = this.config.aot ? composeGeneralHandler(this) : createDynamicHandler(this))(request);
    };
    this.handleError = async (context, error22) => (this.handleError = this.config.aot ? composeErrorHandler(this) : createDynamicErrorHandler(this))(context, error22);
    this.outerErrorHandler = (error22) => new Response(error22.message || error22.name || "Error", {
      status: error22?.status ?? 500
    });
    this.listen = (options, callback) => {
      if (typeof Bun === "undefined")
        throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
      this.compile();
      if (typeof options === "string") {
        options = +options.trim();
        if (Number.isNaN(options))
          throw new Error("Port must be a numeric value");
      }
      const fetch = this.fetch;
      const serve = typeof options === "object" ? {
        development: !isProduction,
        reusePort: true,
        ...this.config.serve || {},
        ...options || {},
        websocket: {
          ...this.config.websocket || {},
          ...websocket || {}
        },
        fetch,
        error: this.outerErrorHandler
      } : {
        development: !isProduction,
        reusePort: true,
        ...this.config.serve || {},
        websocket: {
          ...this.config.websocket || {},
          ...websocket || {}
        },
        port: options,
        fetch,
        error: this.outerErrorHandler
      };
      this.server = Bun?.serve(serve);
      if (this.event.start.length)
        for (let i = 0;i < this.event.start.length; i++)
          this.event.start[i](this);
      if (callback)
        callback(this.server);
      process.on("beforeExit", () => {
        for (let i = 0;i < this.event.stop.length; i++)
          this.event.stop[i](this);
      });
      Promise.all(this.lazyLoadModules).then(() => {
        Bun?.gc(false);
      });
      return this;
    };
    this.stop = async () => {
      if (!this.server)
        throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
      this.server.stop();
      if (this.event.stop.length)
        for (let i = 0;i < this.event.stop.length; i++)
          this.event.stop[i](this);
    };
    this.config = {
      forceErrorEncapsulation: true,
      prefix: "",
      aot: true,
      strictPath: false,
      scoped: false,
      cookie: {},
      analytic: false,
      ...config || {},
      seed: config?.seed === undefined ? "" : config?.seed
    };
    if (config?.analytic && (config?.name || config?.seed !== undefined))
      this.stack = new Error().stack;
  }
  getServer() {
    return this.server;
  }
  add(method, paths, handle, localHook, { allowMeta = false, skipPrefix = false } = {
    allowMeta: false,
    skipPrefix: false
  }) {
    if (typeof paths === "string")
      paths = [paths];
    for (let path of paths) {
      path = path === "" ? path : path.charCodeAt(0) === 47 ? path : `/${path}`;
      if (this.config.prefix && !skipPrefix && !this.config.scoped)
        path = this.config.prefix + path;
      if (localHook?.type)
        switch (localHook.type) {
          case "text":
            localHook.type = "text/plain";
            break;
          case "json":
            localHook.type = "application/json";
            break;
          case "formdata":
            localHook.type = "multipart/form-data";
            break;
          case "urlencoded":
            localHook.type = "application/x-www-form-urlencoded";
            break;
          case "arrayBuffer":
            localHook.type = "application/octet-stream";
            break;
          default:
            break;
        }
      const models = this.definitions.type;
      let cookieValidator = getSchemaValidator(localHook?.cookie ?? this.validator?.cookie, {
        dynamic: !this.config.aot,
        models,
        additionalProperties: true
      });
      if (isNotEmpty(this.config.cookie ?? {})) {
        if (cookieValidator) {
          cookieValidator.schema = mergeCookie(cookieValidator.schema, this.config.cookie ?? {});
        } else {
          cookieValidator = getSchemaValidator(t.Cookie({}, this.config.cookie), {
            dynamic: !this.config.aot,
            models,
            additionalProperties: true
          });
        }
      }
      const validator = {
        body: getSchemaValidator(localHook?.body ?? this.validator?.body, {
          dynamic: !this.config.aot,
          models
        }),
        headers: getSchemaValidator(localHook?.headers ?? this.validator?.headers, {
          dynamic: !this.config.aot,
          models,
          additionalProperties: true
        }),
        params: getSchemaValidator(localHook?.params ?? this.validator?.params, {
          dynamic: !this.config.aot,
          models
        }),
        query: getSchemaValidator(localHook?.query ?? this.validator?.query, {
          dynamic: !this.config.aot,
          models
        }),
        cookie: cookieValidator,
        response: getResponseSchemaValidator(localHook?.response ?? this.validator?.response, {
          dynamic: !this.config.aot,
          models
        })
      };
      const globalHook = this.event;
      const loosePath = path.endsWith("/") ? path.slice(0, path.length - 1) : path + "/";
      if (this.macros.length) {
        const createManager = (stackName) => (type3, fn) => {
          if (typeof type3 === "function" || Array.isArray(type3)) {
            if (!localHook[stackName])
              localHook[stackName] = [];
            if (typeof localHook[stackName] === "function")
              localHook[stackName] = [localHook[stackName]];
            if (Array.isArray(type3))
              localHook[stackName] = localHook[stackName].concat(type3);
            else
              localHook[stackName].push(type3);
            return;
          }
          const { insert = "after", stack = "local" } = type3;
          if (stack === "global") {
            if (!Array.isArray(fn)) {
              if (insert === "before") {
                globalHook[stackName].unshift(fn);
              } else {
                globalHook[stackName].push(fn);
              }
            } else {
              if (insert === "before") {
                globalHook[stackName] = fn.concat(globalHook[stackName]);
              } else {
                globalHook[stackName] = globalHook[stackName].concat(fn);
              }
            }
            return;
          } else {
            if (!localHook[stackName])
              localHook[stackName] = [];
            if (typeof localHook[stackName] === "function")
              localHook[stackName] = [localHook[stackName]];
            if (!Array.isArray(fn)) {
              if (insert === "before") {
                localHook[stackName].unshift(fn);
              } else {
                localHook[stackName].push(fn);
              }
            } else {
              if (insert === "before") {
                localHook[stackName] = fn.concat(localHook[stackName]);
              } else {
                localHook[stackName] = localHook[stackName].concat(fn);
              }
            }
            return;
          }
        };
        const manager = {
          events: {
            global: globalHook,
            local: localHook
          },
          onParse: createManager("parse"),
          onTransform: createManager("transform"),
          onBeforeHandle: createManager("beforeHandle"),
          onAfterHandle: createManager("afterHandle"),
          onResponse: createManager("onResponse"),
          onError: createManager("error")
        };
        for (const macro of this.macros)
          traceBackMacro(macro(manager), localHook);
      }
      const hooks = mergeHook(globalHook, localHook);
      const isFn = typeof handle === "function";
      if (this.config.aot === false) {
        this.dynamicRouter.add(method, path, {
          validator,
          hooks,
          content: localHook?.type,
          handle
        });
        if (this.config.strictPath === false) {
          this.dynamicRouter.add(method, loosePath, {
            validator,
            hooks,
            content: localHook?.type,
            handle
          });
        }
        this.routes.push({
          method,
          path,
          composed: null,
          handler: handle,
          hooks
        });
        return;
      }
      const mainHandler = composeHandler({
        path,
        method,
        hooks,
        validator,
        handler: handle,
        handleError: this.handleError,
        onRequest: this.event.request,
        config: this.config,
        definitions: allowMeta ? this.definitions.type : undefined,
        schema: allowMeta ? this.schema : undefined,
        getReporter: () => this.reporter,
        setHeader: this.setHeaders
      });
      if (!isFn) {
        const context = Object.assign({
          headers: {},
          query: {},
          params: {},
          body: undefined,
          request: new Request(`http://localhost${path}`),
          store: this.store,
          path,
          set: {
            headers: this.setHeaders ?? {},
            status: 200
          }
        }, this.decorators);
        let response;
        for (const onRequest of Object.values(hooks.request)) {
          try {
            const inner = mapEarlyResponse(onRequest(context), context.set);
            if (inner !== undefined) {
              response = inner;
              break;
            }
          } catch (error22) {
            response = this.handleError(context, error22);
            break;
          }
        }
        if (response)
          mainHandler.response = response;
        else {
          try {
            mainHandler.response = mainHandler(context);
          } catch (error22) {
            mainHandler.response = this.handleError(context, error22);
          }
        }
      }
      const existingRouteIndex = this.routes.findIndex((route) => route.path === path && route.method === method);
      if (existingRouteIndex !== -1) {
        this.routes.splice(existingRouteIndex, 1);
      }
      this.routes.push({
        method,
        path,
        composed: mainHandler,
        handler: handle,
        hooks
      });
      if (method === "$INTERNALWS") {
        const loose = this.config.strictPath ? undefined : path.endsWith("/") ? path.slice(0, path.length - 1) : path + "/";
        if (path.indexOf(":") === -1 && path.indexOf("*") === -1) {
          const index = this.staticRouter.handlers.length;
          this.staticRouter.handlers.push(mainHandler);
          if (mainHandler.response instanceof Response)
            this.staticRouter.variables += `const st${index} = staticRouter.handlers[${index}].response
`;
          else
            this.staticRouter.variables += `const st${index} = staticRouter.handlers[${index}]
`;
          this.wsPaths[path] = index;
          if (loose)
            this.wsPaths[loose] = index;
        } else {
          this.wsRouter.add("ws", path, mainHandler);
          if (loose)
            this.wsRouter.add("ws", loose, mainHandler);
        }
        return;
      }
      if (path.indexOf(":") === -1 && path.indexOf("*") === -1) {
        const index = this.staticRouter.handlers.length;
        this.staticRouter.handlers.push(mainHandler);
        if (mainHandler.response instanceof Response)
          this.staticRouter.variables += `const st${index} = staticRouter.handlers[${index}].response
`;
        else
          this.staticRouter.variables += `const st${index} = staticRouter.handlers[${index}]
`;
        if (!this.staticRouter.map[path])
          this.staticRouter.map[path] = {
            code: ""
          };
        if (method === "ALL")
          this.staticRouter.map[path].all = `default: return st${index}(ctx)
`;
        else {
          if (mainHandler.response instanceof Response)
            this.staticRouter.map[path].code = `case '${method}': return st${index}.clone()
${this.staticRouter.map[path].code}`;
          else
            this.staticRouter.map[path].code = `case '${method}': return st${index}(ctx)
${this.staticRouter.map[path].code}`;
        }
        if (!this.config.strictPath) {
          if (!this.staticRouter.map[loosePath])
            this.staticRouter.map[loosePath] = {
              code: ""
            };
          if (method === "ALL")
            this.staticRouter.map[loosePath].all = `default: return st${index}(ctx)
`;
          else {
            if (mainHandler.response instanceof Response)
              this.staticRouter.map[loosePath].code = `case '${method}': return st${index}.clone()
${this.staticRouter.map[loosePath].code}`;
            else
              this.staticRouter.map[loosePath].code = `case '${method}': return st${index}(ctx)
${this.staticRouter.map[loosePath].code}`;
          }
        }
      } else {
        this.router.add(method, path, mainHandler);
        if (!this.config.strictPath)
          this.router.add(method, path.endsWith("/") ? path.slice(0, path.length - 1) : path + "/", mainHandler);
      }
    }
  }
  headers(header) {
    if (!header)
      return this;
    if (!this.setHeaders)
      this.setHeaders = {};
    this.setHeaders = mergeDeep(this.setHeaders, header);
    return this;
  }
  onStart(handler) {
    this.on("start", handler);
    return this;
  }
  onRequest(handler) {
    this.on("request", handler);
    return this;
  }
  onParse(parser) {
    this.on("parse", parser);
    return this;
  }
  onTransform(handler) {
    this.on("transform", handler);
    return this;
  }
  resolve(resolver2) {
    resolver2.$elysia = "resolve";
    return this.onBeforeHandle(resolver2);
  }
  onBeforeHandle(handler) {
    this.on("beforeHandle", handler);
    return this;
  }
  onAfterHandle(handler) {
    this.on("afterHandle", handler);
    return this;
  }
  mapResponse(handler) {
    this.on("mapResponse", handler);
    return this;
  }
  onResponse(handler) {
    this.on("response", handler);
    return this;
  }
  trace(handler) {
    this.reporter.on("event", createTraceListener(() => this.reporter, this.event.trace.length, handler));
    this.on("trace", handler);
    return this;
  }
  error(name, error22) {
    switch (typeof name) {
      case "string":
        error22.prototype[ERROR_CODE] = name;
        this.definitions.error[name] = error22;
        return this;
      case "function":
        this.definitions.error = name(this.definitions.error);
        return this;
    }
    for (const [code, error3] of Object.entries(name)) {
      error3.prototype[ERROR_CODE] = code;
      this.definitions.error[code] = error3;
    }
    return this;
  }
  onError(handler) {
    this.on("error", handler);
    return this;
  }
  onStop(handler) {
    this.on("stop", handler);
    return this;
  }
  on(type3, handlers) {
    for (let handler of Array.isArray(handlers) ? handlers : [handlers]) {
      handler = asGlobal(handler);
      switch (type3) {
        case "start":
          this.event.start.push(handler);
          break;
        case "request":
          this.event.request.push(handler);
          break;
        case "parse":
          this.event.parse.splice(this.event.parse.length - 1, 0, handler);
          break;
        case "transform":
          this.event.transform.push(handler);
          break;
        case "beforeHandle":
          this.event.beforeHandle.push(handler);
          break;
        case "afterHandle":
          this.event.afterHandle.push(handler);
          break;
        case "mapResponse":
          this.event.mapResponse.push(handler);
          break;
        case "response":
          this.event.onResponse.push(handler);
          break;
        case "trace":
          this.event.trace.push(handler);
          break;
        case "error":
          this.event.error.push(handler);
          break;
        case "stop":
          this.event.stop.push(handler);
          break;
      }
    }
    return this;
  }
  group(prefix, schemaOrRun, run) {
    const instance = new _Elysia({
      ...this.config || {},
      prefix: ""
    });
    instance.store = this.store;
    instance.definitions = this.definitions;
    instance.getServer = () => this.server;
    const isSchema = typeof schemaOrRun === "object";
    const sandbox = (isSchema ? run : schemaOrRun)(instance);
    this.decorators = mergeDeep(this.decorators, instance.decorators);
    if (sandbox.event.request.length)
      this.event.request = [
        ...this.event.request || [],
        ...sandbox.event.request || []
      ];
    if (sandbox.event.onResponse.length)
      this.event.onResponse = [
        ...this.event.onResponse || [],
        ...sandbox.event.onResponse || []
      ];
    this.model(sandbox.definitions.type);
    Object.values(instance.routes).forEach(({ method, path, handler, hooks }) => {
      path = (isSchema ? "" : this.config.prefix) + prefix + path;
      if (isSchema) {
        const hook = schemaOrRun;
        const localHook = hooks;
        this.add(method, path, handler, mergeHook(hook, {
          ...localHook || {},
          error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [
            ...localHook.error || {},
            ...sandbox.event.error || {}
          ] : [
            localHook.error,
            ...sandbox.event.error || {}
          ]
        }));
      } else {
        this.add(method, path, handler, mergeHook(hooks, {
          error: sandbox.event.error
        }), {
          skipPrefix: true
        });
      }
    });
    return this;
  }
  guard(hook, run) {
    if (!run) {
      this.event = mergeLifeCycle(this.event, hook);
      this.validator = {
        body: hook.body,
        headers: hook.headers,
        params: hook.params,
        query: hook.query,
        response: hook.response
      };
      return this;
    }
    const instance = new _Elysia({
      ...this.config || {},
      prefix: ""
    });
    instance.store = this.store;
    instance.definitions = this.definitions;
    const sandbox = run(instance);
    this.decorators = mergeDeep(this.decorators, instance.decorators);
    if (sandbox.event.request.length)
      this.event.request = [
        ...this.event.request || [],
        ...sandbox.event.request || []
      ];
    if (sandbox.event.onResponse.length)
      this.event.onResponse = [
        ...this.event.onResponse || [],
        ...sandbox.event.onResponse || []
      ];
    this.model(sandbox.definitions.type);
    Object.values(instance.routes).forEach(({ method, path, handler, hooks: localHook }) => {
      this.add(method, path, handler, mergeHook(hook, {
        ...localHook || {},
        error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [
          ...localHook.error || {},
          ...sandbox.event.error || []
        ] : [localHook.error, ...sandbox.event.error || []]
      }));
    });
    return this;
  }
  use(plugin) {
    if (plugin instanceof Promise) {
      this.lazyLoadModules.push(plugin.then((plugin2) => {
        if (typeof plugin2 === "function") {
          return plugin2(this);
        }
        if (typeof plugin2.default === "function")
          return plugin2.default(this);
        return this._use(plugin2);
      }).then((x) => x.compile()));
      return this;
    } else
      return this._use(plugin);
    return this;
  }
  _use(plugin) {
    if (typeof plugin === "function") {
      const instance = plugin(this);
      if (instance instanceof Promise) {
        this.lazyLoadModules.push(instance.then((plugin2) => {
          if (plugin2 instanceof _Elysia) {
            this.compile();
            for (const {
              method,
              path,
              handler,
              hooks
            } of Object.values(plugin2.routes)) {
              this.add(method, path, handler, mergeHook(hooks, {
                error: plugin2.event.error
              }));
            }
            return plugin2;
          }
          if (typeof plugin2 === "function")
            return plugin2(this);
          if (typeof plugin2.default === "function")
            return plugin2.default(this);
          return this._use(plugin2);
        }).then((x) => x.compile()));
        return this;
      }
      return instance;
    }
    const { name, seed } = plugin.config;
    plugin.getServer = () => this.getServer();
    this.headers(plugin.setHeaders);
    const isScoped = plugin.config.scoped;
    if (isScoped) {
      if (name) {
        if (!(name in this.dependencies))
          this.dependencies[name] = [];
        const current = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
        if (this.dependencies[name].some(({ checksum: checksum2 }) => current === checksum2))
          return this;
        this.dependencies[name].push(!this.config?.analytic ? {
          name: plugin.config.name,
          seed: plugin.config.seed,
          checksum: current,
          dependencies: plugin.dependencies
        } : {
          name: plugin.config.name,
          seed: plugin.config.seed,
          checksum: current,
          dependencies: plugin.dependencies,
          stack: plugin.stack,
          routes: plugin.routes,
          decorators: plugin.decorators,
          store: plugin.store,
          type: plugin.definitions.type,
          error: plugin.definitions.error,
          derive: plugin.event.transform.filter((x) => x.$elysia === "derive").map((x) => ({
            fn: x.toString(),
            stack: new Error().stack ?? ""
          })),
          resolve: plugin.event.transform.filter((x) => x.$elysia === "derive").map((x) => ({
            fn: x.toString(),
            stack: new Error().stack ?? ""
          }))
        });
      }
      plugin.model(this.definitions.type);
      plugin.error(this.definitions.error);
      plugin.macros = [...this.macros || [], ...plugin.macros || []];
      plugin.onRequest((context) => {
        Object.assign(context, this.decorators);
        Object.assign(context.store, this.store);
      });
      if (plugin.event.trace.length)
        plugin.event.trace.push(...plugin.event.trace);
      if (isScoped && !plugin.config.prefix)
        console.warn("When using scoped plugins it is recommended to use a prefix, else routing may not work correctly for the second scoped instance");
      if (plugin.event.error.length)
        plugin.event.error.push(...this.event.error);
      if (plugin.config.aot)
        plugin.compile();
      let instance;
      if (isScoped && plugin.config.prefix) {
        instance = this.mount(plugin.config.prefix + "/", plugin.fetch);
        for (const route of plugin.routes)
          this.routes.push({
            ...route,
            path: `${plugin.config.prefix}${route.path}`,
            hooks: mergeHook(route.hooks, {
              error: this.event.error
            })
          });
      } else {
        instance = this.mount(plugin.fetch);
        if (instance.routes.length)
          this.routes.push(...instance.routes);
      }
      return this;
    } else {
      plugin.reporter = this.reporter;
      for (const trace of plugin.event.trace)
        this.trace(trace);
      if (name) {
        if (!(name in this.dependencies))
          this.dependencies[name] = [];
        const current = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
        if (!this.dependencies[name].some(({ checksum: checksum2 }) => current === checksum2))
          this.macros.push(...plugin.macros || []);
        const macroHashes = [];
        for (let i = 0;i < this.macros.length; i++) {
          const macro = this.macros[i];
          if (macroHashes.includes(macro.$elysiaChecksum)) {
            this.macros.splice(i, 1);
            i--;
          }
          macroHashes.push(macro.$elysiaChecksum);
        }
      }
    }
    this.decorate(plugin.decorators);
    this.state(plugin.store);
    this.model(plugin.definitions.type);
    this.error(plugin.definitions.error);
    for (const { method, path, handler, hooks } of Object.values(plugin.routes)) {
      this.add(method, path, handler, mergeHook(hooks, {
        error: plugin.event.error
      }));
    }
    if (!isScoped)
      if (name) {
        if (!(name in this.dependencies))
          this.dependencies[name] = [];
        const current = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
        if (this.dependencies[name].some(({ checksum: checksum2 }) => current === checksum2))
          return this;
        this.dependencies[name].push(!this.config?.analytic ? {
          name: plugin.config.name,
          seed: plugin.config.seed,
          checksum: current,
          dependencies: plugin.dependencies
        } : {
          name: plugin.config.name,
          seed: plugin.config.seed,
          checksum: current,
          dependencies: plugin.dependencies,
          stack: plugin.stack,
          routes: plugin.routes,
          decorators: plugin.decorators,
          store: plugin.store,
          type: plugin.definitions.type,
          error: plugin.definitions.error,
          derive: plugin.event.transform.filter((x) => x?.$elysia === "derive").map((x) => ({
            fn: x.toString(),
            stack: new Error().stack ?? ""
          })),
          resolve: plugin.event.transform.filter((x) => x?.$elysia === "resolve").map((x) => ({
            fn: x.toString(),
            stack: new Error().stack ?? ""
          }))
        });
        this.event = mergeLifeCycle(this.event, filterGlobalHook(plugin.event), current);
      } else {
        this.event = mergeLifeCycle(this.event, filterGlobalHook(plugin.event));
      }
    return this;
  }
  macro(macro) {
    macro.$elysiaChecksum = checksum(JSON.stringify({
      name: this.config.name,
      seed: this.config.seed,
      content: macro.toString()
    }));
    this.macros.push(macro);
    return this;
  }
  mount(path, handle) {
    if (path instanceof _Elysia || typeof path === "function" || path.length === 0 || path === "/") {
      const run = typeof path === "function" ? path : path instanceof _Elysia ? path.compile().fetch : handle instanceof _Elysia ? handle.compile().fetch : handle;
      const handler2 = async ({ request, path: path2 }) => run(new Request(replaceUrlPath(request.url, path2 || "/"), request));
      this.all("/", handler2, {
        type: "none"
      });
      this.all("/*", handler2, {
        type: "none"
      });
      return this;
    }
    const length = path.length;
    if (handle instanceof _Elysia)
      handle = handle.compile().fetch;
    const handler = async ({ request, path: path2 }) => handle(new Request(replaceUrlPath(request.url, path2.slice(length) || "/"), request));
    this.all(path, handler, {
      type: "none"
    });
    this.all(path + (path.endsWith("/") ? "*" : "/*"), handler, {
      type: "none"
    });
    return this;
  }
  get(path, handler, hook) {
    this.add("GET", path, handler, hook);
    return this;
  }
  post(path, handler, hook) {
    this.add("POST", path, handler, hook);
    return this;
  }
  put(path, handler, hook) {
    this.add("PUT", path, handler, hook);
    return this;
  }
  patch(path, handler, hook) {
    this.add("PATCH", path, handler, hook);
    return this;
  }
  delete(path, handler, hook) {
    this.add("DELETE", path, handler, hook);
    return this;
  }
  options(path, handler, hook) {
    this.add("OPTIONS", path, handler, hook);
    return this;
  }
  all(path, handler, hook) {
    this.add("ALL", path, handler, hook);
    return this;
  }
  head(path, handler, hook) {
    this.add("HEAD", path, handler, hook);
    return this;
  }
  connect(path, handler, hook) {
    this.add("CONNECT", path, handler, hook);
    return this;
  }
  ws(path, options) {
    const transform4 = options.transformMessage ? Array.isArray(options.transformMessage) ? options.transformMessage : [options.transformMessage] : undefined;
    let server = null;
    const validateMessage = getSchemaValidator(options?.body, {
      models: this.definitions.type
    });
    const validateResponse = getSchemaValidator(options?.response, {
      models: this.definitions.type
    });
    const parseMessage = (message) => {
      if (typeof message === "string") {
        const start = message?.charCodeAt(0);
        if (start === 47 || start === 123)
          try {
            message = JSON.parse(message);
          } catch {}
        else if (isNumericString(message))
          message = +message;
      }
      if (transform4?.length)
        for (let i = 0;i < transform4.length; i++) {
          const temp = transform4[i](message);
          if (temp !== undefined)
            message = temp;
        }
      return message;
    };
    this.route("$INTERNALWS", path, (context) => {
      const { set: set2, path: path2, qi, headers, query, params } = context;
      if (server === null)
        server = this.getServer();
      if (server?.upgrade(context.request, {
        headers: typeof options.upgrade === "function" ? options.upgrade(context) : options.upgrade,
        data: {
          validator: validateResponse,
          open(ws) {
            options.open?.(new ElysiaWS(ws, context));
          },
          message: (ws, msg) => {
            const message = parseMessage(msg);
            if (validateMessage?.Check(message) === false)
              return void ws.send(new ValidationError("message", validateMessage, message).message);
            options.message?.(new ElysiaWS(ws, context), message);
          },
          drain(ws) {
            options.drain?.(new ElysiaWS(ws, context));
          },
          close(ws, code, reason) {
            options.close?.(new ElysiaWS(ws, context), code, reason);
          }
        }
      }))
        return;
      set2.status = 400;
      return "Expected a websocket connection";
    }, {
      beforeHandle: options.beforeHandle,
      transform: options.transform,
      headers: options.headers,
      params: options.params,
      query: options.query
    });
    return this;
  }
  route(method, path, handler, {
    config,
    ...hook
  } = {
    config: {
      allowMeta: false
    }
  }) {
    this.add(method, path, handler, hook, config);
    return this;
  }
  state(name, value2) {
    switch (typeof name) {
      case "object":
        this.store = mergeDeep(this.store, name);
        return this;
      case "function":
        this.store = name(this.store);
        return this;
    }
    if (!(name in this.store)) {
      this.store[name] = value2;
    }
    return this;
  }
  decorate(name, value2) {
    switch (typeof name) {
      case "object":
        this.decorators = mergeDeep(this.decorators, name);
        return this;
      case "function":
        this.decorators = name(this.decorators);
        return this;
    }
    if (!(name in this.decorators))
      this.decorators[name] = value2;
    return this;
  }
  derive(transform4) {
    transform4.$elysia = "derive";
    return this.onTransform(transform4);
  }
  model(name, model) {
    switch (typeof name) {
      case "object":
        Object.entries(name).forEach(([key, value2]) => {
          if (!(key in this.definitions.type))
            this.definitions.type[key] = value2;
        });
        return this;
      case "function":
        this.definitions.type = name(this.definitions.type);
        return this;
    }
    this.definitions.type[name] = model;
    return this;
  }
  mapDerive(mapper) {
    mapper.$elysia = "derive";
    return this.onTransform(mapper);
  }
  affix(base, type3, word) {
    if (word === "")
      return this;
    const delimieter = ["_", "-", " "];
    const capitalize2 = (word2) => word2[0].toUpperCase() + word2.slice(1);
    const joinKey = base === "prefix" ? (prefix, word2) => delimieter.includes(prefix.at(-1) ?? "") ? prefix + word2 : prefix + capitalize2(word2) : delimieter.includes(word.at(-1) ?? "") ? (suffix, word2) => word2 + suffix : (suffix, word2) => word2 + capitalize2(suffix);
    const remap = (type22) => {
      const store = {};
      switch (type22) {
        case "decorator":
          for (const key in this.decorators)
            store[joinKey(word, key)] = this.decorators[key];
          this.decorators = store;
          break;
        case "state":
          for (const key in this.store)
            store[joinKey(word, key)] = this.store[key];
          this.store = store;
          break;
        case "model":
          for (const key in this.definitions.type)
            store[joinKey(word, key)] = this.definitions.type[key];
          this.definitions.type = store;
          break;
        case "error":
          for (const key in this.definitions.error)
            store[joinKey(word, key)] = this.definitions.error[key];
          this.definitions.error = store;
          break;
      }
    };
    const types = Array.isArray(type3) ? type3 : [type3];
    for (const type22 of types.some((x) => x === "all") ? ["decorator", "state", "model", "error"] : types)
      remap(type22);
    return this;
  }
  prefix(type3, word) {
    return this.affix("prefix", type3, word);
  }
  suffix(type3, word) {
    return this.affix("suffix", type3, word);
  }
  compile() {
    this.fetch = this.config.aot ? composeGeneralHandler(this) : createDynamicHandler(this);
    if (typeof this.server?.reload === "function")
      this.server.reload({
        ...this.server || {},
        fetch: this.fetch
      });
    return this;
  }
  get modules() {
    return Promise.all(this.lazyLoadModules);
  }
};

// node_modules/@elysiajs/swagger/dist/swagger/index.js
var SwaggerUIRender = (info, version, theme, stringifiedSwaggerOptions, autoDarkMode) => `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>${info.title}</title>
    <meta
        name="description"
        content="${info.description}"
    />
    <meta
        name="og:description"
        content="${info.description}"
    />
    ${autoDarkMode && typeof theme === "string" ? `
    <style>
        @media (prefers-color-scheme: dark) {
            body {
                background-color: #222;
                color: #faf9a;
            }
            .swagger-ui {
                filter: invert(92%) hue-rotate(180deg);
            }

            .swagger-ui .microlight {
                filter: invert(100%) hue-rotate(180deg);
            }
        }
    </style>` : ""}
    ${typeof theme === "string" ? `<link rel="stylesheet" href="${theme}" />` : `<link rel="stylesheet" media="(prefers-color-scheme: light)" href="${theme.light}" />
<link rel="stylesheet" media="(prefers-color-scheme: dark)" href="${theme.dark}" />`}
</head>
<body>
    <div id="swagger-ui"></div>
    <script src="https://unpkg.com/swagger-ui-dist@${version}/swagger-ui-bundle.js" crossorigin></script>
    <script>
        window.onload = () => {
            window.ui = SwaggerUIBundle(${stringifiedSwaggerOptions});
        };
    </script>
</body>
</html>`;

// node_modules/@elysiajs/swagger/dist/scalar/theme.js
var theme_default = `
/* basic theme */
.light-mode {
  --theme-color-1: #2a2f45;
  --theme-color-2: #757575;
  --theme-color-3: #8e8e8e;
  --theme-color-accent: #f06292;

  --theme-background-1: #fff;
  --theme-background-2: #f6f6f6;
  --theme-background-3: #e7e7e7;
  --theme-background-accent: #f062921f;

  --theme-border-color: rgba(0, 0, 0, 0.1);
}
.dark-mode {
  --theme-color-1: rgba(255, 255, 255, 0.9);
  --theme-color-2: rgba(156, 163, 175, 1);
  --theme-color-3: rgba(255, 255, 255, 0.44);
  --theme-color-accent: #f06292;

  --theme-background-1: #111728;
  --theme-background-2: #1e293b;
  --theme-background-3: #334155;
  --theme-background-accent: #f062921f;

  --theme-border-color: rgba(255, 255, 255, 0.1);
}
/* Document Sidebar */
.light-mode .sidebar,
.dark-mode .sidebar {
  --sidebar-background-1: var(--theme-background-1);
  --sidebar-item-hover-color: currentColor;
  --sidebar-item-hover-background: var(--theme-background-2);
  --sidebar-item-active-background: var(--theme-background-accent);
  --sidebar-border-color: transparent;
  --sidebar-color-1: var(--theme-color-1);
  --sidebar-color-2: var(--theme-color-2);
  --sidebar-color-active: var(--theme-color-accent);
  --sidebar-search-background: transparent;
  --sidebar-search-border-color: var(--theme-border-color);
  --sidebar-search--color: var(--theme-color-3);
}
/* Document header only shows on mobile*/
.dark-mode .t-doc__header,
.light-mode .t-doc__header {
  --header-background-1: rgba(255, 255, 255, 0.85);
  --header-border-color: transparent;
  --header-color-1: var(--theme-color-1);
  --header-color-2: var(--theme-color-2);
  --header-background-toggle: var(--theme-color-3);
  --header-call-to-action-color: var(--theme-color-accent);
}

.dark-mode .t-doc__header {
  --header-background-1: rgba(17, 23, 40, 0.75);
}

/* advanced */
.light-mode {
  --theme-button-1: rgb(49 53 56);
  --theme-button-1-color: #fff;
  --theme-button-1-hover: rgb(28 31 33);

  --theme-color-green: #069061;
  --theme-color-red: #ef0006;
  --theme-color-yellow: #edbe20;
  --theme-color-blue: #0082d0;
  --theme-color-orange: #fb892c;
  --theme-color-purple: #5203d1;

  --theme-scrollbar-color: rgba(0, 0, 0, 0.18);
  --theme-scrollbar-color-active: rgba(0, 0, 0, 0.36);
}
.dark-mode {
  --theme-button-1: #f6f6f6;
  --theme-button-1-color: #000;
  --theme-button-1-hover: #e7e7e7;

  --theme-color-green: #a3ffa9;
  --theme-color-red: #ffa3a3;
  --theme-color-yellow: #fffca3;
  --theme-color-blue: #a5d6ff;
  --theme-color-orange: #e2ae83;
  --theme-color-purple: #d2a8ff;

  --theme-scrollbar-color: rgba(255, 255, 255, 0.24);
  --theme-scrollbar-color-active: rgba(255, 255, 255, 0.48);
}
/* Elysia Specific */
.scalar-api-client__send-request-button,
.show-api-client-button {
  background: #3c82f6 !important;
}
.show-api-client-button:before {
  display: none;
}

.sidebar-search:hover {
  transition: all 0.15s ease-in-out;
  --sidebar-search-border-color: var(--theme-color-accent) !important;
  color: var(--sidebar-color-1) !important;
}
.scalar-api-client__container .sidebar {
  --sidebar-border-color: var(--theme-border-color);
}
@media (min-width: 1150px) {
  .section-container:has( ~ .footer):before,
  .tag-section-container:before {
    content: "";
    position: absolute;
    top: -5px;
    left: 0;
    width: 100%;
    height: 10px;
    background: linear-gradient(90deg, var(--theme-background-1) 3%,transparent 10%);
  }
}
.section-flare {
  position: absolute;
  width: 100vw;
  height: 300px;
  --stripes: repeating-linear-gradient(
    100deg,
    #fff 0%,
    #fff 7%,
    transparent 10%,
    transparent 12%,
    #fff 16%
  );
  --stripesDark: repeating-linear-gradient(
    100deg,
    #000 0%,
    #000 7%,
    transparent 10%,
    transparent 12%,
    #000 16%
  );
  --rainbow: repeating-linear-gradient(
    100deg,
    #60a5fa 10%,
    #e879f9 16%,
    #5eead4 22%,
    #60a5fa 30%
  );
  background-image: var(--stripes), var(--rainbow);
  background-size: 300%, 200%;
  background-position: 50% 50%, 50% 50%;
  filter: invert(100%);
  -webkit-mask-image: radial-gradient(
    ellipse at 100% 0%,
    black 40%,
    transparent 70%
  );
  mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);
  pointer-events: none;
  opacity: 0.15;
}
.dark-mode .section-flare {
  background-image: var(--stripesDark), var(--rainbow);
  filter: opacity(50%) saturate(200%);
  opacity: 0.25;
}
.section-flare:after {
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-image: var(--stripes), var(--rainbow);
  background-size: 200%, 100%;
  background-attachment: fixed;
  mix-blend-mode: difference;
}
.dark-mode .section-flare:after {
  background-image: var(--stripesDark), var(--rainbow);
}
@keyframes headerbackground {
  from {
    background: transparent;
    backdrop-filter: none;
  }
  to {
    background: var(--header-background-1);
    backdrop-filter: blur(12px);
  }
}
.light-mode .t-doc__header,
.dark-mode .t-doc__header {
  animation: headerbackground forwards;
  animation-timeline: scroll();
  animation-range: 0px 200px;
  --header-border-color: transparent;
}
`;

// node_modules/@elysiajs/swagger/dist/scalar/index.js
var ScalarRender = (version, config, cdn) => `<!doctype html>
<html>
  <head>
    <title>API Reference</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1" />
    <style>
      body {
        margin: 0;
      }
    </style>
    <style>
      ${config.customCss ?? theme_default}
    </style>
  </head>
  <body>
    <script
      id="api-reference"
      data-url="${config.spec?.url}"
      data-configuration='${JSON.stringify(config)}'
    >
    </script>
    <script src="${cdn ? cdn : `https://cdn.jsdelivr.net/npm/@scalar/api-reference@${version}/dist/browser/standalone.min.js`}"></script>
  </body>
</html>`;

// node_modules/@elysiajs/swagger/dist/utils.js
var import_lodash = __toESM(require_lodash(), 1);
var toOpenAPIPath = (path) => path.split("/").map((x) => x.startsWith(":") ? `{${x.slice(1, x.length)}}` : x).join("/");
var mapProperties = (name, schema3, models) => {
  if (schema3 === undefined)
    return [];
  if (typeof schema3 === "string")
    if (schema3 in models)
      schema3 = models[schema3];
    else
      throw new Error(`Can't find model ${schema3}`);
  return Object.entries(schema3?.properties ?? []).map(([key, value2]) => {
    const { type: valueType = undefined, ...rest3 } = value2;
    return {
      ...rest3,
      schema: { type: valueType },
      in: name,
      name: key,
      required: schema3.required?.includes(key) ?? false
    };
  });
};
var mapTypesResponse = (types, schema3) => {
  if (typeof schema3 === "object" && ["void", "undefined", "null"].includes(schema3.type))
    return;
  const responses = {};
  for (const type3 of types)
    responses[type3] = {
      schema: typeof schema3 === "string" ? {
        $ref: `#/components/schemas/${schema3}`
      } : { ...schema3 }
    };
  return responses;
};
var capitalize2 = (word) => word.charAt(0).toUpperCase() + word.slice(1);
var generateOperationId = (method, paths) => {
  let operationId = method.toLowerCase();
  if (paths === "/")
    return operationId + "Index";
  for (const path of paths.split("/")) {
    if (path.charCodeAt(0) === 123) {
      operationId += "By" + capitalize2(path.slice(1, -1));
    } else {
      operationId += capitalize2(path);
    }
  }
  return operationId;
};
var registerSchemaPath = ({ schema: schema3, path, method, hook, models }) => {
  if (hook)
    hook = import_lodash.default(hook);
  const contentType = hook?.type ?? [
    "application/json",
    "multipart/form-data",
    "text/plain"
  ];
  path = toOpenAPIPath(path);
  const contentTypes = typeof contentType === "string" ? [contentType] : contentType ?? ["application/json"];
  const bodySchema = hook?.body;
  const paramsSchema = hook?.params;
  const headerSchema = hook?.headers;
  const querySchema = hook?.query;
  let responseSchema = hook?.response;
  if (typeof responseSchema === "object") {
    if (Kind in responseSchema) {
      const { type: type3, properties, required: required3, additionalProperties, ...rest3 } = responseSchema;
      responseSchema = {
        "200": {
          ...rest3,
          description: rest3.description,
          content: mapTypesResponse(contentTypes, type3 === "object" || type3 === "array" ? {
            type: type3,
            properties,
            items: responseSchema.items,
            required: required3
          } : responseSchema)
        }
      };
    } else {
      Object.entries(responseSchema).forEach(([key, value2]) => {
        if (typeof value2 === "string") {
          if (!models[value2])
            return;
          const { type: type3, properties, required: required3, additionalProperties: _, ...rest3 } = models[value2];
          responseSchema[key] = {
            ...rest3,
            description: rest3.description,
            content: mapTypesResponse(contentTypes, value2)
          };
        } else {
          const { type: type3, properties, required: required3, additionalProperties, ...rest3 } = value2;
          responseSchema[key] = {
            ...rest3,
            description: rest3.description,
            content: mapTypesResponse(contentTypes, rest3.type === "object" || rest3.type === "array" ? {
              type: rest3.type,
              properties,
              items: value2.items,
              required: required3
            } : value2)
          };
        }
      });
    }
  } else if (typeof responseSchema === "string") {
    if (!(responseSchema in models))
      return;
    const { type: type3, properties, required: required3, additionalProperties: _, ...rest3 } = models[responseSchema];
    responseSchema = {
      "200": {
        ...rest3,
        content: mapTypesResponse(contentTypes, responseSchema)
      }
    };
  }
  const parameters3 = [
    ...mapProperties("header", headerSchema, models),
    ...mapProperties("path", paramsSchema, models),
    ...mapProperties("query", querySchema, models)
  ];
  schema3[path] = {
    ...schema3[path] ? schema3[path] : {},
    [method.toLowerCase()]: {
      ...headerSchema || paramsSchema || querySchema || bodySchema ? { parameters: parameters3 } : {},
      ...responseSchema ? {
        responses: responseSchema
      } : {},
      operationId: hook?.detail?.operationId ?? generateOperationId(method, path),
      ...hook?.detail,
      ...bodySchema ? {
        requestBody: {
          content: mapTypesResponse(contentTypes, typeof bodySchema === "string" ? {
            $ref: `#/components/schemas/${bodySchema}`
          } : bodySchema)
        }
      } : null
    }
  };
};
var filterPaths = (paths, { excludeStaticFile = true, exclude: exclude3 = [] }) => {
  const newPaths = {};
  for (const [key, value2] of Object.entries(paths))
    if (!exclude3.some((x) => {
      if (typeof x === "string")
        return key === x;
      return x.test(key);
    }) && !key.includes("/swagger") && !key.includes("*") && (excludeStaticFile ? !key.includes(".") : true)) {
      Object.keys(value2).forEach((method) => {
        const schema3 = value2[method];
        if (key.includes("{")) {
          if (!schema3.parameters)
            schema3.parameters = [];
          schema3.parameters = [
            ...key.split("/").filter((x) => x.startsWith("{") && !schema3.parameters.find((params) => params.in === "path" && params.name === x.slice(1, x.length - 1))).map((x) => ({
              schema: { type: "string" },
              in: "path",
              name: x.slice(1, x.length - 1),
              required: true
            })),
            ...schema3.parameters
          ];
        }
        if (!schema3.responses)
          schema3.responses = {
            200: {}
          };
      });
      newPaths[key] = value2;
    }
  return newPaths;
};

// node_modules/@elysiajs/swagger/dist/index.js
var swagger = ({ provider = "scalar", scalarVersion = "latest", scalarCDN = "", scalarConfig = {}, documentation = {}, version = "5.9.0", excludeStaticFile = true, path = "/swagger", exclude: exclude3 = [], swaggerOptions = {}, theme = `https://unpkg.com/swagger-ui-dist@${version}/swagger-ui.css`, autoDarkMode = true, excludeMethods = ["OPTIONS"] } = {
  provider: "scalar",
  scalarVersion: "latest",
  scalarCDN: "",
  scalarConfig: {},
  documentation: {},
  version: "5.9.0",
  excludeStaticFile: true,
  path: "/swagger",
  exclude: [],
  swaggerOptions: {},
  autoDarkMode: true,
  excludeMethods: ["OPTIONS"]
}) => (app) => {
  const schema3 = {};
  let totalRoutes = 0;
  if (!version)
    version = `https://unpkg.com/swagger-ui-dist@${version}/swagger-ui.css`;
  const info = {
    title: "Elysia Documentation",
    description: "Development documentation",
    version: "0.0.0",
    ...documentation.info
  };
  const relativePath = path.startsWith("/") ? path.slice(1) : path;
  app.get(path, (() => {
    const combinedSwaggerOptions = {
      url: `${relativePath}/json`,
      dom_id: "#swagger-ui",
      ...swaggerOptions
    };
    const stringifiedSwaggerOptions = JSON.stringify(combinedSwaggerOptions, (key, value2) => {
      if (typeof value2 == "function")
        return;
      return value2;
    });
    const scalarConfiguration = {
      spec: {
        ...scalarConfig.spec,
        url: `${relativePath}/json`
      },
      ...scalarConfig
    };
    return new Response(provider === "swagger-ui" ? SwaggerUIRender(info, version, theme, stringifiedSwaggerOptions, autoDarkMode) : ScalarRender(scalarVersion, scalarConfiguration, scalarCDN), {
      headers: {
        "content-type": "text/html; charset=utf8"
      }
    });
  })()).get(`${path}/json`, () => {
    const routes = app.routes;
    if (routes.length !== totalRoutes) {
      totalRoutes = routes.length;
      routes.forEach((route) => {
        if (excludeMethods.includes(route.method))
          return;
        registerSchemaPath({
          schema: schema3,
          hook: route.hooks,
          method: route.method,
          path: route.path,
          models: app.definitions?.type,
          contentType: route.hooks.type
        });
      });
    }
    return {
      openapi: "3.0.3",
      ...{
        ...documentation,
        info: {
          title: "Elysia Documentation",
          description: "Development documentation",
          version: "0.0.0",
          ...documentation.info
        }
      },
      paths: filterPaths(schema3, {
        excludeStaticFile,
        exclude: Array.isArray(exclude3) ? exclude3 : [exclude3]
      }),
      components: {
        ...documentation.components,
        schemas: {
          ...app.definitions?.type,
          ...documentation.components?.schemas
        }
      }
    };
  });
  return app;
};

// node_modules/@elysiajs/cors/dist/index.js
var cors = (config = {
  origin: true,
  methods: true,
  allowedHeaders: "*",
  exposedHeaders: "*",
  credentials: true,
  maxAge: 5,
  preflight: true
}) => {
  const { origin = true, methods = true, allowedHeaders = "*", exposedHeaders = "*", credentials = true, maxAge = 5, preflight = true } = config;
  const app = new Elysia({
    name: "@elysiajs/cors",
    seed: config
  });
  const origins = typeof origin === "boolean" ? undefined : Array.isArray(origin) ? origin : [origin];
  const processOrigin = (origin2, request, from) => {
    switch (typeof origin2) {
      case "string":
        const protocolStart = from.indexOf("://");
        if (protocolStart !== -1)
          from = from.slice(protocolStart + 3);
        const trailingSlash = from.indexOf("/", 0);
        if (trailingSlash !== -1)
          from = from.slice(trailingSlash);
        return origin2 === from;
      case "function":
        return origin2(request);
      case "object":
        return origin2.test(from);
    }
  };
  const handleOrigin = (set2, request) => {
    if (origin === true) {
      set2.headers["Vary"] = "*";
      set2.headers["Access-Control-Allow-Origin"] = request.headers.get("Origin") || "*";
      return;
    }
    if (!origins?.length)
      return;
    const headers = [];
    if (origins.length) {
      const from = request.headers.get("Origin") ?? "";
      for (let i = 0;i < origins.length; i++) {
        const value2 = processOrigin(origins[i], request, from);
        if (value2 === true) {
          set2.headers["Vary"] = origin ? "Origin" : "*";
          set2.headers["Access-Control-Allow-Origin"] = request.headers.get("Origin") || "*";
          return;
        }
        if (value2)
          headers.push(value2);
      }
    }
    set2.headers["Vary"] = "Origin";
    set2.headers["Access-Control-Allow-Origin"] = headers.join(", ");
  };
  const handleMethod = (set2, method) => {
    if (methods === true)
      return set2.headers["Access-Control-Allow-Methods"] = method ?? "*";
    if (methods === false || !methods?.length)
      return;
    if (methods === "*")
      return set2.headers["Access-Control-Allow-Methods"] = "*";
    if (!Array.isArray(methods))
      return set2.headers["Access-Control-Allow-Methods"] = methods;
    set2.headers["Access-Control-Allow-Methods"] = methods.join(", ");
  };
  if (preflight)
    app.options("/", ({ set: set2, request }) => {
      handleOrigin(set2, request);
      handleMethod(set2, request.method);
      if (exposedHeaders.length)
        set2.headers["Access-Control-Allow-Headers"] = typeof allowedHeaders === "string" ? allowedHeaders : allowedHeaders.join(", ");
      if (maxAge)
        set2.headers["Access-Control-Max-Age"] = maxAge.toString();
      return new Response("", {
        status: 204
      });
    }).options("/*", ({ set: set2, request }) => {
      handleOrigin(set2, request);
      handleMethod(set2, request.method);
      if (exposedHeaders.length)
        set2.headers["Access-Control-Allow-Headers"] = typeof allowedHeaders === "string" ? allowedHeaders : allowedHeaders.join(", ");
      if (maxAge)
        set2.headers["Access-Control-Max-Age"] = maxAge.toString();
      return new Response("", {
        status: 204
      });
    });
  const defaultHeaders = {
    "Access-Control-Allow-Headers": typeof allowedHeaders === "string" ? allowedHeaders : allowedHeaders.join(", "),
    "Access-Control-Exposed-Headers": typeof exposedHeaders === "string" ? exposedHeaders : exposedHeaders.join(", ")
  };
  if (credentials === true)
    defaultHeaders["Access-Control-Allow-Credentials"] = "true";
  return app.headers(defaultHeaders).onRequest(({ set: set2, request }) => {
    handleOrigin(set2, request);
    handleMethod(set2, request.method);
  });
};

// src/config/database.ts
var import_mongoose = __toESM(require_browser_umd(), 1);
var connectDB = async () => {
  try {
    const mongoURI = process.env.MONGODB_URI;
    if (!mongoURI) {
      console.warn("MONGODB_URI is not set. Skipping MongoDB connection. Swagger docs will still work, but DB operations will fail.");
      return null;
    }
    const conn = await import_mongoose.default.connect(mongoURI);
    console.log(`MongoDB Connected: ${conn.connection.host}`);
    return conn;
  } catch (error3) {
    console.error("Error connecting to MongoDB:", error3);
    console.warn("Continuing without a database connection so the server and Swagger docs are available.");
    return null;
  }
};

// src/models/User.ts
var import_mongoose2 = __toESM(require_browser_umd(), 1);
var import_bcryptjs = __toESM(require_bcrypt(), 1);
var userSchema = new import_mongoose2.Schema({
  name: {
    type: String,
    required: [true, "Name is required"],
    trim: true,
    maxlength: [50, "Name cannot be more than 50 characters"]
  },
  email: {
    type: String,
    required: [true, "Email is required"],
    unique: true,
    lowercase: true,
    match: [
      /^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/,
      "Please enter a valid email"
    ]
  },
  password: {
    type: String,
    required: [true, "Password is required"],
    minlength: [6, "Password must be at least 6 characters"],
    select: false
  },
  role: {
    type: String,
    enum: ["user", "admin"],
    default: "user"
  },
  phone: {
    type: String,
    match: [/^\+?[\d\s-()]+$/, "Please enter a valid phone number"]
  },
  address: {
    street: String,
    city: String,
    state: String,
    zipCode: String,
    country: String
  },
  isActive: {
    type: Boolean,
    default: true
  }
}, {
  timestamps: true,
  toJSON: {
    transform: function(doc, ret) {
      delete ret.password;
      return ret;
    }
  }
});
userSchema.pre("save", async function(next) {
  if (!this.isModified("password"))
    return next();
  try {
    const salt = await import_bcryptjs.default.genSalt(12);
    this.password = await import_bcryptjs.default.hash(this.password, salt);
    next();
  } catch (error3) {
    next(error3);
  }
});
userSchema.methods.comparePassword = async function(candidatePassword) {
  return import_bcryptjs.default.compare(candidatePassword, this.password);
};
var User = import_mongoose2.default.model("User", userSchema);

// src/controllers/userController.ts
var import_jsonwebtoken = __toESM(require_jsonwebtoken(), 1);

class UserController {
  static async createUser(userData) {
    try {
      const existingUser = await User.findOne({ email: userData.email });
      if (existingUser) {
        throw new Error("User with this email already exists");
      }
      const user = new User(userData);
      await user.save();
      return {
        success: true,
        message: "User created successfully",
        data: user
      };
    } catch (error3) {
      throw new Error(error3.message || "Error creating user");
    }
  }
  static async getAllUsers(page = 1, limit = 10) {
    try {
      const skip = (page - 1) * limit;
      const users = await User.find({ isActive: true }).select("-password").skip(skip).limit(limit).sort({ createdAt: -1 });
      const total = await User.countDocuments({ isActive: true });
      return {
        success: true,
        data: users,
        pagination: {
          page,
          limit,
          total,
          pages: Math.ceil(total / limit)
        }
      };
    } catch (error3) {
      throw new Error(error3.message || "Error fetching users");
    }
  }
  static async getUserById(id) {
    try {
      const user = await User.findById(id).select("-password");
      if (!user || !user.isActive) {
        throw new Error("User not found");
      }
      return {
        success: true,
        data: user
      };
    } catch (error3) {
      throw new Error(error3.message || "Error fetching user");
    }
  }
  static async updateUser(id, updateData) {
    try {
      const { password, ...safeUpdateData } = updateData;
      const user = await User.findByIdAndUpdate(id, safeUpdateData, { new: true, runValidators: true }).select("-password");
      if (!user) {
        throw new Error("User not found");
      }
      return {
        success: true,
        message: "User updated successfully",
        data: user
      };
    } catch (error3) {
      throw new Error(error3.message || "Error updating user");
    }
  }
  static async deleteUser(id) {
    try {
      const user = await User.findByIdAndUpdate(id, { isActive: false }, { new: true });
      if (!user) {
        throw new Error("User not found");
      }
      return {
        success: true,
        message: "User deleted successfully"
      };
    } catch (error3) {
      throw new Error(error3.message || "Error deleting user");
    }
  }
  static async loginUser(email, password) {
    try {
      const user = await User.findOne({ email, isActive: true }).select("+password");
      if (!user) {
        throw new Error("Invalid email or password");
      }
      const isPasswordValid = await user.comparePassword(password);
      if (!isPasswordValid) {
        throw new Error("Invalid email or password");
      }
      const token = import_jsonwebtoken.default.sign({ userId: user._id, email: user.email, role: user.role }, process.env.JWT_SECRET || "fallback-secret", { expiresIn: process.env.JWT_EXPIRES_IN || "7d" });
      return {
        success: true,
        message: "Login successful",
        data: {
          user: {
            _id: user._id,
            name: user.name,
            email: user.email,
            role: user.role
          },
          token
        }
      };
    } catch (error3) {
      throw new Error(error3.message || "Error during login");
    }
  }
  static async changePassword(id, currentPassword, newPassword) {
    try {
      const user = await User.findById(id).select("+password");
      if (!user) {
        throw new Error("User not found");
      }
      const isCurrentPasswordValid = await user.comparePassword(currentPassword);
      if (!isCurrentPasswordValid) {
        throw new Error("Current password is incorrect");
      }
      user.password = newPassword;
      await user.save();
      return {
        success: true,
        message: "Password changed successfully"
      };
    } catch (error3) {
      throw new Error(error3.message || "Error changing password");
    }
  }
}

// src/routes/userRoutes.ts
var userRoutes = new Elysia({ prefix: "/api/users" }).post("/register", async ({ body, set: set2 }) => {
  try {
    const result = await UserController.createUser(body);
    set2.status = 201;
    return result;
  } catch (error3) {
    set2.status = 400;
    return { success: false, message: error3.message };
  }
}, {
  body: t.Object({
    name: t.String({ minLength: 1, maxLength: 50 }),
    email: t.String({ format: "email" }),
    password: t.String({ minLength: 6 }),
    role: t.Optional(t.Union([t.Literal("user"), t.Literal("admin")])),
    phone: t.Optional(t.String()),
    address: t.Optional(t.Object({
      street: t.String(),
      city: t.String(),
      state: t.String(),
      zipCode: t.String(),
      country: t.String()
    }))
  }),
  detail: {
    tags: ["Users"],
    summary: "Register a new user",
    description: "Create a new user account"
  }
}).post("/login", async ({ body, set: set2 }) => {
  try {
    const { email, password } = body;
    const result = await UserController.loginUser(email, password);
    return result;
  } catch (error3) {
    set2.status = 401;
    return { success: false, message: error3.message };
  }
}, {
  body: t.Object({
    email: t.String({ format: "email" }),
    password: t.String({ minLength: 1 })
  }),
  detail: {
    tags: ["Users"],
    summary: "User login",
    description: "Authenticate user and return JWT token"
  }
}).get("/", async ({ query, set: set2 }) => {
  try {
    const { page = 1, limit = 10 } = query;
    const result = await UserController.getAllUsers(Number(page), Number(limit));
    return result;
  } catch (error3) {
    set2.status = 500;
    return { success: false, message: error3.message };
  }
}, {
  query: t.Object({
    page: t.Optional(t.String()),
    limit: t.Optional(t.String())
  }),
  detail: {
    tags: ["Users"],
    summary: "Get all users",
    description: "Retrieve all active users with pagination"
  }
}).get("/:id", async ({ params, set: set2 }) => {
  try {
    const result = await UserController.getUserById(params.id);
    return result;
  } catch (error3) {
    set2.status = 404;
    return { success: false, message: error3.message };
  }
}, {
  params: t.Object({
    id: t.String({ minLength: 24, maxLength: 24 })
  }),
  detail: {
    tags: ["Users"],
    summary: "Get user by ID",
    description: "Retrieve a specific user by their ID"
  }
}).put("/:id", async ({ params, body, set: set2 }) => {
  try {
    const result = await UserController.updateUser(params.id, body);
    return result;
  } catch (error3) {
    set2.status = 400;
    return { success: false, message: error3.message };
  }
}, {
  params: t.Object({
    id: t.String({ minLength: 24, maxLength: 24 })
  }),
  body: t.Object({
    name: t.Optional(t.String({ minLength: 1, maxLength: 50 })),
    email: t.Optional(t.String({ format: "email" })),
    role: t.Optional(t.Union([t.Literal("user"), t.Literal("admin")])),
    phone: t.Optional(t.String()),
    address: t.Optional(t.Object({
      street: t.String(),
      city: t.String(),
      state: t.String(),
      zipCode: t.String(),
      country: t.String()
    }))
  }),
  detail: {
    tags: ["Users"],
    summary: "Update user",
    description: "Update user information"
  }
}).delete("/:id", async ({ params, set: set2 }) => {
  try {
    const result = await UserController.deleteUser(params.id);
    return result;
  } catch (error3) {
    set2.status = 404;
    return { success: false, message: error3.message };
  }
}, {
  params: t.Object({
    id: t.String({ minLength: 24, maxLength: 24 })
  }),
  detail: {
    tags: ["Users"],
    summary: "Delete user",
    description: "Soft delete a user (deactivate)"
  }
}).post("/:id/change-password", async ({ params, body, set: set2 }) => {
  try {
    const { currentPassword, newPassword } = body;
    const result = await UserController.changePassword(params.id, currentPassword, newPassword);
    return result;
  } catch (error3) {
    set2.status = 400;
    return { success: false, message: error3.message };
  }
}, {
  params: t.Object({
    id: t.String({ minLength: 24, maxLength: 24 })
  }),
  body: t.Object({
    currentPassword: t.String({ minLength: 1 }),
    newPassword: t.String({ minLength: 6 })
  }),
  detail: {
    tags: ["Users"],
    summary: "Change password",
    description: "Change user password"
  }
});

// src/models/Product.ts
var import_mongoose3 = __toESM(require_browser_umd(), 1);
var productSchema = new import_mongoose3.Schema({
  name: {
    type: String,
    required: [true, "Product name is required"],
    trim: true,
    maxlength: [100, "Product name cannot be more than 100 characters"]
  },
  description: {
    type: String,
    required: [true, "Product description is required"],
    maxlength: [2000, "Description cannot be more than 2000 characters"]
  },
  price: {
    type: Number,
    required: [true, "Product price is required"],
    min: [0, "Price cannot be negative"]
  },
  category: {
    type: String,
    required: [true, "Product category is required"],
    trim: true
  },
  brand: {
    type: String,
    trim: true
  },
  sku: {
    type: String,
    required: [true, "SKU is required"],
    unique: true,
    trim: true,
    uppercase: true
  },
  stock: {
    type: Number,
    required: [true, "Stock quantity is required"],
    min: [0, "Stock cannot be negative"],
    default: 0
  },
  images: [{
    type: String,
    validate: {
      validator: function(v) {
        return /^https?:\/\/.+\.(jpg|jpeg|png|webp|gif)$/i.test(v);
      },
      message: "Please provide a valid image URL"
    }
  }],
  specifications: {
    type: Map,
    of: String
  },
  tags: [{
    type: String,
    trim: true,
    lowercase: true
  }],
  isActive: {
    type: Boolean,
    default: true
  },
  isFeatured: {
    type: Boolean,
    default: false
  },
  discount: {
    type: {
      type: String,
      enum: ["percentage", "fixed"]
    },
    value: {
      type: Number,
      min: 0
    },
    startDate: Date,
    endDate: Date
  },
  ratings: {
    average: {
      type: Number,
      default: 0,
      min: 0,
      max: 5
    },
    count: {
      type: Number,
      default: 0,
      min: 0
    }
  }
}, {
  timestamps: true,
  toJSON: {
    transform: function(doc, ret) {
      if (ret.specifications) {
        ret.specifications = Object.fromEntries(ret.specifications);
      }
      return ret;
    }
  }
});
productSchema.index({ name: "text", description: "text", tags: "text" });
productSchema.index({ category: 1, isActive: 1 });
productSchema.index({ price: 1 });
productSchema.index({ createdAt: -1 });
var Product = import_mongoose3.default.model("Product", productSchema);

// src/controllers/productController.ts
class ProductController {
  static async createProduct(productData) {
    try {
      const existingProduct = await Product.findOne({ sku: productData.sku });
      if (existingProduct) {
        throw new Error("Product with this SKU already exists");
      }
      const product = new Product(productData);
      await product.save();
      return {
        success: true,
        message: "Product created successfully",
        data: product
      };
    } catch (error3) {
      throw new Error(error3.message || "Error creating product");
    }
  }
  static async getAllProducts(page = 1, limit = 10, category, minPrice, maxPrice, search, sortBy = "createdAt", sortOrder = "desc") {
    try {
      const skip = (page - 1) * limit;
      const filter = { isActive: true };
      if (category) {
        filter.category = new RegExp(category, "i");
      }
      if (minPrice !== undefined || maxPrice !== undefined) {
        filter.price = {};
        if (minPrice !== undefined)
          filter.price.$gte = minPrice;
        if (maxPrice !== undefined)
          filter.price.$lte = maxPrice;
      }
      if (search) {
        filter.$text = { $search: search };
      }
      const sort = {};
      sort[sortBy] = sortOrder === "asc" ? 1 : -1;
      const products = await Product.find(filter).skip(skip).limit(limit).sort(sort);
      const total = await Product.countDocuments(filter);
      return {
        success: true,
        data: products,
        pagination: {
          page,
          limit,
          total,
          pages: Math.ceil(total / limit)
        }
      };
    } catch (error3) {
      throw new Error(error3.message || "Error fetching products");
    }
  }
  static async getProductById(id) {
    try {
      const product = await Product.findById(id);
      if (!product || !product.isActive) {
        throw new Error("Product not found");
      }
      return {
        success: true,
        data: product
      };
    } catch (error3) {
      throw new Error(error3.message || "Error fetching product");
    }
  }
  static async getProductBySku(sku) {
    try {
      const product = await Product.findOne({ sku: sku.toUpperCase(), isActive: true });
      if (!product) {
        throw new Error("Product not found");
      }
      return {
        success: true,
        data: product
      };
    } catch (error3) {
      throw new Error(error3.message || "Error fetching product");
    }
  }
  static async updateProduct(id, updateData) {
    try {
      const product = await Product.findByIdAndUpdate(id, updateData, { new: true, runValidators: true });
      if (!product) {
        throw new Error("Product not found");
      }
      return {
        success: true,
        message: "Product updated successfully",
        data: product
      };
    } catch (error3) {
      throw new Error(error3.message || "Error updating product");
    }
  }
  static async deleteProduct(id) {
    try {
      const product = await Product.findByIdAndUpdate(id, { isActive: false }, { new: true });
      if (!product) {
        throw new Error("Product not found");
      }
      return {
        success: true,
        message: "Product deleted successfully"
      };
    } catch (error3) {
      throw new Error(error3.message || "Error deleting product");
    }
  }
  static async getFeaturedProducts(limit = 10) {
    try {
      const products = await Product.find({
        isActive: true,
        isFeatured: true
      }).limit(limit).sort({ createdAt: -1 });
      return {
        success: true,
        data: products
      };
    } catch (error3) {
      throw new Error(error3.message || "Error fetching featured products");
    }
  }
  static async getProductsByCategory(category, page = 1, limit = 10) {
    try {
      const skip = (page - 1) * limit;
      const products = await Product.find({
        category: new RegExp(category, "i"),
        isActive: true
      }).skip(skip).limit(limit).sort({ createdAt: -1 });
      const total = await Product.countDocuments({
        category: new RegExp(category, "i"),
        isActive: true
      });
      return {
        success: true,
        data: products,
        pagination: {
          page,
          limit,
          total,
          pages: Math.ceil(total / limit)
        }
      };
    } catch (error3) {
      throw new Error(error3.message || "Error fetching products by category");
    }
  }
  static async updateStock(id, quantity, operation = "add") {
    try {
      const product = await Product.findById(id);
      if (!product) {
        throw new Error("Product not found");
      }
      if (operation === "add") {
        product.stock += quantity;
      } else {
        if (product.stock < quantity) {
          throw new Error("Insufficient stock");
        }
        product.stock -= quantity;
      }
      await product.save();
      return {
        success: true,
        message: "Stock updated successfully",
        data: { stock: product.stock }
      };
    } catch (error3) {
      throw new Error(error3.message || "Error updating stock");
    }
  }
  static async getCategories() {
    try {
      const categories = await Product.distinct("category", { isActive: true });
      return {
        success: true,
        data: categories.sort()
      };
    } catch (error3) {
      throw new Error(error3.message || "Error fetching categories");
    }
  }
}

// src/routes/productRoutes.ts
var productRoutes = new Elysia({ prefix: "/api/products" }).post("/", async ({ body, set: set2 }) => {
  try {
    const result = await ProductController.createProduct(body);
    set2.status = 201;
    return result;
  } catch (error3) {
    set2.status = 400;
    return { success: false, message: error3.message };
  }
}, {
  body: t.Object({
    name: t.String({ minLength: 1, maxLength: 100 }),
    description: t.String({ minLength: 1, maxLength: 2000 }),
    price: t.Number({ minimum: 0 }),
    category: t.String({ minLength: 1 }),
    brand: t.Optional(t.String()),
    sku: t.String({ minLength: 1 }),
    stock: t.Number({ minimum: 0 }),
    images: t.Optional(t.Array(t.String({ format: "uri" }))),
    specifications: t.Optional(t.Record(t.String(), t.String())),
    tags: t.Optional(t.Array(t.String())),
    isFeatured: t.Optional(t.Boolean()),
    discount: t.Optional(t.Object({
      type: t.Union([t.Literal("percentage"), t.Literal("fixed")]),
      value: t.Number({ minimum: 0 }),
      startDate: t.Optional(t.String({ format: "date-time" })),
      endDate: t.Optional(t.String({ format: "date-time" }))
    }))
  }),
  detail: {
    tags: ["Products"],
    summary: "Create a new product",
    description: "Add a new product to the catalog"
  }
}).get("/", async ({ query, set: set2 }) => {
  try {
    const {
      page = 1,
      limit = 10,
      category,
      minPrice,
      maxPrice,
      search,
      sortBy = "createdAt",
      sortOrder = "desc"
    } = query;
    const result = await ProductController.getAllProducts(Number(page), Number(limit), category, minPrice ? Number(minPrice) : undefined, maxPrice ? Number(maxPrice) : undefined, search, sortBy, sortOrder);
    return result;
  } catch (error3) {
    set2.status = 500;
    return { success: false, message: error3.message };
  }
}, {
  query: t.Object({
    page: t.Optional(t.String()),
    limit: t.Optional(t.String()),
    category: t.Optional(t.String()),
    minPrice: t.Optional(t.String()),
    maxPrice: t.Optional(t.String()),
    search: t.Optional(t.String()),
    sortBy: t.Optional(t.String()),
    sortOrder: t.Optional(t.Union([t.Literal("asc"), t.Literal("desc")]))
  }),
  detail: {
    tags: ["Products"],
    summary: "Get all products",
    description: "Retrieve all products with filtering, searching, and pagination"
  }
}).get("/featured", async ({ query, set: set2 }) => {
  try {
    const { limit = 10 } = query;
    const result = await ProductController.getFeaturedProducts(Number(limit));
    return result;
  } catch (error3) {
    set2.status = 500;
    return { success: false, message: error3.message };
  }
}, {
  query: t.Object({
    limit: t.Optional(t.String())
  }),
  detail: {
    tags: ["Products"],
    summary: "Get featured products",
    description: "Retrieve featured products"
  }
}).get("/categories", async ({ set: set2 }) => {
  try {
    const result = await ProductController.getCategories();
    return result;
  } catch (error3) {
    set2.status = 500;
    return { success: false, message: error3.message };
  }
}, {
  detail: {
    tags: ["Products"],
    summary: "Get all categories",
    description: "Retrieve all product categories"
  }
}).get("/category/:category", async ({ params, query, set: set2 }) => {
  try {
    const { page = 1, limit = 10 } = query;
    const result = await ProductController.getProductsByCategory(params.category, Number(page), Number(limit));
    return result;
  } catch (error3) {
    set2.status = 500;
    return { success: false, message: error3.message };
  }
}, {
  params: t.Object({
    category: t.String({ minLength: 1 })
  }),
  query: t.Object({
    page: t.Optional(t.String()),
    limit: t.Optional(t.String())
  }),
  detail: {
    tags: ["Products"],
    summary: "Get products by category",
    description: "Retrieve products filtered by category"
  }
}).get("/sku/:sku", async ({ params, set: set2 }) => {
  try {
    const result = await ProductController.getProductBySku(params.sku);
    return result;
  } catch (error3) {
    set2.status = 404;
    return { success: false, message: error3.message };
  }
}, {
  params: t.Object({
    sku: t.String({ minLength: 1 })
  }),
  detail: {
    tags: ["Products"],
    summary: "Get product by SKU",
    description: "Retrieve a specific product by its SKU"
  }
}).get("/:id", async ({ params, set: set2 }) => {
  try {
    const result = await ProductController.getProductById(params.id);
    return result;
  } catch (error3) {
    set2.status = 404;
    return { success: false, message: error3.message };
  }
}, {
  params: t.Object({
    id: t.String({ minLength: 24, maxLength: 24 })
  }),
  detail: {
    tags: ["Products"],
    summary: "Get product by ID",
    description: "Retrieve a specific product by its ID"
  }
}).put("/:id", async ({ params, body, set: set2 }) => {
  try {
    const result = await ProductController.updateProduct(params.id, body);
    return result;
  } catch (error3) {
    set2.status = 400;
    return { success: false, message: error3.message };
  }
}, {
  params: t.Object({
    id: t.String({ minLength: 24, maxLength: 24 })
  }),
  body: t.Object({
    name: t.Optional(t.String({ minLength: 1, maxLength: 100 })),
    description: t.Optional(t.String({ minLength: 1, maxLength: 2000 })),
    price: t.Optional(t.Number({ minimum: 0 })),
    category: t.Optional(t.String({ minLength: 1 })),
    brand: t.Optional(t.String()),
    stock: t.Optional(t.Number({ minimum: 0 })),
    images: t.Optional(t.Array(t.String({ format: "uri" }))),
    specifications: t.Optional(t.Record(t.String(), t.String())),
    tags: t.Optional(t.Array(t.String())),
    isFeatured: t.Optional(t.Boolean()),
    discount: t.Optional(t.Object({
      type: t.Union([t.Literal("percentage"), t.Literal("fixed")]),
      value: t.Number({ minimum: 0 }),
      startDate: t.Optional(t.String({ format: "date-time" })),
      endDate: t.Optional(t.String({ format: "date-time" }))
    }))
  }),
  detail: {
    tags: ["Products"],
    summary: "Update product",
    description: "Update product information"
  }
}).delete("/:id", async ({ params, set: set2 }) => {
  try {
    const result = await ProductController.deleteProduct(params.id);
    return result;
  } catch (error3) {
    set2.status = 404;
    return { success: false, message: error3.message };
  }
}, {
  params: t.Object({
    id: t.String({ minLength: 24, maxLength: 24 })
  }),
  detail: {
    tags: ["Products"],
    summary: "Delete product",
    description: "Soft delete a product (deactivate)"
  }
}).patch("/:id/stock", async ({ params, body, set: set2 }) => {
  try {
    const { quantity, operation = "add" } = body;
    const result = await ProductController.updateStock(params.id, quantity, operation);
    return result;
  } catch (error3) {
    set2.status = 400;
    return { success: false, message: error3.message };
  }
}, {
  params: t.Object({
    id: t.String({ minLength: 24, maxLength: 24 })
  }),
  body: t.Object({
    quantity: t.Number({ minimum: 0 }),
    operation: t.Optional(t.Union([t.Literal("add"), t.Literal("subtract")]))
  }),
  detail: {
    tags: ["Products"],
    summary: "Update product stock",
    description: "Add or subtract from product stock quantity"
  }
});

// src/index.ts
var PORT = Number(process.env.PORT) || 3000;
var app = new Elysia().use(cors({
  origin: true,
  methods: ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
  allowedHeaders: ["Content-Type", "Authorization"],
  credentials: true
})).use(swagger({
  documentation: {
    info: {
      title: "Elysia Ecommerce API",
      version: "1.0.0",
      description: "A comprehensive ecommerce API built with Elysia.js and MongoDB"
    },
    tags: [
      { name: "Users", description: "User management endpoints" },
      { name: "Products", description: "Product management endpoints" }
    ],
    servers: [
      {
        url: `http://localhost:${PORT}`,
        description: "Development server"
      }
    ]
  },
  path: "/docs"
})).get("/", () => ({
  message: "Welcome to Elysia Ecommerce API",
  version: "1.0.0",
  documentation: "/docs",
  endpoints: {
    users: "/api/users",
    products: "/api/products"
  }
})).get("/health", () => ({
  status: "OK",
  timestamp: new Date().toISOString(),
  uptime: process.uptime()
})).use(userRoutes).use(productRoutes).onError(({ code: code2, error: error3, set: set2 }) => {
  console.error("Error:", error3);
  switch (code2) {
    case "VALIDATION":
      set2.status = 400;
      return {
        success: false,
        message: "Validation error",
        error: error3.message
      };
    case "NOT_FOUND":
      set2.status = 404;
      return {
        success: false,
        message: "Route not found"
      };
    default:
      set2.status = 500;
      return {
        success: false,
        message: "Internal server error"
      };
  }
}).listen(PORT);
connectDB().then(() => {
  console.log(`\uD83D\uDE80 Elysia Ecommerce API is running at http://localhost:${PORT}`);
  console.log(`\uD83D\uDCDA API Documentation available at http://localhost:${PORT}/docs`);
}).catch((error3) => {
  console.error("Failed to start server:", error3);
  process.exit(1);
});
process.on("SIGINT", async () => {
  console.log(`
\uD83D\uDED1 Shutting down gracefully...`);
  process.exit(0);
});
process.on("SIGTERM", async () => {
  console.log(`
\uD83D\uDED1 Shutting down gracefully...`);
  process.exit(0);
});
var src_default = app;
export {
  src_default as default
};
